"""GitHub integration for PR comments and checks.

Posts test results as PR comments and creates check runs.
"""

import os
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

import httpx
import structlog

logger = structlog.get_logger()


@dataclass
class TestSummary:
    """Summary of test results for GitHub."""
    total: int
    passed: int
    failed: int
    skipped: int
    duration_seconds: float
    cost_usd: float
    failures: list[dict]
    screenshots: list[str]  # URLs to uploaded screenshots


class GitHubIntegration:
    """
    GitHub integration for posting test results.

    Features:
    - Post PR comments with test summaries
    - Create check runs with detailed results
    - Upload failure screenshots as artifacts
    - Update commit status

    Usage:
        github = GitHubIntegration(token="ghp_xxx")

        # Post comment on PR
        await github.post_pr_comment(
            owner="myorg",
            repo="myapp",
            pr_number=123,
            summary=test_summary,
        )

        # Create check run
        await github.create_check_run(
            owner="myorg",
            repo="myapp",
            sha="abc123",
            summary=test_summary,
        )
    """

    def __init__(
        self,
        token: Optional[str] = None,
        api_base: str = "https://api.github.com",
    ):
        self.token = token or os.environ.get("GITHUB_TOKEN")
        self.api_base = api_base
        self.log = logger.bind(component="github")

        if not self.token:
            self.log.warning("No GitHub token provided - integration will be disabled")

    @property
    def headers(self) -> dict:
        """Get headers for GitHub API requests."""
        return {
            "Authorization": f"Bearer {self.token}",
            "Accept": "application/vnd.github.v3+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }

    def _format_comment(self, summary: TestSummary, title: str = "E2E Test Results") -> str:
        """Format test results as a GitHub comment."""
        pass_rate = (summary.passed / summary.total * 100) if summary.total > 0 else 0
        status_emoji = "‚úÖ" if summary.failed == 0 else "‚ùå"

        comment = f"""## {status_emoji} {title}

| Metric | Value |
|--------|-------|
| **Total Tests** | {summary.total} |
| **Passed** | {summary.passed} |
| **Failed** | {summary.failed} |
| **Skipped** | {summary.skipped} |
| **Pass Rate** | {pass_rate:.1f}% |
| **Duration** | {summary.duration_seconds:.1f}s |
| **Cost** | ${summary.cost_usd:.4f} |

"""

        if summary.failed > 0:
            comment += "### ‚ùå Failed Tests\n\n"
            for failure in summary.failures[:10]:  # Limit to 10
                test_id = failure.get("test_id", "unknown")
                error = failure.get("error_message", "Unknown error")
                root_cause = failure.get("root_cause", "")

                comment += f"""<details>
<summary><code>{test_id}</code></summary>

**Error:** {error}

"""
                if root_cause:
                    comment += f"**Root Cause:** {root_cause}\n\n"

                comment += "</details>\n\n"

            if len(summary.failures) > 10:
                comment += f"*...and {len(summary.failures) - 10} more failures*\n\n"

        # Add screenshots if available
        if summary.screenshots:
            comment += "### üì∏ Failure Screenshots\n\n"
            for i, url in enumerate(summary.screenshots[:5]):
                comment += f"![Screenshot {i+1}]({url})\n"

        comment += "\n---\n*Generated by [E2E Testing Agent](https://github.com/yourusername/e2e-testing-agent)*"

        return comment

    def _format_check_output(self, summary: TestSummary) -> dict:
        """Format test results for check run output."""
        pass_rate = (summary.passed / summary.total * 100) if summary.total > 0 else 0

        title = f"{'‚úÖ' if summary.failed == 0 else '‚ùå'} {summary.passed}/{summary.total} tests passed"

        text = f"""## Test Results

- **Passed:** {summary.passed}
- **Failed:** {summary.failed}
- **Skipped:** {summary.skipped}
- **Pass Rate:** {pass_rate:.1f}%
- **Duration:** {summary.duration_seconds:.1f}s
- **Cost:** ${summary.cost_usd:.4f}

"""

        if summary.failures:
            text += "## Failures\n\n"
            for failure in summary.failures:
                text += f"### {failure.get('test_id', 'Unknown')}\n"
                text += f"- **Error:** {failure.get('error_message', 'Unknown')}\n"
                if failure.get("root_cause"):
                    text += f"- **Root Cause:** {failure.get('root_cause')}\n"
                text += "\n"

        return {
            "title": title,
            "summary": f"{summary.passed} passed, {summary.failed} failed, {summary.skipped} skipped",
            "text": text,
        }

    async def post_pr_comment(
        self,
        owner: str,
        repo: str,
        pr_number: int,
        summary: TestSummary,
        title: str = "E2E Test Results",
        update_existing: bool = True,
    ) -> Optional[dict]:
        """
        Post test results as a PR comment.

        Args:
            owner: Repository owner
            repo: Repository name
            pr_number: Pull request number
            summary: Test results summary
            title: Comment title
            update_existing: If True, update existing comment instead of creating new

        Returns:
            Created/updated comment data or None on failure
        """
        if not self.token:
            self.log.warning("GitHub token not configured, skipping PR comment")
            return None

        comment_body = self._format_comment(summary, title)
        signature = "<!-- e2e-testing-agent -->"
        comment_body = f"{signature}\n{comment_body}"

        async with httpx.AsyncClient() as client:
            # Check for existing comment to update
            if update_existing:
                existing = await self._find_existing_comment(
                    client, owner, repo, pr_number, signature
                )
                if existing:
                    # Update existing comment
                    url = f"{self.api_base}/repos/{owner}/{repo}/issues/comments/{existing['id']}"
                    try:
                        response = await client.patch(
                            url,
                            headers=self.headers,
                            json={"body": comment_body},
                        )
                        response.raise_for_status()
                        self.log.info("Updated PR comment", pr=pr_number, comment_id=existing["id"])
                        return response.json()
                    except Exception as e:
                        self.log.error("Failed to update PR comment", error=str(e))

            # Create new comment
            url = f"{self.api_base}/repos/{owner}/{repo}/issues/{pr_number}/comments"
            try:
                response = await client.post(
                    url,
                    headers=self.headers,
                    json={"body": comment_body},
                )
                response.raise_for_status()
                data = response.json()
                self.log.info("Posted PR comment", pr=pr_number, comment_id=data.get("id"))
                return data
            except Exception as e:
                self.log.error("Failed to post PR comment", error=str(e))
                return None

    async def _find_existing_comment(
        self,
        client: httpx.AsyncClient,
        owner: str,
        repo: str,
        pr_number: int,
        signature: str,
    ) -> Optional[dict]:
        """Find an existing comment with our signature."""
        url = f"{self.api_base}/repos/{owner}/{repo}/issues/{pr_number}/comments"
        try:
            response = await client.get(url, headers=self.headers)
            response.raise_for_status()
            comments = response.json()

            for comment in comments:
                if signature in comment.get("body", ""):
                    return comment

        except Exception as e:
            self.log.warning("Failed to fetch existing comments", error=str(e))

        return None

    async def create_check_run(
        self,
        owner: str,
        repo: str,
        sha: str,
        summary: TestSummary,
        name: str = "E2E Tests",
    ) -> Optional[dict]:
        """
        Create a check run with test results.

        Args:
            owner: Repository owner
            repo: Repository name
            sha: Commit SHA
            summary: Test results summary
            name: Check run name

        Returns:
            Created check run data or None on failure
        """
        if not self.token:
            self.log.warning("GitHub token not configured, skipping check run")
            return None

        output = self._format_check_output(summary)
        conclusion = "success" if summary.failed == 0 else "failure"

        payload = {
            "name": name,
            "head_sha": sha,
            "status": "completed",
            "conclusion": conclusion,
            "completed_at": datetime.utcnow().isoformat() + "Z",
            "output": output,
        }

        url = f"{self.api_base}/repos/{owner}/{repo}/check-runs"

        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    url,
                    headers=self.headers,
                    json=payload,
                )
                response.raise_for_status()
                data = response.json()
                self.log.info("Created check run", sha=sha[:8], check_id=data.get("id"))
                return data
            except Exception as e:
                self.log.error("Failed to create check run", error=str(e))
                return None

    async def update_commit_status(
        self,
        owner: str,
        repo: str,
        sha: str,
        state: str,  # error, failure, pending, success
        description: str,
        context: str = "e2e-tests",
        target_url: Optional[str] = None,
    ) -> Optional[dict]:
        """
        Update commit status.

        Args:
            owner: Repository owner
            repo: Repository name
            sha: Commit SHA
            state: Status state (error, failure, pending, success)
            description: Status description
            context: Status context name
            target_url: URL to link to

        Returns:
            Created status data or None on failure
        """
        if not self.token:
            self.log.warning("GitHub token not configured, skipping status update")
            return None

        payload = {
            "state": state,
            "description": description[:140],  # GitHub limit
            "context": context,
        }
        if target_url:
            payload["target_url"] = target_url

        url = f"{self.api_base}/repos/{owner}/{repo}/statuses/{sha}"

        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    url,
                    headers=self.headers,
                    json=payload,
                )
                response.raise_for_status()
                data = response.json()
                self.log.info("Updated commit status", sha=sha[:8], state=state)
                return data
            except Exception as e:
                self.log.error("Failed to update commit status", error=str(e))
                return None

    async def get_pr_files(
        self,
        owner: str,
        repo: str,
        pr_number: int,
    ) -> list[str]:
        """
        Get list of files changed in a PR.

        Returns:
            List of file paths
        """
        if not self.token:
            return []

        url = f"{self.api_base}/repos/{owner}/{repo}/pulls/{pr_number}/files"

        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(url, headers=self.headers)
                response.raise_for_status()
                files = response.json()
                return [f["filename"] for f in files]
            except Exception as e:
                self.log.error("Failed to get PR files", error=str(e))
                return []


def create_github_integration(token: Optional[str] = None) -> GitHubIntegration:
    """Factory function for GitHubIntegration."""
    return GitHubIntegration(token=token)
