var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options2) {
        this.name = name;
        this.startTime = options2?.startTime || _performanceNow();
        this.detail = options2?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options2) {
        const entry = new PerformanceMark(name, options2);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options2) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count3, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node-built-in-modules:path
import libDefault from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node-built-in-modules:fs
import libDefault2 from "fs";
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// .wrangler/tmp/bundle-rpkAQp/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-rpkAQp/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/locales/en.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/ZodError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/util.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error3) => {
      for (const issue of error3.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error3 = new ZodError(issues);
  return error3;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path: path30, errorMaps, issueData } = params;
  const fullPath = [...path30, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/errorUtil.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value, path30, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path30;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error3 = new ZodError(ctx.common.issues);
        this._error = error3;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version6) {
  if ((version6 === "v4" || !version6) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version6 === "v6" || !version6) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip, version6) {
  if ((version6 === "v4" || !version6) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version6 === "v6" || !version6) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      offset: options2?.offset ?? false,
      local: options2?.local ?? false,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2?.position,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types2, params) => {
  return new ZodUnion({
    options: types2,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas2, params) => {
  if (!Array.isArray(schemas2)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas2,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error3) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error3
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error3) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error3
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error3 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error3.addIssue(makeArgsIssue(args, e));
          throw error3;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error3.addIssue(makeReturnsIssue(result, e));
          throw error3;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
__name(cleanParams, "cleanParams");
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name(((arg) => ZodString.create({ ...arg, coerce: true })), "string"),
  number: /* @__PURE__ */ __name(((arg) => ZodNumber.create({ ...arg, coerce: true })), "number"),
  boolean: /* @__PURE__ */ __name(((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  })), "boolean"),
  bigint: /* @__PURE__ */ __name(((arg) => ZodBigInt.create({ ...arg, coerce: true })), "bigint"),
  date: /* @__PURE__ */ __name(((arg) => ZodDate.create({ ...arg, coerce: true })), "date")
};
var NEVER = INVALID;

// node_modules/@cloudflare/playwright/lib/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/inProcessFactory.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/androidServerImpl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/remote/playwrightServer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/remote/playwrightConnection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/_virtual/_commonjs-dynamic-modules.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function commonjsRequire(path30) {
  throw new Error('Could not dynamically require "' + path30 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
__name(commonjsRequire, "commonjsRequire");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/browsers.json.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var comment = "Do not edit this file, use utils/roll_browser.js";
var browsers = [{ "name": "chromium", "revision": "1187", "installByDefault": true, "browserVersion": "140.0.7339.16" }, { "name": "chromium-headless-shell", "revision": "1187", "installByDefault": true, "browserVersion": "140.0.7339.16" }, { "name": "chromium-tip-of-tree", "revision": "1357", "installByDefault": false, "browserVersion": "141.0.7342.0" }, { "name": "chromium-tip-of-tree-headless-shell", "revision": "1357", "installByDefault": false, "browserVersion": "141.0.7342.0" }, { "name": "firefox", "revision": "1490", "installByDefault": true, "browserVersion": "141.0" }, { "name": "firefox-beta", "revision": "1485", "installByDefault": false, "browserVersion": "142.0b4" }, { "name": "webkit", "revision": "2203", "installByDefault": true, "revisionOverrides": { "debian11-x64": "2105", "debian11-arm64": "2105", "mac10.14": "1446", "mac10.15": "1616", "mac11": "1816", "mac11-arm64": "1816", "mac12": "2009", "mac12-arm64": "2009", "mac13": "2140", "mac13-arm64": "2140", "ubuntu20.04-x64": "2092", "ubuntu20.04-arm64": "2092" }, "browserVersion": "26.0" }, { "name": "ffmpeg", "revision": "1011", "installByDefault": true, "revisionOverrides": { "mac12": "1010", "mac12-arm64": "1010" } }, { "name": "winldd", "revision": "1007", "installByDefault": false }, { "name": "android", "revision": "1001", "installByDefault": false }];
var require$$0 = {
  comment,
  browsers
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/index.js
import fs10 from "node:fs";
import os6 from "node:os";
import path8 from "node:path";
import * as require$$0$22 from "node:util";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/browserFetcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/child_process.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
var execSync = /* @__PURE__ */ notImplemented("child_process.execSyn");
var fork = /* @__PURE__ */ notImplemented("child_process.fork");
var spawn = /* @__PURE__ */ notImplemented("child_process.spawn");
var spawnSync = /* @__PURE__ */ notImplemented("child_process.spawnSync");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/browserFetcher.js
import fs6 from "node:fs";
import os3 from "node:os";
import path4 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/debugLogger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs2 from "node:fs";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utilsBundle.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/_virtual/utilsBundleImpl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/bundles/utilsBundleImpl.js
var utilsBundleImpl_exports = {};
__export(utilsBundleImpl_exports, {
  HttpsProxyAgent: () => HttpsProxyAgent,
  PNG: () => PNG,
  SocksProxyAgent: () => SocksProxyAgent,
  colors: () => colors,
  debug: () => debug3,
  diff: () => diff2,
  dotenv: () => dotenv,
  getProxyForUrl: () => getProxyForUrl,
  jpegjs: () => jpegjs,
  lockfile: () => lockfile,
  mime: () => mime,
  minimatch: () => minimatch,
  open: () => open,
  program: () => program,
  progress: () => progress,
  ws: () => ws,
  wsReceiver: () => wsReceiver,
  wsSender: () => wsSender,
  wsServer: () => wsServer,
  yaml: () => yaml
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path from "node:path";
import fs from "node:fs";
import require$$02 from "node:constants";
import require$$62 from "node:stream";
import require$$0$2__default2 from "node:util";
import require$$52 from "node:assert";
import EventEmitter2 from "node:events";
import os from "node:os";
import crypto from "node:crypto";
import url from "node:url";
import net from "node:net";
import tls from "node:tls";

// node_modules/@cloudflare/playwright/lib/bundles/pngjs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import require$$0$2__default from "node:util";
import require$$6 from "node:stream";
import require$$0$1 from "node:buffer";
import require$$5 from "node:assert";
var png = {};
var parserAsync = { exports: {} };
var lib = {};
var binding2 = {};
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  __name(ZStream, "ZStream");
  zstream = ZStream;
  return zstream;
}
__name(requireZstream, "requireZstream");
var deflate = {};
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(_has, "_has");
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source8 = sources.shift();
        if (!source8) {
          continue;
        }
        if (typeof source8 !== "object") {
          throw new TypeError(source8 + "must be non-object");
        }
        for (var p in source8) {
          if (_has(source8, p)) {
            obj[p] = source8[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }, "flattenChunks")
    };
    var fnUntyped = {
      arraySet: /* @__PURE__ */ __name(function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      }, "arraySet"),
      // Join array of chunks to single array.
      flattenChunks: /* @__PURE__ */ __name(function(chunks) {
        return [].concat.apply([], chunks);
      }, "flattenChunks")
    };
    exports.setTyped = function(on2) {
      if (on2) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common);
  return common;
}
__name(requireCommon, "requireCommon");
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var utils = requireCommon();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  __name(zero, "zero");
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  __name(StaticTreeDesc, "StaticTreeDesc");
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  __name(TreeDesc, "TreeDesc");
  function d_code(dist2) {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  }
  __name(d_code, "d_code");
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  __name(put_short, "put_short");
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  __name(send_bits, "send_bits");
  function send_code(s, c, tree) {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  }
  __name(send_code, "send_code");
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  __name(bi_reverse, "bi_reverse");
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  __name(bi_flush, "bi_flush");
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  __name(gen_bitlen, "gen_bitlen");
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  __name(gen_codes, "gen_codes");
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist2;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist2 = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  __name(tr_static_init, "tr_static_init");
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  __name(init_block, "init_block");
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  __name(bi_windup, "bi_windup");
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  __name(copy_block, "copy_block");
  function smaller(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  __name(smaller, "smaller");
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  __name(pqdownheap, "pqdownheap");
  function compress_block(s, ltree, dtree) {
    var dist2;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  __name(compress_block, "compress_block");
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  __name(build_tree, "build_tree");
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count3 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        s.bl_tree[curlen * 2] += count3;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count3 <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(scan_tree, "scan_tree");
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count3 = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count3 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count3--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count3 - 3, 2);
      } else if (count3 <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count3 - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count3 - 11, 7);
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  __name(send_tree, "send_tree");
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  __name(build_bl_tree, "build_bl_tree");
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  __name(send_all_trees, "send_all_trees");
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  __name(detect_data_type, "detect_data_type");
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  __name(_tr_init, "_tr_init");
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len);
  }
  __name(_tr_stored_block, "_tr_stored_block");
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  __name(_tr_align, "_tr_align");
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  __name(_tr_flush_block, "_tr_flush_block");
  function _tr_tally(s, dist2, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  __name(_tr_tally, "_tr_tally");
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
__name(requireTrees, "requireTrees");
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  __name(adler32, "adler32");
  adler32_1 = adler32;
  return adler32_1;
}
__name(requireAdler32, "requireAdler32");
var crc32_1;
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  function makeTable() {
    var c, table3 = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table3[n] = c;
    }
    return table3;
  }
  __name(makeTable, "makeTable");
  var crcTable = makeTable();
  function crc32(crc2, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc2 ^= -1;
    for (var i = pos; i < end; i++) {
      crc2 = crc2 >>> 8 ^ t[(crc2 ^ buf[i]) & 255];
    }
    return crc2 ^ -1;
  }
  __name(crc32, "crc32");
  crc32_1 = crc32;
  return crc32_1;
}
__name(requireCrc32, "requireCrc32");
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
__name(requireMessages, "requireMessages");
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate;
  hasRequiredDeflate = 1;
  var utils = requireCommon();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  __name(err, "err");
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  __name(rank, "rank");
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  __name(zero, "zero");
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  __name(flush_pending, "flush_pending");
  function flush_block_only(s, last) {
    trees2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  __name(flush_block_only, "flush_block_only");
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  __name(put_byte, "put_byte");
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  __name(putShortMSB, "putShortMSB");
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  __name(read_buf, "read_buf");
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  __name(longest_match, "longest_match");
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  __name(fill_window, "fill_window");
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  __name(deflate_stored, "deflate_stored");
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_fast, "deflate_fast");
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_slow, "deflate_slow");
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_rle, "deflate_rle");
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  __name(deflate_huff, "deflate_huff");
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  __name(Config, "Config");
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  __name(lm_init, "lm_init");
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils.Buf16(MAX_BITS + 1);
    this.heap = new utils.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  __name(DeflateState, "DeflateState");
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s);
    return Z_OK;
  }
  __name(deflateResetKeep, "deflateResetKeep");
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  __name(deflateReset, "deflateReset");
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  __name(deflateSetHeader, "deflateSetHeader");
  function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils.Buf8(s.w_size * 2);
    s.head = new utils.Buf16(s.hash_size);
    s.prev = new utils.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  }
  __name(deflateInit2, "deflateInit2");
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  __name(deflateInit, "deflateInit");
  function deflate$1(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  __name(deflate$1, "deflate$1");
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  __name(deflateEnd, "deflateEnd");
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils.Buf8(s.w_size);
      utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK;
  }
  __name(deflateSetDictionary, "deflateSetDictionary");
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$1;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
__name(requireDeflate, "requireDeflate");
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE = 12;
  inffast = /* @__PURE__ */ __name(function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist2;
    var from;
    var from_source;
    var input, output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist2;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }, "inflate_fast");
  return inffast;
}
__name(requireInffast, "requireInffast");
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var utils = requireCommon();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = /* @__PURE__ */ __name(function inflate_table(type, lens, lens_index, codes, table3, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min = 0, max = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count3 = new utils.Buf16(MAXBITS + 1);
    var offs = new utils.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count3[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count3[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count3[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table3[table_index++] = 1 << 24 | 64 << 16 | 0;
      table3[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count3[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count3[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count3[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES) {
      base = extra = work;
      end = 19;
    } else if (type === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table3[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count3[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count3[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table3[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }, "inflate_table");
  return inftrees;
}
__name(requireInftrees, "requireInftrees");
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate;
  hasRequiredInflate = 1;
  var utils = requireCommon();
  var adler32 = requireAdler32();
  var crc32 = requireCrc32();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  __name(zswap32, "zswap32");
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils.Buf16(320);
    this.work = new utils.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  __name(InflateState, "InflateState");
  function inflateResetKeep(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK;
  }
  __name(inflateResetKeep, "inflateResetKeep");
  function inflateReset(strm) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  }
  __name(inflateReset, "inflateReset");
  function inflateReset2(strm, windowBits) {
    var wrap;
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  }
  __name(inflateReset2, "inflateReset2");
  function inflateInit2(strm, windowBits) {
    var ret;
    var state;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state = new InflateState();
    strm.state = state;
    state.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  __name(inflateInit2, "inflateInit2");
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  __name(inflateInit, "inflateInit");
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state) {
    if (virgin) {
      var sym;
      lenfix = new utils.Buf32(512);
      distfix = new utils.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  }
  __name(fixedtables, "fixedtables");
  function updatewindow(strm, src2, end, copy) {
    var dist2;
    var state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new utils.Buf8(state.wsize);
    }
    if (copy >= state.wsize) {
      utils.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist2 = state.wsize - state.wnext;
      if (dist2 > copy) {
        dist2 = copy;
      }
      utils.arraySet(state.window, src2, end - copy, dist2, state.wnext);
      copy -= dist2;
      if (copy) {
        utils.arraySet(state.window, src2, end - copy, copy, 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist2;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist2;
        }
      }
    }
    return 0;
  }
  __name(updatewindow, "updatewindow");
  function inflate$1(strm, flush) {
    var state;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils.Buf8(4);
    var opts;
    var n;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  __name(inflate$1, "inflate$1");
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  __name(inflateEnd, "inflateEnd");
  function inflateGetHeader(strm, head) {
    var state;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return Z_OK;
  }
  __name(inflateGetHeader, "inflateGetHeader");
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
    state.havedict = 1;
    return Z_OK;
  }
  __name(inflateSetDictionary, "inflateSetDictionary");
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$1;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
__name(requireInflate, "requireInflate");
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  constants$1 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants$1;
}
__name(requireConstants$1, "requireConstants$1");
var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding) return binding2;
  hasRequiredBinding = 1;
  (function(exports) {
    var assert4 = require$$5;
    var Zstream = requireZstream();
    var zlib_deflate = requireDeflate();
    var zlib_inflate = requireInflate();
    var constants3 = requireConstants$1();
    for (var key in constants3) {
      exports[key] = constants3[key];
    }
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    __name(Zlib, "Zlib");
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert4(this.init_done, "close before init");
      assert4(this.mode <= exports.UNZIP);
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert4.equal(arguments.length, 8);
      assert4(this.init_done, "write before init");
      assert4(this.mode !== exports.NONE, "already finalized");
      assert4.equal(false, this.write_in_progress, "write already in progress");
      assert4.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert4.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            // fallthrough
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports.GUNZIP;
              } else {
                this.mode = exports.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        // fallthrough
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports.Z_DATA_ERROR) {
              this.err = exports.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert4(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert4(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert4(level >= -1 && level <= 9, "invalid compression level");
      assert4(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert4(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports.Z_NO_FLUSH;
      this.err = exports.Z_OK;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports.Zlib = Zlib;
  })(binding2);
  return binding2;
}
__name(requireBinding, "requireBinding");
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  (function(exports) {
    var Buffer2 = require$$0$1.Buffer;
    var Transform2 = require$$6.Transform;
    var binding3 = requireBinding();
    var util2 = require$$0$2__default;
    var assert4 = require$$5.ok;
    var kMaxLength = require$$0$1.kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding3.Z_MIN_WINDOWBITS = 8;
    binding3.Z_MAX_WINDOWBITS = 15;
    binding3.Z_DEFAULT_WINDOWBITS = 15;
    binding3.Z_MIN_CHUNK = 64;
    binding3.Z_MAX_CHUNK = Infinity;
    binding3.Z_DEFAULT_CHUNK = 16 * 1024;
    binding3.Z_MIN_MEMLEVEL = 1;
    binding3.Z_MAX_MEMLEVEL = 9;
    binding3.Z_DEFAULT_MEMLEVEL = 8;
    binding3.Z_MIN_LEVEL = -1;
    binding3.Z_MAX_LEVEL = 9;
    binding3.Z_DEFAULT_LEVEL = binding3.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding3);
    for (var bk = 0; bk < bkeys.length; bk++) {
      var bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports, bkey, {
          enumerable: true,
          value: binding3[bkey],
          writable: false
        });
      }
    }
    var codes = {
      Z_OK: binding3.Z_OK,
      Z_STREAM_END: binding3.Z_STREAM_END,
      Z_NEED_DICT: binding3.Z_NEED_DICT,
      Z_ERRNO: binding3.Z_ERRNO,
      Z_STREAM_ERROR: binding3.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding3.Z_DATA_ERROR,
      Z_MEM_ERROR: binding3.Z_MEM_ERROR,
      Z_BUF_ERROR: binding3.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding3.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes);
    for (var ck = 0; ck < ckeys.length; ck++) {
      var ckey = ckeys[ck];
      codes[codes[ckey]] = ckey;
    }
    Object.defineProperty(exports, "codes", {
      enumerable: true,
      value: Object.freeze(codes),
      writable: false
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      __name(flow, "flow");
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      __name(onError, "onError");
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer2.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
      __name(onEnd, "onEnd");
    }
    __name(zlibBuffer, "zlibBuffer");
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") buffer = Buffer2.from(buffer);
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    __name(zlibBufferSync, "zlibBufferSync");
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding3.DEFLATE);
    }
    __name(Deflate, "Deflate");
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding3.INFLATE);
    }
    __name(Inflate, "Inflate");
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding3.GZIP);
    }
    __name(Gzip, "Gzip");
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding3.GUNZIP);
    }
    __name(Gunzip, "Gunzip");
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding3.DEFLATERAW);
    }
    __name(DeflateRaw, "DeflateRaw");
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding3.INFLATERAW);
    }
    __name(InflateRaw, "InflateRaw");
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding3.UNZIP);
    }
    __name(Unzip, "Unzip");
    function isValidFlushFlag(flag) {
      return flag === binding3.Z_NO_FLUSH || flag === binding3.Z_PARTIAL_FLUSH || flag === binding3.Z_SYNC_FLUSH || flag === binding3.Z_FULL_FLUSH || flag === binding3.Z_FINISH || flag === binding3.Z_BLOCK;
    }
    __name(isValidFlushFlag, "isValidFlushFlag");
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform2.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding3.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding3.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer2.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding3.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno) {
        _close(self2);
        self2._hadError = true;
        var error3 = new Error(message);
        error3.errno = errno;
        error3.code = exports.codes[errno];
        self2.emit("error", error3);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer2.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: /* @__PURE__ */ __name(function() {
          return !_this._handle;
        }, "get"),
        configurable: true,
        enumerable: true
      });
    }
    __name(Zlib, "Zlib");
    util2.inherits(Zlib, Transform2);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding3.Z_SYNC_FLUSH, function() {
          assert4(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert4(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer2.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws3 = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding3.Z_FULL_FLUSH;
      }
      if (ws3.ended) {
        if (callback) process.nextTick(callback);
      } else if (ws3.ending) {
        if (callback) this.once("end", callback);
      } else if (ws3.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer2.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback) process.nextTick(callback);
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    __name(_close, "_close");
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws3 = this._writableState;
      var ending = ws3.ending || ws3.ended;
      var last = ending && (!chunk || ws3.length === chunk.length);
      if (chunk !== null && !Buffer2.isBuffer(chunk)) return cb(new Error("invalid input"));
      if (!this._handle) return cb(new Error("zlib binding closed"));
      if (last) flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws3.length) {
          this._flushFlag = this._opts.flush || binding3.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error3;
        this.on("error", function(er) {
          error3 = er;
        });
        assert4(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error3;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer2.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert4(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert4(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer2.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
      __name(callback, "callback");
    };
    util2.inherits(Deflate, Zlib);
    util2.inherits(Inflate, Zlib);
    util2.inherits(Gzip, Zlib);
    util2.inherits(Gunzip, Zlib);
    util2.inherits(DeflateRaw, Zlib);
    util2.inherits(InflateRaw, Zlib);
    util2.inherits(Unzip, Zlib);
  })(lib);
  return lib;
}
__name(requireLib, "requireLib");
var chunkstream = { exports: {} };
var hasRequiredChunkstream;
function requireChunkstream() {
  if (hasRequiredChunkstream) return chunkstream.exports;
  hasRequiredChunkstream = 1;
  let util2 = require$$0$2__default;
  let Stream2 = require$$6;
  let ChunkStream = chunkstream.exports = function() {
    Stream2.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util2.inherits(ChunkStream, Stream2);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(
      function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this)
    );
  };
  ChunkStream.prototype.write = function(data, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = Buffer.from(data, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding) {
    if (data) {
      this.write(data, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count3 = 0;
    let data = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count3++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count3] = buf.slice(len);
      }
    }
    if (count3 > 0) {
      this._buffers.splice(0, count3);
    }
    this._buffered -= read.length;
    read.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
  return chunkstream.exports;
}
__name(requireChunkstream, "requireChunkstream");
var filterParseAsync = { exports: {} };
var filterParse = { exports: {} };
var interlace = {};
var hasRequiredInterlace;
function requireInterlace() {
  if (hasRequiredInterlace) return interlace;
  hasRequiredInterlace = 1;
  let imagePasses = [
    {
      // pass 1 - 1px
      x: [0],
      y: [0]
    },
    {
      // pass 2 - 1px
      x: [4],
      y: [0]
    },
    {
      // pass 3 - 2px
      x: [0, 4],
      y: [4]
    },
    {
      // pass 4 - 4px
      x: [2, 6],
      y: [0, 4]
    },
    {
      // pass 5 - 8px
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      // pass 6 - 16px
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      // pass 7 - 32px
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  interlace.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i = 0; i < imagePasses.length; i++) {
      let pass = imagePasses[i];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0; j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0; j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  interlace.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
  return interlace;
}
__name(requireInterlace, "requireInterlace");
var paethPredictor;
var hasRequiredPaethPredictor;
function requirePaethPredictor() {
  if (hasRequiredPaethPredictor) return paethPredictor;
  hasRequiredPaethPredictor = 1;
  paethPredictor = /* @__PURE__ */ __name(function paethPredictor2(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  }, "paethPredictor");
  return paethPredictor;
}
__name(requirePaethPredictor, "requirePaethPredictor");
var hasRequiredFilterParse;
function requireFilterParse() {
  if (hasRequiredFilterParse) return filterParse.exports;
  hasRequiredFilterParse = 1;
  let interlaceUtils = requireInterlace();
  let paethPredictor2 = requirePaethPredictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  __name(getByteWidth, "getByteWidth");
  let Filter = filterParse.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace2 = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace2) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i = 0; i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(
      this._images[this._imageIndex].byteWidth + 1,
      this._reverseFilterLine.bind(this)
    );
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0; x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor2(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
  return filterParse.exports;
}
__name(requireFilterParse, "requireFilterParse");
var hasRequiredFilterParseAsync;
function requireFilterParseAsync() {
  if (hasRequiredFilterParseAsync) return filterParseAsync.exports;
  hasRequiredFilterParseAsync = 1;
  let util2 = require$$0$2__default;
  let ChunkStream = requireChunkstream();
  let Filter = requireFilterParse();
  let FilterAsync = filterParseAsync.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: /* @__PURE__ */ __name(function(buffer) {
        buffers.push(buffer);
      }, "write"),
      complete: /* @__PURE__ */ __name(function() {
        that.emit("complete", Buffer.concat(buffers));
      }, "complete")
    });
    this._filter.start();
  };
  util2.inherits(FilterAsync, ChunkStream);
  return filterParseAsync.exports;
}
__name(requireFilterParseAsync, "requireFilterParseAsync");
var parser = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    // eslint-disable-line camelcase
    TYPE_gAMA: 1732332865,
    // eslint-disable-line camelcase
    // color-type bits
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    // e.g. grayscale and alpha
    // color-type combinations
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
  return constants;
}
__name(requireConstants, "requireConstants");
var crc = { exports: {} };
var hasRequiredCrc;
function requireCrc() {
  if (hasRequiredCrc) return crc.exports;
  hasRequiredCrc = 1;
  let crcTable = [];
  (function() {
    for (let i = 0; i < 256; i++) {
      let currentCrc = i;
      for (let j = 0; j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  let CrcCalculator = crc.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (let i = 0; i < data.length; i++) {
      this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc2 = -1;
    for (let i = 0; i < buf.length; i++) {
      crc2 = crcTable[(crc2 ^ buf[i]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  return crc.exports;
}
__name(requireCrc, "requireCrc");
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser.exports;
  hasRequiredParser = 1;
  let constants3 = requireConstants();
  let CrcCalculator = requireCrc();
  let Parser2 = parser.exports = function(options2, dependencies) {
    this._options = options2;
    options2.checkCRC = options2.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants3.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants3.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants3.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants3.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants3.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants3.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {
    };
  };
  Parser2.prototype.start = function() {
    this.read(constants3.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser2.prototype._parseSignature = function(data) {
    let signature = constants3.PNG_SIGNATURE;
    for (let i = 0; i < signature.length; i++) {
      if (data[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser2.prototype._parseChunkBegin = function(data) {
    let length = data.readUInt32BE(0);
    let type = data.readUInt32BE(4);
    let name = "";
    for (let i = 4; i < 8; i++) {
      name += String.fromCharCode(data[i]);
    }
    let ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type !== constants3.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator();
    this._crc.write(Buffer.from(name));
    if (this._chunks[type]) {
      return this._chunks[type](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser2.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser2.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser2.prototype._parseChunkEnd = function(data) {
    let fileCrc = data.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser2.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser2.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    let width = data.readUInt32BE(0);
    let height = data.readUInt32BE(4);
    let depth = data[8];
    let colorType = data[9];
    let compr = data[10];
    let filter = data[11];
    let interlace2 = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants3.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace2 !== 0 && interlace2 !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants3.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace2),
      palette: Boolean(colorType & constants3.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants3.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants3.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser2.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser2.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    let entries = Math.floor(data.length / 3);
    for (let i = 0; i < entries; i++) {
      this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser2.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser2.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants3.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i = 0; i < data.length; i++) {
        this._palette[i][3] = data[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants3.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants3.COLORTYPE_COLOR) {
      this.transColor([
        data.readUInt16BE(0),
        data.readUInt16BE(2),
        data.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser2.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser2.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants3.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser2.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser2.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants3.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    let leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser2.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser2.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
  return parser.exports;
}
__name(requireParser, "requireParser");
var bitmapper = {};
var hasRequiredBitmapper;
function requireBitmapper() {
  if (hasRequiredBitmapper) return bitmapper;
  hasRequiredBitmapper = 1;
  let interlaceUtils = requireInterlace();
  let pixelBppMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  let pixelBppCustomMapper = [
    // 0 - dummy entry
    function() {
    },
    // 1 - L
    // 0: 0, 1: 0, 2: 0, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    // 2 - LA
    // 0: 0, 1: 0, 2: 0, 3: 1
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    // 3 - RGB
    // 0: 0, 1: 1, 2: 2, 3: 0xff
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    // 4 - RGBA
    // 0: 0, 1: 1, 2: 2, 3: 3
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    let leftOver = [];
    let i = 0;
    function split() {
      if (i === data.length) {
        throw new Error("Ran out of data");
      }
      let byte = data[i];
      i++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    __name(split, "split");
    return {
      get: /* @__PURE__ */ __name(function(count3) {
        while (leftOver.length < count3) {
          split();
        }
        let returner = leftOver.slice(0, count3);
        leftOver = leftOver.slice(count3);
        return returner;
      }, "get"),
      resetAfterLine: /* @__PURE__ */ __name(function() {
        leftOver.length = 0;
      }, "resetAfterLine"),
      end: /* @__PURE__ */ __name(function() {
        if (i !== data.length) {
          throw new Error("extra data found");
        }
      }, "end")
    };
  }
  __name(bitRetriever, "bitRetriever");
  function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  __name(mapImage8Bit, "mapImage8Bit");
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0; y < imageHeight; y++) {
      for (let x = 0; x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  __name(mapImageCustomBit, "mapImageCustomBit");
  bitmapper.dataToBitMap = function(data, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace2 = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace2) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = /* @__PURE__ */ __name(function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      }, "getPxPos");
      images = [{ width, height }];
    }
    for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          data,
          rawPos
        );
      } else {
        mapImageCustomBit(
          images[imageIndex],
          pxData,
          getPxPos,
          bpp,
          bits,
          maxBit
        );
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
  return bitmapper;
}
__name(requireBitmapper, "requireBitmapper");
var formatNormaliser;
var hasRequiredFormatNormaliser;
function requireFormatNormaliser() {
  if (hasRequiredFormatNormaliser) return formatNormaliser;
  hasRequiredFormatNormaliser = 1;
  function dePalette(indata, outdata, width, height, palette) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  __name(dePalette, "dePalette");
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  __name(replaceTransparentColor, "replaceTransparentColor");
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        for (let i = 0; i < 4; i++) {
          outdata[pxPos + i] = Math.floor(
            indata[pxPos + i] * maxOutSample / maxInSample + 0.5
          );
        }
        pxPos += 4;
      }
    }
  }
  __name(scaleDepth, "scaleDepth");
  formatNormaliser = /* @__PURE__ */ __name(function(indata, imageData, skipRescale = false) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8 && !skipRescale) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  }, "formatNormaliser");
  return formatNormaliser;
}
__name(requireFormatNormaliser, "requireFormatNormaliser");
var hasRequiredParserAsync;
function requireParserAsync() {
  if (hasRequiredParserAsync) return parserAsync.exports;
  hasRequiredParserAsync = 1;
  let util2 = require$$0$2__default;
  let zlib2 = requireLib();
  let ChunkStream = requireChunkstream();
  let FilterAsync = requireFilterParseAsync();
  let Parser2 = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  let ParserAsync = parserAsync.exports = function(options2) {
    ChunkStream.call(this);
    this._parser = new Parser2(options2, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options2;
    this.writable = true;
    this._parser.start();
  };
  util2.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {
      });
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib2.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib2.Z_MIN_CHUNK);
        this._inflate = zlib2.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper2.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser2(
        bitmapData,
        this._bitmapInfo,
        this._options.skipRescale
      );
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
  return parserAsync.exports;
}
__name(requireParserAsync, "requireParserAsync");
var packerAsync = { exports: {} };
var packer = { exports: {} };
var bitpacker;
var hasRequiredBitpacker;
function requireBitpacker() {
  if (hasRequiredBitpacker) return bitpacker;
  hasRequiredBitpacker = 1;
  let constants3 = requireConstants();
  bitpacker = /* @__PURE__ */ __name(function(dataIn, width, height, options2) {
    let outHasAlpha = [constants3.COLORTYPE_COLOR_ALPHA, constants3.COLORTYPE_ALPHA].indexOf(
      options2.colorType
    ) !== -1;
    if (options2.colorType === options2.inputColorType) {
      let bigEndian = (function() {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(
          0,
          256,
          true
          /* littleEndian */
        );
        return new Int16Array(buffer)[0] !== 256;
      })();
      if (options2.bitDepth === 8 || options2.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data = options2.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants3.COLORTYPE_TO_BPP_MAP[options2.inputColorType];
    if (inBpp === 4 && !options2.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants3.COLORTYPE_TO_BPP_MAP[options2.colorType];
    if (options2.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options2.bgColor || {};
    if (bgColor.red === void 0) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === void 0) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === void 0) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options2.inputColorType) {
        case constants3.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants3.COLORTYPE_COLOR:
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants3.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        case constants3.COLORTYPE_GRAYSCALE:
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error(
            "input color type:" + options2.inputColorType + " is not supported at present"
          );
      }
      if (options2.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
            maxValue
          );
          green = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
            maxValue
          );
          blue = Math.min(
            Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
            maxValue
          );
        }
      }
      return { red, green, blue, alpha };
    }
    __name(getRGBA, "getRGBA");
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let rgba = getRGBA();
        switch (options2.colorType) {
          case constants3.COLORTYPE_COLOR_ALPHA:
          case constants3.COLORTYPE_COLOR:
            if (options2.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants3.COLORTYPE_ALPHA:
          case constants3.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options2.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options2.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  }, "bitpacker");
  return bitpacker;
}
__name(requireBitpacker, "requireBitpacker");
var filterPack;
var hasRequiredFilterPack;
function requireFilterPack() {
  if (hasRequiredFilterPack) return filterPack;
  hasRequiredFilterPack = 1;
  let paethPredictor2 = requirePaethPredictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  __name(filterNone, "filterNone");
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i = pxPos; i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  __name(filterSumNone, "filterSumNone");
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  __name(filterSub, "filterSub");
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumSub, "filterSumSub");
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0; x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  __name(filterUp, "filterUp");
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos; x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumUp, "filterSumUp");
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  __name(filterAvg, "filterAvg");
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumAvg, "filterSumAvg");
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  __name(filterPaeth, "filterPaeth");
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0; x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor2(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  __name(filterSumPaeth, "filterSumPaeth");
  let filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  let filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  filterPack = /* @__PURE__ */ __name(function(pxData, width, height, options2, bpp) {
    let filterTypes;
    if (!("filterType" in options2) || options2.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options2.filterType === "number") {
      filterTypes = [options2.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options2.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0; y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i = 0; i < filterTypes.length; i++) {
          let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  }, "filterPack");
  return filterPack;
}
__name(requireFilterPack, "requireFilterPack");
var hasRequiredPacker;
function requirePacker() {
  if (hasRequiredPacker) return packer.exports;
  hasRequiredPacker = 1;
  let constants3 = requireConstants();
  let CrcStream = requireCrc();
  let bitPacker = requireBitpacker();
  let filter = requireFilterPack();
  let zlib2 = requireLib();
  let Packer = packer.exports = function(options2) {
    this._options = options2;
    options2.deflateChunkSize = options2.deflateChunkSize || 32 * 1024;
    options2.deflateLevel = options2.deflateLevel != null ? options2.deflateLevel : 9;
    options2.deflateStrategy = options2.deflateStrategy != null ? options2.deflateStrategy : 3;
    options2.inputHasAlpha = options2.inputHasAlpha != null ? options2.inputHasAlpha : true;
    options2.deflateFactory = options2.deflateFactory || zlib2.createDeflate;
    options2.bitDepth = options2.bitDepth || 8;
    options2.colorType = typeof options2.colorType === "number" ? options2.colorType : constants3.COLORTYPE_COLOR_ALPHA;
    options2.inputColorType = typeof options2.inputColorType === "number" ? options2.inputColorType : constants3.COLORTYPE_COLOR_ALPHA;
    if ([
      constants3.COLORTYPE_GRAYSCALE,
      constants3.COLORTYPE_COLOR,
      constants3.COLORTYPE_COLOR_ALPHA,
      constants3.COLORTYPE_ALPHA
    ].indexOf(options2.colorType) === -1) {
      throw new Error(
        "option color type:" + options2.colorType + " is not supported at present"
      );
    }
    if ([
      constants3.COLORTYPE_GRAYSCALE,
      constants3.COLORTYPE_COLOR,
      constants3.COLORTYPE_COLOR_ALPHA,
      constants3.COLORTYPE_ALPHA
    ].indexOf(options2.inputColorType) === -1) {
      throw new Error(
        "option input color type:" + options2.inputColorType + " is not supported at present"
      );
    }
    if (options2.bitDepth !== 8 && options2.bitDepth !== 16) {
      throw new Error(
        "option bit depth:" + options2.bitDepth + " is not supported at present"
      );
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    let packedData = bitPacker(data, width, height, this._options);
    let bpp = constants3.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type, data) {
    let len = data ? data.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(
      CrcStream.crc32(buf.slice(4, buf.length - 4)),
      buf.length - 4
    );
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants3.GAMMA_DIVISION), 0);
    return this._packChunk(constants3.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants3.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants3.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants3.TYPE_IEND, null);
  };
  return packer.exports;
}
__name(requirePacker, "requirePacker");
var hasRequiredPackerAsync;
function requirePackerAsync() {
  if (hasRequiredPackerAsync) return packerAsync.exports;
  hasRequiredPackerAsync = 1;
  let util2 = require$$0$2__default;
  let Stream2 = require$$6;
  let constants3 = requireConstants();
  let Packer = requirePacker();
  let PackerAsync = packerAsync.exports = function(opt) {
    Stream2.call(this);
    let options2 = opt || {};
    this._packer = new Packer(options2);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util2.inherits(PackerAsync, Stream2);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", Buffer.from(constants3.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on(
      "data",
      function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this)
    );
    this._deflate.on(
      "end",
      function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this)
    );
    this._deflate.end(filteredData);
  };
  return packerAsync.exports;
}
__name(requirePackerAsync, "requirePackerAsync");
var pngSync = {};
var syncInflate = { exports: {} };
var hasRequiredSyncInflate;
function requireSyncInflate() {
  if (hasRequiredSyncInflate) return syncInflate.exports;
  hasRequiredSyncInflate = 1;
  (function(module, exports) {
    let assert4 = require$$5.ok;
    let zlib2 = requireLib();
    let util2 = require$$0$2__default;
    let kMaxLength = require$$0$1.kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib2.Z_MIN_CHUNK) {
        opts.chunkSize = zlib2.Z_MIN_CHUNK;
      }
      zlib2.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    __name(Inflate, "Inflate");
    function createInflate2(opts) {
      return new Inflate(opts);
    }
    __name(createInflate2, "createInflate");
    function _close(engine, callback) {
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    __name(_close, "_close");
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib2.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error3;
      this.on("error", function(err) {
        error3 = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert4(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      __name(handleChunk, "handleChunk");
      assert4(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error3;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(
          "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
        );
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util2.inherits(Inflate, zlib2.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib2.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    __name(zlibBufferSync, "zlibBufferSync");
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    __name(inflateSync, "inflateSync");
    module.exports = exports = inflateSync;
    exports.Inflate = Inflate;
    exports.createInflate = createInflate2;
    exports.inflateSync = inflateSync;
  })(syncInflate, syncInflate.exports);
  return syncInflate.exports;
}
__name(requireSyncInflate, "requireSyncInflate");
var syncReader = { exports: {} };
var hasRequiredSyncReader;
function requireSyncReader() {
  if (hasRequiredSyncReader) return syncReader.exports;
  hasRequiredSyncReader = 1;
  let SyncReader = syncReader.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      // if length < 0 then at most this length
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      throw new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      throw new Error("unrecognised content at end of stream");
    }
  };
  return syncReader.exports;
}
__name(requireSyncReader, "requireSyncReader");
var filterParseSync = {};
var hasRequiredFilterParseSync;
function requireFilterParseSync() {
  if (hasRequiredFilterParseSync) return filterParseSync;
  hasRequiredFilterParseSync = 1;
  let SyncReader = requireSyncReader();
  let Filter = requireFilterParse();
  filterParseSync.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: /* @__PURE__ */ __name(function(bufferPart) {
        outBuffers.push(bufferPart);
      }, "write"),
      complete: /* @__PURE__ */ __name(function() {
      }, "complete")
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
  return filterParseSync;
}
__name(requireFilterParseSync, "requireFilterParseSync");
var parserSync;
var hasRequiredParserSync;
function requireParserSync() {
  if (hasRequiredParserSync) return parserSync;
  hasRequiredParserSync = 1;
  let hasSyncZlib = true;
  let zlib2 = requireLib();
  let inflateSync = requireSyncInflate();
  if (!zlib2.deflateSync) {
    hasSyncZlib = false;
  }
  let SyncReader = requireSyncReader();
  let FilterSync = requireFilterParseSync();
  let Parser2 = requireParser();
  let bitmapper2 = requireBitmapper();
  let formatNormaliser2 = requireFormatNormaliser();
  parserSync = /* @__PURE__ */ __name(function(buffer, options2) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    __name(handleError, "handleError");
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    __name(handleMetaData, "handleMetaData");
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    __name(handleTransColor, "handleTransColor");
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    __name(handlePalette, "handlePalette");
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    __name(handleSimpleTransparency, "handleSimpleTransparency");
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    __name(handleGamma, "handleGamma");
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    __name(handleInflateData, "handleInflateData");
    let reader = new SyncReader(buffer);
    let parser2 = new Parser2(options2, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser2.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib2.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper2.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser2(
      bitmapData,
      metaData,
      options2.skipRescale
    );
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  }, "parserSync");
  return parserSync;
}
__name(requireParserSync, "requireParserSync");
var packerSync;
var hasRequiredPackerSync;
function requirePackerSync() {
  if (hasRequiredPackerSync) return packerSync;
  hasRequiredPackerSync = 1;
  let hasSyncZlib = true;
  let zlib2 = requireLib();
  if (!zlib2.deflateSync) {
    hasSyncZlib = false;
  }
  let constants3 = requireConstants();
  let Packer = requirePacker();
  packerSync = /* @__PURE__ */ __name(function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error(
        "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
      );
    }
    let options2 = opt || {};
    let packer2 = new Packer(options2);
    let chunks = [];
    chunks.push(Buffer.from(constants3.PNG_SIGNATURE));
    chunks.push(packer2.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer2.packGAMA(metaData.gamma));
    }
    let filteredData = packer2.filterData(
      metaData.data,
      metaData.width,
      metaData.height
    );
    let compressedData = zlib2.deflateSync(
      filteredData,
      packer2.getDeflateOptions()
    );
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer2.packIDAT(compressedData));
    chunks.push(packer2.packIEND());
    return Buffer.concat(chunks);
  }, "packerSync");
  return packerSync;
}
__name(requirePackerSync, "requirePackerSync");
var hasRequiredPngSync;
function requirePngSync() {
  if (hasRequiredPngSync) return pngSync;
  hasRequiredPngSync = 1;
  let parse2 = requireParserSync();
  let pack = requirePackerSync();
  pngSync.read = function(buffer, options2) {
    return parse2(buffer, options2 || {});
  };
  pngSync.write = function(png2, options2) {
    return pack(png2, options2);
  };
  return pngSync;
}
__name(requirePngSync, "requirePngSync");
var hasRequiredPng;
function requirePng() {
  if (hasRequiredPng) return png;
  hasRequiredPng = 1;
  let util2 = require$$0$2__default;
  let Stream2 = require$$6;
  let Parser2 = requireParserAsync();
  let Packer = requirePackerAsync();
  let PNGSync = requirePngSync();
  let PNG3 = png.PNG = function(options2) {
    Stream2.call(this);
    options2 = options2 || {};
    this.width = options2.width | 0;
    this.height = options2.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options2.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser2(options2);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on(
      "parsed",
      function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this)
    );
    this._packer = new Packer(options2);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util2.inherits(PNG3, Stream2);
  PNG3.sync = PNGSync;
  PNG3.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(
      function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this)
    );
    return this;
  };
  PNG3.prototype.parse = function(data, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG3.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG3.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG3.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG3.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG3.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG3.bitblt = function(src2, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src2.width || srcY > src2.height || srcX + width > src2.width || srcY + height > src2.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0; y < height; y++) {
      src2.data.copy(
        dst.data,
        (deltaY + y) * dst.width + deltaX << 2,
        (srcY + y) * src2.width + srcX << 2,
        (srcY + y) * src2.width + srcX + width << 2
      );
    }
  };
  PNG3.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG3.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG3.adjustGamma = function(src2) {
    if (src2.gamma) {
      for (let y = 0; y < src2.height; y++) {
        for (let x = 0; x < src2.width; x++) {
          let idx = src2.width * y + x << 2;
          for (let i = 0; i < 3; i++) {
            let sample = src2.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src2.gamma);
            src2.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src2.gamma = 0;
    }
  };
  PNG3.prototype.adjustGamma = function() {
    PNG3.adjustGamma(this);
  };
  return png;
}
__name(requirePng, "requirePng");
var pngExports = requirePng();
var PNG = pngExports.PNG;

// node_modules/@cloudflare/playwright/lib/bundles/utilsBundleImpl.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
var lockfile$1 = {};
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants3 = require$$02;
  var origCwd = process.cwd;
  var cwd2 = null;
  var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd2)
      cwd2 = origCwd.call(process);
    return cwd2;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir2 = process.chdir;
    process.chdir = function(d) {
      cwd2 = null;
      chdir2.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir2);
  }
  polyfills = patch;
  function patch(fs34) {
    if (constants3.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs34);
    }
    if (!fs34.lutimes) {
      patchLutimes(fs34);
    }
    fs34.chown = chownFix(fs34.chown);
    fs34.fchown = chownFix(fs34.fchown);
    fs34.lchown = chownFix(fs34.lchown);
    fs34.chmod = chmodFix(fs34.chmod);
    fs34.fchmod = chmodFix(fs34.fchmod);
    fs34.lchmod = chmodFix(fs34.lchmod);
    fs34.chownSync = chownFixSync(fs34.chownSync);
    fs34.fchownSync = chownFixSync(fs34.fchownSync);
    fs34.lchownSync = chownFixSync(fs34.lchownSync);
    fs34.chmodSync = chmodFixSync(fs34.chmodSync);
    fs34.fchmodSync = chmodFixSync(fs34.fchmodSync);
    fs34.lchmodSync = chmodFixSync(fs34.lchmodSync);
    fs34.stat = statFix(fs34.stat);
    fs34.fstat = statFix(fs34.fstat);
    fs34.lstat = statFix(fs34.lstat);
    fs34.statSync = statFixSync(fs34.statSync);
    fs34.fstatSync = statFixSync(fs34.fstatSync);
    fs34.lstatSync = statFixSync(fs34.lstatSync);
    if (fs34.chmod && !fs34.lchmod) {
      fs34.lchmod = function(path30, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs34.lchmodSync = function() {
      };
    }
    if (fs34.chown && !fs34.lchown) {
      fs34.lchown = function(path30, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs34.lchownSync = function() {
      };
    }
    if (platform2 === "win32") {
      fs34.rename = typeof fs34.rename !== "function" ? fs34.rename : (function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, /* @__PURE__ */ __name(function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs34.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          }, "CB"));
        }
        __name(rename, "rename");
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      })(fs34.rename);
    }
    fs34.read = typeof fs34.read !== "function" ? fs34.read : (function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = /* @__PURE__ */ __name(function(er, _, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs34, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          }, "callback");
        }
        return fs$read.call(fs34, fd, buffer, offset, length, position, callback);
      }
      __name(read, "read");
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    })(fs34.read);
    fs34.readSync = typeof fs34.readSync !== "function" ? fs34.readSync : /* @__PURE__ */ (function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs34, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    })(fs34.readSync);
    function patchLchmod(fs210) {
      fs210.lchmod = function(path30, mode, callback) {
        fs210.open(
          path30,
          constants3.O_WRONLY | constants3.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs210.fchmod(fd, mode, function(err2) {
              fs210.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs210.lchmodSync = function(path30, mode) {
        var fd = fs210.openSync(path30, constants3.O_WRONLY | constants3.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs210.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs210.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs210.closeSync(fd);
          }
        }
        return ret;
      };
    }
    __name(patchLchmod, "patchLchmod");
    function patchLutimes(fs210) {
      if (constants3.hasOwnProperty("O_SYMLINK") && fs210.futimes) {
        fs210.lutimes = function(path30, at, mt, cb) {
          fs210.open(path30, constants3.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs210.futimes(fd, at, mt, function(er2) {
              fs210.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs210.lutimesSync = function(path30, at, mt) {
          var fd = fs210.openSync(path30, constants3.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs210.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs210.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs210.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs210.futimes) {
        fs210.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs210.lutimesSync = function() {
        };
      }
    }
    __name(patchLutimes, "patchLutimes");
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode, cb) {
        return orig.call(fs34, target, mode, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    __name(chmodFix, "chmodFix");
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode) {
        try {
          return orig.call(fs34, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    __name(chmodFixSync, "chmodFixSync");
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs34, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    __name(chownFix, "chownFix");
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs34, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    __name(chownFixSync, "chownFixSync");
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options2, cb) {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        __name(callback, "callback");
        return options2 ? orig.call(fs34, target, options2, callback) : orig.call(fs34, target, callback);
      };
    }
    __name(statFix, "statFix");
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options2) {
        var stats = options2 ? orig.call(fs34, target, options2) : orig.call(fs34, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    __name(statFixSync, "statFixSync");
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
    __name(chownErOk, "chownErOk");
  }
  __name(patch, "patch");
  return polyfills;
}
__name(requirePolyfills, "requirePolyfills");
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream2 = require$$62.Stream;
  legacyStreams = legacy;
  function legacy(fs34) {
    return {
      ReadStream: ReadStream2,
      WriteStream: WriteStream2
    };
    function ReadStream2(path30, options2) {
      if (!(this instanceof ReadStream2)) return new ReadStream2(path30, options2);
      Stream2.call(this);
      var self2 = this;
      this.path = path30;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options2 = options2 || {};
      var keys = Object.keys(options2);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options2[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs34.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    __name(ReadStream2, "ReadStream");
    function WriteStream2(path30, options2) {
      if (!(this instanceof WriteStream2)) return new WriteStream2(path30, options2);
      Stream2.call(this);
      this.path = path30;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options2 = options2 || {};
      var keys = Object.keys(options2);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options2[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs34.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
    __name(WriteStream2, "WriteStream");
  }
  __name(legacy, "legacy");
  return legacyStreams;
}
__name(requireLegacyStreams, "requireLegacyStreams");
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  __name(clone, "clone");
  return clone_1;
}
__name(requireClone, "requireClone");
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs$1 = fs;
  var polyfills2 = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone();
  var util2 = require$$0$2__default2;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop() {
  }
  __name(noop, "noop");
  function publishQueue(context2, queue2) {
    Object.defineProperty(context2, gracefulQueue, {
      get: /* @__PURE__ */ __name(function() {
        return queue2;
      }, "get")
    });
  }
  __name(publishQueue, "publishQueue");
  var debug22 = noop;
  if (util2.debuglog)
    debug22 = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug22 = /* @__PURE__ */ __name(function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    }, "debug2");
  if (!fs$1[gracefulQueue]) {
    var queue = commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs$1, queue);
    fs$1.close = (function(fs$close) {
      function close2(fd, cb) {
        return fs$close.call(fs$1, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      __name(close2, "close");
      Object.defineProperty(close2, previousSymbol, {
        value: fs$close
      });
      return close2;
    })(fs$1.close);
    fs$1.closeSync = (function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs$1, arguments);
        resetQueue();
      }
      __name(closeSync, "closeSync");
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    })(fs$1.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug22(fs$1[gracefulQueue]);
        require$$52.equal(fs$1[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal[gracefulQueue]) {
    publishQueue(commonjsGlobal, fs$1[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs$1));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$1.__patched) {
    gracefulFs = patch(fs$1);
    fs$1.__patched = true;
  }
  function patch(fs210) {
    polyfills2(fs210);
    fs210.gracefulify = patch;
    fs210.createReadStream = createReadStream;
    fs210.createWriteStream = createWriteStream;
    var fs$readFile = fs210.readFile;
    fs210.readFile = readFile;
    function readFile(path30, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$readFile(path30, options2, cb);
      function go$readFile(path210, options22, cb2, startTime) {
        return fs$readFile(path210, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path210, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$readFile, "go$readFile");
    }
    __name(readFile, "readFile");
    var fs$writeFile = fs210.writeFile;
    fs210.writeFile = writeFile;
    function writeFile(path30, data, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$writeFile(path30, data, options2, cb);
      function go$writeFile(path210, data2, options22, cb2, startTime) {
        return fs$writeFile(path210, data2, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path210, data2, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$writeFile, "go$writeFile");
    }
    __name(writeFile, "writeFile");
    var fs$appendFile = fs210.appendFile;
    if (fs$appendFile)
      fs210.appendFile = appendFile;
    function appendFile(path30, data, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      return go$appendFile(path30, data, options2, cb);
      function go$appendFile(path210, data2, options22, cb2, startTime) {
        return fs$appendFile(path210, data2, options22, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path210, data2, options22, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$appendFile, "go$appendFile");
    }
    __name(appendFile, "appendFile");
    var fs$copyFile = fs210.copyFile;
    if (fs$copyFile)
      fs210.copyFile = copyFile;
    function copyFile(src2, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src3, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src3, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src3, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$copyFile, "go$copyFile");
    }
    __name(copyFile, "copyFile");
    var fs$readdir = fs210.readdir;
    fs210.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path30, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? /* @__PURE__ */ __name(function go$readdir2(path210, options22, cb2, startTime) {
        return fs$readdir(path210, fs$readdirCallback(
          path210,
          options22,
          cb2,
          startTime
        ));
      }, "go$readdir2") : /* @__PURE__ */ __name(function go$readdir2(path210, options22, cb2, startTime) {
        return fs$readdir(path210, options22, fs$readdirCallback(
          path210,
          options22,
          cb2,
          startTime
        ));
      }, "go$readdir2");
      return go$readdir(path30, options2, cb);
      function fs$readdirCallback(path210, options22, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path210, options22, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
      __name(fs$readdirCallback, "fs$readdirCallback");
    }
    __name(readdir, "readdir");
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs210);
      ReadStream2 = legStreams.ReadStream;
      WriteStream2 = legStreams.WriteStream;
    }
    var fs$ReadStream = fs210.ReadStream;
    if (fs$ReadStream) {
      ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream2.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs210.WriteStream;
    if (fs$WriteStream) {
      WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream2.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs210, "ReadStream", {
      get: /* @__PURE__ */ __name(function() {
        return ReadStream2;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        ReadStream2 = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs210, "WriteStream", {
      get: /* @__PURE__ */ __name(function() {
        return WriteStream2;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        WriteStream2 = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream2;
    Object.defineProperty(fs210, "FileReadStream", {
      get: /* @__PURE__ */ __name(function() {
        return FileReadStream;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        FileReadStream = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream2;
    Object.defineProperty(fs210, "FileWriteStream", {
      get: /* @__PURE__ */ __name(function() {
        return FileWriteStream;
      }, "get"),
      set: /* @__PURE__ */ __name(function(val) {
        FileWriteStream = val;
      }, "set"),
      enumerable: true,
      configurable: true
    });
    function ReadStream2(path30, options2) {
      if (this instanceof ReadStream2)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
    }
    __name(ReadStream2, "ReadStream");
    function ReadStream$open() {
      var that = this;
      open22(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    __name(ReadStream$open, "ReadStream$open");
    function WriteStream2(path30, options2) {
      if (this instanceof WriteStream2)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
    }
    __name(WriteStream2, "WriteStream");
    function WriteStream$open() {
      var that = this;
      open22(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    __name(WriteStream$open, "WriteStream$open");
    function createReadStream(path30, options2) {
      return new fs210.ReadStream(path30, options2);
    }
    __name(createReadStream, "createReadStream");
    function createWriteStream(path30, options2) {
      return new fs210.WriteStream(path30, options2);
    }
    __name(createWriteStream, "createWriteStream");
    var fs$open = fs210.open;
    fs210.open = open22;
    function open22(path30, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path30, flags, mode, cb);
      function go$open(path210, flags2, mode2, cb2, startTime) {
        return fs$open(path210, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path210, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
      __name(go$open, "go$open");
    }
    __name(open22, "open2");
    return fs210;
  }
  __name(patch, "patch");
  function enqueue(elem) {
    debug22("ENQUEUE", elem[0].name, elem[1]);
    fs$1[gracefulQueue].push(elem);
    retry2();
  }
  __name(enqueue, "enqueue");
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs$1[gracefulQueue].length; ++i) {
      if (fs$1[gracefulQueue][i].length > 2) {
        fs$1[gracefulQueue][i][3] = now;
        fs$1[gracefulQueue][i][4] = now;
      }
    }
    retry2();
  }
  __name(resetQueue, "resetQueue");
  function retry2() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs$1[gracefulQueue].length === 0)
      return;
    var elem = fs$1[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug22("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug22("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug22("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs$1[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry2, 0);
    }
  }
  __name(retry2, "retry2");
  return gracefulFs;
}
__name(requireGracefulFs, "requireGracefulFs");
var retry$1 = {};
var retry_operation;
var hasRequiredRetry_operation;
function requireRetry_operation() {
  if (hasRequiredRetry_operation) return retry_operation;
  hasRequiredRetry_operation = 1;
  function RetryOperation(timeouts, options2) {
    if (typeof options2 === "boolean") {
      options2 = { forever: options2 };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options2 || {};
    this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  __name(RetryOperation, "RetryOperation");
  retry_operation = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = (/* @__PURE__ */ new Date()).getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self2 = this;
    var timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = (/* @__PURE__ */ new Date()).getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error3 = this._errors[i];
      var message = error3.message;
      var count3 = (counts[message] || 0) + 1;
      counts[message] = count3;
      if (count3 >= mainErrorCount) {
        mainError = error3;
        mainErrorCount = count3;
      }
    }
    return mainError;
  };
  return retry_operation;
}
__name(requireRetry_operation, "requireRetry_operation");
var hasRequiredRetry$1;
function requireRetry$1() {
  if (hasRequiredRetry$1) return retry$1;
  hasRequiredRetry$1 = 1;
  (function(exports) {
    var RetryOperation = requireRetry_operation();
    exports.operation = function(options2) {
      var timeouts = exports.timeouts(options2);
      return new RetryOperation(timeouts, {
        forever: options2 && options2.forever,
        unref: options2 && options2.unref,
        maxRetryTime: options2 && options2.maxRetryTime
      });
    };
    exports.timeouts = function(options2) {
      if (options2 instanceof Array) {
        return [].concat(options2);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options2) {
        opts[key] = options2[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options2 && options2.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options2, methods) {
      if (options2 instanceof Array) {
        methods = options2;
        options2 = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
          var op = exports.operation(options2);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }, "retryWrapper")).bind(obj, original);
        obj[method].options = options2;
      }
    };
  })(retry$1);
  return retry$1;
}
__name(requireRetry$1, "requireRetry$1");
var retry;
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  retry = requireRetry$1();
  return retry;
}
__name(requireRetry, "requireRetry");
var signalExit = { exports: {} };
var signals = { exports: {} };
var hasRequiredSignals;
function requireSignals() {
  if (hasRequiredSignals) return signals.exports;
  hasRequiredSignals = 1;
  (function(module) {
    module.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  })(signals);
  return signals.exports;
}
__name(requireSignals, "requireSignals");
var hasRequiredSignalExit;
function requireSignalExit() {
  if (hasRequiredSignalExit) return signalExit.exports;
  hasRequiredSignalExit = 1;
  var process2 = commonjsGlobal.process;
  const processOk = /* @__PURE__ */ __name(function(process3) {
    return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
  }, "processOk");
  if (!processOk(process2)) {
    signalExit.exports = function() {
      return function() {
      };
    };
  } else {
    var assert4 = require$$52;
    var signals2 = requireSignals();
    var isWin2 = /^win/i.test(process2.platform);
    var EE = EventEmitter2;
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process2.__signal_exit_emitter__) {
      emitter = process2.__signal_exit_emitter__;
    } else {
      emitter = process2.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    signalExit.exports = function(cb, opts) {
      if (!processOk(commonjsGlobal.process)) {
        return function() {
        };
      }
      assert4.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove = /* @__PURE__ */ __name(function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      }, "remove");
      emitter.on(ev, cb);
      return remove;
    };
    var unload = /* @__PURE__ */ __name(function unload2() {
      if (!loaded || !processOk(commonjsGlobal.process)) {
        return;
      }
      loaded = false;
      signals2.forEach(function(sig) {
        try {
          process2.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process2.emit = originalProcessEmit;
      process2.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }, "unload2");
    signalExit.exports.unload = unload;
    var emit2 = /* @__PURE__ */ __name(function emit22(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }, "emit2");
    var sigListeners = {};
    signals2.forEach(function(sig) {
      sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
        if (!processOk(commonjsGlobal.process)) {
          return;
        }
        var listeners2 = process2.listeners(sig);
        if (listeners2.length === emitter.count) {
          unload();
          emit2("exit", null, sig);
          emit2("afterexit", null, sig);
          if (isWin2 && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process2.kill(process2.pid, sig);
        }
      }, "listener");
    });
    signalExit.exports.signals = function() {
      return signals2;
    };
    var loaded = false;
    var load = /* @__PURE__ */ __name(function load2() {
      if (loaded || !processOk(commonjsGlobal.process)) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals2 = signals2.filter(function(sig) {
        try {
          process2.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process2.emit = processEmit;
      process2.reallyExit = processReallyExit;
    }, "load2");
    signalExit.exports.load = load;
    var originalProcessReallyExit = process2.reallyExit;
    var processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
      if (!processOk(commonjsGlobal.process)) {
        return;
      }
      process2.exitCode = code || /* istanbul ignore next */
      0;
      emit2("exit", process2.exitCode, null);
      emit2("afterexit", process2.exitCode, null);
      originalProcessReallyExit.call(process2, process2.exitCode);
    }, "processReallyExit2");
    var originalProcessEmit = process2.emit;
    var processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg) {
      if (ev === "exit" && processOk(commonjsGlobal.process)) {
        if (arg !== void 0) {
          process2.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit2("exit", process2.exitCode, null);
        emit2("afterexit", process2.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }, "processEmit2");
  }
  return signalExit.exports;
}
__name(requireSignalExit, "requireSignalExit");
var hasRequiredLockfile;
function requireLockfile() {
  if (hasRequiredLockfile) return lockfile$1;
  hasRequiredLockfile = 1;
  const path$1 = path;
  const fs34 = requireGracefulFs();
  const retry2 = requireRetry();
  const onExit = requireSignalExit();
  const locks = {};
  const cacheSymbol = Symbol();
  function probe(file, fs210, callback) {
    const cachedPrecision = fs210[cacheSymbol];
    if (cachedPrecision) {
      return fs210.stat(file, (err, stat) => {
        if (err) {
          return callback(err);
        }
        callback(null, stat.mtime, cachedPrecision);
      });
    }
    const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
    fs210.utimes(file, mtime, mtime, (err) => {
      if (err) {
        return callback(err);
      }
      fs210.stat(file, (err2, stat) => {
        if (err2) {
          return callback(err2);
        }
        const precision = stat.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
        Object.defineProperty(fs210, cacheSymbol, { value: precision });
        callback(null, stat.mtime, precision);
      });
    });
  }
  __name(probe, "probe");
  function getMtime(precision) {
    let now = Date.now();
    if (precision === "s") {
      now = Math.ceil(now / 1e3) * 1e3;
    }
    return new Date(now);
  }
  __name(getMtime, "getMtime");
  function getLockFile(file, options2) {
    return options2.lockfilePath || `${file}.lock`;
  }
  __name(getLockFile, "getLockFile");
  function resolveCanonicalPath(file, options2, callback) {
    if (!options2.realpath) {
      return callback(null, path$1.resolve(file));
    }
    options2.fs.realpath(file, callback);
  }
  __name(resolveCanonicalPath, "resolveCanonicalPath");
  function acquireLock(file, options2, callback) {
    const lockfilePath = getLockFile(file, options2);
    options2.fs.mkdir(lockfilePath, (err) => {
      if (!err) {
        return probe(lockfilePath, options2.fs, (err2, mtime, mtimePrecision) => {
          if (err2) {
            options2.fs.rmdir(lockfilePath, () => {
            });
            return callback(err2);
          }
          callback(null, mtime, mtimePrecision);
        });
      }
      if (err.code !== "EEXIST") {
        return callback(err);
      }
      if (options2.stale <= 0) {
        return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
      }
      options2.fs.stat(lockfilePath, (err2, stat) => {
        if (err2) {
          if (err2.code === "ENOENT") {
            return acquireLock(file, { ...options2, stale: 0 }, callback);
          }
          return callback(err2);
        }
        if (!isLockStale(stat, options2)) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        removeLock(file, options2, (err3) => {
          if (err3) {
            return callback(err3);
          }
          acquireLock(file, { ...options2, stale: 0 }, callback);
        });
      });
    });
  }
  __name(acquireLock, "acquireLock");
  function isLockStale(stat, options2) {
    return stat.mtime.getTime() < Date.now() - options2.stale;
  }
  __name(isLockStale, "isLockStale");
  function removeLock(file, options2, callback) {
    options2.fs.rmdir(getLockFile(file, options2), (err) => {
      if (err && err.code !== "ENOENT") {
        return callback(err);
      }
      callback();
    });
  }
  __name(removeLock, "removeLock");
  function updateLock(file, options2) {
    const lock2 = locks[file];
    if (lock2.updateTimeout) {
      return;
    }
    lock2.updateDelay = lock2.updateDelay || options2.update;
    lock2.updateTimeout = setTimeout(() => {
      lock2.updateTimeout = null;
      options2.fs.stat(lock2.lockfilePath, (err, stat) => {
        const isOverThreshold = lock2.lastUpdate + options2.stale < Date.now();
        if (err) {
          if (err.code === "ENOENT" || isOverThreshold) {
            return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
          }
          lock2.updateDelay = 1e3;
          return updateLock(file, options2);
        }
        const isMtimeOurs = lock2.mtime.getTime() === stat.mtime.getTime();
        if (!isMtimeOurs) {
          return setLockAsCompromised(
            file,
            lock2,
            Object.assign(
              new Error("Unable to update lock within the stale threshold"),
              { code: "ECOMPROMISED" }
            )
          );
        }
        const mtime = getMtime(lock2.mtimePrecision);
        options2.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
          const isOverThreshold2 = lock2.lastUpdate + options2.stale < Date.now();
          if (lock2.released) {
            return;
          }
          if (err2) {
            if (err2.code === "ENOENT" || isOverThreshold2) {
              return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options2);
          }
          lock2.mtime = mtime;
          lock2.lastUpdate = Date.now();
          lock2.updateDelay = null;
          updateLock(file, options2);
        });
      });
    }, lock2.updateDelay);
    if (lock2.updateTimeout.unref) {
      lock2.updateTimeout.unref();
    }
  }
  __name(updateLock, "updateLock");
  function setLockAsCompromised(file, lock2, err) {
    lock2.released = true;
    if (lock2.updateTimeout) {
      clearTimeout(lock2.updateTimeout);
    }
    if (locks[file] === lock2) {
      delete locks[file];
    }
    lock2.options.onCompromised(err);
  }
  __name(setLockAsCompromised, "setLockAsCompromised");
  function lock(file, options2, callback) {
    options2 = {
      stale: 1e4,
      update: null,
      realpath: true,
      retries: 0,
      fs: fs34,
      onCompromised: /* @__PURE__ */ __name((err) => {
        throw err;
      }, "onCompromised"),
      ...options2
    };
    options2.retries = options2.retries || 0;
    options2.retries = typeof options2.retries === "number" ? { retries: options2.retries } : options2.retries;
    options2.stale = Math.max(options2.stale || 0, 2e3);
    options2.update = options2.update == null ? options2.stale / 2 : options2.update || 0;
    options2.update = Math.max(Math.min(options2.update, options2.stale / 2), 1e3);
    resolveCanonicalPath(file, options2, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const operation = retry2.operation(options2.retries);
      operation.attempt(() => {
        acquireLock(file2, options2, (err2, mtime, mtimePrecision) => {
          if (operation.retry(err2)) {
            return;
          }
          if (err2) {
            return callback(operation.mainError());
          }
          const lock2 = locks[file2] = {
            lockfilePath: getLockFile(file2, options2),
            mtime,
            mtimePrecision,
            options: options2,
            lastUpdate: Date.now()
          };
          updateLock(file2, options2);
          callback(null, (releasedCallback) => {
            if (lock2.released) {
              return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
            }
            unlock(file2, { ...options2, realpath: false }, releasedCallback);
          });
        });
      });
    });
  }
  __name(lock, "lock");
  function unlock(file, options2, callback) {
    options2 = {
      fs: fs34,
      realpath: true,
      ...options2
    };
    resolveCanonicalPath(file, options2, (err, file2) => {
      if (err) {
        return callback(err);
      }
      const lock2 = locks[file2];
      if (!lock2) {
        return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
      }
      lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
      lock2.released = true;
      delete locks[file2];
      removeLock(file2, options2, callback);
    });
  }
  __name(unlock, "unlock");
  function toPromise(method) {
    return (...args) => new Promise((resolve, reject) => {
      args.push((err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
      method(...args);
    });
  }
  __name(toPromise, "toPromise");
  let cleanupInitialized = false;
  function ensureCleanup() {
    if (cleanupInitialized) {
      return;
    }
    cleanupInitialized = true;
    onExit(() => {
      for (const file in locks) {
        const options2 = locks[file].options;
        try {
          options2.fs.rmdirSync(getLockFile(file, options2));
        } catch (e) {
        }
      }
    });
  }
  __name(ensureCleanup, "ensureCleanup");
  lockfile$1.lock = async (file, options2) => {
    ensureCleanup();
    const release2 = await toPromise(lock)(file, options2);
    return toPromise(release2);
  };
  return lockfile$1;
}
__name(requireLockfile, "requireLockfile");
var safe = { exports: {} };
var colors$1 = { exports: {} };
var styles = { exports: {} };
var hasRequiredStyles;
function requireStyles() {
  if (hasRequiredStyles) return styles.exports;
  hasRequiredStyles = 1;
  (function(module) {
    var styles2 = {};
    module["exports"] = styles2;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles2[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  })(styles);
  return styles.exports;
}
__name(requireStyles, "requireStyles");
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = /* @__PURE__ */ __name(function(flag, argv2) {
    argv2 = argv2 || process.argv;
    var terminatorPos = argv2.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv2.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  }, "hasFlag");
  return hasFlag;
}
__name(requireHasFlag, "requireHasFlag");
var supportsColors;
var hasRequiredSupportsColors;
function requireSupportsColors() {
  if (hasRequiredSupportsColors) return supportsColors;
  hasRequiredSupportsColors = 1;
  var os$1 = os;
  var hasFlag2 = requireHasFlag();
  var env3 = process.env;
  var forceColor = void 0;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false")) {
    forceColor = false;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env3) {
    forceColor = env3.FORCE_COLOR.length === 0 || parseInt(env3.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  __name(translateLevel, "translateLevel");
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease2 = os$1.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease2[0]) >= 10 && Number(osRelease2[2]) >= 10586) {
        return Number(osRelease2[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env3;
      }) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env3) {
      var version22 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version22 >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    if (env3.TERM === "dumb") {
      return min;
    }
    return min;
  }
  __name(supportsColor, "supportsColor");
  function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  }
  __name(getSupportLevel, "getSupportLevel");
  supportsColors = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
  return supportsColors;
}
__name(requireSupportsColors, "requireSupportsColors");
var trap = { exports: {} };
var hasRequiredTrap;
function requireTrap() {
  if (hasRequiredTrap) return trap.exports;
  hasRequiredTrap = 1;
  (function(module) {
    module["exports"] = /* @__PURE__ */ __name(function runTheTrap(text, options2) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap2 = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap2[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap2[c] !== "undefined") {
          result += trap2[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    }, "runTheTrap");
  })(trap);
  return trap.exports;
}
__name(requireTrap, "requireTrap");
var zalgo = { exports: {} };
var hasRequiredZalgo;
function requireZalgo() {
  if (hasRequiredZalgo) return zalgo.exports;
  hasRequiredZalgo = 1;
  (function(module) {
    module["exports"] = /* @__PURE__ */ __name(function zalgo2(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      __name(randomNumber, "randomNumber");
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      __name(isChar, "isChar");
      function heComes(text2, options22) {
        var result = "";
        var counts;
        var l;
        options22 = options22 || {};
        options22["up"] = typeof options22["up"] !== "undefined" ? options22["up"] : true;
        options22["mid"] = typeof options22["mid"] !== "undefined" ? options22["mid"] : true;
        options22["down"] = typeof options22["down"] !== "undefined" ? options22["down"] : true;
        options22["size"] = typeof options22["size"] !== "undefined" ? options22["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options22.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index2 = arr[d];
            for (var i = 0; i <= counts[index2]; i++) {
              if (options22[index2]) {
                result = result + soul[index2][randomNumber(soul[index2].length)];
              }
            }
          }
        }
        return result;
      }
      __name(heComes, "heComes");
      return heComes(text, options2);
    }, "zalgo2");
  })(zalgo);
  return zalgo.exports;
}
__name(requireZalgo, "requireZalgo");
var america = { exports: {} };
var hasRequiredAmerica;
function requireAmerica() {
  if (hasRequiredAmerica) return america.exports;
  hasRequiredAmerica = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      return function(letter2, i, exploded) {
        if (letter2 === " ") return letter2;
        switch (i % 3) {
          case 0:
            return colors22.red(letter2);
          case 1:
            return colors22.white(letter2);
          case 2:
            return colors22.blue(letter2);
        }
      };
    };
  })(america);
  return america.exports;
}
__name(requireAmerica, "requireAmerica");
var zebra = { exports: {} };
var hasRequiredZebra;
function requireZebra() {
  if (hasRequiredZebra) return zebra.exports;
  hasRequiredZebra = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      return function(letter2, i, exploded) {
        return i % 2 === 0 ? letter2 : colors22.inverse(letter2);
      };
    };
  })(zebra);
  return zebra.exports;
}
__name(requireZebra, "requireZebra");
var rainbow = { exports: {} };
var hasRequiredRainbow;
function requireRainbow() {
  if (hasRequiredRainbow) return rainbow.exports;
  hasRequiredRainbow = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter2, i, exploded) {
        if (letter2 === " ") {
          return letter2;
        } else {
          return colors22[rainbowColors[i++ % rainbowColors.length]](letter2);
        }
      };
    };
  })(rainbow);
  return rainbow.exports;
}
__name(requireRainbow, "requireRainbow");
var random = { exports: {} };
var hasRequiredRandom;
function requireRandom() {
  if (hasRequiredRandom) return random.exports;
  hasRequiredRandom = 1;
  (function(module) {
    module["exports"] = function(colors22) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter2, i, exploded) {
        return letter2 === " " ? letter2 : colors22[available[Math.round(Math.random() * (available.length - 2))]](letter2);
      };
    };
  })(random);
  return random.exports;
}
__name(requireRandom, "requireRandom");
var hasRequiredColors;
function requireColors() {
  if (hasRequiredColors) return colors$1.exports;
  hasRequiredColors = 1;
  (function(module) {
    var colors22 = {};
    module["exports"] = colors22;
    colors22.themes = {};
    var util2 = require$$0$2__default2;
    var ansiStyles = colors22.styles = requireStyles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors22.supportsColor = requireSupportsColors().supportsColor;
    if (typeof colors22.enabled === "undefined") {
      colors22.enabled = colors22.supportsColor() !== false;
    }
    colors22.enable = function() {
      colors22.enabled = true;
    };
    colors22.disable = function() {
      colors22.enabled = false;
    };
    colors22.stripColors = colors22.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    colors22.stylize = /* @__PURE__ */ __name(function stylize(str, style) {
      if (!colors22.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors22) {
        return colors22[style](str);
      }
      return styleMap.open + str + styleMap.close;
    }, "stylize");
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = /* @__PURE__ */ __name(function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    }, "escapeStringRegexp");
    function build(_styles) {
      var builder = /* @__PURE__ */ __name(function builder2() {
        return applyStyle.apply(builder2, arguments);
      }, "builder2");
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    __name(build, "build");
    var styles2 = (function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: /* @__PURE__ */ __name(function() {
            return build(this._styles.concat(key));
          }, "get")
        };
      });
      return ret;
    })();
    var proto = defineProps(/* @__PURE__ */ __name(function colors3() {
    }, "colors3"), styles2);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util2.inspect(arg);
        }
      }).join(" ");
      if (!colors22.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    __name(applyStyle, "applyStyle");
    colors22.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors22[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors22[theme[style2][i]](out);
              }
              return out;
            }
            return colors22[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles2).forEach(function(name) {
        ret[name] = {
          get: /* @__PURE__ */ __name(function() {
            return build([name]);
          }, "get")
        };
      });
      return ret;
    }
    __name(init, "init");
    var sequencer = /* @__PURE__ */ __name(function sequencer2(map3, str) {
      var exploded = str.split("");
      exploded = exploded.map(map3);
      return exploded.join("");
    }, "sequencer2");
    colors22.trap = requireTrap();
    colors22.zalgo = requireZalgo();
    colors22.maps = {};
    colors22.maps.america = requireAmerica()(colors22);
    colors22.maps.zebra = requireZebra()(colors22);
    colors22.maps.rainbow = requireRainbow()(colors22);
    colors22.maps.random = requireRandom()(colors22);
    for (var map2 in colors22.maps) {
      (function(map3) {
        colors22[map3] = function(str) {
          return sequencer(colors22.maps[map3], str);
        };
      })(map2);
    }
    defineProps(colors22, init());
  })(colors$1);
  return colors$1.exports;
}
__name(requireColors, "requireColors");
var hasRequiredSafe;
function requireSafe() {
  if (hasRequiredSafe) return safe.exports;
  hasRequiredSafe = 1;
  (function(module) {
    var colors22 = requireColors();
    module["exports"] = colors22;
  })(safe);
  return safe.exports;
}
__name(requireSafe, "requireSafe");
var safeExports = requireSafe();
var colorsLibrary = /* @__PURE__ */ getDefaultExportFromCjs(safeExports);
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = /* @__PURE__ */ __name(function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  }, "ms");
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  __name(parse2, "parse2");
  function fmtShort(ms22) {
    var msAbs = Math.abs(ms22);
    if (msAbs >= d) {
      return Math.round(ms22 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms22 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms22 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms22 / s) + "s";
    }
    return ms22 + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms22) {
    var msAbs = Math.abs(ms22);
    if (msAbs >= d) {
      return plural(ms22, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms22, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms22, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms22, msAbs, s, "second");
    }
    return ms22 + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms22, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms22 / n) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
  return ms;
}
__name(requireMs, "requireMs");
var common2;
var hasRequiredCommon2;
function requireCommon2() {
  if (hasRequiredCommon2) return common2;
  hasRequiredCommon2 = 1;
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor");
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug22(...args) {
        if (!debug22.enabled) {
          return;
        }
        const self2 = debug22;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms22 = curr - (prevTime || curr);
        self2.diff = ms22;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      __name(debug22, "debug2");
      debug22.namespace = namespace;
      debug22.useColors = createDebug.useColors();
      debug22.color = createDebug.selectColor(namespace);
      debug22.extend = extend;
      debug22.destroy = createDebug.destroy;
      Object.defineProperty(debug22, "enabled", {
        enumerable: true,
        configurable: false,
        get: /* @__PURE__ */ __name(() => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          enableOverride = v;
        }, "set")
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug22);
      }
      return debug22;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    __name(enable, "enable");
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    __name(enabled, "enabled");
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    __name(toNamespace, "toNamespace");
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    __name(coerce2, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    __name(destroy, "destroy");
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  __name(setup, "setup");
  common2 = setup;
  return common2;
}
__name(requireCommon2, "requireCommon");
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = requireCommon2()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
__name(requireBrowser$1, "requireBrowser$1");
var browserExports$1 = requireBrowser$1();
var debugLibrary = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
function Diff() {
}
__name(Diff, "Diff");
Diff.prototype = {
  diff: /* @__PURE__ */ __name(function diff(oldString, newString) {
    var _options$timeout;
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options2.callback;
    if (typeof options2 === "function") {
      callback = options2;
      options2 = {};
    }
    var self2 = this;
    function done(value) {
      value = self2.postProcess(value, options2);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    __name(done, "done");
    oldString = this.castInput(oldString, options2);
    newString = this.castInput(newString, options2);
    oldString = this.removeEmpty(this.tokenize(oldString, options2));
    newString = this.removeEmpty(this.tokenize(newString, options2));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options2.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options2.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options2.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options2);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self2, bestPath[0].lastComponent, newString, oldString, self2.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self2.addToPath(addPath, true, false, 0, options2);
        } else {
          basePath = self2.addToPath(removePath, false, true, 1, options2);
        }
        newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath, options2);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    __name(execEditLength, "execEditLength");
    if (callback) {
      (/* @__PURE__ */ __name((function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      }), "exec"))();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  }, "diff"),
  addToPath: /* @__PURE__ */ __name(function addToPath(path30, added, removed, oldPosInc, options2) {
    var last = path30.lastComponent;
    if (last && !options2.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path30.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path30.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  }, "addToPath"),
  extractCommon: /* @__PURE__ */ __name(function extractCommon(basePath, newString, oldString, diagonalPath, options2) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options2)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options2.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options2.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  }, "extractCommon"),
  equals: /* @__PURE__ */ __name(function equals(left, right, options2) {
    if (options2.comparator) {
      return options2.comparator(left, right);
    } else {
      return left === right || options2.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  }, "equals"),
  removeEmpty: /* @__PURE__ */ __name(function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  }, "removeEmpty"),
  castInput: /* @__PURE__ */ __name(function castInput(value) {
    return value;
  }, "castInput"),
  tokenize: /* @__PURE__ */ __name(function tokenize(value) {
    return Array.from(value);
  }, "tokenize"),
  join: /* @__PURE__ */ __name(function join(chars) {
    return chars.join("");
  }, "join"),
  postProcess: /* @__PURE__ */ __name(function postProcess(changeObjects) {
    return changeObjects;
  }, "postProcess")
};
function buildValues(diff32, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff32.join(value);
      } else {
        component.value = diff32.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff32.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
__name(buildValues, "buildValues");
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options2) {
  return characterDiff.diff(oldStr, newStr, options2);
}
__name(diffChars, "diffChars");
function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
__name(longestCommonPrefix, "longestCommonPrefix");
function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
__name(longestCommonSuffix, "longestCommonSuffix");
function replacePrefix(string2, oldPrefix, newPrefix) {
  if (string2.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string2.slice(oldPrefix.length);
}
__name(replacePrefix, "replacePrefix");
function replaceSuffix(string2, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string2 + newSuffix;
  }
  if (string2.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string2), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string2.slice(0, -oldSuffix.length) + newSuffix;
}
__name(replaceSuffix, "replaceSuffix");
function removePrefix(string2, oldPrefix) {
  return replacePrefix(string2, oldPrefix, "");
}
__name(removePrefix, "removePrefix");
function removeSuffix(string2, oldSuffix) {
  return replaceSuffix(string2, oldSuffix, "");
}
__name(removeSuffix, "removeSuffix");
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
__name(maximumOverlap, "maximumOverlap");
function overlapCount(a, b) {
  var startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  var endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  var map2 = Array(endB);
  var k = 0;
  map2[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k]) {
      map2[j] = map2[k];
    } else {
      map2[j] = k;
    }
    while (k > 0 && b[j] != b[k]) {
      k = map2[k];
    }
    if (b[j] == b[k]) {
      k++;
    }
  }
  k = 0;
  for (var i = startA; i < a.length; i++) {
    while (k > 0 && a[i] != b[k]) {
      k = map2[k];
    }
    if (a[i] == b[k]) {
      k++;
    }
  }
  return k;
}
__name(overlapCount, "overlapCount");
function hasOnlyWinLineEndings(string2) {
  return string2.includes("\r\n") && !string2.startsWith("\n") && !string2.match(/[^\r]\n/);
}
__name(hasOnlyWinLineEndings, "hasOnlyWinLineEndings");
function hasOnlyUnixLineEndings(string2) {
  return !string2.includes("\r\n") && string2.includes("\n");
}
__name(hasOnlyUnixLineEndings, "hasOnlyUnixLineEndings");
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff();
wordDiff.equals = function(left, right, options2) {
  if (options2.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options2.intlSegmenter) {
    if (options2.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options2.intlSegmenter.segment(value), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options2) {
  if (!changes || options2.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function diffWords(oldStr, newStr, options2) {
  if ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreWhitespace) != null && !options2.ignoreWhitespace) {
    return diffWordsWithSpace(oldStr, newStr, options2);
  }
  return wordDiff.diff(oldStr, newStr, options2);
}
__name(diffWords, "diffWords");
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
__name(dedupeWhitespaceInChangeObjects, "dedupeWhitespaceInChangeObjects");
var wordWithSpaceDiff = new Diff();
wordWithSpaceDiff.tokenize = function(value) {
  var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex) || [];
};
function diffWordsWithSpace(oldStr, newStr, options2) {
  return wordWithSpaceDiff.diff(oldStr, newStr, options2);
}
__name(diffWordsWithSpace, "diffWordsWithSpace");
function generateOptions(options2, defaults) {
  if (typeof options2 === "function") {
    defaults.callback = options2;
  } else if (options2) {
    for (var name in options2) {
      if (options2.hasOwnProperty(name)) {
        defaults[name] = options2[name];
      }
    }
  }
  return defaults;
}
__name(generateOptions, "generateOptions");
var lineDiff = new Diff();
lineDiff.tokenize = function(value, options2) {
  if (options2.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !options2.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff.equals = function(left, right, options2) {
  if (options2.ignoreWhitespace) {
    if (!options2.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options2.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options2.ignoreNewlineAtEof && !options2.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff.prototype.equals.call(this, left, right, options2);
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
__name(diffLines, "diffLines");
function diffTrimmedLines(oldStr, newStr, callback) {
  var options2 = generateOptions(callback, {
    ignoreWhitespace: true
  });
  return lineDiff.diff(oldStr, newStr, options2);
}
__name(diffTrimmedLines, "diffTrimmedLines");
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}
__name(diffSentences, "diffSentences");
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}
__name(diffCss, "diffCss");
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
__name(ownKeys, "ownKeys");
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
__name(_objectSpread2, "_objectSpread2");
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
__name(_toPrimitive, "_toPrimitive");
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
__name(_toPropertyKey, "_toPropertyKey");
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
__name(_typeof, "_typeof");
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
__name(_iterableToArray, "_iterableToArray");
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
__name(_nonIterableSpread, "_nonIterableSpread");
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value, options2) {
  var undefinedReplacement = options2.undefinedReplacement, _options$stringifyRep = options2.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options2) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options2);
};
function diffJson(oldObj, newObj, options2) {
  return jsonDiff.diff(oldObj, newObj, options2);
}
__name(diffJson, "diffJson");
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
__name(canonicalize, "canonicalize");
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}
__name(diffArrays, "diffArrays");
function unixToWin(patch) {
  if (Array.isArray(patch)) {
    return patch.map(unixToWin);
  }
  return _objectSpread2(_objectSpread2({}, patch), {}, {
    hunks: patch.hunks.map(function(hunk) {
      return _objectSpread2(_objectSpread2({}, hunk), {}, {
        lines: hunk.lines.map(function(line, i) {
          var _hunk$lines;
          return line.startsWith("\\") || line.endsWith("\r") || (_hunk$lines = hunk.lines[i + 1]) !== null && _hunk$lines !== void 0 && _hunk$lines.startsWith("\\") ? line : line + "\r";
        })
      });
    })
  });
}
__name(unixToWin, "unixToWin");
function winToUnix(patch) {
  if (Array.isArray(patch)) {
    return patch.map(winToUnix);
  }
  return _objectSpread2(_objectSpread2({}, patch), {}, {
    hunks: patch.hunks.map(function(hunk) {
      return _objectSpread2(_objectSpread2({}, hunk), {}, {
        lines: hunk.lines.map(function(line) {
          return line.endsWith("\r") ? line.substring(0, line.length - 1) : line;
        })
      });
    })
  });
}
__name(winToUnix, "winToUnix");
function isUnix(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return !patch.some(function(index2) {
    return index2.hunks.some(function(hunk) {
      return hunk.lines.some(function(line) {
        return !line.startsWith("\\") && line.endsWith("\r");
      });
    });
  });
}
__name(isUnix, "isUnix");
function isWin(patch) {
  if (!Array.isArray(patch)) {
    patch = [patch];
  }
  return patch.some(function(index2) {
    return index2.hunks.some(function(hunk) {
      return hunk.lines.some(function(line) {
        return line.endsWith("\r");
      });
    });
  }) && patch.every(function(index2) {
    return index2.hunks.every(function(hunk) {
      return hunk.lines.every(function(line, i) {
        var _hunk$lines2;
        return line.startsWith("\\") || line.endsWith("\r") || ((_hunk$lines2 = hunk.lines[i + 1]) === null || _hunk$lines2 === void 0 ? void 0 : _hunk$lines2.startsWith("\\"));
      });
    });
  });
}
__name(isWin, "isWin");
function parsePatch(uniDiff) {
  var diffstr = uniDiff.split(/\n/), list = [], i = 0;
  function parseIndex() {
    var index2 = {};
    list.push(index2);
    while (i < diffstr.length) {
      var line = diffstr[i];
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      }
      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) {
        index2.index = header[1];
      }
      i++;
    }
    parseFileHeader(index2);
    parseFileHeader(index2);
    index2.hunks = [];
    while (i < diffstr.length) {
      var _line = diffstr[i];
      if (/^(Index:\s|diff\s|\-\-\-\s|\+\+\+\s|===================================================================)/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index2.hunks.push(parseHunk());
      } else if (_line) {
        throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  }
  __name(parseIndex, "parseIndex");
  function parseFileHeader(index2) {
    var fileHeader = /^(---|\+\+\+)\s+(.*)\r?$/.exec(diffstr[i]);
    if (fileHeader) {
      var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
      var data = fileHeader[2].split("	", 2);
      var fileName = data[0].replace(/\\\\/g, "\\");
      if (/^".*"$/.test(fileName)) {
        fileName = fileName.substr(1, fileName.length - 2);
      }
      index2[keyPrefix + "FileName"] = fileName;
      index2[keyPrefix + "Header"] = (data[1] || "").trim();
      i++;
    }
  }
  __name(parseFileHeader, "parseFileHeader");
  function parseHunk() {
    var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: typeof chunkHeader[2] === "undefined" ? 1 : +chunkHeader[2],
      newStart: +chunkHeader[3],
      newLines: typeof chunkHeader[4] === "undefined" ? 1 : +chunkHeader[4],
      lines: []
    };
    if (hunk.oldLines === 0) {
      hunk.oldStart += 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart += 1;
    }
    var addCount = 0, removeCount = 0;
    for (; i < diffstr.length && (removeCount < hunk.oldLines || addCount < hunk.newLines || (_diffstr$i = diffstr[i]) !== null && _diffstr$i !== void 0 && _diffstr$i.startsWith("\\")); i++) {
      var _diffstr$i;
      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
      if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
        hunk.lines.push(diffstr[i]);
        if (operation === "+") {
          addCount++;
        } else if (operation === "-") {
          removeCount++;
        } else if (operation === " ") {
          addCount++;
          removeCount++;
        }
      } else {
        throw new Error("Hunk at line ".concat(chunkHeaderIndex + 1, " contained invalid line ").concat(diffstr[i]));
      }
    }
    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }
    if (addCount !== hunk.newLines) {
      throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    if (removeCount !== hunk.oldLines) {
      throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
    }
    return hunk;
  }
  __name(parseHunk, "parseHunk");
  while (i < diffstr.length) {
    parseIndex();
  }
  return list;
}
__name(parsePatch, "parsePatch");
function distanceIterator(start, minLine, maxLine) {
  var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
  return /* @__PURE__ */ __name(function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      }
      if (start + localOffset <= maxLine) {
        return start + localOffset;
      }
      forwardExhausted = true;
    }
    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      }
      if (minLine <= start - localOffset) {
        return start - localOffset++;
      }
      backwardExhausted = true;
      return iterator();
    }
  }, "iterator");
}
__name(distanceIterator, "distanceIterator");
function applyPatch(source8, uniDiff) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof uniDiff === "string") {
    uniDiff = parsePatch(uniDiff);
  }
  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error("applyPatch only works with a single input.");
    }
    uniDiff = uniDiff[0];
  }
  if (options2.autoConvertLineEndings || options2.autoConvertLineEndings == null) {
    if (hasOnlyWinLineEndings(source8) && isUnix(uniDiff)) {
      uniDiff = unixToWin(uniDiff);
    } else if (hasOnlyUnixLineEndings(source8) && isWin(uniDiff)) {
      uniDiff = winToUnix(uniDiff);
    }
  }
  var lines = source8.split("\n"), hunks = uniDiff.hunks, compareLine = options2.compareLine || function(lineNumber, line2, operation, patchContent) {
    return line2 === patchContent;
  }, fuzzFactor = options2.fuzzFactor || 0, minLine = 0;
  if (fuzzFactor < 0 || !Number.isInteger(fuzzFactor)) {
    throw new Error("fuzzFactor must be a non-negative integer");
  }
  if (!hunks.length) {
    return source8;
  }
  var prevLine = "", removeEOFNL = false, addEOFNL = false;
  for (var i = 0; i < hunks[hunks.length - 1].lines.length; i++) {
    var line = hunks[hunks.length - 1].lines[i];
    if (line[0] == "\\") {
      if (prevLine[0] == "+") {
        removeEOFNL = true;
      } else if (prevLine[0] == "-") {
        addEOFNL = true;
      }
    }
    prevLine = line;
  }
  if (removeEOFNL) {
    if (addEOFNL) {
      if (!fuzzFactor && lines[lines.length - 1] == "") {
        return false;
      }
    } else if (lines[lines.length - 1] == "") {
      lines.pop();
    } else if (!fuzzFactor) {
      return false;
    }
  } else if (addEOFNL) {
    if (lines[lines.length - 1] != "") {
      lines.push("");
    } else if (!fuzzFactor) {
      return false;
    }
  }
  function applyHunk(hunkLines, toPos2, maxErrors2) {
    var hunkLinesI = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    var lastContextLineMatched = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var patchedLines = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
    var patchedLinesLength = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
    var nConsecutiveOldContextLines = 0;
    var nextContextLineMustMatch = false;
    for (; hunkLinesI < hunkLines.length; hunkLinesI++) {
      var hunkLine = hunkLines[hunkLinesI], operation = hunkLine.length > 0 ? hunkLine[0] : " ", content = hunkLine.length > 0 ? hunkLine.substr(1) : hunkLine;
      if (operation === "-") {
        if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
          toPos2++;
          nConsecutiveOldContextLines = 0;
        } else {
          if (!maxErrors2 || lines[toPos2] == null) {
            return null;
          }
          patchedLines[patchedLinesLength] = lines[toPos2];
          return applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1);
        }
      }
      if (operation === "+") {
        if (!lastContextLineMatched) {
          return null;
        }
        patchedLines[patchedLinesLength] = content;
        patchedLinesLength++;
        nConsecutiveOldContextLines = 0;
        nextContextLineMustMatch = true;
      }
      if (operation === " ") {
        nConsecutiveOldContextLines++;
        patchedLines[patchedLinesLength] = lines[toPos2];
        if (compareLine(toPos2 + 1, lines[toPos2], operation, content)) {
          patchedLinesLength++;
          lastContextLineMatched = true;
          nextContextLineMustMatch = false;
          toPos2++;
        } else {
          if (nextContextLineMustMatch || !maxErrors2) {
            return null;
          }
          return lines[toPos2] && (applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength + 1) || applyHunk(hunkLines, toPos2 + 1, maxErrors2 - 1, hunkLinesI, false, patchedLines, patchedLinesLength + 1)) || applyHunk(hunkLines, toPos2, maxErrors2 - 1, hunkLinesI + 1, false, patchedLines, patchedLinesLength);
        }
      }
    }
    patchedLinesLength -= nConsecutiveOldContextLines;
    toPos2 -= nConsecutiveOldContextLines;
    patchedLines.length = patchedLinesLength;
    return {
      patchedLines,
      oldLineLastI: toPos2 - 1
    };
  }
  __name(applyHunk, "applyHunk");
  var resultLines = [];
  var prevHunkOffset = 0;
  for (var _i = 0; _i < hunks.length; _i++) {
    var hunk = hunks[_i];
    var hunkResult = void 0;
    var maxLine = lines.length - hunk.oldLines + fuzzFactor;
    var toPos = void 0;
    for (var maxErrors = 0; maxErrors <= fuzzFactor; maxErrors++) {
      toPos = hunk.oldStart + prevHunkOffset - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);
      for (; toPos !== void 0; toPos = iterator()) {
        hunkResult = applyHunk(hunk.lines, toPos, maxErrors);
        if (hunkResult) {
          break;
        }
      }
      if (hunkResult) {
        break;
      }
    }
    if (!hunkResult) {
      return false;
    }
    for (var _i2 = minLine; _i2 < toPos; _i2++) {
      resultLines.push(lines[_i2]);
    }
    for (var _i3 = 0; _i3 < hunkResult.patchedLines.length; _i3++) {
      var _line = hunkResult.patchedLines[_i3];
      resultLines.push(_line);
    }
    minLine = hunkResult.oldLineLastI + 1;
    prevHunkOffset = toPos + 1 - hunk.oldStart;
  }
  for (var _i4 = minLine; _i4 < lines.length; _i4++) {
    resultLines.push(lines[_i4]);
  }
  return resultLines.join("\n");
}
__name(applyPatch, "applyPatch");
function applyPatches(uniDiff, options2) {
  if (typeof uniDiff === "string") {
    uniDiff = parsePatch(uniDiff);
  }
  var currentIndex = 0;
  function processIndex() {
    var index2 = uniDiff[currentIndex++];
    if (!index2) {
      return options2.complete();
    }
    options2.loadFile(index2, function(err, data) {
      if (err) {
        return options2.complete(err);
      }
      var updatedContent = applyPatch(data, index2, options2);
      options2.patched(index2, updatedContent, function(err2) {
        if (err2) {
          return options2.complete(err2);
        }
        processIndex();
      });
    });
  }
  __name(processIndex, "processIndex");
  processIndex();
}
__name(applyPatches, "applyPatches");
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  if (!options2) {
    options2 = {};
  }
  if (typeof options2 === "function") {
    options2 = {
      callback: options2
    };
  }
  if (typeof options2.context === "undefined") {
    options2.context = 4;
  }
  if (options2.newlineIsToken) {
    throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");
  }
  if (!options2.callback) {
    return diffLinesResultToPatch(diffLines(oldStr, newStr, options2));
  } else {
    var _options = options2, _callback = _options.callback;
    diffLines(oldStr, newStr, _objectSpread2(_objectSpread2({}, options2), {}, {
      callback: /* @__PURE__ */ __name(function callback(diff32) {
        var patch = diffLinesResultToPatch(diff32);
        _callback(patch);
      }, "callback")
    }));
  }
  function diffLinesResultToPatch(diff32) {
    if (!diff32) {
      return;
    }
    diff32.push({
      value: "",
      lines: []
    });
    function contextLines(lines) {
      return lines.map(function(entry) {
        return " " + entry;
      });
    }
    __name(contextLines, "contextLines");
    var hunks = [];
    var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
    var _loop = /* @__PURE__ */ __name(function _loop2() {
      var current = diff32[i], lines = current.lines || splitLines$1(current.value);
      current.lines = lines;
      if (current.added || current.removed) {
        var _curRange;
        if (!oldRangeStart) {
          var prev = diff32[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;
          if (prev) {
            curRange = options2.context > 0 ? contextLines(prev.lines.slice(-options2.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }
        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
          return (current.added ? "+" : "-") + entry;
        })));
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        if (oldRangeStart) {
          if (lines.length <= options2.context * 2 && i < diff32.length - 2) {
            var _curRange2;
            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
          } else {
            var _curRange3;
            var contextSize = Math.min(lines.length, options2.context);
            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
            var _hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            hunks.push(_hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    }, "_loop2");
    for (var i = 0; i < diff32.length; i++) {
      _loop();
    }
    for (var _i = 0, _hunks = hunks; _i < _hunks.length; _i++) {
      var hunk = _hunks[_i];
      for (var _i2 = 0; _i2 < hunk.lines.length; _i2++) {
        if (hunk.lines[_i2].endsWith("\n")) {
          hunk.lines[_i2] = hunk.lines[_i2].slice(0, -1);
        } else {
          hunk.lines.splice(_i2 + 1, 0, "\\ No newline at end of file");
          _i2++;
        }
      }
    }
    return {
      oldFileName,
      newFileName,
      oldHeader,
      newHeader,
      hunks
    };
  }
  __name(diffLinesResultToPatch, "diffLinesResultToPatch");
}
__name(structuredPatch, "structuredPatch");
function formatPatch(diff32) {
  if (Array.isArray(diff32)) {
    return diff32.map(formatPatch).join("\n");
  }
  var ret = [];
  if (diff32.oldFileName == diff32.newFileName) {
    ret.push("Index: " + diff32.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + diff32.oldFileName + (typeof diff32.oldHeader === "undefined" ? "" : "	" + diff32.oldHeader));
  ret.push("+++ " + diff32.newFileName + (typeof diff32.newHeader === "undefined" ? "" : "	" + diff32.newHeader));
  for (var i = 0; i < diff32.hunks.length; i++) {
    var hunk = diff32.hunks[i];
    if (hunk.oldLines === 0) {
      hunk.oldStart -= 1;
    }
    if (hunk.newLines === 0) {
      hunk.newStart -= 1;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    ret.push.apply(ret, hunk.lines);
  }
  return ret.join("\n") + "\n";
}
__name(formatPatch, "formatPatch");
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2) {
  var _options2;
  if (typeof options2 === "function") {
    options2 = {
      callback: options2
    };
  }
  if (!((_options2 = options2) !== null && _options2 !== void 0 && _options2.callback)) {
    var patchObj = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options2);
    if (!patchObj) {
      return;
    }
    return formatPatch(patchObj);
  } else {
    var _options3 = options2, _callback2 = _options3.callback;
    structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, _objectSpread2(_objectSpread2({}, options2), {}, {
      callback: /* @__PURE__ */ __name(function callback(patchObj2) {
        if (!patchObj2) {
          _callback2();
        } else {
          _callback2(formatPatch(patchObj2));
        }
      }, "callback")
    }));
  }
}
__name(createTwoFilesPatch, "createTwoFilesPatch");
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options2) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options2);
}
__name(createPatch, "createPatch");
function splitLines$1(text) {
  var hasTrailingNl = text.endsWith("\n");
  var result = text.split("\n").map(function(line) {
    return line + "\n";
  });
  if (hasTrailingNl) {
    result.pop();
  } else {
    result.push(result.pop().slice(0, -1));
  }
  return result;
}
__name(splitLines$1, "splitLines$1");
function arrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return arrayStartsWith(a, b);
}
__name(arrayEqual, "arrayEqual");
function arrayStartsWith(array, start) {
  if (start.length > array.length) {
    return false;
  }
  for (var i = 0; i < start.length; i++) {
    if (start[i] !== array[i]) {
      return false;
    }
  }
  return true;
}
__name(arrayStartsWith, "arrayStartsWith");
function calcLineCount(hunk) {
  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
  if (oldLines !== void 0) {
    hunk.oldLines = oldLines;
  } else {
    delete hunk.oldLines;
  }
  if (newLines !== void 0) {
    hunk.newLines = newLines;
  } else {
    delete hunk.newLines;
  }
}
__name(calcLineCount, "calcLineCount");
function merge$1(mine, theirs, base) {
  mine = loadPatch(mine, base);
  theirs = loadPatch(theirs, base);
  var ret = {};
  if (mine.index || theirs.index) {
    ret.index = mine.index || theirs.index;
  }
  if (mine.newFileName || theirs.newFileName) {
    if (!fileNameChanged(mine)) {
      ret.oldFileName = theirs.oldFileName || mine.oldFileName;
      ret.newFileName = theirs.newFileName || mine.newFileName;
      ret.oldHeader = theirs.oldHeader || mine.oldHeader;
      ret.newHeader = theirs.newHeader || mine.newHeader;
    } else if (!fileNameChanged(theirs)) {
      ret.oldFileName = mine.oldFileName;
      ret.newFileName = mine.newFileName;
      ret.oldHeader = mine.oldHeader;
      ret.newHeader = mine.newHeader;
    } else {
      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
    }
  }
  ret.hunks = [];
  var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
    var mineCurrent = mine.hunks[mineIndex] || {
      oldStart: Infinity
    }, theirsCurrent = theirs.hunks[theirsIndex] || {
      oldStart: Infinity
    };
    if (hunkBefore(mineCurrent, theirsCurrent)) {
      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
      mineIndex++;
      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
    } else if (hunkBefore(theirsCurrent, mineCurrent)) {
      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
      theirsIndex++;
      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
    } else {
      var mergedHunk = {
        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
        oldLines: 0,
        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
        newLines: 0,
        lines: []
      };
      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
      theirsIndex++;
      mineIndex++;
      ret.hunks.push(mergedHunk);
    }
  }
  return ret;
}
__name(merge$1, "merge$1");
function loadPatch(param, base) {
  if (typeof param === "string") {
    if (/^@@/m.test(param) || /^Index:/m.test(param)) {
      return parsePatch(param)[0];
    }
    if (!base) {
      throw new Error("Must provide a base reference or pass in a patch");
    }
    return structuredPatch(void 0, void 0, base, param);
  }
  return param;
}
__name(loadPatch, "loadPatch");
function fileNameChanged(patch) {
  return patch.newFileName && patch.newFileName !== patch.oldFileName;
}
__name(fileNameChanged, "fileNameChanged");
function selectField(index2, mine, theirs) {
  if (mine === theirs) {
    return mine;
  } else {
    index2.conflict = true;
    return {
      mine,
      theirs
    };
  }
}
__name(selectField, "selectField");
function hunkBefore(test, check) {
  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
}
__name(hunkBefore, "hunkBefore");
function cloneHunk(hunk, offset) {
  return {
    oldStart: hunk.oldStart,
    oldLines: hunk.oldLines,
    newStart: hunk.newStart + offset,
    newLines: hunk.newLines,
    lines: hunk.lines
  };
}
__name(cloneHunk, "cloneHunk");
function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
  var mine = {
    offset: mineOffset,
    lines: mineLines,
    index: 0
  }, their = {
    offset: theirOffset,
    lines: theirLines,
    index: 0
  };
  insertLeading(hunk, mine, their);
  insertLeading(hunk, their, mine);
  while (mine.index < mine.lines.length && their.index < their.lines.length) {
    var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
    if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
      mutualChange(hunk, mine, their);
    } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
      var _hunk$lines;
      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
    } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
      var _hunk$lines2;
      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
    } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
      removal(hunk, mine, their);
    } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
      removal(hunk, their, mine, true);
    } else if (mineCurrent === theirCurrent) {
      hunk.lines.push(mineCurrent);
      mine.index++;
      their.index++;
    } else {
      conflict(hunk, collectChange(mine), collectChange(their));
    }
  }
  insertTrailing(hunk, mine);
  insertTrailing(hunk, their);
  calcLineCount(hunk);
}
__name(mergeLines, "mergeLines");
function mutualChange(hunk, mine, their) {
  var myChanges = collectChange(mine), theirChanges = collectChange(their);
  if (allRemoves(myChanges) && allRemoves(theirChanges)) {
    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
      var _hunk$lines3;
      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
      return;
    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
      var _hunk$lines4;
      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
      return;
    }
  } else if (arrayEqual(myChanges, theirChanges)) {
    var _hunk$lines5;
    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
    return;
  }
  conflict(hunk, myChanges, theirChanges);
}
__name(mutualChange, "mutualChange");
function removal(hunk, mine, their, swap) {
  var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
  if (theirChanges.merged) {
    var _hunk$lines6;
    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
  } else {
    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
  }
}
__name(removal, "removal");
function conflict(hunk, mine, their) {
  hunk.conflict = true;
  hunk.lines.push({
    conflict: true,
    mine,
    theirs: their
  });
}
__name(conflict, "conflict");
function insertLeading(hunk, insert, their) {
  while (insert.offset < their.offset && insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
    insert.offset++;
  }
}
__name(insertLeading, "insertLeading");
function insertTrailing(hunk, insert) {
  while (insert.index < insert.lines.length) {
    var line = insert.lines[insert.index++];
    hunk.lines.push(line);
  }
}
__name(insertTrailing, "insertTrailing");
function collectChange(state) {
  var ret = [], operation = state.lines[state.index][0];
  while (state.index < state.lines.length) {
    var line = state.lines[state.index];
    if (operation === "-" && line[0] === "+") {
      operation = "+";
    }
    if (operation === line[0]) {
      ret.push(line);
      state.index++;
    } else {
      break;
    }
  }
  return ret;
}
__name(collectChange, "collectChange");
function collectContext(state, matchChanges) {
  var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
  while (matchIndex < matchChanges.length && state.index < state.lines.length) {
    var change = state.lines[state.index], match = matchChanges[matchIndex];
    if (match[0] === "+") {
      break;
    }
    contextChanges = contextChanges || change[0] !== " ";
    merged.push(match);
    matchIndex++;
    if (change[0] === "+") {
      conflicted = true;
      while (change[0] === "+") {
        changes.push(change);
        change = state.lines[++state.index];
      }
    }
    if (match.substr(1) === change.substr(1)) {
      changes.push(change);
      state.index++;
    } else {
      conflicted = true;
    }
  }
  if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
    conflicted = true;
  }
  if (conflicted) {
    return changes;
  }
  while (matchIndex < matchChanges.length) {
    merged.push(matchChanges[matchIndex++]);
  }
  return {
    merged,
    changes
  };
}
__name(collectContext, "collectContext");
function allRemoves(changes) {
  return changes.reduce(function(prev, change) {
    return prev && change[0] === "-";
  }, true);
}
__name(allRemoves, "allRemoves");
function skipRemoveSuperset(state, removeChanges, delta) {
  for (var i = 0; i < delta; i++) {
    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
    if (state.lines[state.index + i] !== " " + changeContent) {
      return false;
    }
  }
  state.index += delta;
  return true;
}
__name(skipRemoveSuperset, "skipRemoveSuperset");
function calcOldNewLineCount(lines) {
  var oldLines = 0;
  var newLines = 0;
  lines.forEach(function(line) {
    if (typeof line !== "string") {
      var myCount = calcOldNewLineCount(line.mine);
      var theirCount = calcOldNewLineCount(line.theirs);
      if (oldLines !== void 0) {
        if (myCount.oldLines === theirCount.oldLines) {
          oldLines += myCount.oldLines;
        } else {
          oldLines = void 0;
        }
      }
      if (newLines !== void 0) {
        if (myCount.newLines === theirCount.newLines) {
          newLines += myCount.newLines;
        } else {
          newLines = void 0;
        }
      }
    } else {
      if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
        newLines++;
      }
      if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
        oldLines++;
      }
    }
  });
  return {
    oldLines,
    newLines
  };
}
__name(calcOldNewLineCount, "calcOldNewLineCount");
function reversePatch(structuredPatch2) {
  if (Array.isArray(structuredPatch2)) {
    return structuredPatch2.map(reversePatch).reverse();
  }
  return _objectSpread2(_objectSpread2({}, structuredPatch2), {}, {
    oldFileName: structuredPatch2.newFileName,
    oldHeader: structuredPatch2.newHeader,
    newFileName: structuredPatch2.oldFileName,
    newHeader: structuredPatch2.oldHeader,
    hunks: structuredPatch2.hunks.map(function(hunk) {
      return {
        oldLines: hunk.newLines,
        oldStart: hunk.newStart,
        newLines: hunk.oldLines,
        newStart: hunk.oldStart,
        lines: hunk.lines.map(function(l) {
          if (l.startsWith("-")) {
            return "+".concat(l.slice(1));
          }
          if (l.startsWith("+")) {
            return "-".concat(l.slice(1));
          }
          return l;
        })
      };
    })
  });
}
__name(reversePatch, "reversePatch");
function convertChangesToDMP(changes) {
  var ret = [], change, operation;
  for (var i = 0; i < changes.length; i++) {
    change = changes[i];
    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }
    ret.push([operation, change.value]);
  }
  return ret;
}
__name(convertChangesToDMP, "convertChangesToDMP");
function convertChangesToXML(changes) {
  var ret = [];
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    if (change.added) {
      ret.push("<ins>");
    } else if (change.removed) {
      ret.push("<del>");
    }
    ret.push(escapeHTML(change.value));
    if (change.added) {
      ret.push("</ins>");
    } else if (change.removed) {
      ret.push("</del>");
    }
  }
  return ret.join("");
}
__name(convertChangesToXML, "convertChangesToXML");
function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, "&amp;");
  n = n.replace(/</g, "&lt;");
  n = n.replace(/>/g, "&gt;");
  n = n.replace(/"/g, "&quot;");
  return n;
}
__name(escapeHTML, "escapeHTML");
var diffLibrary = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Diff,
  applyPatch,
  applyPatches,
  canonicalize,
  convertChangesToDMP,
  convertChangesToXML,
  createPatch,
  createTwoFilesPatch,
  diffArrays,
  diffChars,
  diffCss,
  diffJson,
  diffLines,
  diffSentences,
  diffTrimmedLines,
  diffWords,
  diffWordsWithSpace,
  formatPatch,
  merge: merge$1,
  parsePatch,
  reversePatch,
  structuredPatch
}, Symbol.toStringTag, { value: "Module" }));
var main = { exports: {} };
var version2 = "16.4.5";
var require$$4 = {
  version: version2
};
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main.exports;
  hasRequiredMain = 1;
  const fs$1 = fs;
  const path$1 = path;
  const os$1 = os;
  const crypto$1 = crypto;
  const packageJson = require$$4;
  const version22 = packageJson.version;
  const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse2(src2) {
    const obj = {};
    let lines = src2.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  __name(parse2, "parse2");
  function _parseVault(options2) {
    const vaultPath = _vaultPath(options2);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options2).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0; i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error3) {
        if (i + 1 >= length) {
          throw error3;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  __name(_parseVault, "_parseVault");
  function _log(message) {
    console.log(`[dotenv@${version22}][INFO] ${message}`);
  }
  __name(_log, "_log");
  function _warn(message) {
    console.log(`[dotenv@${version22}][WARN] ${message}`);
  }
  __name(_warn, "_warn");
  function _debug(message) {
    console.log(`[dotenv@${version22}][DEBUG] ${message}`);
  }
  __name(_debug, "_debug");
  function _dotenvKey(options2) {
    if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
      return options2.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  __name(_dotenvKey, "_dotenvKey");
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error3) {
      if (error3.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error3;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  __name(_instructions, "_instructions");
  function _vaultPath(options2) {
    let possibleVaultPath = null;
    if (options2 && options2.path && options2.path.length > 0) {
      if (Array.isArray(options2.path)) {
        for (const filepath of options2.path) {
          if (fs$1.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
      }
    } else {
      possibleVaultPath = path$1.resolve(process.cwd(), ".env.vault");
    }
    if (fs$1.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  __name(_vaultPath, "_vaultPath");
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path$1.join(os$1.homedir(), envPath.slice(1)) : envPath;
  }
  __name(_resolveHome, "_resolveHome");
  function _configVault(options2) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options2);
    let processEnv = process.env;
    if (options2 && options2.processEnv != null) {
      processEnv = options2.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options2);
    return { parsed };
  }
  __name(_configVault, "_configVault");
  function configDotenv(options2) {
    const dotenvPath = path$1.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug22 = Boolean(options2 && options2.debug);
    if (options2 && options2.encoding) {
      encoding = options2.encoding;
    } else {
      if (debug22) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options2 && options2.path) {
      if (!Array.isArray(options2.path)) {
        optionPaths = [_resolveHome(options2.path)];
      } else {
        optionPaths = [];
        for (const filepath of options2.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path210 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs$1.readFileSync(path210, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options2);
      } catch (e) {
        if (debug22) {
          _debug(`Failed to load ${path210} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options2 && options2.processEnv != null) {
      processEnv = options2.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options2);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  __name(configDotenv, "configDotenv");
  function config2(options2) {
    if (_dotenvKey(options2).length === 0) {
      return DotenvModule.configDotenv(options2);
    }
    const vaultPath = _vaultPath(options2);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options2);
    }
    return DotenvModule._configVault(options2);
  }
  __name(config2, "config");
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error3) {
      const isRange = error3 instanceof RangeError;
      const invalidKeyLength = error3.message === "Invalid key length";
      const decryptionFailed = error3.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error3;
      }
    }
  }
  __name(decrypt, "decrypt");
  function populate(processEnv, parsed, options2 = {}) {
    const debug22 = Boolean(options2 && options2.debug);
    const override = Boolean(options2 && options2.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug22) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  __name(populate, "populate");
  const DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse2,
    populate
  };
  main.exports.configDotenv = DotenvModule.configDotenv;
  main.exports._configVault = DotenvModule._configVault;
  main.exports._parseVault = DotenvModule._parseVault;
  main.exports.config = DotenvModule.config;
  main.exports.decrypt = DotenvModule.decrypt;
  main.exports.parse = DotenvModule.parse;
  main.exports.populate = DotenvModule.populate;
  main.exports = DotenvModule;
  return main.exports;
}
__name(requireMain, "requireMain");
var mainExports = requireMain();
var dotenvLibrary = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
var proxyFromEnv = {};
var hasRequiredProxyFromEnv;
function requireProxyFromEnv() {
  if (hasRequiredProxyFromEnv) return proxyFromEnv;
  hasRequiredProxyFromEnv = 1;
  var parseUrl = url.parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl22(url4) {
    var parsedUrl = typeof url4 === "string" ? parseUrl(url4) : url4 || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  __name(getProxyForUrl22, "getProxyForUrl2");
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  __name(shouldProxy, "shouldProxy");
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  __name(getEnv, "getEnv");
  proxyFromEnv.getProxyForUrl = getProxyForUrl22;
  return proxyFromEnv;
}
__name(requireProxyFromEnv, "requireProxyFromEnv");
var proxyFromEnvExports = requireProxyFromEnv();
var agent = {};
var promisify = {};
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  Object.defineProperty(promisify, "__esModule", { value: true });
  function promisify$1(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  __name(promisify$1, "promisify$1");
  promisify.default = promisify$1;
  return promisify;
}
__name(requirePromisify, "requirePromisify");
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var __importDefault = src && src.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  const events_1 = EventEmitter2;
  const debug_1 = __importDefault(requireBrowser$1());
  const promisify_1 = __importDefault(requirePromisify());
  const debug22 = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  __name(isAgent, "isAgent");
  function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  __name(isSecureEndpoint, "isSecureEndpoint");
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  __name(createAgent, "createAgent");
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      static {
        __name(this, "Agent");
      }
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      /**
       * Called by node-core's "_http_client.js" module when creating
       * a new HTTP request with this Agent instance.
       *
       * @api public
       */
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = /* @__PURE__ */ __name((err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        }, "onerror");
        const ontimeout = /* @__PURE__ */ __name(() => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        }, "ontimeout");
        const callbackError = /* @__PURE__ */ __name((err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        }, "callbackError");
        const onsocket = /* @__PURE__ */ __name((socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug22("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        }, "onsocket");
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug22("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug22("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug22("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug22("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  src = createAgent;
  return src;
}
__name(requireSrc, "requireSrc");
var parseProxyResponse = {};
var hasRequiredParseProxyResponse;
function requireParseProxyResponse() {
  if (hasRequiredParseProxyResponse) return parseProxyResponse;
  hasRequiredParseProxyResponse = 1;
  var __importDefault = parseProxyResponse && parseProxyResponse.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(parseProxyResponse, "__esModule", { value: true });
  const debug_1 = __importDefault(requireBrowser$1());
  const debug22 = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse$1(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      __name(read, "read");
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      __name(cleanup, "cleanup");
      function onclose(err) {
        debug22("onclose had error %o", err);
      }
      __name(onclose, "onclose");
      function onend() {
        debug22("onend");
      }
      __name(onend, "onend");
      function onerror(err) {
        cleanup();
        debug22("onerror %o", err);
        reject(err);
      }
      __name(onerror, "onerror");
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug22("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug22("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      __name(ondata, "ondata");
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  __name(parseProxyResponse$1, "parseProxyResponse$1");
  parseProxyResponse.default = parseProxyResponse$1;
  return parseProxyResponse;
}
__name(requireParseProxyResponse, "requireParseProxyResponse");
var hasRequiredAgent;
function requireAgent() {
  if (hasRequiredAgent) return agent;
  hasRequiredAgent = 1;
  var __awaiter = agent && agent.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    __name(adopt, "adopt");
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      __name(fulfilled, "fulfilled");
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      __name(rejected, "rejected");
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      __name(step, "step");
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = agent && agent.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(agent, "__esModule", { value: true });
  const net_1 = __importDefault(net);
  const tls_1 = __importDefault(tls);
  const url_1 = __importDefault(url);
  const assert_1 = __importDefault(require$$52);
  const debug_1 = __importDefault(requireBrowser$1());
  const agent_base_1 = requireSrc();
  const parse_proxy_response_1 = __importDefault(requireParseProxyResponse());
  const debug22 = debug_1.default("https-proxy-agent:agent");
  class HttpsProxyAgent22 extends agent_base_1.Agent {
    static {
      __name(this, "HttpsProxyAgent2");
    }
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug22("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const { proxy, secureProxy } = this;
        let socket;
        if (secureProxy) {
          debug22("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug22("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let { host, port, secureEndpoint } = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const { statusCode, buffered } = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug22("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug22("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  }
  agent.default = HttpsProxyAgent22;
  function resume(socket) {
    socket.resume();
  }
  __name(resume, "resume");
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  __name(isDefaultPort, "isDefaultPort");
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  __name(isHTTPS, "isHTTPS");
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
  __name(omit, "omit");
  return agent;
}
__name(requireAgent, "requireAgent");
var dist;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __importDefault = dist && dist.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  const agent_1 = __importDefault(requireAgent());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  __name(createHttpsProxyAgent, "createHttpsProxyAgent");
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  dist = createHttpsProxyAgent;
  return dist;
}
__name(requireDist, "requireDist");
var distExports = requireDist();
var encoder = { exports: {} };
var hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder.exports;
  hasRequiredEncoder = 1;
  (function(module) {
    function JPEGEncoder(quality) {
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      __name(initQuantTables, "initQuantTables");
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      __name(computeHuffmanTbl, "computeHuffmanTbl");
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      __name(initHuffmanTbl, "initHuffmanTbl");
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      __name(initCategoryNumber, "initCategoryNumber");
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      __name(initRGBYUVTable, "initRGBYUVTable");
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      __name(writeBits, "writeBits");
      function writeByte(value) {
        byteout.push(value);
      }
      __name(writeByte, "writeByte");
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      __name(writeWord, "writeWord");
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      __name(fDCTQuant, "fDCTQuant");
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      __name(writeAPP0, "writeAPP0");
      function writeAPP1(exifBuffer) {
        if (!exifBuffer) return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      __name(writeAPP1, "writeAPP1");
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      __name(writeSOF0, "writeSOF0");
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      __name(writeDQT, "writeDQT");
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      __name(writeDHT, "writeDHT");
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array) return;
        comments.forEach((e) => {
          if (typeof e !== "string") return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i;
          for (i = 0; i < l; i++)
            writeByte(e.charCodeAt(i));
        });
      }
      __name(writeCOM, "writeCOM");
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      __name(writeSOS, "writeSOS");
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff2 = DU[0] - DC;
        DC = DU[0];
        if (Diff2 == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff2;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      __name(processDU, "processDU");
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      __name(initCharLookupTable, "initCharLookupTable");
      this.encode = function(image, quality2) {
        (/* @__PURE__ */ new Date()).getTime();
        if (quality2) setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image.comments);
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        return Buffer.from(byteout);
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2) return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      __name(setQuality, "setQuality");
      function init() {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (!quality) quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        (/* @__PURE__ */ new Date()).getTime() - time_start;
      }
      __name(init, "init");
      init();
    }
    __name(JPEGEncoder, "JPEGEncoder");
    {
      module.exports = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined") qu = 50;
      var encoder2 = new JPEGEncoder(qu);
      var data = encoder2.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
    __name(encode, "encode");
  })(encoder);
  return encoder.exports;
}
__name(requireEncoder, "requireEncoder");
var decoder = { exports: {} };
var hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder.exports;
  hasRequiredDecoder = 1;
  (function(module) {
    var JpegImage = (/* @__PURE__ */ __name(function jpegImage() {
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      __name(constructor, "constructor");
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      __name(buildHuffmanTable, "buildHuffmanTable");
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        frame.precision;
        frame.samplesPerLine;
        frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        frame.maxH;
        frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        __name(readBit, "readBit");
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        __name(decodeHuffman, "decodeHuffman");
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null) return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        __name(receive, "receive");
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        __name(receiveAndExtend, "receiveAndExtend");
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff32 = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff32;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        __name(decodeBaseline, "decodeBaseline");
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff32 = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff32;
        }
        __name(decodeDCFirst, "decodeDCFirst");
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        __name(decodeDCSuccessive, "decodeDCSuccessive");
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        __name(decodeACFirst, "decodeACFirst");
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              // skipping r zero items
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        __name(decodeACSuccessive, "decodeACSuccessive");
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        __name(decodeMcu, "decodeMcu");
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        __name(decodeBlock, "decodeBlock");
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval) resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected) break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      __name(decodeScan, "decodeScan");
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        __name(quantizeAndInverse, "quantizeAndInverse");
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      __name(buildComponentData, "buildComponentData");
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      __name(clampTo8bit, "clampTo8bit");
      constructor.prototype = {
        load: /* @__PURE__ */ __name(function load(path30) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path30, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        }, "load"),
        parse: /* @__PURE__ */ __name(function parse2(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0;
          data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          __name(readUint16, "readUint16");
          function readDataBlock() {
            var length = readUint16();
            var array = data.subarray(offset, offset + length - 2);
            offset += array.length;
            return array;
          }
          __name(readDataBlock, "readDataBlock");
          function prepareComponents(frame2) {
            var maxH = 1, maxV = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH < component2.h) maxH = component2.h;
                if (maxV < component2.v) maxV = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH;
            frame2.maxV = maxV;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          __name(prepareComponents, "prepareComponents");
          var jfif = null;
          var adobe = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              // APP0 (Application Specific)
              case 65505:
              // APP1
              case 65506:
              // APP2
              case 65507:
              // APP3
              case 65508:
              // APP4
              case 65509:
              // APP5
              case 65510:
              // APP6
              case 65511:
              // APP7
              case 65512:
              // APP8
              case 65513:
              // APP9
              case 65514:
              // APP10
              case 65515:
              // APP11
              case 65516:
              // APP12
              case 65517:
              // APP13
              case 65518:
              // APP14
              case 65519:
              // APP15
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment2 = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment2);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              // SOF0 (Start of Frame, Baseline DCT)
              case 65473:
              // SOF1 (Start of Frame, Extended DCT)
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(
                  data,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        }, "parse2"),
        getData: /* @__PURE__ */ __name(function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        }, "getData"),
        copyToImageData: /* @__PURE__ */ __name(function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }, "copyToImageData")
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      __name(requestMemoryAllocation, "requestMemoryAllocation");
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }, "jpegImage"))();
    {
      module.exports = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the images color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder2 = new JpegImage();
      decoder2.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder2.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder2.width * decoder2.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder2.width,
          height: decoder2.height,
          exifBuffer: decoder2.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder2.comments.length > 0) {
          image["comments"] = decoder2.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder2.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
    __name(decode, "decode");
  })(decoder);
  return decoder.exports;
}
__name(requireDecoder, "requireDecoder");
var jpegJs;
var hasRequiredJpegJs;
function requireJpegJs() {
  if (hasRequiredJpegJs) return jpegJs;
  hasRequiredJpegJs = 1;
  var encode = requireEncoder(), decode = requireDecoder();
  jpegJs = {
    encode,
    decode
  };
  return jpegJs;
}
__name(requireJpegJs, "requireJpegJs");
var jpegJsExports = requireJpegJs();
var jpegLibrary = /* @__PURE__ */ getDefaultExportFromCjs(jpegJsExports);
var Mime_1;
var hasRequiredMime$1;
function requireMime$1() {
  if (hasRequiredMime$1) return Mime_1;
  hasRequiredMime$1 = 1;
  function Mime() {
    this._types = /* @__PURE__ */ Object.create(null);
    this._extensions = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < arguments.length; i++) {
      this.define(arguments[i]);
    }
    this.define = this.define.bind(this);
    this.getType = this.getType.bind(this);
    this.getExtension = this.getExtension.bind(this);
  }
  __name(Mime, "Mime");
  Mime.prototype.define = function(typeMap, force) {
    for (let type in typeMap) {
      let extensions = typeMap[type].map(function(t) {
        return t.toLowerCase();
      });
      type = type.toLowerCase();
      for (let i = 0; i < extensions.length; i++) {
        const ext = extensions[i];
        if (ext[0] === "*") {
          continue;
        }
        if (!force && ext in this._types) {
          throw new Error(
            'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
          );
        }
        this._types[ext] = type;
      }
      if (force || !this._extensions[type]) {
        const ext = extensions[0];
        this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
      }
    }
  };
  Mime.prototype.getType = function(path30) {
    path30 = String(path30);
    let last = path30.replace(/^.*[/\\]/, "").toLowerCase();
    let ext = last.replace(/^.*\./, "").toLowerCase();
    let hasPath = last.length < path30.length;
    let hasDot = ext.length < last.length - 1;
    return (hasDot || !hasPath) && this._types[ext] || null;
  };
  Mime.prototype.getExtension = function(type) {
    type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
    return type && this._extensions[type.toLowerCase()] || null;
  };
  Mime_1 = Mime;
  return Mime_1;
}
__name(requireMime$1, "requireMime$1");
var standard;
var hasRequiredStandard;
function requireStandard() {
  if (hasRequiredStandard) return standard;
  hasRequiredStandard = 1;
  standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  return standard;
}
__name(requireStandard, "requireStandard");
var other;
var hasRequiredOther;
function requireOther() {
  if (hasRequiredOther) return other;
  hasRequiredOther = 1;
  other = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  return other;
}
__name(requireOther, "requireOther");
var mime$1;
var hasRequiredMime;
function requireMime() {
  if (hasRequiredMime) return mime$1;
  hasRequiredMime = 1;
  let Mime = requireMime$1();
  mime$1 = new Mime(requireStandard(), requireOther());
  return mime$1;
}
__name(requireMime, "requireMime");
var mimeExports = requireMime();
var mimeLibrary = /* @__PURE__ */ getDefaultExportFromCjs(mimeExports);
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = /* @__PURE__ */ __name(function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x)) res.push.apply(res, x);
      else res.push(x);
    }
    return res;
  }, "concatMap");
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
__name(requireConcatMap, "requireConcatMap");
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  __name(balanced, "balanced");
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  __name(maybeMatch, "maybeMatch");
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  __name(range, "range");
  return balancedMatch;
}
__name(requireBalancedMatch, "requireBalancedMatch");
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = requireConcatMap();
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  __name(numeric, "numeric");
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  __name(escapeBraces, "escapeBraces");
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  __name(unescapeBraces, "unescapeBraces");
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  __name(parseCommaParts, "parseCommaParts");
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  __name(expandTop, "expandTop");
  function embrace(str) {
    return "{" + str + "}";
  }
  __name(embrace, "embrace");
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  __name(isPadded, "isPadded");
  function lte(i, y) {
    return i <= y;
  }
  __name(lte, "lte");
  function gte(i, y) {
    return i >= y;
  }
  __name(gte, "gte");
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap2(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  __name(expand, "expand");
  return braceExpansion;
}
__name(requireBraceExpansion, "requireBraceExpansion");
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch22;
  minimatch22.Minimatch = Minimatch;
  var path30 = (function() {
    try {
      return require_path();
    } catch (e) {
    }
  })() || {
    sep: "/"
  };
  minimatch22.sep = path30.sep;
  var GLOBSTAR = minimatch22.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set2, c) {
      set2[c] = true;
      return set2;
    }, {});
  }
  __name(charSet, "charSet");
  var slashSplit = /\/+/;
  minimatch22.filter = filter;
  function filter(pattern, options2) {
    options2 = options2 || {};
    return function(p, i, list) {
      return minimatch22(p, pattern, options2);
    };
  }
  __name(filter, "filter");
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  __name(ext, "ext");
  minimatch22.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch22;
    }
    var orig = minimatch22;
    var m = /* @__PURE__ */ __name(function minimatch3(p, pattern, options2) {
      return orig(p, pattern, ext(def, options2));
    }, "minimatch3");
    m.Minimatch = /* @__PURE__ */ __name(function Minimatch2(pattern, options2) {
      return new orig.Minimatch(pattern, ext(def, options2));
    }, "Minimatch2");
    m.Minimatch.defaults = /* @__PURE__ */ __name(function defaults(options2) {
      return orig.defaults(ext(def, options2)).Minimatch;
    }, "defaults");
    m.filter = /* @__PURE__ */ __name(function filter2(pattern, options2) {
      return orig.filter(pattern, ext(def, options2));
    }, "filter2");
    m.defaults = /* @__PURE__ */ __name(function defaults(options2) {
      return orig.defaults(ext(def, options2));
    }, "defaults");
    m.makeRe = /* @__PURE__ */ __name(function makeRe2(pattern, options2) {
      return orig.makeRe(pattern, ext(def, options2));
    }, "makeRe2");
    m.braceExpand = /* @__PURE__ */ __name(function braceExpand2(pattern, options2) {
      return orig.braceExpand(pattern, ext(def, options2));
    }, "braceExpand2");
    m.match = function(list, pattern, options2) {
      return orig.match(list, pattern, ext(def, options2));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch22.defaults(def).Minimatch;
  };
  function minimatch22(p, pattern, options2) {
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options2).match(p);
  }
  __name(minimatch22, "minimatch2");
  function Minimatch(pattern, options2) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options2);
    }
    assertValidPattern(pattern);
    if (!options2) options2 = {};
    pattern = pattern.trim();
    if (!options2.allowWindowsEscape && path30.sep !== "/") {
      pattern = pattern.split(path30.sep).join("/");
    }
    this.options = options2;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options2.partial;
    this.make();
  }
  __name(Minimatch, "Minimatch");
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set2 = this.globSet = this.braceExpand();
    if (options2.debug) this.debug = /* @__PURE__ */ __name(function debug22() {
      console.error.apply(console, arguments);
    }, "debug2");
    this.debug(this.pattern, set2);
    set2 = this.globParts = set2.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set2);
    set2 = set2.map(function(s, si, set3) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set2);
    set2 = set2.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set2);
    this.set = set2;
  }
  __name(make, "make");
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options2 = this.options;
    var negateOffset = 0;
    if (options2.nonegate) return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  __name(parseNegate, "parseNegate");
  minimatch22.braceExpand = function(pattern, options2) {
    return braceExpand(pattern, options2);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options2) {
    if (!options2) {
      if (this instanceof Minimatch) {
        options2 = this.options;
      } else {
        options2 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  __name(braceExpand, "braceExpand");
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = /* @__PURE__ */ __name(function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  }, "assertValidPattern");
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    assertValidPattern(pattern);
    var options2 = this.options;
    if (pattern === "**") {
      if (!options2.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "") return "";
    var re2 = "";
    var hasMagic = !!options2.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re2 += star;
            hasMagic = true;
            break;
          case "?":
            re2 += qmark;
            hasMagic = true;
            break;
          default:
            re2 += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re2);
        stateChar = false;
      }
    }
    __name(clearStateChar, "clearStateChar");
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re2, c);
      if (escaping && reSpecials[c]) {
        re2 += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        /* istanbul ignore next */
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re2, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1) c = "^";
            re2 += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options2.noext) clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re2 += "(";
            continue;
          }
          if (!stateChar) {
            re2 += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re2.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re2);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re2 += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re2 += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re2.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re2 += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re2 += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          clearStateChar();
          if (inClass) {
            re2 += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re2.length;
          re2 += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re2 += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re2 += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re2 += "\\";
          }
          re2 += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re2.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re2, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re2);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re2 += "\\\\";
    }
    var addPatternStart = false;
    switch (re2.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re2.slice(0, nl.reStart);
      var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re2.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re2 = newRe;
    }
    if (re2 !== "" && hasMagic) {
      re2 = "(?=.)" + re2;
    }
    if (addPatternStart) {
      re2 = patternStart + re2;
    }
    if (isSub === SUBPARSE) {
      return [re2, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re2 + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re2;
    return regExp;
  }
  __name(parse2, "parse2");
  minimatch22.makeRe = function(pattern, options2) {
    return new Minimatch(pattern, options2 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var set2 = this.set;
    if (!set2.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options2 = this.options;
    var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    var flags = options2.nocase ? "i" : "";
    var re2 = set2.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re2 = "^(?:" + re2 + ")$";
    if (this.negate) re2 = "^(?!" + re2 + ").*$";
    try {
      this.regexp = new RegExp(re2, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  __name(makeRe, "makeRe");
  minimatch22.match = function(list, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch(pattern, options2);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = /* @__PURE__ */ __name(function match(f, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    var options2 = this.options;
    if (path30.sep !== "/") {
      f = f.split(path30.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set2 = this.set;
    this.debug(this.pattern, "set", set2);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (i = 0; i < set2.length; i++) {
      var pattern = set2[i];
      var file = f;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options2.flipNegate) return false;
    return this.negate;
  }, "match");
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern }
    );
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false) return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  __name(globUnescape, "globUnescape");
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  __name(regExpEscape, "regExpEscape");
  return minimatch_1;
}
__name(requireMinimatch, "requireMinimatch");
var minimatchExports = requireMinimatch();
var minimatchLibrary = /* @__PURE__ */ getDefaultExportFromCjs(minimatchExports);
function open$1() {
  throw new Error("Not implemented");
}
__name(open$1, "open$1");
var program = {};
var nodeProgress = { exports: {} };
var hasRequiredNodeProgress;
function requireNodeProgress() {
  if (hasRequiredNodeProgress) return nodeProgress.exports;
  hasRequiredNodeProgress = 1;
  (function(module, exports) {
    module.exports = ProgressBar;
    function ProgressBar(fmt, options2) {
      this.stream = options2.stream || process.stderr;
      if (typeof options2 == "number") {
        var total = options2;
        options2 = {};
        options2.total = total;
      } else {
        options2 = options2 || {};
        if ("string" != typeof fmt) throw new Error("format required");
        if ("number" != typeof options2.total) throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options2.curr || 0;
      this.total = options2.total;
      this.width = options2.width || this.total;
      this.clear = options2.clear;
      this.chars = {
        complete: options2.complete || "=",
        incomplete: options2.incomplete || "-",
        head: options2.head || (options2.complete || "=")
      };
      this.renderThrottle = options2.renderThrottle !== 0 ? options2.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options2.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    __name(ProgressBar, "ProgressBar");
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if ("object" == typeof len) tokens = len, len = 1;
      if (tokens) this.tokens = tokens;
      if (0 == this.curr) this.start = /* @__PURE__ */ new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens) this.tokens = tokens;
      if (!this.stream.isTTY) return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = /* @__PURE__ */ new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens) for (var key in this.tokens) str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  })(nodeProgress);
  return nodeProgress.exports;
}
__name(requireNodeProgress, "requireNodeProgress");
var progress$1;
var hasRequiredProgress;
function requireProgress() {
  if (hasRequiredProgress) return progress$1;
  hasRequiredProgress = 1;
  progress$1 = requireNodeProgress();
  return progress$1;
}
__name(requireProgress, "requireProgress");
var progressExports = requireProgress();
var progressLibrary = /* @__PURE__ */ getDefaultExportFromCjs(progressExports);
var SocksProxyAgent = class {
  static {
    __name(this, "SocksProxyAgent");
  }
  constructor() {
    throw new Error("not implemented");
  }
};
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR$1 = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS, "isAlias");
var isDocument = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC, "isDocument");
var isMap = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP, "isMap");
var isPair = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR, "isPair");
var isScalar$1 = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1, "isScalar$1");
var isSeq = /* @__PURE__ */ __name((node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ, "isSeq");
function isCollection$1(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
__name(isCollection$1, "isCollection$1");
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
__name(isNode, "isNode");
var hasAnchor = /* @__PURE__ */ __name((node) => (isScalar$1(node) || isCollection$1(node)) && !!node.anchor, "hasAnchor");
var BREAK$1 = Symbol("break visit");
var SKIP$1 = Symbol("skip children");
var REMOVE$1 = Symbol("remove node");
function visit$1(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE$1)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
__name(visit$1, "visit$1");
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key, node, visitor, path30) {
  const ctrl = callVisitor(key, node, visitor, path30);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path30, ctrl);
    return visit_(key, ctrl, visitor, path30);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node)) {
      path30 = Object.freeze(path30.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path30);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path30 = Object.freeze(path30.concat(node));
      const ck = visit_("key", node.key, visitor, path30);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path30);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node.value = null;
    }
  }
  return ctrl;
}
__name(visit_, "visit_");
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE$1)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
__name(visitAsync, "visitAsync");
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node, visitor, path30) {
  const ctrl = await callVisitor(key, node, visitor, path30);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path30, ctrl);
    return visitAsync_(key, ctrl, visitor, path30);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node)) {
      path30 = Object.freeze(path30.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path30);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path30 = Object.freeze(path30.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path30);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path30);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node.value = null;
    }
  }
  return ctrl;
}
__name(visitAsync_, "visitAsync_");
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
__name(initVisitor, "initVisitor");
function callVisitor(key, node, visitor, path30) {
  if (typeof visitor === "function")
    return visitor(key, node, path30);
  if (isMap(node))
    return visitor.Map?.(key, node, path30);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path30);
  if (isPair(node))
    return visitor.Pair?.(key, node, path30);
  if (isScalar$1(node))
    return visitor.Scalar?.(key, node, path30);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path30);
  return void 0;
}
__name(callVisitor, "callVisitor");
function replaceNode(key, path30, node) {
  const parent = path30[path30.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
__name(replaceNode, "replaceNode");
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = /* @__PURE__ */ __name((tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]), "escapeTagName");
var Directives = class _Directives {
  static {
    __name(this, "Directives");
  }
  constructor(yaml22, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml22);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version22] = parts;
        if (version22 === "1.1" || version22 === "1.2") {
          this.yaml.version = version22;
          return true;
        } else {
          const isValid2 = /^\d+\.\d+$/.test(version22);
          onError(6, `Unsupported YAML version ${version22}`, isValid2);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source8, onError) {
    if (source8 === "!")
      return "!";
    if (source8[0] !== "!") {
      onError(`Not a valid tag: ${source8}`);
      return null;
    }
    if (source8[1] === "<") {
      const verbatim = source8.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source8} is invalid.`);
        return null;
      }
      if (source8[source8.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source8.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source8} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error3) {
        onError(String(error3));
        return null;
      }
    }
    if (handle === "!")
      return source8;
    onError(`Could not resolve tag: ${source8}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit$1(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
__name(anchorIsValid, "anchorIsValid");
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
__name(anchorNames, "anchorNames");
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
__name(findNewAnchor, "findNewAnchor");
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: /* @__PURE__ */ __name((source8) => {
      aliasObjects.push(source8);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    }, "onAnchor"),
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: /* @__PURE__ */ __name(() => {
      for (const source8 of aliasObjects) {
        const ref2 = sourceObjects.get(source8);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar$1(ref2.node) || isCollection$1(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error3 = new Error("Failed to resolve repeated object (this should not happen)");
          error3.source = source8;
          throw error3;
        }
      }
    }, "setAnchors"),
    sourceObjects
  };
}
__name(createNodeAnchors, "createNodeAnchors");
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
__name(applyReviver, "applyReviver");
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
__name(toJS, "toJS");
var NodeBase = class {
  static {
    __name(this, "NodeBase");
  }
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count3, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count3);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};
var Alias = class extends NodeBase {
  static {
    __name(this, "Alias");
  }
  constructor(source8) {
    super(ALIAS);
    this.source = source8;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit$1(doc, {
      Node: /* @__PURE__ */ __name((_key, node) => {
        if (node === this)
          return visit$1.BREAK;
        if (node.anchor === this.source)
          found = node;
      }, "Node")
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source8 = this.resolve(doc);
    if (!source8) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source8);
    if (!data) {
      toJS(source8, null, ctx);
      data = anchors.get(source8);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source8, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src2 = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src2} `;
    }
    return src2;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source8 = node.resolve(doc);
    const anchor = anchors && source8 && anchors.get(source8);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node)) {
    let count3 = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count3)
        count3 = c;
    }
    return count3;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
__name(getAliasCount, "getAliasCount");
var isScalarValue = /* @__PURE__ */ __name((value) => !value || typeof value !== "function" && typeof value !== "object", "isScalarValue");
var Scalar = class extends NodeBase {
  static {
    __name(this, "Scalar");
  }
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
__name(findTagObject, "findTagObject");
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref2 = sourceObjects.get(value);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value, ref2);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref2)
        ref2.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref2)
    ref2.node = node;
  return node;
}
__name(createNode, "createNode");
function collectionFromPath(schema2, path30, value) {
  let v = value;
  for (let i = path30.length - 1; i >= 0; --i) {
    const k = path30[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: /* @__PURE__ */ __name(() => {
      throw new Error("This should not happen, please report a bug.");
    }, "onAnchor"),
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
__name(collectionFromPath, "collectionFromPath");
var isEmptyPath = /* @__PURE__ */ __name((path30) => path30 == null || typeof path30 === "object" && !!path30[Symbol.iterator]().next().done, "isEmptyPath");
var Collection = class extends NodeBase {
  static {
    __name(this, "Collection");
  }
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema2) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path30, value) {
    if (isEmptyPath(path30))
      this.add(value);
    else {
      const [key, ...rest] = path30;
      const node = this.get(key, true);
      if (isCollection$1(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path30) {
    const [key, ...rest] = path30;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection$1(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path30, keepScalar) {
    const [key, ...rest] = path30;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar$1(node) ? node.value : node;
    else
      return isCollection$1(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar$1(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path30) {
    const [key, ...rest] = path30;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection$1(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path30, value) {
    const [key, ...rest] = path30;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection$1(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
var stringifyComment = /* @__PURE__ */ __name((str) => str.replace(/^(?!$)(?: $)?/gm, "#"), "stringifyComment");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
__name(indentComment, "indentComment");
var lineComment = /* @__PURE__ */ __name((str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2, "lineComment");
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
__name(foldFlowLines, "foldFlowLines");
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}
__name(consumeMoreIndentedLines, "consumeMoreIndentedLines");
var getFoldOptions = /* @__PURE__ */ __name((ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
}), "getFoldOptions");
var containsDocumentMarker = /* @__PURE__ */ __name((str) => /^(%|---|\.\.\.)/m.test(str), "containsDocumentMarker");
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
__name(lineLengthOverLimit, "lineLengthOverLimit");
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
__name(doubleQuotedString, "doubleQuotedString");
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
__name(singleQuotedString, "singleQuotedString");
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
__name(quotedString, "quotedString");
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
__name(blockString, "blockString");
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = /* @__PURE__ */ __name((tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str), "test");
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
__name(plainString, "plainString");
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = /* @__PURE__ */ __name((_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  }, "_stringify");
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
__name(stringifyString, "stringifyString");
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
__name(createStringifyContext, "createStringifyContext");
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    let match = tags.filter((t) => t.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
__name(getTagObject, "getTagObject");
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node) || isCollection$1(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
__name(stringifyProps, "stringifyProps");
function stringify$2(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: /* @__PURE__ */ __name((o) => tagObj = o, "onTagObj") });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar$1(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar$1(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
__name(stringify$2, "stringify$2");
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws22 = " ";
  if (keyComment || vsb || vcb) {
    ws22 = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws22 += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws22 === "\n")
        ws22 = "\n\n";
    } else {
      ws22 += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection$1(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws22 = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws22 = "";
  }
  str += ws22 + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
__name(stringifyPair, "stringifyPair");
function warn3(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
__name(warn3, "warn");
var MERGE_KEY = "<<";
var merge = {
  identify: /* @__PURE__ */ __name((value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY, "identify"),
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: /* @__PURE__ */ __name(() => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }), "resolve"),
  stringify: /* @__PURE__ */ __name(() => MERGE_KEY, "stringify")
};
var isMergeKey = /* @__PURE__ */ __name((ctx, key) => (merge.identify(key) || isScalar$1(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default), "isMergeKey");
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
__name(addMergeToJSMap, "addMergeToJSMap");
function mergeValue(ctx, map2, value) {
  const source8 = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source8))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source8.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
__name(mergeValue, "mergeValue");
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
__name(addPairToJSMap, "addPairToJSMap");
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn3(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
__name(stringifyKey, "stringifyKey");
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
__name(createPair, "createPair");
var Pair = class _Pair {
  static {
    __name(this, "Pair");
  }
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};
function stringifyCollection(collection, ctx, options2) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options2);
}
__name(stringifyCollection, "stringifyCollection");
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment22 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment22 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$2(item, itemCtx, () => comment22 = null, () => chompKeep = true);
    if (comment22)
      str2 += lineComment(str2, itemIndent, commentString(comment22));
    if (chompKeep && comment22)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
__name(stringifyBlockCollection, "stringifyBlockCollection");
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str = stringify$2(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str += ",";
    if (comment2)
      str += lineComment(str, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
__name(stringifyFlowCollection, "stringifyFlowCollection");
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}
__name(addCommentBefore, "addCommentBefore");
function findPair(items, key) {
  const k = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
__name(findPair, "findPair");
var YAMLMap = class extends Collection {
  static {
    __name(this, "YAMLMap");
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema2, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema2);
    const add = /* @__PURE__ */ __name((key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    }, "add");
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema2.sortMapEntries === "function") {
      map2.items.sort(schema2.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar$1(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it?.value;
    return (!keepScalar && isScalar$1(node) ? node.value : node) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: /* @__PURE__ */ __name((schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx), "createNode")
};
var YAMLSeq = class extends Collection {
  static {
    __name(this, "YAMLSeq");
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar$1(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar$1(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema2, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema2);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
__name(asItemIndex, "asItemIndex");
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: /* @__PURE__ */ __name((schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx), "createNode")
};
var string = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "string", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: /* @__PURE__ */ __name((str) => str, "resolve"),
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
var nullTag = {
  identify: /* @__PURE__ */ __name((value) => value == null, "identify"),
  createNode: /* @__PURE__ */ __name(() => new Scalar(null), "createNode"),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(null), "resolve"),
  stringify: /* @__PURE__ */ __name(({ source: source8 }, ctx) => typeof source8 === "string" && nullTag.test.test(source8) ? source8 : ctx.options.nullStr, "stringify")
};
var boolTag = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "boolean", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: /* @__PURE__ */ __name((str) => new Scalar(str[0] === "t" || str[0] === "T"), "resolve"),
  stringify({ source: source8, value }, ctx) {
    if (source8 && boolTag.test.test(source8)) {
      const sv = source8[0] === "t" || source8[0] === "T";
      if (value === sv)
        return source8;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
__name(stringifyNumber, "stringifyNumber");
var floatNaN$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: /* @__PURE__ */ __name((str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, "resolve"),
  stringify: stringifyNumber
};
var floatExp$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str) => parseFloat(str), "resolve"),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float$1 = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};
var intIdentify$2 = /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "intIdentify$2");
var intResolve$1 = /* @__PURE__ */ __name((str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix), "intResolve$1");
function intStringify$1(node, radix, prefix) {
  const { value } = node;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
__name(intStringify$1, "intStringify$1");
var intOct$1 = {
  identify: /* @__PURE__ */ __name((value) => intIdentify$2(value) && value >= 0, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 2, 8, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node) => intStringify$1(node, 8, "0o"), "stringify")
};
var int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 0, 10, opt), "resolve"),
  stringify: stringifyNumber
};
var intHex$1 = {
  identify: /* @__PURE__ */ __name((value) => intIdentify$2(value) && value >= 0, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve$1(str, 2, 16, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node) => intStringify$1(node, 16, "0x"), "stringify")
};
var schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
__name(intIdentify$1, "intIdentify$1");
var stringifyJSON = /* @__PURE__ */ __name(({ value }) => JSON.stringify(value), "stringifyJSON");
var jsonScalars = [
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "string", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: /* @__PURE__ */ __name((str) => str, "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: /* @__PURE__ */ __name((value) => value == null, "identify"),
    createNode: /* @__PURE__ */ __name(() => new Scalar(null), "createNode"),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: /* @__PURE__ */ __name(() => null, "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "boolean", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: /* @__PURE__ */ __name((str) => str === "true", "resolve"),
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: /* @__PURE__ */ __name((str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10), "resolve"),
    stringify: /* @__PURE__ */ __name(({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value), "stringify")
  },
  {
    identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: /* @__PURE__ */ __name((str) => parseFloat(str), "resolve"),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema$1 = [map, seq].concat(jsonScalars, jsonError);
var binary = {
  identify: /* @__PURE__ */ __name((value) => value instanceof Uint8Array, "identify"),
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src2, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src2, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src2.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src2;
    }
  },
  stringify({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
__name(resolvePairs, "resolvePairs");
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
__name(createPairs, "createPairs");
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  static {
    __name(this, "YAMLOMap");
  }
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: /* @__PURE__ */ __name((value) => value instanceof Map, "identify"),
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar$1(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: /* @__PURE__ */ __name((schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx), "createNode")
};
function boolStringify({ value, source: source8 }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source8 && boolObj.test.test(source8))
    return source8;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
__name(boolStringify, "boolStringify");
var trueTag = {
  identify: /* @__PURE__ */ __name((value) => value === true, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(true), "resolve"),
  stringify: boolStringify
};
var falseTag = {
  identify: /* @__PURE__ */ __name((value) => value === false, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: /* @__PURE__ */ __name(() => new Scalar(false), "resolve"),
  stringify: boolStringify
};
var floatNaN = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: /* @__PURE__ */ __name((str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, "resolve"),
  stringify: stringifyNumber
};
var floatExp = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: /* @__PURE__ */ __name((str) => parseFloat(str.replace(/_/g, "")), "resolve"),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};
var intIdentify = /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "intIdentify");
function intResolve(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
__name(intResolve, "intResolve");
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
__name(intStringify, "intStringify");
var intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 2, 2, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node) => intStringify(node, 2, "0b"), "stringify")
};
var intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 1, 8, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node) => intStringify(node, 8, "0"), "stringify")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 0, 10, opt), "resolve"),
  stringify: stringifyNumber
};
var intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, opt) => intResolve(str, 2, 16, opt), "resolve"),
  stringify: /* @__PURE__ */ __name((node) => intStringify(node, 16, "0x"), "stringify")
};
var YAMLSet = class _YAMLSet extends YAMLMap {
  static {
    __name(this, "YAMLSet");
  }
  constructor(schema2) {
    super(schema2);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema2, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: /* @__PURE__ */ __name((value) => value instanceof Set, "identify"),
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: /* @__PURE__ */ __name((schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx), "createNode"),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = /* @__PURE__ */ __name((n) => asBigInt ? BigInt(n) : Number(n), "num");
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
__name(parseSexagesimal, "parseSexagesimal");
function stringifySexagesimal(node) {
  let { value } = node;
  let num = /* @__PURE__ */ __name((n) => n, "num");
  if (typeof value === "bigint")
    num = /* @__PURE__ */ __name((n) => BigInt(n), "num");
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
__name(stringifySexagesimal, "stringifySexagesimal");
var intTime = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "bigint" || Number.isInteger(value), "identify"),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: /* @__PURE__ */ __name((str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt), "resolve"),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: /* @__PURE__ */ __name((value) => typeof value === "number", "identify"),
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: /* @__PURE__ */ __name((str) => parseSexagesimal(str, false), "resolve"),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: /* @__PURE__ */ __name((value) => value instanceof Date, "identify"),
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: /* @__PURE__ */ __name(({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, ""), "stringify")
};
var schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
var schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}
__name(getTags, "getTags");
var sortMapEntriesByKey = /* @__PURE__ */ __name((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0, "sortMapEntriesByKey");
var Schema = class _Schema {
  static {
    __name(this, "Schema");
  }
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};
function stringifyDocument(doc, options2) {
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir3 = doc.directives.toString(doc);
    if (dir3) {
      lines.push(dir3);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
__name(stringifyDocument, "stringifyDocument");
var Document = class _Document {
  static {
    __name(this, "Document");
  }
  constructor(value, replacer, options2) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options2);
    this.options = opt;
    let { version: version22 } = opt;
    if (options2?._directives) {
      this.directives = options2._directives.atDocument();
      if (this.directives.yaml.explicit)
        version22 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version22 });
    this.setSchema(version22, options2);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options2);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path30, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path30, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options2) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = /* @__PURE__ */ __name((v) => typeof v === "number" || v instanceof String || v instanceof Number, "keyToStr");
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection$1(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options2 = {}) {
    const k = this.createNode(key, null, options2);
    const v = this.createNode(value, null, options2);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path30) {
    if (isEmptyPath(path30)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path30) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path30, keepScalar) {
    if (isEmptyPath(path30))
      return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
    return isCollection$1(this.contents) ? this.contents.getIn(path30, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection$1(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path30) {
    if (isEmptyPath(path30))
      return this.contents !== void 0;
    return isCollection$1(this.contents) ? this.contents.hasIn(path30) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path30, value) {
    if (isEmptyPath(path30)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path30), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path30, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version22, options2 = {}) {
    if (typeof version22 === "number")
      version22 = String(version22);
    let opt;
    switch (version22) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version22;
        else
          this.directives = new Directives({ version: version22 });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version22);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options2.schema instanceof Object)
      this.schema = options2.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options2));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count: count3, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count3);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options2 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
      const s = JSON.stringify(options2.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options2);
  }
};
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
__name(assertCollection, "assertCollection");
var YAMLError = class extends Error {
  static {
    __name(this, "YAMLError");
  }
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  static {
    __name(this, "YAMLParseError");
  }
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  static {
    __name(this, "YAMLWarning");
  }
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = /* @__PURE__ */ __name((src2, lc) => (error3) => {
  if (error3.pos[0] === -1)
    return;
  error3.linePos = error3.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error3.linePos[0];
  error3.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src2.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src2.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count3 = 1;
    const end = error3.linePos[1];
    if (end && end.line === line && end.col > col) {
      count3 = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count3);
    error3.message += `:

${lineStr}
${pointer}
`;
  }
}, "prettifyError");
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}
__name(resolveProps, "resolveProps");
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
__name(containsNewline, "containsNewline");
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
__name(flowIndentCheck, "flowIndentCheck");
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar$1(a) && isScalar$1(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}
__name(mapIncludes, "mapIncludes");
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}
__name(resolveBlockMap, "resolveBlockMap");
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  const NodeClass = tag?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
__name(resolveBlockSeq, "resolveBlockSeq");
function resolveEnd(end, offset, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source: source8, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source8.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source8;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source8.length;
    }
  }
  return { comment: comment2, offset };
}
__name(resolveEnd, "resolveEnd");
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = /* @__PURE__ */ __name((token) => token && (token.type === "block-map" || token.type === "block-seq"), "isBlock");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
__name(resolveFlowCollection, "resolveFlowCollection");
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
__name(resolveCollection, "resolveCollection");
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt?.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag?.format)
    node.format = tag.format;
  return node;
}
__name(composeCollection, "composeCollection");
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src2 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src2}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
__name(resolveBlockScalar, "resolveBlockScalar");
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source: source8 } = props[0];
  const mode = source8[0];
  let indent = 0;
  let chomp = "";
  let error3 = -1;
  for (let i = 1; i < source8.length; ++i) {
    const ch = source8[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error3 === -1)
        error3 = offset + i;
    }
  }
  if (error3 !== -1)
    onError(error3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source8}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source8.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment: comment2, length };
}
__name(parseBlockScalarHeader, "parseBlockScalarHeader");
function splitLines(source8) {
  const split = source8.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
__name(splitLines, "splitLines");
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source: source8, end } = scalar;
  let _type;
  let value;
  const _onError = /* @__PURE__ */ __name((rel, code, msg) => onError(offset + rel, code, msg), "_onError");
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source8, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source8, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source8, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source8.length, offset + source8.length]
      };
  }
  const valueEnd = offset + source8.length;
  const re2 = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re2.comment,
    range: [offset, valueEnd, re2.offset]
  };
}
__name(resolveFlowScalar, "resolveFlowScalar");
function plainValue(source8, onError) {
  let badChar = "";
  switch (source8[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source8[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source8[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source8);
}
__name(plainValue, "plainValue");
function singleQuotedValue(source8, onError) {
  if (source8[source8.length - 1] !== "'" || source8.length === 1)
    onError(source8.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source8.slice(1, -1)).replace(/''/g, "'");
}
__name(singleQuotedValue, "singleQuotedValue");
function foldLines(source8) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source8);
  if (!match)
    return source8;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source8)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source8);
  return res + sep + (match?.[1] ?? "");
}
__name(foldLines, "foldLines");
function doubleQuotedValue(source8, onError) {
  let res = "";
  for (let i = 1; i < source8.length - 1; ++i) {
    const ch = source8[i];
    if (ch === "\r" && source8[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source8, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source8[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source8[i + 1];
        while (next === " " || next === "	")
          next = source8[++i + 1];
      } else if (next === "\r" && source8[i + 1] === "\n") {
        next = source8[++i + 1];
        while (next === " " || next === "	")
          next = source8[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source8, i + 1, length, onError);
        i += length;
      } else {
        const raw = source8.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source8[i + 1];
      while (next === " " || next === "	")
        next = source8[++i + 1];
      if (next !== "\n" && !(next === "\r" && source8[i + 2] === "\n"))
        res += i > wsStart ? source8.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source8[source8.length - 1] !== '"' || source8.length === 1)
    onError(source8.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
__name(doubleQuotedValue, "doubleQuotedValue");
function foldNewline(source8, offset) {
  let fold = "";
  let ch = source8[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source8[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source8[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
__name(foldNewline, "foldNewline");
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source8, offset, length, onError) {
  const cc = source8.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source8.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
__name(parseCharCode, "parseCharCode");
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment: comment2, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR$1];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error3) {
    const msg = error3 instanceof Error ? error3.message : String(error3);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
__name(composeScalar, "composeScalar");
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema2.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if (tag.test?.test(value))
      return tag;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
__name(findScalarTagByName, "findScalarTagByName");
function findScalarTagByTest({ atKey, directives, schema: schema2 }, value, token, onError) {
  const tag = schema2.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema2[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
__name(findScalarTagByTest, "findScalarTagByTest");
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
__name(emptyScalarPosition, "emptyScalarPosition");
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar$1(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment2;
    else
      node.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
__name(composeNode, "composeNode");
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment2, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    node.comment = comment2;
    node.range[2] = end;
  }
  return node;
}
__name(composeEmptyNode, "composeEmptyNode");
function composeAlias({ options: options2 }, { offset, source: source8, end }, onError) {
  const alias = new Alias(source8.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source8.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source8.length;
  const re2 = resolveEnd(end, valueEnd, options2.strict, onError);
  alias.range = [offset, valueEnd, re2.offset];
  if (re2.comment)
    alias.comment = re2.comment;
  return alias;
}
__name(composeAlias, "composeAlias");
function composeDoc(options2, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re2 = resolveEnd(end, contentEnd, false, onError);
  if (re2.comment)
    doc.comment = re2.comment;
  doc.range = [offset, contentEnd, re2.offset];
  return doc;
}
__name(composeDoc, "composeDoc");
function getErrorPos(src2) {
  if (typeof src2 === "number")
    return [src2, src2 + 1];
  if (Array.isArray(src2))
    return src2.length === 2 ? src2 : [src2[0], src2[1]];
  const { offset, source: source8 } = src2;
  return [offset, offset + (typeof source8 === "string" ? source8.length : 1)];
}
__name(getErrorPos, "getErrorPos");
function parsePrelude(prelude) {
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source8 = prelude[i];
    switch (source8[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source8.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
__name(parsePrelude, "parsePrelude");
var Composer = class {
  static {
    __name(this, "Composer");
  }
  constructor(options2 = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source8, code, message, warning) => {
      const pos = getErrorPos(source8);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options2.version || "1.2" });
    this.options = options2;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error3 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error3);
        else
          this.doc.errors.push(error3);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = /* @__PURE__ */ __name((pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    }, "_onError");
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
__name(resolveAsScalar, "resolveAsScalar");
function createScalarToken(value, context2) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context2;
  const source8 = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context2.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source8[0]) {
    case "|":
    case ">": {
      const he = source8.indexOf("\n");
      const head = source8.substring(0, he);
      const body = source8.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source: source8, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source: source8, end };
    default:
      return { type: "scalar", offset, indent, source: source8, end };
  }
}
__name(createScalarToken, "createScalarToken");
function setScalarValue(token, value, context2 = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context2;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source8 = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source8[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source8);
      break;
    case '"':
      setFlowScalarValue(token, source8, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source8, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source8, "scalar");
  }
}
__name(setScalarValue, "setScalarValue");
function setBlockScalarValue(token, source8) {
  const he = source8.indexOf("\n");
  const head = source8.substring(0, he);
  const body = source8.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
__name(setBlockScalarValue, "setBlockScalarValue");
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
__name(addEndtoBlockProps, "addEndtoBlockProps");
function setFlowScalarValue(token, source8, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source8;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source8.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source: source8, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source8.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source: source8, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source: source8, end });
    }
  }
}
__name(setFlowScalarValue, "setFlowScalarValue");
var stringify$1 = /* @__PURE__ */ __name((cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2), "stringify$1");
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
__name(stringifyToken, "stringifyToken");
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
__name(stringifyItem, "stringifyItem");
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove item");
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
__name(visit, "visit");
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst2, path30) => {
  let item = cst2;
  for (const [field, index2] of path30) {
    const tok = item?.[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit.parentCollection = (cst2, path30) => {
  const parent = visit.itemAtPath(cst2, path30.slice(0, -1));
  const field = path30[path30.length - 1][0];
  const coll = parent?.[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path30, item, visitor) {
  let ctrl = visitor(item, path30);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path30.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path30);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path30) : ctrl;
}
__name(_visit, "_visit");
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR = "";
var isCollection = /* @__PURE__ */ __name((token) => !!token && "items" in token, "isCollection");
var isScalar = /* @__PURE__ */ __name((token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar"), "isScalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
__name(prettyToken, "prettyToken");
function tokenType(source8) {
  switch (source8) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source8[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
__name(tokenType, "tokenType");
var cst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  createScalarToken,
  isCollection,
  isScalar,
  prettyToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$1,
  tokenType,
  visit
}, Symbol.toStringTag, { value: "Module" }));
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
__name(isEmpty, "isEmpty");
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = /* @__PURE__ */ __name((ch) => !ch || invalidAnchorChars.has(ch), "isNotAnchorChar");
var Lexer = class {
  static {
    __name(this, "Lexer");
  }
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source8, incomplete = false) {
    if (source8) {
      if (typeof source8 !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source8 : source8;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote5 = this.charAt(0);
    let end = this.buffer.indexOf(quote5, this.pos + 1);
    if (quote5 === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};
var LineCounter = class {
  static {
    __name(this, "LineCounter");
  }
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
__name(includesToken, "includesToken");
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
__name(findNonEmptyIndex, "findNonEmptyIndex");
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
__name(isFlowToken, "isFlowToken");
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
__name(getPrevProps, "getPrevProps");
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
__name(getFirstKeyStartProps, "getFirstKeyStartProps");
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
__name(fixFlowSeqItems, "fixFlowSeqItems");
var Parser = class {
  static {
    __name(this, "Parser");
  }
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source8, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source8, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source8) {
    this.source = source8;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source8.length;
      return;
    }
    const type = tokenType(source8);
    if (!type) {
      const message = `Not a YAML token: ${source8}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source: source8 });
      this.offset += source8.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source8.length);
          break;
        case "space":
          if (this.atNewLine && source8[0] === " ")
            this.indent += source8.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source8.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source8.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error3) {
    const token = error3 ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs34 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs34, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs34);
          } else {
            Object.assign(it, { key: fs34, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atMapIndent && bv.type !== "block-seq") {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs34 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs34, sep: [] });
          else if (it.sep)
            this.stack.push(fs34);
          else
            Object.assign(it, { key: fs34, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
__name(parseOptions, "parseOptions");
function parseAllDocuments(source8, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  const docs = Array.from(composer.compose(parser2.parse(source8)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source8, lineCounter));
      doc.warnings.forEach(prettifyError(source8, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
__name(parseAllDocuments, "parseAllDocuments");
function parseDocument(source8, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source8), true, source8.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source8, lineCounter));
    doc.warnings.forEach(prettifyError(source8, lineCounter));
  }
  return doc;
}
__name(parseDocument, "parseDocument");
function parse(src2, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src2, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn3(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
__name(parse, "parse");
function stringify(value, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options2);
  return new Document(value, _replacer, options2).toString(options2);
}
__name(stringify, "stringify");
var YAML = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Alias,
  CST: cst,
  Composer,
  Document,
  Lexer,
  LineCounter,
  Pair,
  Parser,
  Scalar,
  Schema,
  YAMLError,
  YAMLMap,
  YAMLParseError,
  YAMLSeq,
  YAMLWarning,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  parse,
  parseAllDocuments,
  parseDocument,
  stringify,
  visit: visit$1,
  visitAsync
}, Symbol.toStringTag, { value: "Module" }));
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = /* @__PURE__ */ __name(function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  }, "browser");
  return browser;
}
__name(requireBrowser, "requireBrowser");
var browserExports = requireBrowser();
var wsLibrary = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var colors = colorsLibrary;
var debug3 = debugLibrary;
var diff2 = diffLibrary;
var dotenv = dotenvLibrary;
var jpegjs = jpegLibrary;
var lockfileLibrary = requireLockfile();
var lockfile = lockfileLibrary;
var mime = mimeLibrary;
var minimatch = minimatchLibrary;
var open = open$1;
var progress = progressLibrary;
var yaml = YAML;
var ws = wsLibrary;
var wsServer = browserExports.WebSocketServer;
var wsReceiver = browserExports.Receiver;
var wsSender = browserExports.Sender;
var HttpsProxyAgent = distExports.HttpsProxyAgent;
var getProxyForUrl = proxyFromEnvExports.getProxyForUrl;

// node_modules/@cloudflare/playwright/lib/_virtual/_commonjsHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs2, "getDefaultExportFromCjs");
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = /* @__PURE__ */ __name(function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    }, "a");
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return n[k];
      }, "get")
    });
  });
  return a;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");

// node_modules/@cloudflare/playwright/lib/_virtual/utilsBundleImpl.js
var require$$03 = /* @__PURE__ */ getAugmentedNamespace(utilsBundleImpl_exports);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utilsBundle.js
var colors2 = require$$03.colors;
var debug4 = require$$03.debug;
var diff3 = require$$03.diff;
var dotenv2 = require$$03.dotenv;
var getProxyForUrl2 = require$$03.getProxyForUrl;
var HttpsProxyAgent2 = require$$03.HttpsProxyAgent;
var jpegjs2 = require$$03.jpegjs;
var lockfile2 = require$$03.lockfile;
var mime2 = require$$03.mime;
var minimatch2 = require$$03.minimatch;
var open2 = require$$03.open;
var PNG2 = require$$03.PNG;
var program2 = require$$03.program;
var progress2 = require$$03.progress;
var SocksProxyAgent2 = require$$03.SocksProxyAgent;
var yaml2 = require$$03.yaml;
var ws2 = require$$03.ws;
var wsServer2 = require$$03.wsServer;
var wsReceiver2 = require$$03.wsReceiver;
var wsSender2 = require$$03.wsSender;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/debugLogger.js
var debugLoggerColorMap = {
  "api": 45,
  // cyan
  "protocol": 34,
  // green
  "install": 34,
  // green
  "download": 34,
  // green
  "browser": 0,
  // reset
  "socks": 92,
  // purple
  "client-certificates": 92,
  // purple
  "error": 160,
  // red,
  "channel": 33,
  // blue
  "server": 45,
  // cyan
  "server:channel": 34,
  // green
  "server:metadata": 33,
  // blue,
  "recorder": 45
  // cyan
};
var DebugLogger = class {
  static {
    __name(this, "DebugLogger");
  }
  constructor() {
    this._debuggers = /* @__PURE__ */ new Map();
    if (process.env.DEBUG_FILE) {
      const ansiRegex = new RegExp([
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|"), "g");
      const stream = fs2.createWriteStream(process.env.DEBUG_FILE);
      debug4.log = (data) => {
        stream.write(data.replace(ansiRegex, ""));
        stream.write("\n");
      };
    }
  }
  log(name, message) {
    let cachedDebugger = this._debuggers.get(name);
    if (!cachedDebugger) {
      cachedDebugger = debug4(`pw:${name}`);
      this._debuggers.set(name, cachedDebugger);
      cachedDebugger.color = debugLoggerColorMap[name] || 0;
    }
    cachedDebugger(message);
  }
  isEnabled(name) {
    return debug4.enabled(`pw:${name}`);
  }
};
var debugLogger = new DebugLogger();
var kLogCount = 150;
var RecentLogsCollector = class {
  static {
    __name(this, "RecentLogsCollector");
  }
  constructor() {
    this._logs = [];
    this._listeners = [];
  }
  log(message) {
    this._logs.push(message);
    if (this._logs.length === kLogCount * 2)
      this._logs.splice(0, kLogCount);
    for (const listener of this._listeners)
      listener(message);
  }
  recentLogs() {
    if (this._logs.length > kLogCount)
      return this._logs.slice(-150);
    return this._logs;
  }
  onMessage(listener) {
    for (const message of this._logs)
      listener(message);
    this._listeners.push(listener);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/manualPromise.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/stackTrace.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function captureRawStack() {
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 50;
  const error3 = new Error();
  const stack = error3.stack || "";
  Error.stackTraceLimit = stackTraceLimit;
  return stack.split("\n");
}
__name(captureRawStack, "captureRawStack");
function parseStackFrame(text, pathSeparator, showInternalStackFrames) {
  const match = text && text.match(re);
  if (!match)
    return null;
  let fname = match[2];
  let file = match[7];
  if (!file)
    return null;
  if (!showInternalStackFrames && (file.startsWith("internal") || file.startsWith("node:")))
    return null;
  const line = match[8];
  const column = match[9];
  const closeParen = match[11] === ")";
  const frame = {
    file: "",
    line: 0,
    column: 0
  };
  if (line)
    frame.line = Number(line);
  if (column)
    frame.column = Number(column);
  if (closeParen && file) {
    let closes = 0;
    for (let i = file.length - 1; i > 0; i--) {
      if (file.charAt(i) === ")") {
        closes++;
      } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
        closes--;
        if (closes === -1 && file.charAt(i - 1) === " ") {
          const before = file.slice(0, i - 1);
          const after = file.slice(i + 1);
          file = after;
          fname += ` (${before}`;
          break;
        }
      }
    }
  }
  if (fname) {
    const methodMatch = fname.match(methodRe);
    if (methodMatch)
      fname = methodMatch[1];
  }
  if (file) {
    if (file.startsWith("file://"))
      file = fileURLToPath(file, pathSeparator);
    frame.file = file;
  }
  if (fname)
    frame.function = fname;
  return frame;
}
__name(parseStackFrame, "parseStackFrame");
function rewriteErrorMessage(e, newMessage) {
  const lines = (e.stack?.split("\n") || []).filter((l) => l.startsWith("    at "));
  e.message = newMessage;
  const errorTitle = `${e.name}: ${e.message}`;
  if (lines.length)
    e.stack = `${errorTitle}
${lines.join("\n")}`;
  return e;
}
__name(rewriteErrorMessage, "rewriteErrorMessage");
function stringifyStackFrames(frames) {
  const stackLines = [];
  for (const frame of frames) {
    if (frame.function)
      stackLines.push(`    at ${frame.function} (${frame.file}:${frame.line}:${frame.column})`);
    else
      stackLines.push(`    at ${frame.file}:${frame.line}:${frame.column}`);
  }
  return stackLines;
}
__name(stringifyStackFrames, "stringifyStackFrames");
function splitErrorMessage(message) {
  const separationIdx = message.indexOf(":");
  return {
    name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
    message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
  };
}
__name(splitErrorMessage, "splitErrorMessage");
var re = new RegExp(
  "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
);
var methodRe = /^(.*?) \[as (.*?)\]$/;
function fileURLToPath(fileUrl, pathSeparator) {
  if (!fileUrl.startsWith("file://"))
    return fileUrl;
  let path30 = decodeURIComponent(fileUrl.slice(7));
  if (path30.startsWith("/") && /^[a-zA-Z]:/.test(path30.slice(1)))
    path30 = path30.slice(1);
  return path30.replace(/\//g, pathSeparator);
}
__name(fileURLToPath, "fileURLToPath");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/manualPromise.js
var ManualPromise = class extends Promise {
  static {
    __name(this, "ManualPromise");
  }
  constructor() {
    let resolve;
    let reject;
    super((f, r) => {
      resolve = f;
      reject = r;
    });
    this._isDone = false;
    this._resolve = resolve;
    this._reject = reject;
  }
  isDone() {
    return this._isDone;
  }
  resolve(t) {
    this._isDone = true;
    this._resolve(t);
  }
  reject(e) {
    this._isDone = true;
    this._reject(e);
  }
  static get [Symbol.species]() {
    return Promise;
  }
  get [Symbol.toStringTag]() {
    return "ManualPromise";
  }
};
var LongStandingScope = class {
  static {
    __name(this, "LongStandingScope");
  }
  constructor() {
    this._terminatePromises = /* @__PURE__ */ new Map();
    this._isClosed = false;
  }
  reject(error3) {
    this._isClosed = true;
    this._terminateError = error3;
    for (const p of this._terminatePromises.keys())
      p.resolve(error3);
  }
  close(error3) {
    this._isClosed = true;
    this._closeError = error3;
    for (const [p, frames] of this._terminatePromises)
      p.resolve(cloneError(error3, frames));
  }
  isClosed() {
    return this._isClosed;
  }
  static async raceMultiple(scopes, promise) {
    return Promise.race(scopes.map((s) => s.race(promise)));
  }
  async race(promise) {
    return this._race(Array.isArray(promise) ? promise : [promise], false);
  }
  async safeRace(promise, defaultValue) {
    return this._race([promise], true, defaultValue);
  }
  async _race(promises, safe2, defaultValue) {
    const terminatePromise = new ManualPromise();
    const frames = captureRawStack();
    if (this._terminateError)
      terminatePromise.resolve(this._terminateError);
    if (this._closeError)
      terminatePromise.resolve(cloneError(this._closeError, frames));
    this._terminatePromises.set(terminatePromise, frames);
    try {
      return await Promise.race([
        terminatePromise.then((e) => safe2 ? defaultValue : Promise.reject(e)),
        ...promises
      ]);
    } finally {
      this._terminatePromises.delete(terminatePromise);
    }
  }
};
function cloneError(error3, frames) {
  const clone = new Error();
  clone.name = error3.name;
  clone.message = error3.message;
  clone.stack = [error3.name + ":" + error3.message, ...frames].join("\n");
  return clone;
}
__name(cloneError, "cloneError");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/userAgent.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/package.json.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version3 = "1.55.0";
var require$$04 = {
  version: version3
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/userAgent.js
import os2 from "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/linuxUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs3 from "node:fs";
var didFailToReadOSRelease = false;
var osRelease;
function getLinuxDistributionInfoSync() {
  if (process.platform !== "linux")
    return void 0;
  if (!osRelease && !didFailToReadOSRelease) {
    try {
      const osReleaseText = fs3.readFileSync("/etc/os-release", "utf8");
      const fields = parseOSReleaseText(osReleaseText);
      osRelease = {
        id: fields.get("id") ?? "",
        version: fields.get("version_id") ?? ""
      };
    } catch (e) {
      didFailToReadOSRelease = true;
    }
  }
  return osRelease;
}
__name(getLinuxDistributionInfoSync, "getLinuxDistributionInfoSync");
function parseOSReleaseText(osReleaseText) {
  const fields = /* @__PURE__ */ new Map();
  for (const line of osReleaseText.split("\n")) {
    const tokens = line.split("=");
    const name = tokens.shift();
    let value = tokens.join("=").trim();
    if (value.startsWith('"') && value.endsWith('"'))
      value = value.substring(1, value.length - 1);
    if (!name)
      continue;
    fields.set(name.toLowerCase(), value);
  }
  return fields;
}
__name(parseOSReleaseText, "parseOSReleaseText");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/userAgent.js
var cachedUserAgent;
function getUserAgent() {
  if (cachedUserAgent)
    return cachedUserAgent;
  try {
    cachedUserAgent = determineUserAgent();
  } catch (e) {
    cachedUserAgent = "Playwright/unknown";
  }
  return cachedUserAgent;
}
__name(getUserAgent, "getUserAgent");
function determineUserAgent() {
  let osIdentifier = "unknown";
  let osVersion = "unknown";
  if (process.platform === "win32") {
    const version6 = os2.release().split(".");
    osIdentifier = "windows";
    osVersion = `${version6[0]}.${version6[1]}`;
  } else if (process.platform === "darwin") {
    const version6 = execSync("sw_vers -productVersion", { stdio: ["ignore", "pipe", "ignore"] }).toString().trim().split(".");
    osIdentifier = "macOS";
    osVersion = `${version6[0]}.${version6[1]}`;
  } else if (process.platform === "linux") {
    const distroInfo = getLinuxDistributionInfoSync();
    if (distroInfo) {
      osIdentifier = distroInfo.id || "linux";
      osVersion = distroInfo.version || "unknown";
    } else {
      osIdentifier = "linux";
    }
  }
  const additionalTokens = [];
  if (process.env.CI)
    additionalTokens.push("CI/1");
  const serializedTokens = additionalTokens.length ? " " + additionalTokens.join(" ") : "";
  const { embedderName, embedderVersion } = getEmbedderName();
  return `Playwright/${getPlaywrightVersion()} (${os2.arch()}; ${osIdentifier} ${osVersion}) ${embedderName}/${embedderVersion}${serializedTokens}`;
}
__name(determineUserAgent, "determineUserAgent");
function getEmbedderName() {
  let embedderName = "unknown";
  let embedderVersion = "unknown";
  if (!process.env.PW_LANG_NAME) {
    embedderName = "node";
    embedderVersion = process.version.substring(1).split(".").slice(0, 2).join(".");
  } else if (["node", "python", "java", "csharp"].includes(process.env.PW_LANG_NAME)) {
    embedderName = process.env.PW_LANG_NAME;
    embedderVersion = process.env.PW_LANG_NAME_VERSION ?? "unknown";
  }
  return { embedderName, embedderVersion };
}
__name(getEmbedderName, "getEmbedderName");
function getPlaywrightVersion(majorMinorOnly = false) {
  const version6 = process.env.PW_VERSION_OVERRIDE || require$$04.version;
  return majorMinorOnly ? version6.split(".").slice(0, 2).join(".") : version6;
}
__name(getPlaywrightVersion, "getPlaywrightVersion");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/fileUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs5 from "node:fs";
import path3 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/zipBundle.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/_virtual/zipBundleImpl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/bundles/zipBundleImpl.js
var zipBundleImpl_exports = {};
__export(zipBundleImpl_exports, {
  extract: () => extract,
  yauzl: () => index$1,
  yazl: () => index$3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs4 from "node:fs";
import require$$0$12 from "node:buffer";
import require$$63 from "node:stream";
import path2 from "node:path";
import require$$0$2__default3 from "node:util";
import zlib__default from "node:zlib";
import EventEmitter3 from "node:events";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: /* @__PURE__ */ __name(() => e[k], "get")
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
__name(_mergeNamespaces, "_mergeNamespaces");
function getDefaultExportFromCjs3(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
__name(getDefaultExportFromCjs3, "getDefaultExportFromCjs");
var browser2 = { exports: {} };
var ms2;
var hasRequiredMs2;
function requireMs2() {
  if (hasRequiredMs2) return ms2;
  hasRequiredMs2 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms2 = /* @__PURE__ */ __name(function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  }, "ms");
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  __name(parse2, "parse");
  function fmtShort(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d) {
      return Math.round(ms3 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms3 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms3 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms3 / s) + "s";
    }
    return ms3 + "ms";
  }
  __name(fmtShort, "fmtShort");
  function fmtLong(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d) {
      return plural(ms3, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms3, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms3, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms3, msAbs, s, "second");
    }
    return ms3 + " ms";
  }
  __name(fmtLong, "fmtLong");
  function plural(ms3, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms3 / n) + " " + name + (isPlural ? "s" : "");
  }
  __name(plural, "plural");
  return ms2;
}
__name(requireMs2, "requireMs");
var common3;
var hasRequiredCommon3;
function requireCommon3() {
  if (hasRequiredCommon3) return common3;
  hasRequiredCommon3 = 1;
  function setup(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs2();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    __name(selectColor, "selectColor");
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug5(...args) {
        if (!debug5.enabled) {
          return;
        }
        const self2 = debug5;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms3 = curr - (prevTime || curr);
        self2.diff = ms3;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      __name(debug5, "debug");
      debug5.namespace = namespace;
      debug5.useColors = createDebug.useColors();
      debug5.color = createDebug.selectColor(namespace);
      debug5.extend = extend;
      debug5.destroy = createDebug.destroy;
      Object.defineProperty(debug5, "enabled", {
        enumerable: true,
        configurable: false,
        get: /* @__PURE__ */ __name(() => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        }, "get"),
        set: /* @__PURE__ */ __name((v) => {
          enableOverride = v;
        }, "set")
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug5);
      }
      return debug5;
    }
    __name(createDebug, "createDebug");
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    __name(extend, "extend");
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    __name(enable, "enable");
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    __name(matchesTemplate, "matchesTemplate");
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    __name(disable, "disable");
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    __name(enabled, "enabled");
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    __name(coerce2, "coerce");
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    __name(destroy, "destroy");
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  __name(setup, "setup");
  common3 = setup;
  return common3;
}
__name(requireCommon3, "requireCommon");
var hasRequiredBrowser2;
function requireBrowser2() {
  if (hasRequiredBrowser2) return browser2.exports;
  hasRequiredBrowser2 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && (m = "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = requireCommon3()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  })(browser2, browser2.exports);
  return browser2.exports;
}
__name(requireBrowser2, "requireBrowser");
var getStream = { exports: {} };
var once2 = { exports: {} };
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
    __name(wrapper, "wrapper");
  }
  __name(wrappy, "wrappy");
  return wrappy_1;
}
__name(requireWrappy, "requireWrappy");
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once2.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once2.exports = wrappy(once$1);
  once2.exports.strict = wrappy(onceStrict);
  once$1.proto = once$1(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: /* @__PURE__ */ __name(function() {
        return once$1(this);
      }, "value"),
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: /* @__PURE__ */ __name(function() {
        return onceStrict(this);
      }, "value"),
      configurable: true
    });
  });
  function once$1(fn) {
    var f = /* @__PURE__ */ __name(function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    }, "f");
    f.called = false;
    return f;
  }
  __name(once$1, "once$1");
  function onceStrict(fn) {
    var f = /* @__PURE__ */ __name(function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    }, "f");
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  __name(onceStrict, "onceStrict");
  return once2.exports;
}
__name(requireOnce, "requireOnce");
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var once3 = requireOnce();
  var noop = /* @__PURE__ */ __name(function() {
  }, "noop");
  var isRequest = /* @__PURE__ */ __name(function(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }, "isRequest");
  var isChildProcess = /* @__PURE__ */ __name(function(stream) {
    return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
  }, "isChildProcess");
  var eos = /* @__PURE__ */ __name(function(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once3(callback || noop);
    var ws3 = stream._writableState;
    var rs = stream._readableState;
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var cancelled = false;
    var onlegacyfinish = /* @__PURE__ */ __name(function() {
      if (!stream.writable) onfinish();
    }, "onlegacyfinish");
    var onfinish = /* @__PURE__ */ __name(function() {
      writable = false;
      if (!readable) callback.call(stream);
    }, "onfinish");
    var onend = /* @__PURE__ */ __name(function() {
      readable = false;
      if (!writable) callback.call(stream);
    }, "onend");
    var onexit = /* @__PURE__ */ __name(function(exitCode2) {
      callback.call(stream, exitCode2 ? new Error("exited with error code: " + exitCode2) : null);
    }, "onexit");
    var onerror = /* @__PURE__ */ __name(function(err) {
      callback.call(stream, err);
    }, "onerror");
    var onclose = /* @__PURE__ */ __name(function() {
      process.nextTick(onclosenexttick);
    }, "onclose");
    var onclosenexttick = /* @__PURE__ */ __name(function() {
      if (cancelled) return;
      if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
      if (writable && !(ws3 && (ws3.ended && !ws3.destroyed))) return callback.call(stream, new Error("premature close"));
    }, "onclosenexttick");
    var onrequest = /* @__PURE__ */ __name(function() {
      stream.req.on("finish", onfinish);
    }, "onrequest");
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !ws3) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream)) stream.on("exit", onexit);
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      cancelled = true;
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("exit", onexit);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }, "eos");
  endOfStream = eos;
  return endOfStream;
}
__name(requireEndOfStream, "requireEndOfStream");
var pump_1;
var hasRequiredPump;
function requirePump() {
  if (hasRequiredPump) return pump_1;
  hasRequiredPump = 1;
  var once3 = requireOnce();
  var eos = requireEndOfStream();
  var fs34;
  try {
    fs34 = require_fs();
  } catch (e) {
  }
  var noop = /* @__PURE__ */ __name(function() {
  }, "noop");
  var ancient = /^v?\.0/.test(process.version);
  var isFn = /* @__PURE__ */ __name(function(fn) {
    return typeof fn === "function";
  }, "isFn");
  var isFS = /* @__PURE__ */ __name(function(stream) {
    if (!ancient) return false;
    if (!fs34) return false;
    return (stream instanceof (fs34.ReadStream || noop) || stream instanceof (fs34.WriteStream || noop)) && isFn(stream.close);
  }, "isFS");
  var isRequest = /* @__PURE__ */ __name(function(stream) {
    return stream.setHeader && isFn(stream.abort);
  }, "isRequest");
  var destroyer = /* @__PURE__ */ __name(function(stream, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    eos(stream, { readable: reading, writable: writing }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isFS(stream)) return stream.close(noop);
      if (isRequest(stream)) return stream.abort();
      if (isFn(stream.destroy)) return stream.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  }, "destroyer");
  var call = /* @__PURE__ */ __name(function(fn) {
    fn();
  }, "call");
  var pipe = /* @__PURE__ */ __name(function(from, to) {
    return from.pipe(to);
  }, "pipe");
  var pump = /* @__PURE__ */ __name(function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new Error("pump requires two streams per minimum");
    var error3;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error3) error3 = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error3);
      });
    });
    return streams.reduce(pipe);
  }, "pump");
  pump_1 = pump;
  return pump_1;
}
__name(requirePump, "requirePump");
var bufferStream;
var hasRequiredBufferStream;
function requireBufferStream() {
  if (hasRequiredBufferStream) return bufferStream;
  hasRequiredBufferStream = 1;
  const { PassThrough: PassThroughStream } = require$$63;
  bufferStream = /* @__PURE__ */ __name((options2) => {
    options2 = { ...options2 };
    const { array } = options2;
    let { encoding } = options2;
    const isBuffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
      objectMode = !(encoding || isBuffer);
    } else {
      encoding = encoding || "utf8";
    }
    if (isBuffer) {
      encoding = null;
    }
    const stream = new PassThroughStream({ objectMode });
    if (encoding) {
      stream.setEncoding(encoding);
    }
    let length = 0;
    const chunks = [];
    stream.on("data", (chunk) => {
      chunks.push(chunk);
      if (objectMode) {
        length = chunks.length;
      } else {
        length += chunk.length;
      }
    });
    stream.getBufferedValue = () => {
      if (array) {
        return chunks;
      }
      return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
    };
    stream.getBufferedLength = () => length;
    return stream;
  }, "bufferStream");
  return bufferStream;
}
__name(requireBufferStream, "requireBufferStream");
var hasRequiredGetStream;
function requireGetStream() {
  if (hasRequiredGetStream) return getStream.exports;
  hasRequiredGetStream = 1;
  const { constants: BufferConstants } = require$$0$12;
  const pump = requirePump();
  const bufferStream2 = requireBufferStream();
  class MaxBufferError extends Error {
    static {
      __name(this, "MaxBufferError");
    }
    constructor() {
      super("maxBuffer exceeded");
      this.name = "MaxBufferError";
    }
  }
  async function getStream$1(inputStream, options2) {
    if (!inputStream) {
      return Promise.reject(new Error("Expected a stream"));
    }
    options2 = {
      maxBuffer: Infinity,
      ...options2
    };
    const { maxBuffer } = options2;
    let stream;
    await new Promise((resolve, reject) => {
      const rejectPromise = /* @__PURE__ */ __name((error3) => {
        if (error3 && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
          error3.bufferedData = stream.getBufferedValue();
        }
        reject(error3);
      }, "rejectPromise");
      stream = pump(inputStream, bufferStream2(options2), (error3) => {
        if (error3) {
          rejectPromise(error3);
          return;
        }
        resolve();
      });
      stream.on("data", () => {
        if (stream.getBufferedLength() > maxBuffer) {
          rejectPromise(new MaxBufferError());
        }
      });
    });
    return stream.getBufferedValue();
  }
  __name(getStream$1, "getStream$1");
  getStream.exports = getStream$1;
  getStream.exports.default = getStream$1;
  getStream.exports.buffer = (stream, options2) => getStream$1(stream, { ...options2, encoding: "buffer" });
  getStream.exports.array = (stream, options2) => getStream$1(stream, { ...options2, array: true });
  getStream.exports.MaxBufferError = MaxBufferError;
  return getStream.exports;
}
__name(requireGetStream, "requireGetStream");
var yauzl = {};
var fdSlicer = {};
var pend;
var hasRequiredPend;
function requirePend() {
  if (hasRequiredPend) return pend;
  hasRequiredPend = 1;
  pend = Pend;
  function Pend() {
    this.pending = 0;
    this.max = Infinity;
    this.listeners = [];
    this.waiting = [];
    this.error = null;
  }
  __name(Pend, "Pend");
  Pend.prototype.go = function(fn) {
    if (this.pending < this.max) {
      pendGo(this, fn);
    } else {
      this.waiting.push(fn);
    }
  };
  Pend.prototype.wait = function(cb) {
    if (this.pending === 0) {
      cb(this.error);
    } else {
      this.listeners.push(cb);
    }
  };
  Pend.prototype.hold = function() {
    return pendHold(this);
  };
  function pendHold(self2) {
    self2.pending += 1;
    var called = false;
    return onCb;
    function onCb(err) {
      if (called) throw new Error("callback called twice");
      called = true;
      self2.error = self2.error || err;
      self2.pending -= 1;
      if (self2.waiting.length > 0 && self2.pending < self2.max) {
        pendGo(self2, self2.waiting.shift());
      } else if (self2.pending === 0) {
        var listeners2 = self2.listeners;
        self2.listeners = [];
        listeners2.forEach(cbListener);
      }
    }
    __name(onCb, "onCb");
    function cbListener(listener) {
      listener(self2.error);
    }
    __name(cbListener, "cbListener");
  }
  __name(pendHold, "pendHold");
  function pendGo(self2, fn) {
    fn(pendHold(self2));
  }
  __name(pendGo, "pendGo");
  return pend;
}
__name(requirePend, "requirePend");
var hasRequiredFdSlicer;
function requireFdSlicer() {
  if (hasRequiredFdSlicer) return fdSlicer;
  hasRequiredFdSlicer = 1;
  var fs$1 = fs4;
  var util2 = require$$0$2__default3;
  var stream = require$$63;
  var Readable2 = stream.Readable;
  var Writable3 = stream.Writable;
  var PassThrough = stream.PassThrough;
  var Pend = requirePend();
  var EventEmitter$1 = EventEmitter3.EventEmitter;
  fdSlicer.createFromBuffer = createFromBuffer;
  fdSlicer.createFromFd = createFromFd;
  fdSlicer.BufferSlicer = BufferSlicer;
  fdSlicer.FdSlicer = FdSlicer;
  util2.inherits(FdSlicer, EventEmitter$1);
  function FdSlicer(fd, options2) {
    options2 = options2 || {};
    EventEmitter$1.call(this);
    this.fd = fd;
    this.pend = new Pend();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options2.autoClose;
  }
  __name(FdSlicer, "FdSlicer");
  FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs$1.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
        cb();
        callback(err, bytesRead, buffer2);
      });
    });
  };
  FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    var self2 = this;
    self2.pend.go(function(cb) {
      fs$1.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
        cb();
        callback(err, written, buffer2);
      });
    });
  };
  FdSlicer.prototype.createReadStream = function(options2) {
    return new ReadStream2(this, options2);
  };
  FdSlicer.prototype.createWriteStream = function(options2) {
    return new WriteStream2(this, options2);
  };
  FdSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  FdSlicer.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0) return;
    if (self2.refCount < 0) throw new Error("invalid unref");
    if (self2.autoClose) {
      fs$1.close(self2.fd, onCloseDone);
    }
    function onCloseDone(err) {
      if (err) {
        self2.emit("error", err);
      } else {
        self2.emit("close");
      }
    }
    __name(onCloseDone, "onCloseDone");
  };
  util2.inherits(ReadStream2, Readable2);
  function ReadStream2(context2, options2) {
    options2 = options2 || {};
    Readable2.call(this, options2);
    this.context = context2;
    this.context.ref();
    this.start = options2.start || 0;
    this.endOffset = options2.end;
    this.pos = this.start;
    this.destroyed = false;
  }
  __name(ReadStream2, "ReadStream");
  ReadStream2.prototype._read = function(n) {
    var self2 = this;
    if (self2.destroyed) return;
    var toRead = Math.min(self2._readableState.highWaterMark, n);
    if (self2.endOffset != null) {
      toRead = Math.min(toRead, self2.endOffset - self2.pos);
    }
    if (toRead <= 0) {
      self2.destroyed = true;
      self2.push(null);
      self2.context.unref();
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed) return cb();
      var buffer = Buffer.allocUnsafe(toRead);
      fs$1.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
        if (err) {
          self2.destroy(err);
        } else if (bytesRead === 0) {
          self2.destroyed = true;
          self2.push(null);
          self2.context.unref();
        } else {
          self2.pos += bytesRead;
          self2.push(buffer.slice(0, bytesRead));
        }
        cb();
      });
    });
  };
  ReadStream2.prototype.destroy = function(err) {
    if (this.destroyed) return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
  };
  util2.inherits(WriteStream2, Writable3);
  function WriteStream2(context2, options2) {
    options2 = options2 || {};
    Writable3.call(this, options2);
    this.context = context2;
    this.context.ref();
    this.start = options2.start || 0;
    this.endOffset = options2.end == null ? Infinity : +options2.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  __name(WriteStream2, "WriteStream");
  WriteStream2.prototype._write = function(buffer, encoding, callback) {
    var self2 = this;
    if (self2.destroyed) return;
    if (self2.pos + buffer.length > self2.endOffset) {
      var err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      self2.destroy();
      callback(err);
      return;
    }
    self2.context.pend.go(function(cb) {
      if (self2.destroyed) return cb();
      fs$1.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
        if (err2) {
          self2.destroy();
          cb();
          callback(err2);
        } else {
          self2.bytesWritten += bytes;
          self2.pos += bytes;
          self2.emit("progress");
          cb();
          callback();
        }
      });
    });
  };
  WriteStream2.prototype.destroy = function() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.context.unref();
  };
  util2.inherits(BufferSlicer, EventEmitter$1);
  function BufferSlicer(buffer, options2) {
    EventEmitter$1.call(this);
    options2 = options2 || {};
    this.refCount = 0;
    this.buffer = buffer;
    this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
  }
  __name(BufferSlicer, "BufferSlicer");
  BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
    if (!(0 <= offset && offset <= buffer.length)) throw new RangeError("offset outside buffer: 0 <= " + offset + " <= " + buffer.length);
    if (position < 0) throw new RangeError("position is negative: " + position);
    if (offset + length > buffer.length) {
      length = buffer.length - offset;
    }
    if (position + length > this.buffer.length) {
      length = this.buffer.length - position;
    }
    if (length <= 0) {
      setImmediate(function() {
        callback(null, 0);
      });
      return;
    }
    this.buffer.copy(buffer, offset, position, position + length);
    setImmediate(function() {
      callback(null, length);
    });
  };
  BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
    buffer.copy(this.buffer, position, offset, offset + length);
    setImmediate(function() {
      callback(null, length, buffer);
    });
  };
  BufferSlicer.prototype.createReadStream = function(options2) {
    options2 = options2 || {};
    var readStream = new PassThrough(options2);
    readStream.destroyed = false;
    readStream.start = options2.start || 0;
    readStream.endOffset = options2.end;
    readStream.pos = readStream.endOffset || this.buffer.length;
    var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
    var offset = 0;
    while (true) {
      var nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream.write(entireSlice.slice(offset, entireSlice.length));
        }
        break;
      }
      readStream.write(entireSlice.slice(offset, nextOffset));
      offset = nextOffset;
    }
    readStream.end();
    readStream.destroy = function() {
      readStream.destroyed = true;
    };
    return readStream;
  };
  BufferSlicer.prototype.createWriteStream = function(options2) {
    var bufferSlicer = this;
    options2 = options2 || {};
    var writeStream = new Writable3(options2);
    writeStream.start = options2.start || 0;
    writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = function(buffer, encoding, callback) {
      if (writeStream.destroyed) return;
      var end = writeStream.pos + buffer.length;
      if (end > writeStream.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
      writeStream.bytesWritten += buffer.length;
      writeStream.pos = end;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = function() {
      writeStream.destroyed = true;
    };
    return writeStream;
  };
  BufferSlicer.prototype.ref = function() {
    this.refCount += 1;
  };
  BufferSlicer.prototype.unref = function() {
    this.refCount -= 1;
    if (this.refCount < 0) {
      throw new Error("invalid unref");
    }
  };
  function createFromBuffer(buffer, options2) {
    return new BufferSlicer(buffer, options2);
  }
  __name(createFromBuffer, "createFromBuffer");
  function createFromFd(fd, options2) {
    return new FdSlicer(fd, options2);
  }
  __name(createFromFd, "createFromFd");
  return fdSlicer;
}
__name(requireFdSlicer, "requireFdSlicer");
var bufferCrc32;
var hasRequiredBufferCrc32;
function requireBufferCrc32() {
  if (hasRequiredBufferCrc32) return bufferCrc32;
  hasRequiredBufferCrc32 = 1;
  var Buffer2 = require$$0$12.Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  __name(ensureBuffer, "ensureBuffer");
  function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
  }
  __name(bufferizeInt, "bufferizeInt");
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc2 = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc2 = CRC_TABLE[(crc2 ^ buf[n]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  }
  __name(_crc32, "_crc32");
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  __name(crc32, "crc32");
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  bufferCrc32 = crc32;
  return bufferCrc32;
}
__name(requireBufferCrc32, "requireBufferCrc32");
var hasRequiredYauzl;
function requireYauzl() {
  if (hasRequiredYauzl) return yauzl;
  hasRequiredYauzl = 1;
  var fs$1 = fs4;
  var zlib2 = zlib__default;
  var fd_slicer = requireFdSlicer();
  var crc32 = requireBufferCrc32();
  var util2 = require$$0$2__default3;
  var EventEmitter$1 = EventEmitter3.EventEmitter;
  var Transform2 = require$$63.Transform;
  var PassThrough = require$$63.PassThrough;
  var Writable3 = require$$63.Writable;
  yauzl.open = open5;
  yauzl.fromFd = fromFd;
  yauzl.fromBuffer = fromBuffer;
  yauzl.fromRandomAccessReader = fromRandomAccessReader;
  yauzl.dosDateTimeToDate = dosDateTimeToDate;
  yauzl.getFileNameLowLevel = getFileNameLowLevel;
  yauzl.validateFileName = validateFileName;
  yauzl.parseExtraFields = parseExtraFields;
  yauzl.ZipFile = ZipFile2;
  yauzl.Entry = Entry;
  yauzl.LocalFileHeader = LocalFileHeader;
  yauzl.RandomAccessReader = RandomAccessReader;
  function open5(path30, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = true;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs$1.open(path30, "r", function(err, fd) {
      if (err) return callback(err);
      fromFd(fd, options2, function(err2, zipfile) {
        if (err2) fs$1.close(fd, defaultCallback);
        callback(err2, zipfile);
      });
    });
  }
  __name(open5, "open");
  function fromFd(fd, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = false;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    fs$1.fstat(fd, function(err, stats) {
      if (err) return callback(err);
      var reader = fd_slicer.createFromFd(fd, { autoClose: true });
      fromRandomAccessReader(reader, stats.size, options2, callback);
    });
  }
  __name(fromFd, "fromFd");
  function fromBuffer(buffer, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    options2.autoClose = false;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
    fromRandomAccessReader(reader, buffer.length, options2, callback);
  }
  __name(fromBuffer, "fromBuffer");
  function fromRandomAccessReader(reader, totalSize, options2, callback) {
    if (typeof options2 === "function") {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (options2.autoClose == null) options2.autoClose = true;
    if (options2.lazyEntries == null) options2.lazyEntries = false;
    if (options2.decodeStrings == null) options2.decodeStrings = true;
    var decodeStrings = !!options2.decodeStrings;
    if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
    if (options2.strictFileNames == null) options2.strictFileNames = false;
    if (callback == null) callback = defaultCallback;
    if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
    if (totalSize > Number.MAX_SAFE_INTEGER) {
      throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
    }
    reader.ref();
    var eocdrWithoutCommentSize = 22;
    var zip64EocdlSize = 20;
    var maxCommentSize = 65535;
    var bufferSize = Math.min(zip64EocdlSize + eocdrWithoutCommentSize + maxCommentSize, totalSize);
    var buffer = newBuffer(bufferSize);
    var bufferReadStart = totalSize - buffer.length;
    readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
      if (err) return callback(err);
      for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
        if (buffer.readUInt32LE(i) !== 101010256) continue;
        var eocdrBuffer = buffer.subarray(i);
        var diskNumber = eocdrBuffer.readUInt16LE(4);
        var entryCount = eocdrBuffer.readUInt16LE(10);
        var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
        var commentLength = eocdrBuffer.readUInt16LE(20);
        var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
        if (commentLength !== expectedCommentLength) {
          return callback(new Error("Invalid comment length. Expected: " + expectedCommentLength + ". Found: " + commentLength + ". Are there extra bytes at the end of the file? Or is the end of central dir signature `PK\u263A\u263B` in the comment?"));
        }
        var comment2 = decodeStrings ? decodeBuffer(eocdrBuffer.subarray(22), false) : eocdrBuffer.subarray(22);
        if (i - zip64EocdlSize >= 0 && buffer.readUInt32LE(i - zip64EocdlSize) === 117853008) {
          var zip64EocdlBuffer = buffer.subarray(i - zip64EocdlSize, i - zip64EocdlSize + zip64EocdlSize);
          var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
          var zip64EocdrBuffer = newBuffer(56);
          return readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err2) {
            if (err2) return callback(err2);
            if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
              return callback(new Error("invalid zip64 end of central directory record signature"));
            }
            diskNumber = zip64EocdrBuffer.readUInt32LE(16);
            if (diskNumber !== 0) {
              return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
            }
            entryCount = readUInt64LE(zip64EocdrBuffer, 32);
            centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
            return callback(null, new ZipFile2(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
          });
        }
        if (diskNumber !== 0) {
          return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
        }
        return callback(null, new ZipFile2(reader, centralDirectoryOffset, totalSize, entryCount, comment2, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
      }
      callback(new Error("End of central directory record signature not found. Either not a zip file, or file is truncated."));
    });
  }
  __name(fromRandomAccessReader, "fromRandomAccessReader");
  util2.inherits(ZipFile2, EventEmitter$1);
  function ZipFile2(reader, centralDirectoryOffset, fileSize, entryCount, comment2, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
    var self2 = this;
    EventEmitter$1.call(self2);
    self2.reader = reader;
    self2.reader.on("error", function(err) {
      emitError(self2, err);
    });
    self2.reader.once("close", function() {
      self2.emit("close");
    });
    self2.readEntryCursor = centralDirectoryOffset;
    self2.fileSize = fileSize;
    self2.entryCount = entryCount;
    self2.comment = comment2;
    self2.entriesRead = 0;
    self2.autoClose = !!autoClose;
    self2.lazyEntries = !!lazyEntries;
    self2.decodeStrings = !!decodeStrings;
    self2.validateEntrySizes = !!validateEntrySizes;
    self2.strictFileNames = !!strictFileNames;
    self2.isOpen = true;
    self2.emittedError = false;
    if (!self2.lazyEntries) self2._readEntry();
  }
  __name(ZipFile2, "ZipFile");
  ZipFile2.prototype.close = function() {
    if (!this.isOpen) return;
    this.isOpen = false;
    this.reader.unref();
  };
  function emitErrorAndAutoClose(self2, err) {
    if (self2.autoClose) self2.close();
    emitError(self2, err);
  }
  __name(emitErrorAndAutoClose, "emitErrorAndAutoClose");
  function emitError(self2, err) {
    if (self2.emittedError) return;
    self2.emittedError = true;
    self2.emit("error", err);
  }
  __name(emitError, "emitError");
  ZipFile2.prototype.readEntry = function() {
    if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
    this._readEntry();
  };
  ZipFile2.prototype._readEntry = function() {
    var self2 = this;
    if (self2.entryCount === self2.entriesRead) {
      setImmediate(function() {
        if (self2.autoClose) self2.close();
        if (self2.emittedError) return;
        self2.emit("end");
      });
      return;
    }
    if (self2.emittedError) return;
    var buffer = newBuffer(46);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
      if (err) return emitErrorAndAutoClose(self2, err);
      if (self2.emittedError) return;
      var entry = new Entry();
      var signature = buffer.readUInt32LE(0);
      if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
      entry.versionMadeBy = buffer.readUInt16LE(4);
      entry.versionNeededToExtract = buffer.readUInt16LE(6);
      entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
      entry.compressionMethod = buffer.readUInt16LE(10);
      entry.lastModFileTime = buffer.readUInt16LE(12);
      entry.lastModFileDate = buffer.readUInt16LE(14);
      entry.crc32 = buffer.readUInt32LE(16);
      entry.compressedSize = buffer.readUInt32LE(20);
      entry.uncompressedSize = buffer.readUInt32LE(24);
      entry.fileNameLength = buffer.readUInt16LE(28);
      entry.extraFieldLength = buffer.readUInt16LE(30);
      entry.fileCommentLength = buffer.readUInt16LE(32);
      entry.internalFileAttributes = buffer.readUInt16LE(36);
      entry.externalFileAttributes = buffer.readUInt32LE(38);
      entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
      if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
      self2.readEntryCursor += 46;
      buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
        if (err2) return emitErrorAndAutoClose(self2, err2);
        if (self2.emittedError) return;
        entry.fileNameRaw = buffer.subarray(0, entry.fileNameLength);
        var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
        entry.extraFieldRaw = buffer.subarray(entry.fileNameLength, fileCommentStart);
        entry.fileCommentRaw = buffer.subarray(fileCommentStart, fileCommentStart + entry.fileCommentLength);
        try {
          entry.extraFields = parseExtraFields(entry.extraFieldRaw);
        } catch (err3) {
          return emitErrorAndAutoClose(self2, err3);
        }
        if (self2.decodeStrings) {
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileComment = decodeBuffer(entry.fileCommentRaw, isUtf8);
          entry.fileName = getFileNameLowLevel(entry.generalPurposeBitFlag, entry.fileNameRaw, entry.extraFields, self2.strictFileNames);
          var errorMessage = validateFileName(entry.fileName);
          if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
        } else {
          entry.fileComment = entry.fileCommentRaw;
          entry.fileName = entry.fileNameRaw;
        }
        entry.comment = entry.fileComment;
        self2.readEntryCursor += buffer.length;
        self2.entriesRead += 1;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id !== 1) continue;
          var zip64EiefBuffer = extraField.data;
          var index2 = 0;
          if (entry.uncompressedSize === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
            }
            entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
          if (entry.compressedSize === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
            }
            entry.compressedSize = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
          if (entry.relativeOffsetOfLocalHeader === 4294967295) {
            if (index2 + 8 > zip64EiefBuffer.length) {
              return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
            }
            entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index2);
            index2 += 8;
          }
          break;
        }
        if (self2.validateEntrySizes && entry.compressionMethod === 0) {
          var expectedCompressedSize = entry.uncompressedSize;
          if (entry.isEncrypted()) {
            expectedCompressedSize += 12;
          }
          if (entry.compressedSize !== expectedCompressedSize) {
            var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
            return emitErrorAndAutoClose(self2, new Error(msg));
          }
        }
        self2.emit("entry", entry);
        if (!self2.lazyEntries) self2._readEntry();
      });
    });
  };
  ZipFile2.prototype.openReadStream = function(entry, options2, callback) {
    var self2 = this;
    var relativeStart = 0;
    var relativeEnd = entry.compressedSize;
    if (callback == null) {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) {
      options2 = {};
    } else {
      if (options2.decrypt != null) {
        if (!entry.isEncrypted()) {
          throw new Error("options.decrypt can only be specified for encrypted entries");
        }
        if (options2.decrypt !== false) throw new Error("invalid options.decrypt value: " + options2.decrypt);
        if (entry.isCompressed()) {
          if (options2.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
        }
      }
      if (options2.decompress != null) {
        if (!entry.isCompressed()) {
          throw new Error("options.decompress can only be specified for compressed entries");
        }
        if (!(options2.decompress === false || options2.decompress === true)) {
          throw new Error("invalid options.decompress value: " + options2.decompress);
        }
      }
      if (options2.start != null || options2.end != null) {
        if (entry.isCompressed() && options2.decompress !== false) {
          throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
        }
        if (entry.isEncrypted() && options2.decrypt !== false) {
          throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
        }
      }
      if (options2.start != null) {
        relativeStart = options2.start;
        if (relativeStart < 0) throw new Error("options.start < 0");
        if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
      }
      if (options2.end != null) {
        relativeEnd = options2.end;
        if (relativeEnd < 0) throw new Error("options.end < 0");
        if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
        if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
      }
    }
    if (!self2.isOpen) return callback(new Error("closed"));
    if (entry.isEncrypted()) {
      if (options2.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
    }
    var decompress;
    if (entry.compressionMethod === 0) {
      decompress = false;
    } else if (entry.compressionMethod === 8) {
      decompress = options2.decompress != null ? options2.decompress : true;
    } else {
      return callback(new Error("unsupported compression method: " + entry.compressionMethod));
    }
    self2.readLocalFileHeader(entry, { minimal: true }, function(err, localFileHeader) {
      if (err) return callback(err);
      self2.openReadStreamLowLevel(
        localFileHeader.fileDataStart,
        entry.compressedSize,
        relativeStart,
        relativeEnd,
        decompress,
        entry.uncompressedSize,
        callback
      );
    });
  };
  ZipFile2.prototype.openReadStreamLowLevel = function(fileDataStart, compressedSize, relativeStart, relativeEnd, decompress, uncompressedSize, callback) {
    var self2 = this;
    var readStream = self2.reader.createReadStream({
      start: fileDataStart + relativeStart,
      end: fileDataStart + relativeEnd
    });
    var endpointStream = readStream;
    if (decompress) {
      var destroyed = false;
      var inflateFilter = zlib2.createInflateRaw();
      readStream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) inflateFilter.emit("error", err);
        });
      });
      readStream.pipe(inflateFilter);
      if (self2.validateEntrySizes) {
        endpointStream = new AssertByteCountStream(uncompressedSize);
        inflateFilter.on("error", function(err) {
          setImmediate(function() {
            if (!destroyed) endpointStream.emit("error", err);
          });
        });
        inflateFilter.pipe(endpointStream);
      } else {
        endpointStream = inflateFilter;
      }
      installDestroyFn(endpointStream, function() {
        destroyed = true;
        if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
        readStream.unpipe(inflateFilter);
        readStream.destroy();
      });
    }
    callback(null, endpointStream);
  };
  ZipFile2.prototype.readLocalFileHeader = function(entry, options2, callback) {
    var self2 = this;
    if (callback == null) {
      callback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    self2.reader.ref();
    var buffer = newBuffer(30);
    readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
      try {
        if (err) return callback(err);
        var signature = buffer.readUInt32LE(0);
        if (signature !== 67324752) {
          return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
        }
        var fileNameLength = buffer.readUInt16LE(26);
        var extraFieldLength = buffer.readUInt16LE(28);
        var fileDataStart = entry.relativeOffsetOfLocalHeader + 30 + fileNameLength + extraFieldLength;
        if (fileDataStart + entry.compressedSize > self2.fileSize) {
          return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
        }
        if (options2.minimal) {
          return callback(null, { fileDataStart });
        }
        var localFileHeader = new LocalFileHeader();
        localFileHeader.fileDataStart = fileDataStart;
        localFileHeader.versionNeededToExtract = buffer.readUInt16LE(4);
        localFileHeader.generalPurposeBitFlag = buffer.readUInt16LE(6);
        localFileHeader.compressionMethod = buffer.readUInt16LE(8);
        localFileHeader.lastModFileTime = buffer.readUInt16LE(10);
        localFileHeader.lastModFileDate = buffer.readUInt16LE(12);
        localFileHeader.crc32 = buffer.readUInt32LE(14);
        localFileHeader.compressedSize = buffer.readUInt32LE(18);
        localFileHeader.uncompressedSize = buffer.readUInt32LE(22);
        localFileHeader.fileNameLength = fileNameLength;
        localFileHeader.extraFieldLength = extraFieldLength;
        buffer = newBuffer(fileNameLength + extraFieldLength);
        self2.reader.ref();
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader + 30, function(err2) {
          try {
            if (err2) return callback(err2);
            localFileHeader.fileName = buffer.subarray(0, fileNameLength);
            localFileHeader.extraField = buffer.subarray(fileNameLength);
            return callback(null, localFileHeader);
          } finally {
            self2.reader.unref();
          }
        });
      } finally {
        self2.reader.unref();
      }
    });
  };
  function Entry() {
  }
  __name(Entry, "Entry");
  Entry.prototype.getLastModDate = function(options2) {
    if (options2 == null) options2 = {};
    if (!options2.forceDosFormat) {
      for (var i = 0; i < this.extraFields.length; i++) {
        var extraField = this.extraFields[i];
        if (extraField.id === 21589) {
          var data = extraField.data;
          if (data.length < 5) continue;
          var flags = data[0];
          var HAS_MTIME = 1;
          if (!(flags & HAS_MTIME)) continue;
          var posixTimestamp = data.readInt32LE(1);
          return new Date(posixTimestamp * 1e3);
        } else if (extraField.id === 10) {
          var data = extraField.data;
          var cursor = 4;
          while (cursor < data.length + 4) {
            var tag = data.readUInt16LE(cursor);
            cursor += 2;
            var size = data.readUInt16LE(cursor);
            cursor += 2;
            if (tag !== 1) {
              cursor += size;
              continue;
            }
            if (size < 8 || cursor + size > data.length) break;
            var hundredNanoSecondsSince1601 = 4294967296 * data.readInt32LE(cursor + 4) + data.readUInt32LE(cursor);
            var millisecondsSince1970 = hundredNanoSecondsSince1601 / 1e4 - 116444736e5;
            return new Date(millisecondsSince1970);
          }
        }
      }
    }
    return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime, options2.timezone);
  };
  Entry.prototype.isEncrypted = function() {
    return (this.generalPurposeBitFlag & 1) !== 0;
  };
  Entry.prototype.isCompressed = function() {
    return this.compressionMethod === 8;
  };
  function LocalFileHeader() {
  }
  __name(LocalFileHeader, "LocalFileHeader");
  function dosDateTimeToDate(date, time3, timezone) {
    var day = date & 31;
    var month = (date >> 5 & 15) - 1;
    var year = (date >> 9 & 127) + 1980;
    var millisecond = 0;
    var second = (time3 & 31) * 2;
    var minute = time3 >> 5 & 63;
    var hour = time3 >> 11 & 31;
    if (timezone == null || timezone === "local") {
      return new Date(year, month, day, hour, minute, second, millisecond);
    } else if (timezone === "UTC") {
      return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
    } else {
      throw new Error("unrecognized options.timezone: " + options.timezone);
    }
  }
  __name(dosDateTimeToDate, "dosDateTimeToDate");
  function getFileNameLowLevel(generalPurposeBitFlag, fileNameBuffer, extraFields, strictFileNames) {
    var fileName = null;
    for (var i = 0; i < extraFields.length; i++) {
      var extraField = extraFields[i];
      if (extraField.id === 28789) {
        if (extraField.data.length < 6) {
          continue;
        }
        if (extraField.data.readUInt8(0) !== 1) {
          continue;
        }
        var oldNameCrc32 = extraField.data.readUInt32LE(1);
        if (crc32.unsigned(fileNameBuffer) !== oldNameCrc32) {
          continue;
        }
        fileName = decodeBuffer(extraField.data.subarray(5), true);
        break;
      }
    }
    if (fileName == null) {
      var isUtf8 = (generalPurposeBitFlag & 2048) !== 0;
      fileName = decodeBuffer(fileNameBuffer, isUtf8);
    }
    if (!strictFileNames) {
      fileName = fileName.replace(/\\/g, "/");
    }
    return fileName;
  }
  __name(getFileNameLowLevel, "getFileNameLowLevel");
  function validateFileName(fileName) {
    if (fileName.indexOf("\\") !== -1) {
      return "invalid characters in fileName: " + fileName;
    }
    if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
      return "absolute path: " + fileName;
    }
    if (fileName.split("/").indexOf("..") !== -1) {
      return "invalid relative path: " + fileName;
    }
    return null;
  }
  __name(validateFileName, "validateFileName");
  function parseExtraFields(extraFieldBuffer) {
    var extraFields = [];
    var i = 0;
    while (i < extraFieldBuffer.length - 3) {
      var headerId = extraFieldBuffer.readUInt16LE(i + 0);
      var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
      var dataStart = i + 4;
      var dataEnd = dataStart + dataSize;
      if (dataEnd > extraFieldBuffer.length) throw new Error("extra field length exceeds extra field buffer size");
      var dataBuffer = extraFieldBuffer.subarray(dataStart, dataEnd);
      extraFields.push({
        id: headerId,
        data: dataBuffer
      });
      i = dataEnd;
    }
    return extraFields;
  }
  __name(parseExtraFields, "parseExtraFields");
  function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
    if (length === 0) {
      return setImmediate(function() {
        callback(null, newBuffer(0));
      });
    }
    reader.read(buffer, offset, length, position, function(err, bytesRead) {
      if (err) return callback(err);
      if (bytesRead < length) {
        return callback(new Error("unexpected EOF"));
      }
      callback();
    });
  }
  __name(readAndAssertNoEof, "readAndAssertNoEof");
  util2.inherits(AssertByteCountStream, Transform2);
  function AssertByteCountStream(byteCount) {
    Transform2.call(this);
    this.actualByteCount = 0;
    this.expectedByteCount = byteCount;
  }
  __name(AssertByteCountStream, "AssertByteCountStream");
  AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
    this.actualByteCount += chunk.length;
    if (this.actualByteCount > this.expectedByteCount) {
      var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb(null, chunk);
  };
  AssertByteCountStream.prototype._flush = function(cb) {
    if (this.actualByteCount < this.expectedByteCount) {
      var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
      return cb(new Error(msg));
    }
    cb();
  };
  util2.inherits(RandomAccessReader, EventEmitter$1);
  function RandomAccessReader() {
    EventEmitter$1.call(this);
    this.refCount = 0;
  }
  __name(RandomAccessReader, "RandomAccessReader");
  RandomAccessReader.prototype.ref = function() {
    this.refCount += 1;
  };
  RandomAccessReader.prototype.unref = function() {
    var self2 = this;
    self2.refCount -= 1;
    if (self2.refCount > 0) return;
    if (self2.refCount < 0) throw new Error("invalid unref");
    self2.close(onCloseDone);
    function onCloseDone(err) {
      if (err) return self2.emit("error", err);
      self2.emit("close");
    }
    __name(onCloseDone, "onCloseDone");
  };
  RandomAccessReader.prototype.createReadStream = function(options2) {
    if (options2 == null) options2 = {};
    var start = options2.start;
    var end = options2.end;
    if (start === end) {
      var emptyStream = new PassThrough();
      setImmediate(function() {
        emptyStream.end();
      });
      return emptyStream;
    }
    var stream = this._readStreamForRange(start, end);
    var destroyed = false;
    var refUnrefFilter = new RefUnrefFilter(this);
    stream.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed) refUnrefFilter.emit("error", err);
      });
    });
    installDestroyFn(refUnrefFilter, function() {
      stream.unpipe(refUnrefFilter);
      refUnrefFilter.unref();
      stream.destroy();
    });
    var byteCounter = new AssertByteCountStream(end - start);
    refUnrefFilter.on("error", function(err) {
      setImmediate(function() {
        if (!destroyed) byteCounter.emit("error", err);
      });
    });
    installDestroyFn(byteCounter, function() {
      destroyed = true;
      refUnrefFilter.unpipe(byteCounter);
      refUnrefFilter.destroy();
    });
    return stream.pipe(refUnrefFilter).pipe(byteCounter);
  };
  RandomAccessReader.prototype._readStreamForRange = function(start, end) {
    throw new Error("not implemented");
  };
  RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
    var readStream = this.createReadStream({ start: position, end: position + length });
    var writeStream = new Writable3();
    var written = 0;
    writeStream._write = function(chunk, encoding, cb) {
      chunk.copy(buffer, offset + written, 0, chunk.length);
      written += chunk.length;
      cb();
    };
    writeStream.on("finish", callback);
    readStream.on("error", function(error3) {
      callback(error3);
    });
    readStream.pipe(writeStream);
  };
  RandomAccessReader.prototype.close = function(callback) {
    setImmediate(callback);
  };
  util2.inherits(RefUnrefFilter, PassThrough);
  function RefUnrefFilter(context2) {
    PassThrough.call(this);
    this.context = context2;
    this.context.ref();
    this.unreffedYet = false;
  }
  __name(RefUnrefFilter, "RefUnrefFilter");
  RefUnrefFilter.prototype._flush = function(cb) {
    this.unref();
    cb();
  };
  RefUnrefFilter.prototype.unref = function(cb) {
    if (this.unreffedYet) return;
    this.unreffedYet = true;
    this.context.unref();
  };
  var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
  function decodeBuffer(buffer, isUtf8) {
    if (isUtf8) {
      return buffer.toString("utf8");
    } else {
      var result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    }
  }
  __name(decodeBuffer, "decodeBuffer");
  function readUInt64LE(buffer, offset) {
    var lower32 = buffer.readUInt32LE(offset);
    var upper32 = buffer.readUInt32LE(offset + 4);
    return upper32 * 4294967296 + lower32;
  }
  __name(readUInt64LE, "readUInt64LE");
  var newBuffer;
  if (typeof Buffer.allocUnsafe === "function") {
    newBuffer = /* @__PURE__ */ __name(function(len) {
      return Buffer.allocUnsafe(len);
    }, "newBuffer");
  } else {
    newBuffer = /* @__PURE__ */ __name(function(len) {
      return new Buffer(len);
    }, "newBuffer");
  }
  function installDestroyFn(stream, fn) {
    if (typeof stream.destroy === "function") {
      stream._destroy = function(err, cb) {
        fn();
        if (cb != null) cb(err);
      };
    } else {
      stream.destroy = fn;
    }
  }
  __name(installDestroyFn, "installDestroyFn");
  function defaultCallback(err) {
    if (err) throw err;
  }
  __name(defaultCallback, "defaultCallback");
  return yauzl;
}
__name(requireYauzl, "requireYauzl");
var extractZip$1;
var hasRequiredExtractZip;
function requireExtractZip() {
  if (hasRequiredExtractZip) return extractZip$1;
  hasRequiredExtractZip = 1;
  const debug5 = requireBrowser2()("extract-zip");
  const { createWriteStream, promises: fs$1 } = fs4;
  const getStream2 = requireGetStream();
  const path$1 = path2;
  const { promisify: promisify3 } = require$$0$2__default3;
  const stream = require$$63;
  const yauzl3 = requireYauzl();
  const openZip = promisify3(yauzl3.open);
  const pipeline3 = promisify3(stream.pipeline);
  class Extractor {
    static {
      __name(this, "Extractor");
    }
    constructor(zipPath, opts) {
      this.zipPath = zipPath;
      this.opts = opts;
    }
    async extract() {
      debug5("opening", this.zipPath, "with opts", this.opts);
      this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
      this.canceled = false;
      return new Promise((resolve, reject) => {
        this.zipfile.on("error", (err) => {
          this.canceled = true;
          reject(err);
        });
        this.zipfile.readEntry();
        this.zipfile.on("close", () => {
          if (!this.canceled) {
            debug5("zip extraction complete");
            resolve();
          }
        });
        this.zipfile.on("entry", async (entry) => {
          if (this.canceled) {
            debug5("skipping entry", entry.fileName, { cancelled: this.canceled });
            return;
          }
          debug5("zipfile entry", entry.fileName);
          if (entry.fileName.startsWith("__MACOSX/")) {
            this.zipfile.readEntry();
            return;
          }
          const destDir = path$1.dirname(path$1.join(this.opts.dir, entry.fileName));
          try {
            await fs$1.mkdir(destDir, { recursive: true });
            const canonicalDestDir = await fs$1.realpath(destDir);
            const relativeDestDir = path$1.relative(this.opts.dir, canonicalDestDir);
            if (relativeDestDir.split(path$1.sep).includes("..")) {
              throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
            }
            await this.extractEntry(entry);
            debug5("finished processing", entry.fileName);
            this.zipfile.readEntry();
          } catch (err) {
            this.canceled = true;
            this.zipfile.close();
            reject(err);
          }
        });
      });
    }
    async extractEntry(entry) {
      if (this.canceled) {
        debug5("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
        return;
      }
      if (this.opts.onEntry) {
        this.opts.onEntry(entry, this.zipfile);
      }
      const dest = path$1.join(this.opts.dir, entry.fileName);
      const mode = entry.externalFileAttributes >> 16 & 65535;
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const symlink = (mode & IFMT) === IFLNK;
      let isDir = (mode & IFMT) === IFDIR;
      if (!isDir && entry.fileName.endsWith("/")) {
        isDir = true;
      }
      const madeBy = entry.versionMadeBy >> 8;
      if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;
      debug5("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
      const procMode = this.getExtractedMode(mode, isDir) & 511;
      const destDir = isDir ? dest : path$1.dirname(dest);
      const mkdirOptions = { recursive: true };
      if (isDir) {
        mkdirOptions.mode = procMode;
      }
      debug5("mkdir", { dir: destDir, ...mkdirOptions });
      await fs$1.mkdir(destDir, mkdirOptions);
      if (isDir) return;
      debug5("opening read stream", dest);
      const readStream = await promisify3(this.zipfile.openReadStream.bind(this.zipfile))(entry);
      if (symlink) {
        const link = await getStream2(readStream);
        debug5("creating symlink", link, dest);
        await fs$1.symlink(link, dest);
      } else {
        await pipeline3(readStream, createWriteStream(dest, { mode: procMode }));
      }
    }
    getExtractedMode(entryMode, isDir) {
      let mode = entryMode;
      if (mode === 0) {
        if (isDir) {
          if (this.opts.defaultDirMode) {
            mode = parseInt(this.opts.defaultDirMode, 10);
          }
          if (!mode) {
            mode = 493;
          }
        } else {
          if (this.opts.defaultFileMode) {
            mode = parseInt(this.opts.defaultFileMode, 10);
          }
          if (!mode) {
            mode = 420;
          }
        }
      }
      return mode;
    }
  }
  extractZip$1 = /* @__PURE__ */ __name(async function(zipPath, opts) {
    debug5("creating target directory", opts.dir);
    if (!path$1.isAbsolute(opts.dir)) {
      throw new Error("Target directory is expected to be absolute");
    }
    await fs$1.mkdir(opts.dir, { recursive: true });
    opts.dir = await fs$1.realpath(opts.dir);
    return new Extractor(zipPath, opts).extract();
  }, "extractZip$1");
  return extractZip$1;
}
__name(requireExtractZip, "requireExtractZip");
var yazl = {};
var hasRequiredYazl;
function requireYazl() {
  if (hasRequiredYazl) return yazl;
  hasRequiredYazl = 1;
  var fs$1 = fs4;
  var Transform2 = require$$63.Transform;
  var PassThrough = require$$63.PassThrough;
  var zlib2 = zlib__default;
  var util2 = require$$0$2__default3;
  var EventEmitter$1 = EventEmitter3.EventEmitter;
  var crc32 = requireBufferCrc32();
  yazl.ZipFile = ZipFile2;
  yazl.dateToDosDateTime = dateToDosDateTime;
  util2.inherits(ZipFile2, EventEmitter$1);
  function ZipFile2() {
    this.outputStream = new PassThrough();
    this.entries = [];
    this.outputStreamCursor = 0;
    this.ended = false;
    this.allDone = false;
    this.forceZip64Eocd = false;
  }
  __name(ZipFile2, "ZipFile");
  ZipFile2.prototype.addFile = function(realPath, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (options2 == null) options2 = {};
    var entry = new Entry(metadataPath, false, options2);
    self2.entries.push(entry);
    fs$1.stat(realPath, function(err, stats) {
      if (err) return self2.emit("error", err);
      if (!stats.isFile()) return self2.emit("error", new Error("not a file: " + realPath));
      entry.uncompressedSize = stats.size;
      if (options2.mtime == null) entry.setLastModDate(stats.mtime);
      if (options2.mode == null) entry.setFileAttributesMode(stats.mode);
      entry.setFileDataPumpFunction(function() {
        var readStream = fs$1.createReadStream(realPath);
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        readStream.on("error", function(err2) {
          self2.emit("error", err2);
        });
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    });
  };
  ZipFile2.prototype.addReadStream = function(readStream, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (options2 == null) options2 = {};
    var entry = new Entry(metadataPath, false, options2);
    self2.entries.push(entry);
    entry.setFileDataPumpFunction(function() {
      entry.state = Entry.FILE_DATA_IN_PROGRESS;
      pumpFileDataReadStream(self2, entry, readStream);
    });
    pumpEntries(self2);
  };
  ZipFile2.prototype.addBuffer = function(buffer, metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, false);
    if (buffer.length > 1073741823) throw new Error("buffer too large: " + buffer.length + " > 1073741823");
    if (options2 == null) options2 = {};
    if (options2.size != null) throw new Error("options.size not allowed");
    var entry = new Entry(metadataPath, false, options2);
    entry.uncompressedSize = buffer.length;
    entry.crc32 = crc32.unsigned(buffer);
    entry.crcAndFileSizeKnown = true;
    self2.entries.push(entry);
    if (!entry.compress) {
      setCompressedBuffer(buffer);
    } else {
      zlib2.deflateRaw(buffer, function(err, compressedBuffer) {
        setCompressedBuffer(compressedBuffer);
      });
    }
    function setCompressedBuffer(compressedBuffer) {
      entry.compressedSize = compressedBuffer.length;
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, compressedBuffer);
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        setImmediate(function() {
          pumpEntries(self2);
        });
      });
      pumpEntries(self2);
    }
    __name(setCompressedBuffer, "setCompressedBuffer");
  };
  ZipFile2.prototype.addEmptyDirectory = function(metadataPath, options2) {
    var self2 = this;
    metadataPath = validateMetadataPath(metadataPath, true);
    if (options2 == null) options2 = {};
    if (options2.size != null) throw new Error("options.size not allowed");
    if (options2.compress != null) throw new Error("options.compress not allowed");
    var entry = new Entry(metadataPath, true, options2);
    self2.entries.push(entry);
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;
      pumpEntries(self2);
    });
    pumpEntries(self2);
  };
  var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
  ZipFile2.prototype.end = function(options2, finalSizeCallback) {
    if (typeof options2 === "function") {
      finalSizeCallback = options2;
      options2 = null;
    }
    if (options2 == null) options2 = {};
    if (this.ended) return;
    this.ended = true;
    this.finalSizeCallback = finalSizeCallback;
    this.forceZip64Eocd = !!options2.forceZip64Format;
    if (options2.comment) {
      if (typeof options2.comment === "string") {
        this.comment = encodeCp437(options2.comment);
      } else {
        this.comment = options2.comment;
      }
      if (this.comment.length > 65535) throw new Error("comment is too large");
      if (bufferIncludes(this.comment, eocdrSignatureBuffer)) throw new Error("comment contains end of central directory record signature");
    } else {
      this.comment = EMPTY_BUFFER;
    }
    pumpEntries(this);
  };
  function writeToOutputStream(self2, buffer) {
    self2.outputStream.write(buffer);
    self2.outputStreamCursor += buffer.length;
  }
  __name(writeToOutputStream, "writeToOutputStream");
  function pumpFileDataReadStream(self2, entry, readStream) {
    var crc32Watcher = new Crc32Watcher();
    var uncompressedSizeCounter = new ByteCounter();
    var compressor = entry.compress ? new zlib2.DeflateRaw() : new PassThrough();
    var compressedSizeCounter = new ByteCounter();
    readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
    compressedSizeCounter.on("end", function() {
      entry.crc32 = crc32Watcher.crc32;
      if (entry.uncompressedSize == null) {
        entry.uncompressedSize = uncompressedSizeCounter.byteCount;
      } else {
        if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount) return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
      }
      entry.compressedSize = compressedSizeCounter.byteCount;
      self2.outputStreamCursor += entry.compressedSize;
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry.FILE_DATA_DONE;
      pumpEntries(self2);
    });
  }
  __name(pumpFileDataReadStream, "pumpFileDataReadStream");
  function pumpEntries(self2) {
    if (self2.allDone) return;
    if (self2.ended && self2.finalSizeCallback != null) {
      var finalSize = calculateFinalSize(self2);
      if (finalSize != null) {
        self2.finalSizeCallback(finalSize);
        self2.finalSizeCallback = null;
      }
    }
    var entry = getFirstNotDoneEntry();
    function getFirstNotDoneEntry() {
      for (var i = 0; i < self2.entries.length; i++) {
        var entry2 = self2.entries[i];
        if (entry2.state < Entry.FILE_DATA_DONE) return entry2;
      }
      return null;
    }
    __name(getFirstNotDoneEntry, "getFirstNotDoneEntry");
    if (entry != null) {
      if (entry.state < Entry.READY_TO_PUMP_FILE_DATA) return;
      if (entry.state === Entry.FILE_DATA_IN_PROGRESS) return;
      entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
      var localFileHeader = entry.getLocalFileHeader();
      writeToOutputStream(self2, localFileHeader);
      entry.doFileDataPump();
    } else {
      if (self2.ended) {
        self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
        self2.entries.forEach(function(entry2) {
          var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
          writeToOutputStream(self2, centralDirectoryRecord);
        });
        writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
        self2.outputStream.end();
        self2.allDone = true;
      }
    }
  }
  __name(pumpEntries, "pumpEntries");
  function calculateFinalSize(self2) {
    var pretendOutputCursor = 0;
    var centralDirectorySize = 0;
    for (var i = 0; i < self2.entries.length; i++) {
      var entry = self2.entries[i];
      if (entry.compress) return -1;
      if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
        if (entry.uncompressedSize == null) return -1;
      } else {
        if (entry.uncompressedSize == null) return null;
      }
      entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
      var useZip64Format = entry.useZip64Format();
      pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
      pretendOutputCursor += entry.uncompressedSize;
      if (!entry.crcAndFileSizeKnown) {
        if (useZip64Format) {
          pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
        } else {
          pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
        }
      }
      centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
      if (useZip64Format) {
        centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
      }
    }
    var endOfCentralDirectorySize = 0;
    if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
      endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
    }
    endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
    return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
  }
  __name(calculateFinalSize, "calculateFinalSize");
  var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
  var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
  var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
  function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
    var needZip64Format = false;
    var normalEntriesLength = self2.entries.length;
    if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
      normalEntriesLength = 65535;
      needZip64Format = true;
    }
    var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
    var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
    if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
      normalSizeOfCentralDirectory = 4294967295;
      needZip64Format = true;
    }
    var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
    if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
      normalOffsetOfStartOfCentralDirectory = 4294967295;
      needZip64Format = true;
    }
    var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
    eocdrBuffer.writeUInt32LE(101010256, 0);
    eocdrBuffer.writeUInt16LE(0, 4);
    eocdrBuffer.writeUInt16LE(0, 6);
    eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
    eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
    eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
    eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
    eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
    self2.comment.copy(eocdrBuffer, 22);
    if (!needZip64Format) return eocdrBuffer;
    var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
    zip64EocdrBuffer.writeUInt32LE(101075792, 0);
    writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
    zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
    zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
    zip64EocdrBuffer.writeUInt32LE(0, 16);
    zip64EocdrBuffer.writeUInt32LE(0, 20);
    writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
    writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
    writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
    writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
    var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
    zip64EocdlBuffer.writeUInt32LE(117853008, 0);
    zip64EocdlBuffer.writeUInt32LE(0, 4);
    writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
    zip64EocdlBuffer.writeUInt32LE(1, 16);
    return Buffer.concat([
      zip64EocdrBuffer,
      zip64EocdlBuffer,
      eocdrBuffer
    ]);
  }
  __name(getEndOfCentralDirectoryRecord, "getEndOfCentralDirectoryRecord");
  function validateMetadataPath(metadataPath, isDirectory) {
    if (metadataPath === "") throw new Error("empty metadataPath");
    metadataPath = metadataPath.replace(/\\/g, "/");
    if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath)) throw new Error("absolute path: " + metadataPath);
    if (metadataPath.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + metadataPath);
    var looksLikeDirectory = /\/$/.test(metadataPath);
    if (isDirectory) {
      if (!looksLikeDirectory) metadataPath += "/";
    } else {
      if (looksLikeDirectory) throw new Error("file path cannot end with '/': " + metadataPath);
    }
    return metadataPath;
  }
  __name(validateMetadataPath, "validateMetadataPath");
  var EMPTY_BUFFER = bufferAlloc(0);
  function Entry(metadataPath, isDirectory, options2) {
    this.utf8FileName = bufferFrom(metadataPath);
    if (this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
    this.isDirectory = isDirectory;
    this.state = Entry.WAITING_FOR_METADATA;
    this.setLastModDate(options2.mtime != null ? options2.mtime : /* @__PURE__ */ new Date());
    if (options2.mode != null) {
      this.setFileAttributesMode(options2.mode);
    } else {
      this.setFileAttributesMode(isDirectory ? 16893 : 33204);
    }
    if (isDirectory) {
      this.crcAndFileSizeKnown = true;
      this.crc32 = 0;
      this.uncompressedSize = 0;
      this.compressedSize = 0;
    } else {
      this.crcAndFileSizeKnown = false;
      this.crc32 = null;
      this.uncompressedSize = null;
      this.compressedSize = null;
      if (options2.size != null) this.uncompressedSize = options2.size;
    }
    if (isDirectory) {
      this.compress = false;
    } else {
      this.compress = true;
      if (options2.compress != null) this.compress = !!options2.compress;
    }
    this.forceZip64Format = !!options2.forceZip64Format;
    if (options2.fileComment) {
      if (typeof options2.fileComment === "string") {
        this.fileComment = bufferFrom(options2.fileComment, "utf-8");
      } else {
        this.fileComment = options2.fileComment;
      }
      if (this.fileComment.length > 65535) throw new Error("fileComment is too large");
    } else {
      this.fileComment = EMPTY_BUFFER;
    }
  }
  __name(Entry, "Entry");
  Entry.WAITING_FOR_METADATA = 0;
  Entry.READY_TO_PUMP_FILE_DATA = 1;
  Entry.FILE_DATA_IN_PROGRESS = 2;
  Entry.FILE_DATA_DONE = 3;
  Entry.prototype.setLastModDate = function(date) {
    var dosDateTime = dateToDosDateTime(date);
    this.lastModFileTime = dosDateTime.time;
    this.lastModFileDate = dosDateTime.date;
  };
  Entry.prototype.setFileAttributesMode = function(mode) {
    if ((mode & 65535) !== mode) throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
    this.externalFileAttributes = mode << 16 >>> 0;
  };
  Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
    this.doFileDataPump = doFileDataPump;
    this.state = Entry.READY_TO_PUMP_FILE_DATA;
  };
  Entry.prototype.useZip64Format = function() {
    return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
  };
  var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
  var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
  var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
  var VERSION_MADE_BY = 3 << 8 | 63;
  var FILE_NAME_IS_UTF8 = 1 << 11;
  var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
  Entry.prototype.getLocalFileHeader = function() {
    var crc322 = 0;
    var compressedSize = 0;
    var uncompressedSize = 0;
    if (this.crcAndFileSizeKnown) {
      crc322 = this.crc32;
      compressedSize = this.compressedSize;
      uncompressedSize = this.uncompressedSize;
    }
    var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
    var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
    if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
    fixedSizeStuff.writeUInt32LE(67324752, 0);
    fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
    fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
    fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
    fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
    fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
    fixedSizeStuff.writeUInt32LE(crc322, 14);
    fixedSizeStuff.writeUInt32LE(compressedSize, 18);
    fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
    fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
    fixedSizeStuff.writeUInt16LE(0, 28);
    return Buffer.concat([
      fixedSizeStuff,
      // file name (variable size)
      this.utf8FileName
      // extra field (variable size)
      // no extra fields
    ]);
  };
  var DATA_DESCRIPTOR_SIZE = 16;
  var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
  Entry.prototype.getDataDescriptor = function() {
    if (this.crcAndFileSizeKnown) {
      return EMPTY_BUFFER;
    }
    if (!this.useZip64Format()) {
      var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
      buffer.writeUInt32LE(134695760, 0);
      buffer.writeUInt32LE(this.crc32, 4);
      buffer.writeUInt32LE(this.compressedSize, 8);
      buffer.writeUInt32LE(this.uncompressedSize, 12);
      return buffer;
    } else {
      var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
      buffer.writeUInt32LE(134695760, 0);
      buffer.writeUInt32LE(this.crc32, 4);
      writeUInt64LE(buffer, this.compressedSize, 8);
      writeUInt64LE(buffer, this.uncompressedSize, 16);
      return buffer;
    }
  };
  var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
  var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
  Entry.prototype.getCentralDirectoryRecord = function() {
    var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
    var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
    if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
    var normalCompressedSize = this.compressedSize;
    var normalUncompressedSize = this.uncompressedSize;
    var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
    var versionNeededToExtract;
    var zeiefBuffer;
    if (this.useZip64Format()) {
      normalCompressedSize = 4294967295;
      normalUncompressedSize = 4294967295;
      normalRelativeOffsetOfLocalHeader = 4294967295;
      versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
      zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
      zeiefBuffer.writeUInt16LE(1, 0);
      zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
      writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
      writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
      writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
    } else {
      versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
      zeiefBuffer = EMPTY_BUFFER;
    }
    fixedSizeStuff.writeUInt32LE(33639248, 0);
    fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
    fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
    fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
    fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
    fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
    fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
    fixedSizeStuff.writeUInt32LE(this.crc32, 16);
    fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
    fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
    fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
    fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
    fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
    fixedSizeStuff.writeUInt16LE(0, 34);
    fixedSizeStuff.writeUInt16LE(0, 36);
    fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
    fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
    return Buffer.concat([
      fixedSizeStuff,
      // file name (variable size)
      this.utf8FileName,
      // extra field (variable size)
      zeiefBuffer,
      // file comment (variable size)
      this.fileComment
    ]);
  };
  Entry.prototype.getCompressionMethod = function() {
    var NO_COMPRESSION = 0;
    var DEFLATE_COMPRESSION = 8;
    return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
  };
  function dateToDosDateTime(jsDate) {
    var date = 0;
    date |= jsDate.getDate() & 31;
    date |= (jsDate.getMonth() + 1 & 15) << 5;
    date |= (jsDate.getFullYear() - 1980 & 127) << 9;
    var time3 = 0;
    time3 |= Math.floor(jsDate.getSeconds() / 2);
    time3 |= (jsDate.getMinutes() & 63) << 5;
    time3 |= (jsDate.getHours() & 31) << 11;
    return { date, time: time3 };
  }
  __name(dateToDosDateTime, "dateToDosDateTime");
  function writeUInt64LE(buffer, n, offset) {
    var high = Math.floor(n / 4294967296);
    var low = n % 4294967296;
    buffer.writeUInt32LE(low, offset);
    buffer.writeUInt32LE(high, offset + 4);
  }
  __name(writeUInt64LE, "writeUInt64LE");
  util2.inherits(ByteCounter, Transform2);
  function ByteCounter(options2) {
    Transform2.call(this, options2);
    this.byteCount = 0;
  }
  __name(ByteCounter, "ByteCounter");
  ByteCounter.prototype._transform = function(chunk, encoding, cb) {
    this.byteCount += chunk.length;
    cb(null, chunk);
  };
  util2.inherits(Crc32Watcher, Transform2);
  function Crc32Watcher(options2) {
    Transform2.call(this, options2);
    this.crc32 = 0;
  }
  __name(Crc32Watcher, "Crc32Watcher");
  Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
    this.crc32 = crc32.unsigned(chunk, this.crc32);
    cb(null, chunk);
  };
  var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
  if (cp437.length !== 256) throw new Error("assertion failure");
  var reverseCp437 = null;
  function encodeCp437(string2) {
    if (/^[\x20-\x7e]*$/.test(string2)) {
      return bufferFrom(string2, "utf-8");
    }
    if (reverseCp437 == null) {
      reverseCp437 = {};
      for (var i = 0; i < cp437.length; i++) {
        reverseCp437[cp437[i]] = i;
      }
    }
    var result = bufferAlloc(string2.length);
    for (var i = 0; i < string2.length; i++) {
      var b = reverseCp437[string2[i]];
      if (b == null) throw new Error("character not encodable in CP437: " + JSON.stringify(string2[i]));
      result[i] = b;
    }
    return result;
  }
  __name(encodeCp437, "encodeCp437");
  function bufferAlloc(size) {
    bufferAlloc = modern;
    try {
      return bufferAlloc(size);
    } catch (e) {
      bufferAlloc = legacy;
      return bufferAlloc(size);
    }
    function modern(size2) {
      return Buffer.allocUnsafe(size2);
    }
    __name(modern, "modern");
    function legacy(size2) {
      return new Buffer(size2);
    }
    __name(legacy, "legacy");
  }
  __name(bufferAlloc, "bufferAlloc");
  function bufferFrom(something, encoding) {
    bufferFrom = modern;
    try {
      return bufferFrom(something, encoding);
    } catch (e) {
      bufferFrom = legacy;
      return bufferFrom(something, encoding);
    }
    function modern(something2, encoding2) {
      return Buffer.from(something2, encoding2);
    }
    __name(modern, "modern");
    function legacy(something2, encoding2) {
      return new Buffer(something2, encoding2);
    }
    __name(legacy, "legacy");
  }
  __name(bufferFrom, "bufferFrom");
  function bufferIncludes(buffer, content) {
    bufferIncludes = modern;
    try {
      return bufferIncludes(buffer, content);
    } catch (e) {
      bufferIncludes = legacy;
      return bufferIncludes(buffer, content);
    }
    function modern(buffer2, content2) {
      return buffer2.includes(content2);
    }
    __name(modern, "modern");
    function legacy(buffer2, content2) {
      for (var i = 0; i <= buffer2.length - content2.length; i++) {
        for (var j = 0; ; j++) {
          if (j === content2.length) return true;
          if (buffer2[i + j] !== content2[j]) break;
        }
      }
      return false;
    }
    __name(legacy, "legacy");
  }
  __name(bufferIncludes, "bufferIncludes");
  return yazl;
}
__name(requireYazl, "requireYazl");
var yazlExports = requireYazl();
var index$2 = /* @__PURE__ */ getDefaultExportFromCjs3(yazlExports);
var index$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$2
}, [yazlExports]);
var yauzlExports = requireYauzl();
var index = /* @__PURE__ */ getDefaultExportFromCjs3(yauzlExports);
var index$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [yauzlExports]);
var extractZip = requireExtractZip();
var extract = extractZip;

// node_modules/@cloudflare/playwright/lib/_virtual/zipBundleImpl.js
var require$$05 = /* @__PURE__ */ getAugmentedNamespace(zipBundleImpl_exports);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/zipBundle.js
var yazl2 = require$$05.yazl;
var yauzl2 = require$$05.yauzl;
var extract2 = require$$05.extract;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/fileUtils.js
var existsAsync = /* @__PURE__ */ __name((path210) => new Promise((resolve) => fs5.stat(path210, (err) => resolve(!err))), "existsAsync");
async function mkdirIfNeeded(filePath) {
  await fs5.promises.mkdir(path3.dirname(filePath), { recursive: true }).catch(() => {
  });
}
__name(mkdirIfNeeded, "mkdirIfNeeded");
async function removeFolders(dirs) {
  return await Promise.all(dirs.map(
    (dir3) => fs5.promises.rm(dir3, { recursive: true, force: true, maxRetries: 10 }).catch((e) => e)
  ));
}
__name(removeFolders, "removeFolders");
function canAccessFile(file) {
  if (!file)
    return false;
  try {
    fs5.accessSync(file);
    return true;
  } catch (e) {
    return false;
  }
}
__name(canAccessFile, "canAccessFile");
var SerializedFS = class {
  static {
    __name(this, "SerializedFS");
  }
  constructor() {
    this._buffers = /* @__PURE__ */ new Map();
    this._operations = [];
    this._operationsDone = new ManualPromise();
    this._operationsDone.resolve();
  }
  mkdir(dir3) {
    this._appendOperation({ op: "mkdir", dir: dir3 });
  }
  writeFile(file, content, skipIfExists) {
    this._buffers.delete(file);
    this._appendOperation({ op: "writeFile", file, content, skipIfExists });
  }
  appendFile(file, text, flush) {
    if (!this._buffers.has(file))
      this._buffers.set(file, []);
    this._buffers.get(file).push(text);
    if (flush)
      this._flushFile(file);
  }
  _flushFile(file) {
    const buffer = this._buffers.get(file);
    if (buffer === void 0)
      return;
    const content = buffer.join("");
    this._buffers.delete(file);
    this._appendOperation({ op: "appendFile", file, content });
  }
  copyFile(from, to) {
    this._flushFile(from);
    this._buffers.delete(to);
    this._appendOperation({ op: "copyFile", from, to });
  }
  async syncAndGetError() {
    for (const file of this._buffers.keys())
      this._flushFile(file);
    await this._operationsDone;
    return this._error;
  }
  zip(entries, zipFileName) {
    for (const file of this._buffers.keys())
      this._flushFile(file);
    this._appendOperation({ op: "zip", entries, zipFileName });
  }
  // This method serializes all writes to the trace.
  _appendOperation(op) {
    const last = this._operations[this._operations.length - 1];
    if (last?.op === "appendFile" && op.op === "appendFile" && last.file === op.file) {
      last.content += op.content;
      return;
    }
    this._operations.push(op);
    if (this._operationsDone.isDone())
      this._performOperations();
  }
  async _performOperations() {
    this._operationsDone = new ManualPromise();
    while (this._operations.length) {
      const op = this._operations.shift();
      if (this._error)
        continue;
      try {
        await this._performOperation(op);
      } catch (e) {
        this._error = e;
      }
    }
    this._operationsDone.resolve();
  }
  async _performOperation(op) {
    switch (op.op) {
      case "mkdir": {
        await fs5.promises.mkdir(op.dir, { recursive: true });
        return;
      }
      case "writeFile": {
        if (op.skipIfExists)
          await fs5.promises.writeFile(op.file, op.content, { flag: "wx" }).catch(() => {
          });
        else
          await fs5.promises.writeFile(op.file, op.content);
        return;
      }
      case "copyFile": {
        await fs5.promises.copyFile(op.from, op.to);
        return;
      }
      case "appendFile": {
        await fs5.promises.appendFile(op.file, op.content);
        return;
      }
      case "zip": {
        const zipFile = new yazl2.ZipFile();
        const result = new ManualPromise();
        zipFile.on("error", (error3) => result.reject(error3));
        for (const entry of op.entries)
          zipFile.addFile(entry.value, entry.name);
        zipFile.end();
        const chunks = [];
        zipFile.outputStream.on("data", (data) => chunks.push(data)).on("close", () => {
          fs5.writeFileSync(op.zipFileName, Buffer.concat(chunks));
          result.resolve();
        }).on("error", (error3) => result.reject(error3));
        await result;
        return;
      }
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/browserFetcher.js
async function downloadBrowserWithProgressBar(title2, browserDirectory, executablePath, downloadURLs, downloadFileName, downloadSocketTimeout) {
  if (await existsAsync(browserDirectoryToMarkerFilePath(browserDirectory))) {
    debugLogger.log("install", `${title2} is already downloaded.`);
    return false;
  }
  const zipPath = path4.join(os3.tmpdir(), downloadFileName);
  try {
    const retryCount = 5;
    for (let attempt = 1; attempt <= retryCount; ++attempt) {
      debugLogger.log("install", `downloading ${title2} - attempt #${attempt}`);
      const url4 = downloadURLs[(attempt - 1) % downloadURLs.length];
      logPolitely(`Downloading ${title2}` + colors2.dim(` from ${url4}`));
      const { error: error3 } = await downloadBrowserWithProgressBarOutOfProcess(title2, browserDirectory, url4, zipPath, executablePath, downloadSocketTimeout);
      if (!error3) {
        debugLogger.log("install", `SUCCESS installing ${title2}`);
        break;
      }
      if (await existsAsync(zipPath))
        await fs6.promises.unlink(zipPath);
      if (await existsAsync(browserDirectory))
        await fs6.promises.rmdir(browserDirectory, { recursive: true });
      const errorMessage = error3?.message || "";
      debugLogger.log("install", `attempt #${attempt} - ERROR: ${errorMessage}`);
      if (attempt >= retryCount)
        throw error3;
    }
  } catch (e) {
    debugLogger.log("install", `FAILED installation ${title2} with error: ${e}`);
    process.exitCode = 1;
    throw e;
  } finally {
    if (await existsAsync(zipPath))
      await fs6.promises.unlink(zipPath);
  }
  logPolitely(`${title2} downloaded to ${browserDirectory}`);
  return true;
}
__name(downloadBrowserWithProgressBar, "downloadBrowserWithProgressBar");
function downloadBrowserWithProgressBarOutOfProcess(title2, browserDirectory, url4, zipPath, executablePath, socketTimeout) {
  const cp = fork(path4.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "oopDownloadBrowserMain.js"));
  const promise = new ManualPromise();
  const progress3 = getDownloadProgress();
  cp.on("message", (message) => {
    if (message?.method === "log")
      debugLogger.log("install", message.params.message);
    if (message?.method === "progress")
      progress3(message.params.done, message.params.total);
  });
  cp.on("exit", (code) => {
    if (code !== 0) {
      promise.resolve({ error: new Error(`Download failure, code=${code}`) });
      return;
    }
    if (!fs6.existsSync(browserDirectoryToMarkerFilePath(browserDirectory)))
      promise.resolve({ error: new Error(`Download failure, ${browserDirectoryToMarkerFilePath(browserDirectory)} does not exist`) });
    else
      promise.resolve({ error: null });
  });
  cp.on("error", (error3) => {
    promise.resolve({ error: error3 });
  });
  debugLogger.log("install", `running download:`);
  debugLogger.log("install", `-- from url: ${url4}`);
  debugLogger.log("install", `-- to location: ${zipPath}`);
  const downloadParams = {
    title: title2,
    browserDirectory,
    url: url4,
    zipPath,
    executablePath,
    socketTimeout,
    userAgent: getUserAgent()
  };
  cp.send({ method: "download", params: downloadParams });
  return promise;
}
__name(downloadBrowserWithProgressBarOutOfProcess, "downloadBrowserWithProgressBarOutOfProcess");
function logPolitely(toBeLogged) {
  const logLevel = process.env.npm_config_loglevel;
  const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
  if (!logLevelDisplay)
    console.log(toBeLogged);
}
__name(logPolitely, "logPolitely");
function getDownloadProgress() {
  if (process.stdout.isTTY)
    return getAnimatedDownloadProgress();
  return getBasicDownloadProgress();
}
__name(getDownloadProgress, "getDownloadProgress");
function getAnimatedDownloadProgress() {
  let progressBar;
  let lastDownloadedBytes = 0;
  return (downloadedBytes, totalBytes) => {
    if (!progressBar) {
      progressBar = new progress2(
        `${toMegabytes(
          totalBytes
        )} [:bar] :percent :etas`,
        {
          complete: "=",
          incomplete: " ",
          width: 20,
          total: totalBytes
        }
      );
    }
    const delta = downloadedBytes - lastDownloadedBytes;
    lastDownloadedBytes = downloadedBytes;
    progressBar.tick(delta);
  };
}
__name(getAnimatedDownloadProgress, "getAnimatedDownloadProgress");
function getBasicDownloadProgress() {
  const totalRows = 10;
  const stepWidth = 8;
  let lastRow = -1;
  return (downloadedBytes, totalBytes) => {
    const percentage = downloadedBytes / totalBytes;
    const row = Math.floor(totalRows * percentage);
    if (row > lastRow) {
      lastRow = row;
      const percentageString = String(percentage * 100 | 0).padStart(3);
      console.log(`|${"\u25A0".repeat(row * stepWidth)}${" ".repeat((totalRows - row) * stepWidth)}| ${percentageString}% of ${toMegabytes(totalBytes)}`);
    }
  };
}
__name(getBasicDownloadProgress, "getBasicDownloadProgress");
function toMegabytes(bytes) {
  const mb = bytes / 1024 / 1024;
  return `${Math.round(mb * 10) / 10} MiB`;
}
__name(toMegabytes, "toMegabytes");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/dependencies.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs7 from "node:fs";
import os5 from "node:os";
import path5 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/nativeDeps.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var deps = {
  "ubuntu20.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "ttf-unifont",
      "libfontconfig",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "ttf-ubuntu-font-family"
    ],
    chromium: [
      "fonts-liberation",
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libgbm1",
      "libglib2.0-0",
      "libgtk-3-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxrandr2",
      "libxshmfence1"
    ],
    firefox: [
      "ffmpeg",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libpangoft2-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrender1",
      "libxt6",
      "libxtst6"
    ],
    webkit: [
      "libenchant-2-2",
      "libflite1",
      "libx264-155",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libegl1",
      "libenchant1c2a",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf2.0-0",
      "libgl1",
      "libgles2",
      "libglib2.0-0",
      "libgtk-3-0",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu66",
      "libjpeg-turbo8",
      "libnghttp2-14",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libsecret-1-0",
      "libvpx6",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp6",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7"
    ],
    lib2package: {
      "libflite.so.1": "libflite1",
      "libflite_usenglish.so.1": "libflite1",
      "libflite_cmu_grapheme_lang.so.1": "libflite1",
      "libflite_cmu_grapheme_lex.so.1": "libflite1",
      "libflite_cmu_indic_lang.so.1": "libflite1",
      "libflite_cmu_indic_lex.so.1": "libflite1",
      "libflite_cmulex.so.1": "libflite1",
      "libflite_cmu_time_awb.so.1": "libflite1",
      "libflite_cmu_us_awb.so.1": "libflite1",
      "libflite_cmu_us_kal16.so.1": "libflite1",
      "libflite_cmu_us_kal.so.1": "libflite1",
      "libflite_cmu_us_rms.so.1": "libflite1",
      "libflite_cmu_us_slt.so.1": "libflite1",
      "libx264.so": "libx264-155",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant.so.1": "libenchant1c2a",
      "libevdev.so.2": "libevdev2",
      "libepoxy.so.0": "libepoxy0",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgdk-x11-2.0.so.0": "libgtk2.0-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGL.so.1": "libgl1",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgthread-2.0.so.0": "libglib2.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-x11-2.0.so.0": "libgtk2.0-0",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicui18n.so.66": "libicu66",
      "libicuuc.so.66": "libicu66",
      "libjpeg.so.8": "libjpeg-turbo8",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libvpx.so.6": "libvpx6",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-dri3.so.0": "libxcb-dri3-0",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXt.so.6": "libxt6",
      "libXtst.so.6": "libxtst6",
      "libxshmfence.so.1": "libxshmfence1",
      "libatomic.so.1": "libatomic1",
      "libenchant-2.so.2": "libenchant-2-2",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "ubuntu22.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libwayland-client0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "ffmpeg",
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "libsoup-3.0-0",
      "libenchant-2-2",
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libicu70",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libepoxy0",
      "libevdev2",
      "libffi7",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libjpeg-turbo8",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libx264-163",
      "libatomic1",
      "libevent-2.1-7",
      "libavif13"
    ],
    lib2package: {
      "libavif.so.13": "libavif13",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libepoxy.so.0": "libepoxy0",
      "libevdev.so.2": "libevdev2",
      "libffi.so.7": "libffi7",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libGLX.so.0": "libglx0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgtk-4.so.1": "libgtk-4-1",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libjpeg.so.8": "libjpeg-turbo8",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libproxy.so.1": "libproxy1v5",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXtst.so.6": "libxtst6",
      "libicui18n.so.60": "libicu70",
      "libicuuc.so.66": "libicu70",
      "libicui18n.so.66": "libicu70",
      "libwebp.so.6": "libwebp6",
      "libenchant-2.so.2": "libenchant-2-2",
      "libx264.so": "libx264-163",
      "libvpx.so.7": "libvpx7",
      "libatomic.so.1": "libatomic1",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "ubuntu24.04-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2t64",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libatspi2.0-0t64",
      "libcairo2",
      "libcups2t64",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0t64",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2t64",
      "libatk1.0-0t64",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0t64",
      "libgtk-3-0t64",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1"
    ],
    webkit: [
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libicu74",
      "libatomic1",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libenchant-2-2",
      "libepoxy0",
      "libevent-2.1-7t64",
      "libflite1",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0t64",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-bad1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu74",
      "libjpeg-turbo8",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libopus0",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libpng16-16t64",
      "libsecret-1-0",
      "libvpx9",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp7",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libx264-164",
      "libavif16"
    ],
    lib2package: {
      "libavif.so.16": "libavif16",
      "libasound.so.2": "libasound2t64",
      "libatk-1.0.so.0": "libatk1.0-0t64",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0t64",
      "libatomic.so.1": "libatomic1",
      "libatspi.so.0": "libatspi2.0-0t64",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2t64",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdrm.so.2": "libdrm2",
      "libenchant-2.so.2": "libenchant-2-2",
      "libepoxy.so.0": "libepoxy0",
      "libevent-2.1.so.7": "libevent-2.1-7t64",
      "libflite_cmu_grapheme_lang.so.1": "libflite1",
      "libflite_cmu_grapheme_lex.so.1": "libflite1",
      "libflite_cmu_indic_lang.so.1": "libflite1",
      "libflite_cmu_indic_lex.so.1": "libflite1",
      "libflite_cmu_time_awb.so.1": "libflite1",
      "libflite_cmu_us_awb.so.1": "libflite1",
      "libflite_cmu_us_kal.so.1": "libflite1",
      "libflite_cmu_us_kal16.so.1": "libflite1",
      "libflite_cmu_us_rms.so.1": "libflite1",
      "libflite_cmu_us_slt.so.1": "libflite1",
      "libflite_cmulex.so.1": "libflite1",
      "libflite_usenglish.so.1": "libflite1",
      "libflite.so.1": "libflite1",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0t64",
      "libgio-2.0.so.0": "libglib2.0-0t64",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0t64",
      "libgmodule-2.0.so.0": "libglib2.0-0t64",
      "libgobject-2.0.so.0": "libglib2.0-0t64",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstcodecparsers-1.0.so.0": "libgstreamer-plugins-bad1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0t64",
      "libgtk-4.so.1": "libgtk-4-1",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicudata.so.74": "libicu74",
      "libicui18n.so.74": "libicu74",
      "libicuuc.so.74": "libicu74",
      "libjpeg.so.8": "libjpeg-turbo8",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16t64",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libvpx.so.9": "libvpx9",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.7": "libwebp7",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libx264.so": "libx264-164"
    }
  },
  "debian11-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-cyrillic",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libwayland-client0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libharfbuzz0b",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libenchant-2-2",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-3-0",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu67",
      "libjpeg62-turbo",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnghttp2-14",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp6",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7"
    ],
    lib2package: {
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo-gobject.so.2": "libcairo-gobject2",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdbus-glib-1.so.2": "libdbus-glib-1-2",
      "libdrm.so.2": "libdrm2",
      "libEGL.so.1": "libegl1",
      "libenchant-2.so.2": "libenchant-2-2",
      "libepoxy.so.0": "libepoxy0",
      "libevdev.so.2": "libevdev2",
      "libfontconfig.so.1": "libfontconfig1",
      "libfreetype.so.6": "libfreetype6",
      "libgbm.so.1": "libgbm1",
      "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
      "libgdk-3.so.0": "libgtk-3-0",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libGLESv2.so.2": "libgles2",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libGLX.so.0": "libglx0",
      "libgmodule-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstbase-1.0.so.0": "libgstreamer1.0-0",
      "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
      "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
      "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
      "libgtk-3.so.0": "libgtk-3-0",
      "libgudev-1.0.so.0": "libgudev-1.0-0",
      "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
      "libharfbuzz.so.0": "libharfbuzz0b",
      "libhyphen.so.0": "libhyphen0",
      "libicui18n.so.67": "libicu67",
      "libicuuc.so.67": "libicu67",
      "libjpeg.so.62": "libjpeg62-turbo",
      "liblcms2.so.2": "liblcms2-2",
      "libmanette-0.2.so.0": "libmanette-0.2-0",
      "libnotify.so.4": "libnotify4",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libOpenGL.so.0": "libopengl0",
      "libopenjp2.so.7": "libopenjp2-7",
      "libopus.so.0": "libopus0",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
      "libpng16.so.16": "libpng16-16",
      "libproxy.so.1": "libproxy1v5",
      "libsecret-1.so.0": "libsecret-1-0",
      "libsmime3.so": "libnss3",
      "libwayland-client.so.0": "libwayland-client0",
      "libwayland-egl.so.1": "libwayland-egl1",
      "libwayland-server.so.0": "libwayland-server0",
      "libwebp.so.6": "libwebp6",
      "libwebpdemux.so.2": "libwebpdemux2",
      "libwoff2dec.so.1.0.2": "libwoff1",
      "libX11-xcb.so.1": "libx11-xcb1",
      "libX11.so.6": "libx11-6",
      "libxcb-shm.so.0": "libxcb-shm0",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXcursor.so.1": "libxcursor1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libXi.so.6": "libxi6",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libxml2.so.2": "libxml2",
      "libXrandr.so.2": "libxrandr2",
      "libXrender.so.1": "libxrender1",
      "libxslt.so.1": "libxslt1.1",
      "libXtst.so.6": "libxtst6",
      "libatomic.so.1": "libatomic1",
      "libevent-2.1.so.7": "libevent-2.1-7"
    }
  },
  "debian12-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libatspi2.0-0",
      "libcairo2",
      "libcups2",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2",
      "libatk1.0-0",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0",
      "libgtk-3-0",
      "libharfbuzz0b",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "libsoup-3.0-0",
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libatk-bridge2.0-0",
      "libatk1.0-0",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libenchant-2-2",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu72",
      "libjpeg62-turbo",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp7",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7",
      "libavif15"
    ],
    lib2package: {
      "libavif.so.15": "libavif15",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libasound.so.2": "libasound2",
      "libatk-1.0.so.0": "libatk1.0-0",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
      "libatspi.so.0": "libatspi2.0-0",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdrm.so.2": "libdrm2",
      "libgbm.so.1": "libgbm1",
      "libgio-2.0.so.0": "libglib2.0-0",
      "libglib-2.0.so.0": "libglib2.0-0",
      "libgobject-2.0.so.0": "libglib2.0-0",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libsmime3.so": "libnss3",
      "libX11.so.6": "libx11-6",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libXrandr.so.2": "libxrandr2",
      "libgtk-4.so.1": "libgtk-4-1"
    }
  },
  "debian13-x64": {
    tools: [
      "xvfb",
      "fonts-noto-color-emoji",
      "fonts-unifont",
      "libfontconfig1",
      "libfreetype6",
      "xfonts-scalable",
      "fonts-liberation",
      "fonts-ipafont-gothic",
      "fonts-wqy-zenhei",
      "fonts-tlwg-loma-otf",
      "fonts-freefont-ttf"
    ],
    chromium: [
      "libasound2t64",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libatspi2.0-0t64",
      "libcairo2",
      "libcups2t64",
      "libdbus-1-3",
      "libdrm2",
      "libgbm1",
      "libglib2.0-0t64",
      "libnspr4",
      "libnss3",
      "libpango-1.0-0",
      "libx11-6",
      "libxcb1",
      "libxcomposite1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxkbcommon0",
      "libxrandr2"
    ],
    firefox: [
      "libasound2",
      "libatk1.0-0t64",
      "libcairo-gobject2",
      "libcairo2",
      "libdbus-1-3",
      "libdbus-glib-1-2",
      "libfontconfig1",
      "libfreetype6",
      "libgdk-pixbuf-2.0-0",
      "libglib2.0-0t64",
      "libgtk-3-0t64",
      "libharfbuzz0b",
      "libpango-1.0-0",
      "libpangocairo-1.0-0",
      "libx11-6",
      "libx11-xcb1",
      "libxcb-shm0",
      "libxcb1",
      "libxcomposite1",
      "libxcursor1",
      "libxdamage1",
      "libxext6",
      "libxfixes3",
      "libxi6",
      "libxrandr2",
      "libxrender1",
      "libxtst6"
    ],
    webkit: [
      "libsoup-3.0-0",
      "gstreamer1.0-libav",
      "gstreamer1.0-plugins-bad",
      "gstreamer1.0-plugins-base",
      "gstreamer1.0-plugins-good",
      "libatk-bridge2.0-0t64",
      "libatk1.0-0t64",
      "libcairo2",
      "libdbus-1-3",
      "libdrm2",
      "libegl1",
      "libenchant-2-2",
      "libepoxy0",
      "libevdev2",
      "libfontconfig1",
      "libfreetype6",
      "libgbm1",
      "libgdk-pixbuf-2.0-0",
      "libgles2",
      "libglib2.0-0t64",
      "libglx0",
      "libgstreamer-gl1.0-0",
      "libgstreamer-plugins-base1.0-0",
      "libgstreamer1.0-0",
      "libgtk-4-1",
      "libgudev-1.0-0",
      "libharfbuzz-icu0",
      "libharfbuzz0b",
      "libhyphen0",
      "libicu76",
      "libjpeg62-turbo",
      "liblcms2-2",
      "libmanette-0.2-0",
      "libnotify4",
      "libopengl0",
      "libopenjp2-7",
      "libopus0",
      "libpango-1.0-0",
      "libpng16-16t64",
      "libproxy1v5",
      "libsecret-1-0",
      "libwayland-client0",
      "libwayland-egl1",
      "libwayland-server0",
      "libwebp7",
      "libwebpdemux2",
      "libwoff1",
      "libx11-6",
      "libxcomposite1",
      "libxdamage1",
      "libxkbcommon0",
      "libxml2",
      "libxslt1.1",
      "libatomic1",
      "libevent-2.1-7t64",
      "libavif16"
    ],
    lib2package: {
      "libicudata.so.74": "libicu76",
      "libicui18n.so.74": "libicu76",
      "libicuuc.so.74": "libicu76",
      "libevent-2.1.so.7": "libevent-2.1-7t64",
      "libpng16.so.16": "libpng16-16t64",
      "libgdk-3.so.0": "libgtk-3-0t64",
      "libgtk-3.so.0": "libgtk-3-0t64",
      "libavif.so.16": "libavif16",
      "libsoup-3.0.so.0": "libsoup-3.0-0",
      "libasound.so.2": "libasound2t64",
      "libatk-1.0.so.0": "libatk1.0-0t64",
      "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0t64",
      "libatspi.so.0": "libatspi2.0-0t64",
      "libcairo.so.2": "libcairo2",
      "libcups.so.2": "libcups2t64",
      "libdbus-1.so.3": "libdbus-1-3",
      "libdrm.so.2": "libdrm2",
      "libgbm.so.1": "libgbm1",
      "libgio-2.0.so.0": "libglib2.0-0t64",
      "libglib-2.0.so.0": "libglib2.0-0t64",
      "libgobject-2.0.so.0": "libglib2.0-0t64",
      "libnspr4.so": "libnspr4",
      "libnss3.so": "libnss3",
      "libnssutil3.so": "libnss3",
      "libpango-1.0.so.0": "libpango-1.0-0",
      "libsmime3.so": "libnss3",
      "libX11.so.6": "libx11-6",
      "libxcb.so.1": "libxcb1",
      "libXcomposite.so.1": "libxcomposite1",
      "libXdamage.so.1": "libxdamage1",
      "libXext.so.6": "libxext6",
      "libXfixes.so.3": "libxfixes3",
      "libxkbcommon.so.0": "libxkbcommon0",
      "libXrandr.so.2": "libxrandr2",
      "libgtk-4.so.1": "libgtk-4-1"
    }
  }
};
deps["ubuntu20.04-arm64"] = {
  tools: [...deps["ubuntu20.04-x64"].tools],
  chromium: [...deps["ubuntu20.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu20.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu20.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu20.04-x64"].lib2package
  }
};
deps["ubuntu22.04-arm64"] = {
  tools: [...deps["ubuntu22.04-x64"].tools],
  chromium: [...deps["ubuntu22.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu22.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu22.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu22.04-x64"].lib2package
  }
};
deps["ubuntu24.04-arm64"] = {
  tools: [...deps["ubuntu24.04-x64"].tools],
  chromium: [...deps["ubuntu24.04-x64"].chromium],
  firefox: [
    ...deps["ubuntu24.04-x64"].firefox
  ],
  webkit: [
    ...deps["ubuntu24.04-x64"].webkit
  ],
  lib2package: {
    ...deps["ubuntu24.04-x64"].lib2package
  }
};
deps["debian11-arm64"] = {
  tools: [...deps["debian11-x64"].tools],
  chromium: [...deps["debian11-x64"].chromium],
  firefox: [
    ...deps["debian11-x64"].firefox
  ],
  webkit: [
    ...deps["debian11-x64"].webkit
  ],
  lib2package: {
    ...deps["debian11-x64"].lib2package
  }
};
deps["debian12-arm64"] = {
  tools: [...deps["debian12-x64"].tools],
  chromium: [...deps["debian12-x64"].chromium],
  firefox: [
    ...deps["debian12-x64"].firefox
  ],
  webkit: [
    ...deps["debian12-x64"].webkit
  ],
  lib2package: {
    ...deps["debian12-x64"].lib2package
  }
};
deps["debian13-arm64"] = {
  tools: [...deps["debian13-x64"].tools],
  chromium: [...deps["debian13-x64"].chromium],
  firefox: [
    ...deps["debian13-x64"].firefox
  ],
  webkit: [
    ...deps["debian13-x64"].webkit
  ],
  lib2package: {
    ...deps["debian13-x64"].lib2package
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/ascii.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function wrapInASCIIBox(text, padding = 0) {
  const lines = text.split("\n");
  const maxLength = Math.max(...lines.map((line) => line.length));
  return [
    "\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557",
    ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"),
    "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"
  ].join("\n");
}
__name(wrapInASCIIBox, "wrapInASCIIBox");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/hostPlatform.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import os4 from "node:os";
function calculatePlatform() {
  if (process.env.PLAYWRIGHT_HOST_PLATFORM_OVERRIDE) {
    return {
      hostPlatform: process.env.PLAYWRIGHT_HOST_PLATFORM_OVERRIDE,
      isOfficiallySupportedPlatform: false
    };
  }
  const platform2 = os4.platform();
  if (platform2 === "darwin") {
    const ver = os4.release().split(".").map((a) => parseInt(a, 10));
    let macVersion = "";
    if (ver[0] < 18) {
      macVersion = "mac10.13";
    } else if (ver[0] === 18) {
      macVersion = "mac10.14";
    } else if (ver[0] === 19) {
      macVersion = "mac10.15";
    } else {
      const LAST_STABLE_MACOS_MAJOR_VERSION = 15;
      macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MACOS_MAJOR_VERSION);
      if (os4.cpus().some((cpu) => cpu.model.includes("Apple")))
        macVersion += "-arm64";
    }
    return { hostPlatform: macVersion, isOfficiallySupportedPlatform: true };
  }
  if (platform2 === "linux") {
    if (!["x64", "arm64"].includes(os4.arch()))
      return { hostPlatform: "<unknown>", isOfficiallySupportedPlatform: false };
    const archSuffix = "-" + os4.arch();
    const distroInfo = getLinuxDistributionInfoSync();
    if (distroInfo?.id === "ubuntu" || distroInfo?.id === "pop" || distroInfo?.id === "neon" || distroInfo?.id === "tuxedo") {
      const isUbuntu = distroInfo?.id === "ubuntu";
      const version6 = distroInfo?.version;
      const major = parseInt(distroInfo.version, 10);
      if (major < 20)
        return { hostPlatform: "ubuntu18.04" + archSuffix, isOfficiallySupportedPlatform: false };
      if (major < 22)
        return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "20.04" };
      if (major < 24)
        return { hostPlatform: "ubuntu22.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "22.04" };
      if (major < 26)
        return { hostPlatform: "ubuntu24.04" + archSuffix, isOfficiallySupportedPlatform: isUbuntu && version6 === "24.04" };
      return { hostPlatform: "ubuntu" + distroInfo.version + archSuffix, isOfficiallySupportedPlatform: false };
    }
    if (distroInfo?.id === "linuxmint") {
      const mintMajor = parseInt(distroInfo.version, 10);
      if (mintMajor <= 20)
        return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: false };
      if (mintMajor === 21)
        return { hostPlatform: "ubuntu22.04" + archSuffix, isOfficiallySupportedPlatform: false };
      return { hostPlatform: "ubuntu24.04" + archSuffix, isOfficiallySupportedPlatform: false };
    }
    if (distroInfo?.id === "debian" || distroInfo?.id === "raspbian") {
      const isOfficiallySupportedPlatform2 = distroInfo?.id === "debian";
      if (distroInfo?.version === "11")
        return { hostPlatform: "debian11" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
      if (distroInfo?.version === "12")
        return { hostPlatform: "debian12" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
      if (distroInfo?.version === "13")
        return { hostPlatform: "debian13" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
      if (distroInfo?.version === "")
        return { hostPlatform: "debian13" + archSuffix, isOfficiallySupportedPlatform: isOfficiallySupportedPlatform2 };
    }
    return { hostPlatform: "ubuntu20.04" + archSuffix, isOfficiallySupportedPlatform: false };
  }
  if (platform2 === "win32")
    return { hostPlatform: "win64", isOfficiallySupportedPlatform: true };
  return { hostPlatform: "<unknown>", isOfficiallySupportedPlatform: false };
}
__name(calculatePlatform, "calculatePlatform");
var { hostPlatform, isOfficiallySupportedPlatform } = calculatePlatform();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/spawnAsync.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function spawnAsync(cmd, args, options2 = {}) {
  const process2 = spawn(cmd, args, Object.assign({ windowsHide: true }, options2));
  return new Promise((resolve) => {
    let stdout2 = "";
    let stderr2 = "";
    if (process2.stdout)
      process2.stdout.on("data", (data) => stdout2 += data.toString());
    if (process2.stderr)
      process2.stderr.on("data", (data) => stderr2 += data.toString());
    process2.on("close", (code) => resolve({ stdout: stdout2, stderr: stderr2, code }));
    process2.on("error", (error3) => resolve({ stdout: stdout2, stderr: stderr2, code: 0, error: error3 }));
  });
}
__name(spawnAsync, "spawnAsync");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/dependencies.js
var BIN_DIRECTORY = path5.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", "bin");
var languageBindingVersion = process.env.PW_CLI_DISPLAY_VERSION || require$$04.version;
var dockerVersionFilePath = "/ms-playwright/.docker-info";
function dockerVersion(dockerImageNameTemplate) {
  return {
    driverVersion: languageBindingVersion,
    dockerImageName: dockerImageNameTemplate.replace("%version%", languageBindingVersion)
  };
}
__name(dockerVersion, "dockerVersion");
function readDockerVersionSync() {
  try {
    const data = JSON.parse(fs7.readFileSync(dockerVersionFilePath, "utf8"));
    return {
      ...data,
      dockerImageNameTemplate: data.dockerImageName.replace(data.driverVersion, "%version%")
    };
  } catch (e) {
    return null;
  }
}
__name(readDockerVersionSync, "readDockerVersionSync");
var checkExecutable = /* @__PURE__ */ __name((filePath) => {
  if (process.platform === "win32")
    return filePath.endsWith(".exe");
  return fs7.promises.access(filePath, fs7.constants.X_OK).then(() => true).catch(() => false);
}, "checkExecutable");
function isSupportedWindowsVersion() {
  if (os5.platform() !== "win32" || os5.arch() !== "x64")
    return false;
  const [major, minor] = os5.release().split(".").map((token) => parseInt(token, 10));
  return major > 6 || major === 6 && minor > 1;
}
__name(isSupportedWindowsVersion, "isSupportedWindowsVersion");
async function installDependenciesWindows(targets, dryRun) {
  if (targets.has("chromium")) {
    const command = "powershell.exe";
    const args = ["-ExecutionPolicy", "Bypass", "-File", path5.join(BIN_DIRECTORY, "install_media_pack.ps1")];
    if (dryRun) {
      console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
      return;
    }
    const { code } = await spawnAsync(command, args, { cwd: BIN_DIRECTORY, stdio: "inherit" });
    if (code !== 0)
      throw new Error("Failed to install windows dependencies!");
  }
}
__name(installDependenciesWindows, "installDependenciesWindows");
async function installDependenciesLinux(targets, dryRun) {
  const libraries = [];
  const platform2 = hostPlatform;
  if (!isOfficiallySupportedPlatform)
    console.warn(`BEWARE: your OS is not officially supported by Playwright; installing dependencies for ${platform2} as a fallback.`);
  for (const target of targets) {
    const info3 = deps[platform2];
    if (!info3) {
      console.warn(`Cannot install dependencies for ${platform2} with Playwright ${getPlaywrightVersion()}!`);
      return;
    }
    libraries.push(...info3[target]);
  }
  const uniqueLibraries = Array.from(new Set(libraries));
  if (!dryRun)
    console.log(`Installing dependencies...`);
  const commands = [];
  commands.push("apt-get update");
  commands.push([
    "apt-get",
    "install",
    "-y",
    "--no-install-recommends",
    ...uniqueLibraries
  ].join(" "));
  const { command, args, elevatedPermissions } = await transformCommandsForRoot(commands);
  if (dryRun) {
    console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
    return;
  }
  if (elevatedPermissions)
    console.log("Switching to root user to install dependencies...");
  const child = spawn(command, args, { stdio: "inherit" });
  await new Promise((resolve, reject) => {
    child.on("exit", (code) => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));
    child.on("error", reject);
  });
}
__name(installDependenciesLinux, "installDependenciesLinux");
async function validateDependenciesWindows(sdkLanguage, windowsExeAndDllDirectories) {
  const directoryPaths = windowsExeAndDllDirectories;
  const lddPaths = [];
  for (const directoryPath of directoryPaths)
    lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
  const allMissingDeps = await Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(sdkLanguage, lddPath)));
  const missingDeps = /* @__PURE__ */ new Set();
  for (const deps2 of allMissingDeps) {
    for (const dep of deps2)
      missingDeps.add(dep);
  }
  if (!missingDeps.size)
    return;
  let isCrtMissing = false;
  let isMediaFoundationMissing = false;
  for (const dep of missingDeps) {
    if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
      isCrtMissing = true;
    else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
      isMediaFoundationMissing = true;
  }
  const details = [];
  if (isCrtMissing) {
    details.push(
      `Some of the Universal C Runtime files cannot be found on the system. You can fix`,
      `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`,
      `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`,
      ``
    );
  }
  if (isMediaFoundationMissing) {
    details.push(
      `Some of the Media Foundation files cannot be found on the system. If you are`,
      `on Windows Server try fixing this by running the following command in PowerShell`,
      `as Administrator:`,
      ``,
      `    Install-WindowsFeature Server-Media-Foundation`,
      ``,
      `For Windows N editions visit:`,
      `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`,
      ``
    );
  }
  details.push(
    `Full list of missing libraries:`,
    `    ${[...missingDeps].join("\n    ")}`,
    ``
  );
  const message = `Host system is missing dependencies!

${details.join("\n")}`;
  if (isSupportedWindowsVersion()) {
    throw new Error(message);
  } else {
    console.warn(`WARNING: running on unsupported windows version!`);
    console.warn(message);
  }
}
__name(validateDependenciesWindows, "validateDependenciesWindows");
async function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
  const directoryPaths = linuxLddDirectories;
  const lddPaths = [];
  for (const directoryPath of directoryPaths)
    lddPaths.push(...await executablesOrSharedLibraries(directoryPath));
  const missingDepsPerFile = await Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
  const missingDeps = /* @__PURE__ */ new Set();
  for (const deps2 of missingDepsPerFile) {
    for (const dep of deps2)
      missingDeps.add(dep);
  }
  for (const dep of await missingDLOPENLibraries(dlOpenLibraries))
    missingDeps.add(dep);
  if (!missingDeps.size)
    return;
  const allMissingDeps = new Set(missingDeps);
  const missingPackages = /* @__PURE__ */ new Set();
  const libraryToPackageNameMapping = deps[hostPlatform] ? {
    ...deps[hostPlatform]?.lib2package || {},
    ...MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU
  } : {};
  for (const missingDep of missingDeps) {
    const packageName = libraryToPackageNameMapping[missingDep];
    if (packageName) {
      missingPackages.add(packageName);
      missingDeps.delete(missingDep);
    }
  }
  const maybeSudo = process.getuid?.() && os5.platform() !== "win32" ? "sudo " : "";
  const dockerInfo = readDockerVersionSync();
  const errorLines = [
    `Host system is missing dependencies to run browsers.`
  ];
  if (dockerInfo && !dockerInfo.driverVersion.startsWith(getPlaywrightVersion(
    true
    /* majorMinorOnly */
  ) + ".")) {
    const pwVersion = getPlaywrightVersion();
    const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);
    errorLines.push(...[
      `This is most likely due to Docker image version not matching Playwright version:`,
      `- Playwright  : ${pwVersion}`,
      `- Docker image: ${dockerInfo.driverVersion}`,
      ``,
      `Either:`,
      `- (recommended) use Docker image "${requiredDockerImage}"`,
      `- (alternative 1) run the following command inside Docker to install missing dependencies:`,
      ``,
      `    ${maybeSudo}${buildPlaywrightCLICommand(sdkLanguage, "install-deps")}`,
      ``,
      `- (alternative 2) use apt inside Docker:`,
      ``,
      `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`,
      ``,
      `<3 Playwright Team`
    ]);
  } else if (missingPackages.size && !missingDeps.size) {
    errorLines.push(...[
      `Please install them with the following command:`,
      ``,
      `    ${maybeSudo}${buildPlaywrightCLICommand(sdkLanguage, "install-deps")}`,
      ``,
      `Alternatively, use apt:`,
      `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`,
      ``,
      `<3 Playwright Team`
    ]);
  } else {
    errorLines.push(...[
      `Missing libraries:`,
      ...[...allMissingDeps].map((dep) => "    " + dep)
    ]);
  }
  throw new Error("\n" + wrapInASCIIBox(errorLines.join("\n"), 1));
}
__name(validateDependenciesLinux, "validateDependenciesLinux");
function isSharedLib(basename) {
  switch (os5.platform()) {
    case "linux":
      return basename.endsWith(".so") || basename.includes(".so.");
    case "win32":
      return basename.endsWith(".dll");
    default:
      return false;
  }
}
__name(isSharedLib, "isSharedLib");
async function executablesOrSharedLibraries(directoryPath) {
  if (!fs7.existsSync(directoryPath))
    return [];
  const allPaths = (await fs7.promises.readdir(directoryPath)).map((file) => path5.resolve(directoryPath, file));
  const allStats = await Promise.all(allPaths.map((aPath) => fs7.promises.stat(aPath)));
  const filePaths = allPaths.filter((aPath, index2) => allStats[index2].isFile());
  const executablersOrLibraries = (await Promise.all(filePaths.map(async (filePath) => {
    const basename = path5.basename(filePath).toLowerCase();
    if (isSharedLib(basename))
      return filePath;
    if (await checkExecutable(filePath))
      return filePath;
    return false;
  }))).filter(Boolean);
  return executablersOrLibraries;
}
__name(executablesOrSharedLibraries, "executablesOrSharedLibraries");
async function missingFileDependenciesWindows(sdkLanguage, filePath) {
  const executable = registry.findExecutable("winldd").executablePathOrDie(sdkLanguage);
  const dirname = path5.dirname(filePath);
  const { stdout: stdout2, code } = await spawnAsync(executable, [filePath], {
    cwd: dirname,
    env: {
      ...process.env,
      LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
    }
  });
  if (code !== 0)
    return [];
  const missingDeps = stdout2.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
  return missingDeps;
}
__name(missingFileDependenciesWindows, "missingFileDependenciesWindows");
async function missingFileDependencies(filePath, extraLDPaths) {
  const dirname = path5.dirname(filePath);
  let LD_LIBRARY_PATH = extraLDPaths.join(":");
  if (process.env.LD_LIBRARY_PATH)
    LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
  const { stdout: stdout2, code } = await spawnAsync("ldd", [filePath], {
    cwd: dirname,
    env: {
      ...process.env,
      LD_LIBRARY_PATH
    }
  });
  if (code !== 0)
    return [];
  const missingDeps = stdout2.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
  return missingDeps;
}
__name(missingFileDependencies, "missingFileDependencies");
async function missingDLOPENLibraries(libraries) {
  if (!libraries.length)
    return [];
  const { stdout: stdout2, code, error: error3 } = await spawnAsync("/sbin/ldconfig", ["-p"], {});
  if (code !== 0 || error3)
    return [];
  const isLibraryAvailable = /* @__PURE__ */ __name((library) => stdout2.toLowerCase().includes(library.toLowerCase()), "isLibraryAvailable");
  return libraries.filter((library) => !isLibraryAvailable(library));
}
__name(missingDLOPENLibraries, "missingDLOPENLibraries");
var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
  // libgstlibav.so (the only actual library provided by gstreamer1.0-libav) is not
  // in the ldconfig cache, so we detect the actual library required for playing h.264
  // and if it's missing recommend installing missing gstreamer lib.
  // gstreamer1.0-libav -> libavcodec57 -> libx264-152
  "libx264.so": "gstreamer1.0-libav"
};
function quoteProcessArgs(args) {
  return args.map((arg) => {
    if (arg.includes(" "))
      return `"${arg}"`;
    return arg;
  });
}
__name(quoteProcessArgs, "quoteProcessArgs");
async function transformCommandsForRoot(commands) {
  const isRoot = process.getuid?.() === 0;
  if (isRoot)
    return { command: "sh", args: ["-c", `${commands.join("&& ")}`], elevatedPermissions: false };
  const sudoExists = await spawnAsync("which", ["sudo"]);
  if (sudoExists.code === 0)
    return { command: "sudo", args: ["--", "sh", "-c", `${commands.join("&& ")}`], elevatedPermissions: true };
  return { command: "su", args: ["root", "-c", `${commands.join("&& ")}`], elevatedPermissions: true };
}
__name(transformCommandsForRoot, "transformCommandsForRoot");

// node_modules/@cloudflare/playwright/lib/_virtual/pixelmatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/third_party/pixelmatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var pixelmatch_1;
var hasRequiredPixelmatch;
function requirePixelmatch() {
  if (hasRequiredPixelmatch) return pixelmatch_1;
  hasRequiredPixelmatch = 1;
  pixelmatch_1 = pixelmatch2;
  const defaultOptions = {
    threshold: 0.1,
    // matching threshold (0 to 1); smaller is more sensitive
    includeAA: false,
    // whether to skip anti-aliasing detection
    alpha: 0.1,
    // opacity of original image in diff output
    aaColor: [255, 255, 0],
    // color of anti-aliased pixels in diff output
    diffColor: [255, 0, 0],
    // color of different pixels in diff output
    diffColorAlt: null,
    // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two
    diffMask: false
    // draw the diff over a transparent background (a mask)
  };
  function pixelmatch2(img1, img2, output, width, height, options2) {
    if (!isPixelData(img1) || !isPixelData(img2) || output && !isPixelData(output))
      throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
    if (img1.length !== img2.length || output && output.length !== img1.length)
      throw new Error("Image sizes do not match.");
    if (img1.length !== width * height * 4) throw new Error("Image data size does not match width/height.");
    options2 = Object.assign({}, defaultOptions, options2);
    const len = width * height;
    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
    let identical = true;
    for (let i = 0; i < len; i++) {
      if (a32[i] !== b32[i]) {
        identical = false;
        break;
      }
    }
    if (identical) {
      if (output && !options2.diffMask) {
        for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options2.alpha, output);
      }
      return 0;
    }
    const maxDelta = 35215 * options2.threshold * options2.threshold;
    let diff4 = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const pos = (y * width + x) * 4;
        const delta = colorDelta(img1, img2, pos, pos);
        if (Math.abs(delta) > maxDelta) {
          if (!options2.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
            if (output && !options2.diffMask) drawPixel2(output, pos, ...options2.aaColor);
          } else {
            if (output) {
              drawPixel2(output, pos, ...delta < 0 && options2.diffColorAlt || options2.diffColor);
            }
            diff4++;
          }
        } else if (output) {
          if (!options2.diffMask) drawGrayPixel(img1, pos, options2.alpha, output);
        }
      }
    }
    return diff4;
  }
  __name(pixelmatch2, "pixelmatch");
  function isPixelData(arr) {
    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
  }
  __name(isPixelData, "isPixelData");
  function antialiased(img, x1, y1, width, height, img2) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    let min = 0;
    let max = 0;
    let minX, minY, maxX, maxY;
    for (let x = x0; x <= x2; x++) {
      for (let y = y0; y <= y2; y++) {
        if (x === x1 && y === y1) continue;
        const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
        if (delta === 0) {
          zeroes++;
          if (zeroes > 2) return false;
        } else if (delta < min) {
          min = delta;
          minX = x;
          minY = y;
        } else if (delta > max) {
          max = delta;
          maxX = x;
          maxY = y;
        }
      }
    }
    if (min === 0 || max === 0) return false;
    return hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height) || hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height);
  }
  __name(antialiased, "antialiased");
  function hasManySiblings(img, x1, y1, width, height) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    for (let x = x0; x <= x2; x++) {
      for (let y = y0; y <= y2; y++) {
        if (x === x1 && y === y1) continue;
        const pos2 = (y * width + x) * 4;
        if (img[pos] === img[pos2] && img[pos + 1] === img[pos2 + 1] && img[pos + 2] === img[pos2 + 2] && img[pos + 3] === img[pos2 + 3]) zeroes++;
        if (zeroes > 2) return true;
      }
    }
    return false;
  }
  __name(hasManySiblings, "hasManySiblings");
  function colorDelta(img1, img2, k, m, yOnly) {
    let r1 = img1[k + 0];
    let g1 = img1[k + 1];
    let b1 = img1[k + 2];
    let a1 = img1[k + 3];
    let r2 = img2[m + 0];
    let g2 = img2[m + 1];
    let b2 = img2[m + 2];
    let a2 = img2[m + 3];
    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;
    if (a1 < 255) {
      a1 /= 255;
      r1 = blend(r1, a1);
      g1 = blend(g1, a1);
      b1 = blend(b1, a1);
    }
    if (a2 < 255) {
      a2 /= 255;
      r2 = blend(r2, a2);
      g2 = blend(g2, a2);
      b2 = blend(b2, a2);
    }
    const y1 = rgb2y(r1, g1, b1);
    const y2 = rgb2y(r2, g2, b2);
    const y = y1 - y2;
    if (yOnly) return y;
    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
    return y1 > y2 ? -delta : delta;
  }
  __name(colorDelta, "colorDelta");
  function rgb2y(r, g, b) {
    return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
  }
  __name(rgb2y, "rgb2y");
  function rgb2i(r, g, b) {
    return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
  }
  __name(rgb2i, "rgb2i");
  function rgb2q(r, g, b) {
    return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
  }
  __name(rgb2q, "rgb2q");
  function blend(c, a) {
    return 255 + (c - 255) * a;
  }
  __name(blend, "blend");
  function drawPixel2(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
  }
  __name(drawPixel2, "drawPixel");
  function drawGrayPixel(img, i, alpha, output) {
    const r = img[i + 0];
    const g = img[i + 1];
    const b = img[i + 2];
    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);
    drawPixel2(output, i, val, val, val);
  }
  __name(drawGrayPixel, "drawGrayPixel");
  return pixelmatch_1;
}
__name(requirePixelmatch, "requirePixelmatch");

// node_modules/@cloudflare/playwright/lib/_virtual/pixelmatch.js
var pixelmatchExports = requirePixelmatch();
var pixelmatch = /* @__PURE__ */ getDefaultExportFromCjs2(pixelmatchExports);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/crypto.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import crypto2 from "node:crypto";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/assert.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assert3(value, message) {
  if (!value)
    throw new Error(message || "Assertion error");
}
__name(assert3, "assert");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/crypto.js
function createGuid() {
  return Array.from({ length: 16 }, () => Math.floor(Math.random() * 256)).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
__name(createGuid, "createGuid");
function calculateSha1(buffer) {
  const hash = crypto2.createHash("sha1");
  hash.update(buffer);
  return hash.digest("hex");
}
__name(calculateSha1, "calculateSha1");
function encodeBase128(value) {
  const bytes = [];
  do {
    let byte = value & 127;
    value >>>= 7;
    if (bytes.length > 0)
      byte |= 128;
    bytes.push(byte);
  } while (value > 0);
  return Buffer.from(bytes.reverse());
}
__name(encodeBase128, "encodeBase128");
var DER = class {
  static {
    __name(this, "DER");
  }
  static encodeSequence(data) {
    return this._encode(48, Buffer.concat(data));
  }
  static encodeInteger(data) {
    assert3(data >= -128 && data <= 127);
    return this._encode(2, Buffer.from([data]));
  }
  static encodeObjectIdentifier(oid) {
    const parts = oid.split(".").map((v) => Number(v));
    const output = [encodeBase128(40 * parts[0] + parts[1])];
    for (let i = 2; i < parts.length; i++)
      output.push(encodeBase128(parts[i]));
    return this._encode(6, Buffer.concat(output));
  }
  static encodeNull() {
    return Buffer.from([5, 0]);
  }
  static encodeSet(data) {
    assert3(data.length === 1, "Only one item in the set is supported. We'd need to sort the data to support more.");
    return this._encode(49, Buffer.concat(data));
  }
  static encodeExplicitContextDependent(tag, data) {
    return this._encode(160 + tag, data);
  }
  static encodePrintableString(data) {
    return this._encode(19, Buffer.from(data));
  }
  static encodeBitString(data) {
    const unusedBits = 0;
    const content = Buffer.concat([Buffer.from([unusedBits]), data]);
    return this._encode(3, content);
  }
  static encodeDate(date) {
    const year = date.getUTCFullYear();
    const isGeneralizedTime = year >= 2050;
    const parts = [
      isGeneralizedTime ? year.toString() : year.toString().slice(-2),
      (date.getUTCMonth() + 1).toString().padStart(2, "0"),
      date.getUTCDate().toString().padStart(2, "0"),
      date.getUTCHours().toString().padStart(2, "0"),
      date.getUTCMinutes().toString().padStart(2, "0"),
      date.getUTCSeconds().toString().padStart(2, "0")
    ];
    const encodedDate = parts.join("") + "Z";
    const tag = isGeneralizedTime ? 24 : 23;
    return this._encode(tag, Buffer.from(encodedDate));
  }
  static _encode(tag, data) {
    const lengthBytes = this._encodeLength(data.length);
    return Buffer.concat([Buffer.from([tag]), lengthBytes, data]);
  }
  static _encodeLength(length) {
    if (length < 128) {
      return Buffer.from([length]);
    } else {
      const lengthBytes = [];
      while (length > 0) {
        lengthBytes.unshift(length & 255);
        length >>= 8;
      }
      return Buffer.from([128 | lengthBytes.length, ...lengthBytes]);
    }
  }
};
function generateSelfSignedCertificate() {
  const { privateKey, publicKey } = crypto2.generateKeyPairSync("rsa", { modulusLength: 2048 });
  const publicKeyDer = publicKey.export({ type: "pkcs1", format: "der" });
  const oneYearInMilliseconds = 365 * 24 * 60 * 60 * 1e3;
  const notBefore = new Date((/* @__PURE__ */ new Date()).getTime() - oneYearInMilliseconds);
  const notAfter = new Date((/* @__PURE__ */ new Date()).getTime() + oneYearInMilliseconds);
  const tbsCertificate = DER.encodeSequence([
    DER.encodeExplicitContextDependent(0, DER.encodeInteger(1)),
    // version
    DER.encodeInteger(1),
    // serialNumber
    DER.encodeSequence([
      DER.encodeObjectIdentifier("1.2.840.113549.1.1.11"),
      // sha256WithRSAEncryption PKCS #1
      DER.encodeNull()
    ]),
    // signature
    DER.encodeSequence([
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.3"),
          // commonName X.520 DN component
          DER.encodePrintableString("localhost")
        ])
      ]),
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.10"),
          // organizationName X.520 DN component
          DER.encodePrintableString("Playwright Client Certificate Support")
        ])
      ])
    ]),
    // issuer
    DER.encodeSequence([
      DER.encodeDate(notBefore),
      // notBefore
      DER.encodeDate(notAfter)
      // notAfter
    ]),
    // validity
    DER.encodeSequence([
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.3"),
          // commonName X.520 DN component
          DER.encodePrintableString("localhost")
        ])
      ]),
      DER.encodeSet([
        DER.encodeSequence([
          DER.encodeObjectIdentifier("2.5.4.10"),
          // organizationName X.520 DN component
          DER.encodePrintableString("Playwright Client Certificate Support")
        ])
      ])
    ]),
    // subject
    DER.encodeSequence([
      DER.encodeSequence([
        DER.encodeObjectIdentifier("1.2.840.113549.1.1.1"),
        // rsaEncryption PKCS #1
        DER.encodeNull()
      ]),
      DER.encodeBitString(publicKeyDer)
    ])
    // SubjectPublicKeyInfo
  ]);
  const signature = crypto2.sign("sha256", tbsCertificate, privateKey);
  const certificate = DER.encodeSequence([
    tbsCertificate,
    DER.encodeSequence([
      DER.encodeObjectIdentifier("1.2.840.113549.1.1.11"),
      // sha256WithRSAEncryption PKCS #1
      DER.encodeNull()
    ]),
    DER.encodeBitString(signature)
  ]);
  const certPem = [
    "-----BEGIN CERTIFICATE-----",
    // Split the base64 string into lines of 64 characters
    certificate.toString("base64").match(/.{1,64}/g).join("\n"),
    "-----END CERTIFICATE-----"
  ].join("\n");
  return {
    cert: certPem,
    key: privateKey.export({ type: "pkcs1", format: "pem" })
  };
}
__name(generateSelfSignedCertificate, "generateSelfSignedCertificate");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/debug.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/env.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getFromENV(name) {
  let value = process.env[name];
  value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
  value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
  return value;
}
__name(getFromENV, "getFromENV");
function getAsBooleanFromENV(name, defaultValue) {
  const value = getFromENV(name);
  if (value === "false" || value === "0")
    return false;
  if (value)
    return true;
  return false;
}
__name(getAsBooleanFromENV, "getAsBooleanFromENV");
function getPackageManager() {
  const env3 = process.env.npm_config_user_agent || "";
  if (env3.includes("yarn"))
    return "yarn";
  if (env3.includes("pnpm"))
    return "pnpm";
  return "npm";
}
__name(getPackageManager, "getPackageManager");
function getPackageManagerExecCommand() {
  const packageManager = getPackageManager();
  if (packageManager === "yarn")
    return "yarn";
  if (packageManager === "pnpm")
    return "pnpm exec";
  return "npx";
}
__name(getPackageManagerExecCommand, "getPackageManagerExecCommand");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/debug.js
var _debugMode = getFromENV("PWDEBUG") || "";
function debugMode() {
  if (_debugMode === "console")
    return "console";
  if (_debugMode === "0" || _debugMode === "false")
    return "";
  return _debugMode ? "inspector" : "";
}
__name(debugMode, "debugMode");
var _isUnderTest = getAsBooleanFromENV("PWTEST_UNDER_TEST");
function isUnderTest() {
  return _isUnderTest;
}
__name(isUnderTest, "isUnderTest");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/network.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import http2 from "node:http";
import "node:http2";
import https2 from "node:https";
import url2 from "node:url";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/happyEyeballs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import dns from "node:dns";
import http from "node:http";
import https from "node:https";
import net2 from "node:net";
import tls2 from "node:tls";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/time.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _timeOrigin2 = performance.timeOrigin;
var _timeShift = 0;
function setTimeOrigin(origin) {
  _timeOrigin2 = origin;
  _timeShift = performance.timeOrigin - origin;
}
__name(setTimeOrigin, "setTimeOrigin");
function timeOrigin() {
  return _timeOrigin2;
}
__name(timeOrigin, "timeOrigin");
function monotonicTime() {
  return Math.floor((performance.now() + _timeShift) * 1e3) / 1e3;
}
__name(monotonicTime, "monotonicTime");
var DEFAULT_PLAYWRIGHT_TIMEOUT = 3e4;
var DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT = 3 * 60 * 1e3;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/happyEyeballs.js
var connectionAttemptDelayMs = 300;
var kDNSLookupAt = Symbol("kDNSLookupAt");
var kTCPConnectionAt = Symbol("kTCPConnectionAt");
var HttpHappyEyeballsAgent = class extends http.Agent {
  static {
    __name(this, "HttpHappyEyeballsAgent");
  }
  createConnection(options2, oncreate) {
    if (net2.isIP(clientRequestArgsToHostName(options2)))
      return net2.createConnection(options2);
    createConnectionAsync(
      options2,
      oncreate,
      /* useTLS */
      false
    ).catch((err) => oncreate?.(err));
  }
};
var HttpsHappyEyeballsAgent = class extends https.Agent {
  static {
    __name(this, "HttpsHappyEyeballsAgent");
  }
  createConnection(options2, oncreate) {
    if (net2.isIP(clientRequestArgsToHostName(options2)))
      return tls2.connect(options2);
    createConnectionAsync(
      options2,
      oncreate,
      /* useTLS */
      true
    ).catch((err) => oncreate?.(err));
  }
};
var httpsHappyEyeballsAgent = new HttpsHappyEyeballsAgent({ keepAlive: true });
var httpHappyEyeballsAgent = new HttpHappyEyeballsAgent({ keepAlive: true });
async function createSocket(host, port) {
  return new Promise((resolve, reject) => {
    if (net2.isIP(host)) {
      const socket = net2.createConnection({ host, port });
      socket.on("connect", () => resolve(socket));
      socket.on("error", (error3) => reject(error3));
    } else {
      createConnectionAsync(
        { host, port },
        (err, socket) => {
          if (err)
            reject(err);
          if (socket)
            resolve(socket);
        },
        /* useTLS */
        false
      ).catch((err) => reject(err));
    }
  });
}
__name(createSocket, "createSocket");
async function createConnectionAsync(options2, oncreate, useTLS) {
  const lookup = options2.__testHookLookup || lookupAddresses;
  const hostname = clientRequestArgsToHostName(options2);
  const addresses = await lookup(hostname);
  const dnsLookupAt = monotonicTime();
  const sockets = /* @__PURE__ */ new Set();
  let firstError;
  let errorCount = 0;
  const handleError = /* @__PURE__ */ __name((socket, err) => {
    if (!sockets.delete(socket))
      return;
    ++errorCount;
    firstError ??= err;
    if (errorCount === addresses.length)
      oncreate?.(firstError);
  }, "handleError");
  const connected2 = new ManualPromise();
  for (const { address } of addresses) {
    const socket = useTLS ? tls2.connect({
      ...options2,
      port: options2.port,
      host: address,
      servername: hostname
    }) : net2.createConnection({
      ...options2,
      port: options2.port,
      host: address
    });
    socket[kDNSLookupAt] = dnsLookupAt;
    socket.on("connect", () => {
      socket[kTCPConnectionAt] = monotonicTime();
      connected2.resolve();
      oncreate?.(null, socket);
      sockets.delete(socket);
      for (const s of sockets)
        s.destroy();
      sockets.clear();
    });
    socket.on("timeout", () => {
      socket.destroy();
      handleError(socket, new Error("Connection timeout"));
    });
    socket.on("error", (e) => handleError(socket, e));
    sockets.add(socket);
    await Promise.race([
      connected2,
      new Promise((f) => setTimeout(f, connectionAttemptDelayMs))
    ]);
    if (connected2.isDone())
      break;
  }
}
__name(createConnectionAsync, "createConnectionAsync");
async function lookupAddresses(hostname) {
  const addresses = await dns.promises.lookup(hostname, { all: true, family: 0, verbatim: true });
  let firstFamily = addresses.filter(({ family }) => family === 6);
  let secondFamily = addresses.filter(({ family }) => family === 4);
  if (firstFamily.length && firstFamily[0] !== addresses[0]) {
    const tmp = firstFamily;
    firstFamily = secondFamily;
    secondFamily = tmp;
  }
  const result = [];
  for (let i = 0; i < Math.max(firstFamily.length, secondFamily.length); i++) {
    if (firstFamily[i])
      result.push(firstFamily[i]);
    if (secondFamily[i])
      result.push(secondFamily[i]);
  }
  return result;
}
__name(lookupAddresses, "lookupAddresses");
function clientRequestArgsToHostName(options2) {
  if (options2.hostname)
    return options2.hostname;
  if (options2.host)
    return options2.host;
  throw new Error("Either options.hostname or options.host must be provided");
}
__name(clientRequestArgsToHostName, "clientRequestArgsToHostName");
function timingForSocket(socket) {
  return {
    dnsLookupAt: socket[kDNSLookupAt],
    tcpConnectionAt: socket[kTCPConnectionAt]
  };
}
__name(timingForSocket, "timingForSocket");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/network.js
var NET_DEFAULT_TIMEOUT = 3e4;
function httpRequest(params, onResponse, onError) {
  const parsedUrl = url2.parse(params.url);
  let options2 = {
    ...parsedUrl,
    agent: parsedUrl.protocol === "https:" ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent,
    method: params.method || "GET",
    headers: params.headers
  };
  if (params.rejectUnauthorized !== void 0)
    options2.rejectUnauthorized = params.rejectUnauthorized;
  const proxyURL = getProxyForUrl2(params.url);
  if (proxyURL) {
    const parsedProxyURL = url2.parse(proxyURL);
    if (params.url.startsWith("http:")) {
      options2 = {
        path: parsedUrl.href,
        host: parsedProxyURL.hostname,
        port: parsedProxyURL.port,
        headers: options2.headers,
        method: options2.method
      };
    } else {
      parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
      options2.agent = new HttpsProxyAgent2(parsedProxyURL);
      options2.rejectUnauthorized = false;
    }
  }
  let cancelRequest;
  const requestCallback = /* @__PURE__ */ __name((res) => {
    const statusCode = res.statusCode || 0;
    if (statusCode >= 300 && statusCode < 400 && res.headers.location) {
      request2.destroy();
      cancelRequest = httpRequest({ ...params, url: new URL(res.headers.location, params.url).toString() }, onResponse, onError).cancel;
    } else {
      onResponse(res);
    }
  }, "requestCallback");
  const request2 = options2.protocol === "https:" ? https2.request(options2, requestCallback) : http2.request(options2, requestCallback);
  request2.on("error", onError);
  if (params.socketTimeout !== void 0) {
    request2.setTimeout(params.socketTimeout, () => {
      onError(new Error(`Request to ${params.url} timed out after ${params.socketTimeout}ms`));
      request2.abort();
    });
  }
  cancelRequest = /* @__PURE__ */ __name((e) => {
    try {
      request2.destroy(e);
    } catch {
    }
  }, "cancelRequest");
  request2.end(params.data);
  return { cancel: /* @__PURE__ */ __name((e) => cancelRequest(e), "cancel") };
}
__name(httpRequest, "httpRequest");
async function fetchData(progress3, params, onError) {
  const promise = new ManualPromise();
  const { cancel } = httpRequest(params, async (response) => {
    if (response.statusCode !== 200) {
      const error3 = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
      promise.reject(error3);
      return;
    }
    let body = "";
    response.on("data", (chunk) => body += chunk);
    response.on("error", (error3) => promise.reject(error3));
    response.on("end", () => promise.resolve(body));
  }, (error3) => promise.reject(error3));
  if (!progress3)
    return promise;
  try {
    return await progress3.race(promise);
  } catch (error3) {
    cancel(error3);
    throw error3;
  }
}
__name(fetchData, "fetchData");
function shouldBypassProxy(url22, bypass) {
  if (!bypass)
    return false;
  const domains = bypass.split(",").map((s) => {
    s = s.trim();
    if (!s.startsWith("."))
      s = "." + s;
    return s;
  });
  const domain2 = "." + url22.hostname;
  return domains.some((d) => domain2.endsWith(d));
}
__name(shouldBypassProxy, "shouldBypassProxy");
function createProxyAgent(proxy, forUrl) {
  if (!proxy)
    return;
  if (forUrl && proxy.bypass && shouldBypassProxy(forUrl, proxy.bypass))
    return;
  let proxyServer = proxy.server.trim();
  if (!/^\w+:\/\//.test(proxyServer))
    proxyServer = "http://" + proxyServer;
  const proxyOpts = url2.parse(proxyServer);
  if (proxyOpts.protocol?.startsWith("socks")) {
    return new SocksProxyAgent2({
      host: proxyOpts.hostname,
      port: proxyOpts.port || void 0
    });
  }
  if (proxy.username)
    proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
  if (forUrl && ["ws:", "wss:"].includes(forUrl.protocol)) {
    return new HttpsProxyAgent2(proxyOpts);
  }
  return new HttpsProxyAgent2(proxyOpts);
}
__name(createProxyAgent, "createProxyAgent");
function createHttpServer(...args) {
  const server = http2.createServer(...args);
  decorateServer(server);
  return server;
}
__name(createHttpServer, "createHttpServer");
function decorateServer(server) {
  const sockets = /* @__PURE__ */ new Set();
  server.on("connection", (socket) => {
    sockets.add(socket);
    socket.once("close", () => sockets.delete(socket));
  });
  const close2 = server.close;
  server.close = (callback) => {
    for (const socket of sockets)
      socket.destroy();
    sockets.clear();
    return close2.call(server, callback);
  };
}
__name(decorateServer, "decorateServer");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/nodePlatform.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/inspector.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils();
init_noop();
var close = noop_default;
var console2 = {
  debug: noop_default,
  error: noop_default,
  info: noop_default,
  log: noop_default,
  warn: noop_default,
  dir: noop_default,
  dirxml: noop_default,
  table: noop_default,
  trace: noop_default,
  group: noop_default,
  groupCollapsed: noop_default,
  groupEnd: noop_default,
  clear: noop_default,
  count: noop_default,
  countReset: noop_default,
  assert: noop_default,
  profile: noop_default,
  profileEnd: noop_default,
  time: noop_default,
  timeLog: noop_default,
  timeStamp: noop_default
};
var open3 = /* @__PURE__ */ __name(() => ({
  __unenv__: true,
  [Symbol.dispose]() {
    return Promise.resolve();
  }
}), "open");
var url3 = /* @__PURE__ */ __name(() => void 0, "url");
var waitForDebugger = noop_default;
var Session = /* @__PURE__ */ notImplementedClass("inspector.Session");
var Network = {
  loadingFailed: /* @__PURE__ */ notImplemented("inspector.Network.loadingFailed"),
  loadingFinished: /* @__PURE__ */ notImplemented("inspector.Network.loadingFinished"),
  requestWillBeSent: /* @__PURE__ */ notImplemented("inspector.Network.requestWillBeSent"),
  responseReceived: /* @__PURE__ */ notImplemented("inspector.Network.responseReceived")
};
var inspector_default = {
  Session,
  close,
  console: console2,
  open: open3,
  url: url3,
  waitForDebugger,
  Network
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/nodePlatform.js
import crypto3 from "node:crypto";
import fs8 from "node:fs";
import path6 from "node:path";
import * as require$$0$2 from "node:util";
import { pipeline, Writable as Writable2, Readable } from "node:stream";
import { EventEmitter as EventEmitter4 } from "node:events";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/zones.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { AsyncLocalStorage } from "node:async_hooks";
var asyncLocalStorage = new AsyncLocalStorage();
var Zone = class _Zone {
  static {
    __name(this, "Zone");
  }
  constructor(asyncLocalStorage2, store) {
    this._asyncLocalStorage = asyncLocalStorage2;
    this._data = store;
  }
  with(type, data) {
    return new _Zone(this._asyncLocalStorage, new Map(this._data).set(type, data));
  }
  without(type) {
    const data = type ? new Map(this._data) : /* @__PURE__ */ new Map();
    data.delete(type);
    return new _Zone(this._asyncLocalStorage, data);
  }
  run(func) {
    return this._asyncLocalStorage.run(this, func);
  }
  data(type) {
    return this._data.get(type);
  }
};
var emptyZone = new Zone(asyncLocalStorage, /* @__PURE__ */ new Map());
function currentZone() {
  return asyncLocalStorage.getStore() ?? emptyZone;
}
__name(currentZone, "currentZone");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/nodePlatform.js
var pipelineAsync = require$$0$2.promisify(pipeline);
var NodeZone = class _NodeZone {
  static {
    __name(this, "NodeZone");
  }
  constructor(zone) {
    this._zone = zone;
  }
  push(data) {
    return new _NodeZone(this._zone.with("apiZone", data));
  }
  pop() {
    return new _NodeZone(this._zone.without("apiZone"));
  }
  run(func) {
    return this._zone.run(func);
  }
  data() {
    return this._zone.data("apiZone");
  }
};
var boxedStackPrefixes = [];
var coreDir = path6.dirname(".");
var nodePlatform = {
  name: "node",
  boxedStackPrefixes: /* @__PURE__ */ __name(() => {
    if (process.env.PWDEBUGIMPL)
      return [];
    return [coreDir, ...boxedStackPrefixes];
  }, "boxedStackPrefixes"),
  calculateSha1: /* @__PURE__ */ __name((text) => {
    const sha1 = crypto3.createHash("sha1");
    sha1.update(text);
    return Promise.resolve(sha1.digest("hex"));
  }, "calculateSha1"),
  colors: colors2,
  coreDir,
  createGuid: /* @__PURE__ */ __name(() => crypto3.randomBytes(16).toString("hex"), "createGuid"),
  defaultMaxListeners: /* @__PURE__ */ __name(() => EventEmitter4.defaultMaxListeners, "defaultMaxListeners"),
  fs: /* @__PURE__ */ __name(() => fs8, "fs"),
  env: process.env,
  inspectCustom: require$$0$2.inspect.custom,
  isDebugMode: /* @__PURE__ */ __name(() => debugMode() === "inspector", "isDebugMode"),
  isJSDebuggerAttached: /* @__PURE__ */ __name(() => !!inspector_default.url(), "isJSDebuggerAttached"),
  isLogEnabled(name) {
    return debugLogger.isEnabled(name);
  },
  isUnderTest: /* @__PURE__ */ __name(() => isUnderTest(), "isUnderTest"),
  log(name, message) {
    debugLogger.log(name, message);
  },
  path: /* @__PURE__ */ __name(() => path6, "path"),
  pathSeparator: path6.sep,
  showInternalStackFrames: /* @__PURE__ */ __name(() => !!process.env.PWDEBUGIMPL, "showInternalStackFrames"),
  async streamFile(path210, stream) {
    await pipelineAsync(fs8.createReadStream(path210), stream);
  },
  streamReadable: /* @__PURE__ */ __name((channel2) => {
    return new ReadableStreamImpl(channel2);
  }, "streamReadable"),
  streamWritable: /* @__PURE__ */ __name((channel2) => {
    return new WritableStreamImpl(channel2);
  }, "streamWritable"),
  zones: {
    current: /* @__PURE__ */ __name(() => new NodeZone(currentZone()), "current"),
    empty: new NodeZone(emptyZone)
  }
};
var ReadableStreamImpl = class extends Readable {
  static {
    __name(this, "ReadableStreamImpl");
  }
  constructor(channel2) {
    super();
    this._channel = channel2;
  }
  async _read() {
    const result = await this._channel.read({ size: 1024 * 1024 });
    if (result.binary.byteLength)
      this.push(result.binary);
    else
      this.push(null);
  }
  _destroy(error3, callback) {
    this._channel.close().catch((e) => null);
    super._destroy(error3, callback);
  }
};
var WritableStreamImpl = class extends Writable2 {
  static {
    __name(this, "WritableStreamImpl");
  }
  constructor(channel2) {
    super();
    this._channel = channel2;
  }
  async _write(chunk, encoding, callback) {
    const error3 = await this._channel.write({ binary: typeof chunk === "string" ? Buffer.from(chunk) : chunk }).catch((e) => e);
    callback(error3 || null);
  }
  async _final(callback) {
    const error3 = await this._channel.close().catch((e) => e);
    callback(error3 || null);
  }
};

// node_modules/unenv/dist/runtime/node/readline.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/readline/promises.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/unenv/dist/runtime/node/internal/readline/interface.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter5 } from "node:events";
var Interface = class extends EventEmitter5 {
  static {
    __name(this, "Interface");
  }
  terminal = false;
  line = "";
  cursor = 0;
  getPrompt() {
    return "";
  }
  setPrompt(prompt) {
  }
  prompt(preserveCursor) {
  }
  question(query, options2, callback) {
    callback && typeof callback === "function" && callback("");
  }
  resume() {
    return this;
  }
  close() {
  }
  write(data, key) {
  }
  getCursorPos() {
    return {
      rows: 0,
      cols: 0
    };
  }
  pause() {
    return this;
  }
  async *[Symbol.asyncIterator]() {
    yield "";
  }
};

// node_modules/unenv/dist/runtime/node/readline.mjs
var createInterface = /* @__PURE__ */ __name(() => new Interface(), "createInterface");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/profiler.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs9 from "node:fs";
import path7 from "node:path";
var profileDir = process.env.PWTEST_PROFILE_DIR || "";
var session;
async function startProfiling() {
  if (!profileDir)
    return;
  session = new inspector_default.Session();
  session.connect();
  await new Promise((f) => {
    session.post("Profiler.enable", () => {
      session.post("Profiler.start", f);
    });
  });
}
__name(startProfiling, "startProfiling");
async function stopProfiling(profileName) {
  if (!profileDir)
    return;
  await new Promise((f) => session.post("Profiler.stop", (err, { profile: profile3 }) => {
    if (!err) {
      fs9.mkdirSync(profileDir, { recursive: true });
      fs9.writeFileSync(path7.join(profileDir, profileName + ".json"), JSON.stringify(profile3));
    }
    f();
  }));
}
__name(stopProfiling, "stopProfiling");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/socksProxy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import EventEmitter6 from "node:events";
import net3 from "node:net";
var SocksConnection = class {
  static {
    __name(this, "SocksConnection");
  }
  constructor(uid, socket, client) {
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    this._uid = uid;
    this._socket = socket;
    this._client = client;
    this._boundOnData = this._onData.bind(this);
    socket.on("data", this._boundOnData);
    socket.on("close", () => this._onClose());
    socket.on("end", () => this._onClose());
    socket.on("error", () => this._onClose());
    this._run().catch(() => this._socket.end());
  }
  async _run() {
    assert3(await this._authenticate());
    const { command, host, port } = await this._parseRequest();
    if (command !== 1) {
      this._writeBytes(Buffer.from([
        5,
        7,
        0,
        // RSV
        1,
        // IPv4
        0,
        0,
        0,
        0,
        // Address
        0,
        0
        // Port
      ]));
      return;
    }
    this._socket.off("data", this._boundOnData);
    this._client.onSocketRequested({ uid: this._uid, host, port });
  }
  async _authenticate() {
    const version6 = await this._readByte();
    assert3(version6 === 5, "The VER field must be set to x05 for this version of the protocol, was " + version6);
    const nMethods = await this._readByte();
    assert3(nMethods, "No authentication methods specified");
    const methods = await this._readBytes(nMethods);
    for (const method of methods) {
      if (method === 0) {
        this._writeBytes(Buffer.from([version6, method]));
        return true;
      }
    }
    this._writeBytes(Buffer.from([
      version6,
      255
      /* NO_ACCEPTABLE_METHODS */
    ]));
    return false;
  }
  async _parseRequest() {
    const version6 = await this._readByte();
    assert3(version6 === 5, "The VER field must be set to x05 for this version of the protocol, was " + version6);
    const command = await this._readByte();
    await this._readByte();
    const addressType = await this._readByte();
    let host = "";
    switch (addressType) {
      case 1:
        host = (await this._readBytes(4)).join(".");
        break;
      case 3:
        const length = await this._readByte();
        host = (await this._readBytes(length)).toString();
        break;
      case 4:
        const bytes = await this._readBytes(16);
        const tokens = [];
        for (let i = 0; i < 8; ++i)
          tokens.push(bytes.readUInt16BE(i * 2).toString(16));
        host = tokens.join(":");
        break;
    }
    const port = (await this._readBytes(2)).readUInt16BE(0);
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    return {
      command,
      host,
      port
    };
  }
  async _readByte() {
    const buffer = await this._readBytes(1);
    return buffer[0];
  }
  async _readBytes(length) {
    this._fence = this._offset + length;
    if (!this._buffer || this._buffer.length < this._fence)
      await new Promise((f) => this._fenceCallback = f);
    this._offset += length;
    return this._buffer.slice(this._offset - length, this._offset);
  }
  _writeBytes(buffer) {
    if (this._socket.writable)
      this._socket.write(buffer);
  }
  _onClose() {
    this._client.onSocketClosed({ uid: this._uid });
  }
  _onData(buffer) {
    this._buffer = Buffer.concat([this._buffer, buffer]);
    if (this._fenceCallback && this._buffer.length >= this._fence) {
      const callback = this._fenceCallback;
      this._fenceCallback = void 0;
      callback();
    }
  }
  socketConnected(host, port) {
    this._writeBytes(Buffer.from([
      5,
      0,
      0,
      // RSV
      ...ipToSocksAddress(host),
      // ATYP, Address
      port >> 8,
      port & 255
      // Port
    ]));
    this._socket.on("data", (data) => this._client.onSocketData({ uid: this._uid, data }));
  }
  socketFailed(errorCode) {
    const buffer = Buffer.from([
      5,
      0,
      0,
      // RSV
      ...ipToSocksAddress("0.0.0.0"),
      // ATYP, Address
      0,
      0
      // Port
    ]);
    switch (errorCode) {
      case "ENOENT":
      case "ENOTFOUND":
      case "ETIMEDOUT":
      case "EHOSTUNREACH":
        buffer[1] = 4;
        break;
      case "ENETUNREACH":
        buffer[1] = 3;
        break;
      case "ECONNREFUSED":
        buffer[1] = 5;
        break;
      case "ERULESET":
        buffer[1] = 2;
        break;
    }
    this._writeBytes(buffer);
    this._socket.end();
  }
  sendData(data) {
    this._socket.write(data);
  }
  end() {
    this._socket.end();
  }
  error(error3) {
    this._socket.destroy(new Error(error3));
  }
};
function hexToNumber(hex) {
  return [...hex].reduce((value, digit2) => {
    const code = digit2.charCodeAt(0);
    if (code >= 48 && code <= 57)
      return value + code;
    if (code >= 97 && code <= 102)
      return value + (code - 97) + 10;
    if (code >= 65 && code <= 70)
      return value + (code - 65) + 10;
    throw new Error("Invalid IPv6 token " + hex);
  }, 0);
}
__name(hexToNumber, "hexToNumber");
function ipToSocksAddress(address) {
  if (net3.isIPv4(address)) {
    return [
      1,
      // IPv4
      ...address.split(".", 4).map((t) => +t & 255)
      // Address
    ];
  }
  if (net3.isIPv6(address)) {
    const result = [4];
    const tokens = address.split(":", 8);
    while (tokens.length < 8)
      tokens.unshift("");
    for (const token of tokens) {
      const value = hexToNumber(token);
      result.push(value >> 8 & 255, value & 255);
    }
    return result;
  }
  throw new Error("Only IPv4 and IPv6 addresses are supported");
}
__name(ipToSocksAddress, "ipToSocksAddress");
function starMatchToRegex(pattern) {
  const source8 = pattern.split("*").map((s) => {
    return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }).join(".*");
  return new RegExp("^" + source8 + "$");
}
__name(starMatchToRegex, "starMatchToRegex");
function parsePattern(pattern) {
  if (!pattern)
    return () => false;
  const matchers = pattern.split(",").map((token) => {
    const match = token.match(/^(.*?)(?::(\d+))?$/);
    if (!match)
      throw new Error(`Unsupported token "${token}" in pattern "${pattern}"`);
    const tokenPort = match[2] ? +match[2] : void 0;
    const portMatches = /* @__PURE__ */ __name((port) => tokenPort === void 0 || tokenPort === port, "portMatches");
    let tokenHost = match[1];
    if (tokenHost === "<loopback>") {
      return (host, port) => {
        if (!portMatches(port))
          return false;
        return host === "localhost" || host.endsWith(".localhost") || host === "127.0.0.1" || host === "[::1]";
      };
    }
    if (tokenHost === "*")
      return (host, port) => portMatches(port);
    if (net3.isIPv4(tokenHost) || net3.isIPv6(tokenHost))
      return (host, port) => host === tokenHost && portMatches(port);
    if (tokenHost[0] === ".")
      tokenHost = "*" + tokenHost;
    const tokenRegex = starMatchToRegex(tokenHost);
    return (host, port) => {
      if (!portMatches(port))
        return false;
      if (net3.isIPv4(host) || net3.isIPv6(host))
        return false;
      return !!host.match(tokenRegex);
    };
  });
  return (host, port) => matchers.some((matcher) => matcher(host, port));
}
__name(parsePattern, "parsePattern");
var SocksProxy = class _SocksProxy extends EventEmitter6 {
  static {
    __name(this, "SocksProxy");
  }
  constructor() {
    super();
    this._connections = /* @__PURE__ */ new Map();
    this._sockets = /* @__PURE__ */ new Set();
    this._closed = false;
    this._patternMatcher = () => false;
    this._directSockets = /* @__PURE__ */ new Map();
    this._server = new net3.Server((socket) => {
      const uid = createGuid();
      const connection = new SocksConnection(uid, socket, this);
      this._connections.set(uid, connection);
    });
    this._server.on("connection", (socket) => {
      if (this._closed) {
        socket.destroy();
        return;
      }
      this._sockets.add(socket);
      socket.once("close", () => this._sockets.delete(socket));
    });
  }
  static {
    this.Events = {
      SocksRequested: "socksRequested",
      SocksData: "socksData",
      SocksClosed: "socksClosed"
    };
  }
  setPattern(pattern) {
    try {
      this._patternMatcher = parsePattern(pattern);
    } catch (e) {
      this._patternMatcher = () => false;
    }
  }
  async _handleDirect(request2) {
    try {
      const socket = await createSocket(request2.host, request2.port);
      socket.on("data", (data) => this._connections.get(request2.uid)?.sendData(data));
      socket.on("error", (error3) => {
        this._connections.get(request2.uid)?.error(error3.message);
        this._directSockets.delete(request2.uid);
      });
      socket.on("end", () => {
        this._connections.get(request2.uid)?.end();
        this._directSockets.delete(request2.uid);
      });
      const localAddress = socket.localAddress;
      const localPort = socket.localPort;
      this._directSockets.set(request2.uid, socket);
      this._connections.get(request2.uid)?.socketConnected(localAddress, localPort);
    } catch (error3) {
      this._connections.get(request2.uid)?.socketFailed(error3.code);
    }
  }
  port() {
    return this._port;
  }
  async listen(port, hostname) {
    return new Promise((f) => {
      this._server.listen(port, hostname, () => {
        const port2 = this._server.address().port;
        this._port = port2;
        f(port2);
      });
    });
  }
  async close() {
    if (this._closed)
      return;
    this._closed = true;
    for (const socket of this._sockets)
      socket.destroy();
    this._sockets.clear();
    await new Promise((f) => this._server.close(f));
  }
  onSocketRequested(payload) {
    if (!this._patternMatcher(payload.host, payload.port)) {
      this._handleDirect(payload);
      return;
    }
    this.emit(_SocksProxy.Events.SocksRequested, payload);
  }
  onSocketData(payload) {
    const direct = this._directSockets.get(payload.uid);
    if (direct) {
      direct.write(payload.data);
      return;
    }
    this.emit(_SocksProxy.Events.SocksData, payload);
  }
  onSocketClosed(payload) {
    const direct = this._directSockets.get(payload.uid);
    if (direct) {
      direct.destroy();
      this._directSockets.delete(payload.uid);
      return;
    }
    this.emit(_SocksProxy.Events.SocksClosed, payload);
  }
  socketConnected({ uid, host, port }) {
    this._connections.get(uid)?.socketConnected(host, port);
  }
  socketFailed({ uid, errorCode }) {
    this._connections.get(uid)?.socketFailed(errorCode);
  }
  sendSocketData({ uid, data }) {
    this._connections.get(uid)?.sendData(data);
  }
  sendSocketEnd({ uid }) {
    this._connections.get(uid)?.end();
  }
  sendSocketError({ uid, error: error3 }) {
    this._connections.get(uid)?.error(error3);
  }
};
var SocksProxyHandler = class _SocksProxyHandler extends EventEmitter6 {
  static {
    __name(this, "SocksProxyHandler");
  }
  constructor(pattern, redirectPortForTest) {
    super();
    this._sockets = /* @__PURE__ */ new Map();
    this._patternMatcher = () => false;
    this._patternMatcher = parsePattern(pattern);
    this._redirectPortForTest = redirectPortForTest;
  }
  static {
    this.Events = {
      SocksConnected: "socksConnected",
      SocksData: "socksData",
      SocksError: "socksError",
      SocksFailed: "socksFailed",
      SocksEnd: "socksEnd"
    };
  }
  cleanup() {
    for (const uid of this._sockets.keys())
      this.socketClosed({ uid });
  }
  async socketRequested({ uid, host, port }) {
    debugLogger.log("socks", `[${uid}] => request ${host}:${port}`);
    if (!this._patternMatcher(host, port)) {
      const payload = { uid, errorCode: "ERULESET" };
      debugLogger.log("socks", `[${uid}] <= pattern error ${payload.errorCode}`);
      this.emit(_SocksProxyHandler.Events.SocksFailed, payload);
      return;
    }
    if (host === "local.playwright")
      host = "localhost";
    try {
      if (this._redirectPortForTest)
        port = this._redirectPortForTest;
      const socket = await createSocket(host, port);
      socket.on("data", (data) => {
        const payload2 = { uid, data };
        this.emit(_SocksProxyHandler.Events.SocksData, payload2);
      });
      socket.on("error", (error3) => {
        const payload2 = { uid, error: error3.message };
        debugLogger.log("socks", `[${uid}] <= network socket error ${payload2.error}`);
        this.emit(_SocksProxyHandler.Events.SocksError, payload2);
        this._sockets.delete(uid);
      });
      socket.on("end", () => {
        const payload2 = { uid };
        debugLogger.log("socks", `[${uid}] <= network socket closed`);
        this.emit(_SocksProxyHandler.Events.SocksEnd, payload2);
        this._sockets.delete(uid);
      });
      const localAddress = socket.localAddress;
      const localPort = socket.localPort;
      this._sockets.set(uid, socket);
      const payload = { uid, host: localAddress, port: localPort };
      debugLogger.log("socks", `[${uid}] <= connected to network ${payload.host}:${payload.port}`);
      this.emit(_SocksProxyHandler.Events.SocksConnected, payload);
    } catch (error3) {
      const payload = { uid, errorCode: error3.code };
      debugLogger.log("socks", `[${uid}] <= connect error ${payload.errorCode}`);
      this.emit(_SocksProxyHandler.Events.SocksFailed, payload);
    }
  }
  sendSocketData({ uid, data }) {
    this._sockets.get(uid)?.write(data);
  }
  socketClosed({ uid }) {
    debugLogger.log("socks", `[${uid}] <= browser socket closed`);
    this._sockets.get(uid)?.destroy();
    this._sockets.delete(uid);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/registry/index.js
var PACKAGE_PATH = path8.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..");
var BIN_PATH = path8.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", "bin");
var PLAYWRIGHT_CDN_MIRRORS = [
  "https://cdn.playwright.dev/dbazure/download/playwright",
  // ESRP CDN
  "https://playwright.download.prss.microsoft.com/dbazure/download/playwright",
  // Directly hit ESRP CDN
  "https://cdn.playwright.dev"
  // Hit the Storage Bucket directly
];
if (process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
  for (let i = 0; i < PLAYWRIGHT_CDN_MIRRORS.length; i++) {
    const cdn = PLAYWRIGHT_CDN_MIRRORS[i];
    if (cdn !== process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
      const parsedCDN = new URL(cdn);
      parsedCDN.hostname = parsedCDN.hostname + ".does-not-resolve.playwright.dev";
      PLAYWRIGHT_CDN_MIRRORS[i] = parsedCDN.toString();
    }
  }
}
var EXECUTABLE_PATHS = {
  "chromium": {
    "linux": ["chrome-linux", "chrome"],
    "mac": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
    "win": ["chrome-win", "chrome.exe"]
  },
  "chromium-headless-shell": {
    "linux": ["chrome-linux", "headless_shell"],
    "mac": ["chrome-mac", "headless_shell"],
    "win": ["chrome-win", "headless_shell.exe"]
  },
  "firefox": {
    "linux": ["firefox", "firefox"],
    "mac": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
    "win": ["firefox", "firefox.exe"]
  },
  "webkit": {
    "linux": ["pw_run.sh"],
    "mac": ["pw_run.sh"],
    "win": ["Playwright.exe"]
  },
  "ffmpeg": {
    "linux": ["ffmpeg-linux"],
    "mac": ["ffmpeg-mac"],
    "win": ["ffmpeg-win64.exe"]
  },
  "winldd": {
    "linux": void 0,
    "mac": void 0,
    "win": ["PrintDeps.exe"]
  }
};
var DOWNLOAD_PATHS = {
  "chromium": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu22.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu24.04-x64": "builds/chromium/%s/chromium-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "debian11-x64": "builds/chromium/%s/chromium-linux.zip",
    "debian11-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "debian12-x64": "builds/chromium/%s/chromium-linux.zip",
    "debian12-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "debian13-x64": "builds/chromium/%s/chromium-linux.zip",
    "debian13-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
    "mac10.13": "builds/chromium/%s/chromium-mac.zip",
    "mac10.14": "builds/chromium/%s/chromium-mac.zip",
    "mac10.15": "builds/chromium/%s/chromium-mac.zip",
    "mac11": "builds/chromium/%s/chromium-mac.zip",
    "mac11-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac12": "builds/chromium/%s/chromium-mac.zip",
    "mac12-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac13": "builds/chromium/%s/chromium-mac.zip",
    "mac13-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac14": "builds/chromium/%s/chromium-mac.zip",
    "mac14-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "mac15": "builds/chromium/%s/chromium-mac.zip",
    "mac15-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
    "win64": "builds/chromium/%s/chromium-win64.zip"
  },
  "chromium-headless-shell": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu22.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu24.04-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "debian11-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "debian11-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "debian12-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "debian12-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "debian13-x64": "builds/chromium/%s/chromium-headless-shell-linux.zip",
    "debian13-arm64": "builds/chromium/%s/chromium-headless-shell-linux-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac11-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac12": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac12-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac13": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac13-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac14": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac14-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "mac15": "builds/chromium/%s/chromium-headless-shell-mac.zip",
    "mac15-arm64": "builds/chromium/%s/chromium-headless-shell-mac-arm64.zip",
    "win64": "builds/chromium/%s/chromium-headless-shell-win64.zip"
  },
  "chromium-tip-of-tree": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu22.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu24.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "debian11-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "debian11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "debian12-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "debian12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "debian13-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
    "debian13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
    "mac10.13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac10.14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac10.15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac14-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "mac15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
    "mac15-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
    "win64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-win64.zip"
  },
  "chromium-tip-of-tree-headless-shell": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu22.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu24.04-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "debian11-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "debian11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "debian12-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "debian12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "debian13-x64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux.zip",
    "debian13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-linux-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac14-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "mac15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac.zip",
    "mac15-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-mac-arm64.zip",
    "win64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-headless-shell-win64.zip"
  },
  "firefox": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/firefox/%s/firefox-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/firefox/%s/firefox-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
    "ubuntu22.04-arm64": "builds/firefox/%s/firefox-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/firefox/%s/firefox-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/firefox/%s/firefox-debian-11.zip",
    "debian11-arm64": "builds/firefox/%s/firefox-debian-11-arm64.zip",
    "debian12-x64": "builds/firefox/%s/firefox-debian-12.zip",
    "debian12-arm64": "builds/firefox/%s/firefox-debian-12-arm64.zip",
    "debian13-x64": "builds/firefox/%s/firefox-debian-13.zip",
    "debian13-arm64": "builds/firefox/%s/firefox-debian-13-arm64.zip",
    "mac10.13": "builds/firefox/%s/firefox-mac.zip",
    "mac10.14": "builds/firefox/%s/firefox-mac.zip",
    "mac10.15": "builds/firefox/%s/firefox-mac.zip",
    "mac11": "builds/firefox/%s/firefox-mac.zip",
    "mac11-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac12": "builds/firefox/%s/firefox-mac.zip",
    "mac12-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac13": "builds/firefox/%s/firefox-mac.zip",
    "mac13-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac14": "builds/firefox/%s/firefox-mac.zip",
    "mac14-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "mac15": "builds/firefox/%s/firefox-mac.zip",
    "mac15-arm64": "builds/firefox/%s/firefox-mac-arm64.zip",
    "win64": "builds/firefox/%s/firefox-win64.zip"
  },
  "firefox-beta": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/firefox-beta/%s/firefox-beta-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": void 0,
    "ubuntu22.04-arm64": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/firefox-beta/%s/firefox-beta-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/firefox-beta/%s/firefox-beta-debian-11.zip",
    "debian11-arm64": "builds/firefox-beta/%s/firefox-beta-debian-11-arm64.zip",
    "debian12-x64": "builds/firefox-beta/%s/firefox-beta-debian-12.zip",
    "debian12-arm64": "builds/firefox-beta/%s/firefox-beta-debian-12-arm64.zip",
    "debian13-x64": "builds/firefox-beta/%s/firefox-beta-debian-12.zip",
    "debian13-arm64": "builds/firefox-beta/%s/firefox-beta-debian-12-arm64.zip",
    "mac10.13": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac10.14": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac10.15": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac11": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac11-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac12": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac12-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac13": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac13-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac14": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac14-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "mac15": "builds/firefox-beta/%s/firefox-beta-mac.zip",
    "mac15-arm64": "builds/firefox-beta/%s/firefox-beta-mac-arm64.zip",
    "win64": "builds/firefox-beta/%s/firefox-beta-win64.zip"
  },
  "webkit": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
    "ubuntu22.04-x64": "builds/webkit/%s/webkit-ubuntu-22.04.zip",
    "ubuntu24.04-x64": "builds/webkit/%s/webkit-ubuntu-24.04.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
    "ubuntu22.04-arm64": "builds/webkit/%s/webkit-ubuntu-22.04-arm64.zip",
    "ubuntu24.04-arm64": "builds/webkit/%s/webkit-ubuntu-24.04-arm64.zip",
    "debian11-x64": "builds/webkit/%s/webkit-debian-11.zip",
    "debian11-arm64": "builds/webkit/%s/webkit-debian-11-arm64.zip",
    "debian12-x64": "builds/webkit/%s/webkit-debian-12.zip",
    "debian12-arm64": "builds/webkit/%s/webkit-debian-12-arm64.zip",
    "debian13-x64": "builds/webkit/%s/webkit-debian-13.zip",
    "debian13-arm64": "builds/webkit/%s/webkit-debian-13-arm64.zip",
    "mac10.13": void 0,
    "mac10.14": "builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
    "mac10.15": "builds/deprecated-webkit-mac-10.15/%s/deprecated-webkit-mac-10.15.zip",
    "mac11": "builds/webkit/%s/webkit-mac-11.zip",
    "mac11-arm64": "builds/webkit/%s/webkit-mac-11-arm64.zip",
    "mac12": "builds/webkit/%s/webkit-mac-12.zip",
    "mac12-arm64": "builds/webkit/%s/webkit-mac-12-arm64.zip",
    "mac13": "builds/webkit/%s/webkit-mac-13.zip",
    "mac13-arm64": "builds/webkit/%s/webkit-mac-13-arm64.zip",
    "mac14": "builds/webkit/%s/webkit-mac-14.zip",
    "mac14-arm64": "builds/webkit/%s/webkit-mac-14-arm64.zip",
    "mac15": "builds/webkit/%s/webkit-mac-15.zip",
    "mac15-arm64": "builds/webkit/%s/webkit-mac-15-arm64.zip",
    "win64": "builds/webkit/%s/webkit-win64.zip"
  },
  "ffmpeg": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu22.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu24.04-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "ubuntu22.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "ubuntu24.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "debian11-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "debian11-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "debian12-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "debian12-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "debian13-x64": "builds/ffmpeg/%s/ffmpeg-linux.zip",
    "debian13-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
    "mac10.13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac10.14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac10.15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac11": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac11-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac12": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac12-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac13-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac14-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "mac15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
    "mac15-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
    "win64": "builds/ffmpeg/%s/ffmpeg-win64.zip"
  },
  "winldd": {
    "<unknown>": void 0,
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": void 0,
    "ubuntu22.04-x64": void 0,
    "ubuntu24.04-x64": void 0,
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": void 0,
    "ubuntu22.04-arm64": void 0,
    "ubuntu24.04-arm64": void 0,
    "debian11-x64": void 0,
    "debian11-arm64": void 0,
    "debian12-x64": void 0,
    "debian12-arm64": void 0,
    "debian13-x64": void 0,
    "debian13-arm64": void 0,
    "mac10.13": void 0,
    "mac10.14": void 0,
    "mac10.15": void 0,
    "mac11": void 0,
    "mac11-arm64": void 0,
    "mac12": void 0,
    "mac12-arm64": void 0,
    "mac13": void 0,
    "mac13-arm64": void 0,
    "mac14": void 0,
    "mac14-arm64": void 0,
    "mac15": void 0,
    "mac15-arm64": void 0,
    "win64": "builds/winldd/%s/winldd-win64.zip"
  },
  "android": {
    "<unknown>": "builds/android/%s/android.zip",
    "ubuntu18.04-x64": void 0,
    "ubuntu20.04-x64": "builds/android/%s/android.zip",
    "ubuntu22.04-x64": "builds/android/%s/android.zip",
    "ubuntu24.04-x64": "builds/android/%s/android.zip",
    "ubuntu18.04-arm64": void 0,
    "ubuntu20.04-arm64": "builds/android/%s/android.zip",
    "ubuntu22.04-arm64": "builds/android/%s/android.zip",
    "ubuntu24.04-arm64": "builds/android/%s/android.zip",
    "debian11-x64": "builds/android/%s/android.zip",
    "debian11-arm64": "builds/android/%s/android.zip",
    "debian12-x64": "builds/android/%s/android.zip",
    "debian12-arm64": "builds/android/%s/android.zip",
    "debian13-x64": "builds/android/%s/android.zip",
    "debian13-arm64": "builds/android/%s/android.zip",
    "mac10.13": "builds/android/%s/android.zip",
    "mac10.14": "builds/android/%s/android.zip",
    "mac10.15": "builds/android/%s/android.zip",
    "mac11": "builds/android/%s/android.zip",
    "mac11-arm64": "builds/android/%s/android.zip",
    "mac12": "builds/android/%s/android.zip",
    "mac12-arm64": "builds/android/%s/android.zip",
    "mac13": "builds/android/%s/android.zip",
    "mac13-arm64": "builds/android/%s/android.zip",
    "mac14": "builds/android/%s/android.zip",
    "mac14-arm64": "builds/android/%s/android.zip",
    "mac15": "builds/android/%s/android.zip",
    "mac15-arm64": "builds/android/%s/android.zip",
    "win64": "builds/android/%s/android.zip"
  },
  // TODO(bidi): implement downloads.
  "_bidiFirefox": {},
  "_bidiChromium": {}
};
var registryDirectory = (() => {
  let result;
  const envDefined = getFromENV("PLAYWRIGHT_BROWSERS_PATH");
  if (envDefined === "0") {
    result = path8.join("/home/runner/work/playwright/playwright/packages/playwright-cloudflare", "..", "..", "..", ".local-browsers");
  } else if (envDefined) {
    result = envDefined;
  } else {
    let cacheDirectory;
    if (process.platform === "linux")
      cacheDirectory = process.env.XDG_CACHE_HOME || path8.join(os6.homedir(), ".cache");
    else if (process.platform === "darwin")
      cacheDirectory = path8.join(os6.homedir(), "Library", "Caches");
    else if (process.platform === "win32")
      cacheDirectory = process.env.LOCALAPPDATA || path8.join(os6.homedir(), "AppData", "Local");
    else
      throw new Error("Unsupported platform: " + process.platform);
    result = path8.join(cacheDirectory, "ms-playwright");
  }
  if (!path8.isAbsolute(result)) {
    result = path8.resolve(getFromENV("INIT_CWD") || process.cwd(), result);
  }
  return result;
})();
function isBrowserDirectory(browserDirectory) {
  const baseName = path8.basename(browserDirectory);
  for (const browserName of allDownloadable) {
    if (baseName.startsWith(browserName.replace(/-/g, "_") + "-"))
      return true;
  }
  return false;
}
__name(isBrowserDirectory, "isBrowserDirectory");
function readDescriptors(browsersJSON) {
  return browsersJSON["browsers"].map((obj) => {
    const name = obj.name;
    const revisionOverride = (obj.revisionOverrides || {})[hostPlatform];
    const revision = revisionOverride || obj.revision;
    const browserDirectoryPrefix = revisionOverride ? `${name}_${hostPlatform}_special` : `${name}`;
    const descriptor = {
      name,
      revision,
      hasRevisionOverride: !!revisionOverride,
      // We only put browser version for the supported operating systems.
      browserVersion: revisionOverride ? void 0 : obj.browserVersion,
      installByDefault: !!obj.installByDefault,
      // Method `isBrowserDirectory` determines directory to be browser iff
      // it starts with some browser name followed by '-'. Some browser names
      // are prefixes of others, e.g. 'webkit' is a prefix of `webkit-technology-preview`.
      // To avoid older registries erroneously removing 'webkit-technology-preview', we have to
      // ensure that browser folders to never include dashes inside.
      dir: path8.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
    };
    return descriptor;
  });
}
__name(readDescriptors, "readDescriptors");
var allDownloadable = ["android", "chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-tip-of-tree", "chromium-headless-shell", "chromium-tip-of-tree-headless-shell"];
var Registry = class {
  static {
    __name(this, "Registry");
  }
  constructor(browsersJSON) {
    const descriptors = readDescriptors(browsersJSON);
    const findExecutablePath = /* @__PURE__ */ __name((dir3, name) => {
      let tokens = void 0;
      if (process.platform === "linux")
        tokens = EXECUTABLE_PATHS[name]["linux"];
      else if (process.platform === "darwin")
        tokens = EXECUTABLE_PATHS[name]["mac"];
      else if (process.platform === "win32")
        tokens = EXECUTABLE_PATHS[name]["win"];
      return tokens ? path8.join(dir3, ...tokens) : void 0;
    }, "findExecutablePath");
    const executablePathOrDie = /* @__PURE__ */ __name((name, e, installByDefault, sdkLanguage) => {
      if (!e)
        throw new Error(`${name} is not supported on ${hostPlatform}`);
      const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
      if (!canAccessFile(e)) {
        const currentDockerVersion = readDockerVersionSync();
        const preferredDockerVersion = currentDockerVersion ? dockerVersion(currentDockerVersion.dockerImageNameTemplate) : null;
        const isOutdatedDockerImage = currentDockerVersion && preferredDockerVersion && currentDockerVersion.dockerImageName !== preferredDockerVersion.dockerImageName;
        const prettyMessage = isOutdatedDockerImage ? [
          `Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just updated to ${preferredDockerVersion.driverVersion}.`,
          `Please update docker image as well.`,
          `-  current: ${currentDockerVersion.dockerImageName}`,
          `- required: ${preferredDockerVersion.dockerImageName}`,
          ``,
          `<3 Playwright Team`
        ].join("\n") : [
          `Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just installed or updated.`,
          `Please run the following command to download new browser${installByDefault ? "s" : ""}:`,
          ``,
          `    ${installCommand}`,
          ``,
          `<3 Playwright Team`
        ].join("\n");
        throw new Error(`Executable doesn't exist at ${e}
${wrapInASCIIBox(prettyMessage, 1)}`);
      }
      return e;
    }, "executablePathOrDie");
    this._executables = [];
    const chromium2 = descriptors.find((d) => d.name === "chromium");
    const chromiumExecutable = findExecutablePath(chromium2.dir, "chromium");
    this._executables.push({
      type: "browser",
      name: "chromium",
      browserName: "chromium",
      directory: chromium2.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium2.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromium2.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromium2.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromium2),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromium2, chromiumExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumHeadlessShell = descriptors.find((d) => d.name === "chromium-headless-shell");
    const chromiumHeadlessShellExecutable = findExecutablePath(chromiumHeadlessShell.dir, "chromium-headless-shell");
    this._executables.push({
      type: "channel",
      name: "chromium-headless-shell",
      browserName: "chromium",
      directory: chromiumHeadlessShell.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumHeadlessShellExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumHeadlessShellExecutable, chromiumHeadlessShell.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumHeadlessShell.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumHeadlessShell.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumHeadlessShell),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumHeadlessShell, chromiumHeadlessShellExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumTipOfTreeHeadlessShell = descriptors.find((d) => d.name === "chromium-tip-of-tree-headless-shell");
    const chromiumTipOfTreeHeadlessShellExecutable = findExecutablePath(chromiumTipOfTreeHeadlessShell.dir, "chromium-headless-shell");
    this._executables.push({
      type: "channel",
      name: "chromium-tip-of-tree-headless-shell",
      browserName: "chromium",
      directory: chromiumTipOfTreeHeadlessShell.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumTipOfTreeHeadlessShellExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumTipOfTreeHeadlessShellExecutable, chromiumTipOfTreeHeadlessShell.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumTipOfTreeHeadlessShell.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumTipOfTreeHeadlessShell.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumTipOfTreeHeadlessShell),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumTipOfTreeHeadlessShell, chromiumTipOfTreeHeadlessShellExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const chromiumTipOfTree = descriptors.find((d) => d.name === "chromium-tip-of-tree");
    const chromiumTipOfTreeExecutable = findExecutablePath(chromiumTipOfTree.dir, "chromium");
    this._executables.push({
      type: "tool",
      name: "chromium-tip-of-tree",
      browserName: "chromium",
      directory: chromiumTipOfTree.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumTipOfTreeExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium-tip-of-tree", chromiumTipOfTreeExecutable, chromiumTipOfTree.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: chromiumTipOfTree.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromiumTipOfTree.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromiumTipOfTree),
      browserVersion: chromiumTipOfTree.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromiumTipOfTree, chromiumTipOfTreeExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    this._executables.push(this._createChromiumChannel("chrome", {
      "linux": "/opt/google/chrome/chrome",
      "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
      "win32": `\\Google\\Chrome\\Application\\chrome.exe`
    }, () => this._installChromiumChannel("chrome", {
      "linux": "reinstall_chrome_stable_linux.sh",
      "darwin": "reinstall_chrome_stable_mac.sh",
      "win32": "reinstall_chrome_stable_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("chrome-beta", {
      "linux": "/opt/google/chrome-beta/chrome",
      "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
      "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
    }, () => this._installChromiumChannel("chrome-beta", {
      "linux": "reinstall_chrome_beta_linux.sh",
      "darwin": "reinstall_chrome_beta_mac.sh",
      "win32": "reinstall_chrome_beta_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("chrome-dev", {
      "linux": "/opt/google/chrome-unstable/chrome",
      "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
      "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
    }));
    this._executables.push(this._createChromiumChannel("chrome-canary", {
      "linux": "/opt/google/chrome-canary/chrome",
      "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
      "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
    }));
    this._executables.push(this._createChromiumChannel("msedge", {
      "linux": "/opt/microsoft/msedge/msedge",
      "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
      "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge", {
      "linux": "reinstall_msedge_stable_linux.sh",
      "darwin": "reinstall_msedge_stable_mac.sh",
      "win32": "reinstall_msedge_stable_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-beta", {
      "linux": "/opt/microsoft/msedge-beta/msedge",
      "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
      "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge-beta", {
      "darwin": "reinstall_msedge_beta_mac.sh",
      "linux": "reinstall_msedge_beta_linux.sh",
      "win32": "reinstall_msedge_beta_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-dev", {
      "linux": "/opt/microsoft/msedge-dev/msedge",
      "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
      "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel("msedge-dev", {
      "darwin": "reinstall_msedge_dev_mac.sh",
      "linux": "reinstall_msedge_dev_linux.sh",
      "win32": "reinstall_msedge_dev_win.ps1"
    })));
    this._executables.push(this._createChromiumChannel("msedge-canary", {
      "linux": "",
      "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
      "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox", {
      "linux": "/snap/bin/firefox",
      "darwin": "/Applications/Firefox.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox-beta", {
      "linux": "/opt/firefox-beta/firefox",
      "darwin": "/Applications/Firefox.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiFirefoxChannel("moz-firefox-nightly", {
      "linux": "/opt/firefox-nightly/firefox",
      "darwin": "/Applications/Firefox Nightly.app/Contents/MacOS/firefox",
      "win32": "\\Mozilla Firefox\\firefox.exe"
    }));
    this._executables.push(this._createBidiChromiumChannel("bidi-chrome-stable", {
      "linux": "/opt/google/chrome/chrome",
      "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
      "win32": `\\Google\\Chrome\\Application\\chrome.exe`
    }));
    this._executables.push(this._createBidiChromiumChannel("bidi-chrome-canary", {
      "linux": "/opt/google/chrome-canary/chrome",
      "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
      "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
    }));
    this._executables.push({
      type: "browser",
      name: "_bidiChromium",
      browserName: "_bidiChromium",
      directory: chromium2.dir,
      executablePath: /* @__PURE__ */ __name(() => chromiumExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium2.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, chromium2.dir, ["chrome-linux"], [], ["chrome-win"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(chromium2),
      browserVersion: chromium2.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(chromium2, chromiumExecutable), "_install"),
      _dependencyGroup: "chromium",
      _isHermeticInstallation: true
    });
    const firefox = descriptors.find((d) => d.name === "firefox");
    const firefoxExecutable = findExecutablePath(firefox.dir, "firefox");
    this._executables.push({
      type: "browser",
      name: "firefox",
      browserName: "firefox",
      directory: firefox.dir,
      executablePath: /* @__PURE__ */ __name(() => firefoxExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: firefox.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, firefox.dir, ["firefox"], [], ["firefox"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(firefox),
      browserVersion: firefox.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(firefox, firefoxExecutable), "_install"),
      _dependencyGroup: "firefox",
      _isHermeticInstallation: true
    });
    const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
    const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
    this._executables.push({
      type: "tool",
      name: "firefox-beta",
      browserName: "firefox",
      directory: firefoxBeta.dir,
      executablePath: /* @__PURE__ */ __name(() => firefoxBetaExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, firefoxBeta.dir, ["firefox"], [], ["firefox"]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(firefoxBeta),
      browserVersion: firefoxBeta.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable), "_install"),
      _dependencyGroup: "firefox",
      _isHermeticInstallation: true
    });
    const webkit = descriptors.find((d) => d.name === "webkit");
    const webkitExecutable = findExecutablePath(webkit.dir, "webkit");
    const webkitLinuxLddDirectories = [
      path8.join("minibrowser-gtk"),
      path8.join("minibrowser-gtk", "bin"),
      path8.join("minibrowser-gtk", "lib"),
      path8.join("minibrowser-gtk", "sys", "lib"),
      path8.join("minibrowser-wpe"),
      path8.join("minibrowser-wpe", "bin"),
      path8.join("minibrowser-wpe", "lib"),
      path8.join("minibrowser-wpe", "sys", "lib")
    ];
    this._executables.push({
      type: "browser",
      name: "webkit",
      browserName: "webkit",
      directory: webkit.dir,
      executablePath: /* @__PURE__ */ __name(() => webkitExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: webkit.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name((sdkLanguage) => this._validateHostRequirements(sdkLanguage, webkit.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(webkit),
      browserVersion: webkit.browserVersion,
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(webkit, webkitExecutable), "_install"),
      _dependencyGroup: "webkit",
      _isHermeticInstallation: true
    });
    const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
    const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
    this._executables.push({
      type: "tool",
      name: "ffmpeg",
      browserName: void 0,
      directory: ffmpeg.dir,
      executablePath: /* @__PURE__ */ __name(() => ffmpegExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(ffmpeg),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(ffmpeg, ffmpegExecutable), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
    const winldd = descriptors.find((d) => d.name === "winldd");
    const winlddExecutable = findExecutablePath(winldd.dir, "winldd");
    this._executables.push({
      type: "tool",
      name: "winldd",
      browserName: void 0,
      directory: winldd.dir,
      executablePath: /* @__PURE__ */ __name(() => winlddExecutable, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePathOrDie("winldd", winlddExecutable, winldd.installByDefault, sdkLanguage), "executablePathOrDie"),
      installType: process.platform === "win32" ? "download-by-default" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(winldd),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(winldd, winlddExecutable), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
    const android = descriptors.find((d) => d.name === "android");
    this._executables.push({
      type: "tool",
      name: "android",
      browserName: void 0,
      directory: android.dir,
      executablePath: /* @__PURE__ */ __name(() => void 0, "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name(() => "", "executablePathOrDie"),
      installType: "download-on-demand",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      downloadURLs: this._downloadURLs(android),
      _install: /* @__PURE__ */ __name(() => this._downloadExecutable(android), "_install"),
      _dependencyGroup: "tools",
      _isHermeticInstallation: true
    });
  }
  _createChromiumChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path8.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (!shouldThrow)
        return void 0;
      const location2 = prefixes.length ? ` at ${path8.join(prefixes[0], suffix)}` : ``;
      const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
      throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "chromium",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: install ? "install-script" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: false,
      _install: install
    };
  }
  _createBidiFirefoxChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Firefox distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path8.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (shouldThrow)
        throw new Error(`Cannot find Firefox installation for channel '${name}' at the standard system paths.`);
      return void 0;
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "_bidiFirefox",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: true,
      _install: install
    };
  }
  _createBidiChromiumChannel(name, lookAt, install) {
    const executablePath = /* @__PURE__ */ __name((sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];
      if (!suffix) {
        if (shouldThrow)
          throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
        return void 0;
      }
      const prefixes = process.platform === "win32" ? [
        process.env.LOCALAPPDATA,
        process.env.PROGRAMFILES,
        process.env["PROGRAMFILES(X86)"],
        // In some cases there is no PROGRAMFILES/(86) env var set but HOMEDRIVE is set.
        process.env.HOMEDRIVE + "\\Program Files",
        process.env.HOMEDRIVE + "\\Program Files (x86)"
      ].filter(Boolean) : [""];
      for (const prefix of prefixes) {
        const executablePath2 = path8.join(prefix, suffix);
        if (canAccessFile(executablePath2))
          return executablePath2;
      }
      if (!shouldThrow)
        return void 0;
      const location2 = prefixes.length ? ` at ${path8.join(prefixes[0], suffix)}` : ``;
      const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
      throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
    }, "executablePath");
    return {
      type: "channel",
      name,
      browserName: "_bidiChromium",
      directory: void 0,
      executablePath: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, false), "executablePath"),
      executablePathOrDie: /* @__PURE__ */ __name((sdkLanguage) => executablePath(sdkLanguage, true), "executablePathOrDie"),
      installType: install ? "install-script" : "none",
      _validateHostRequirements: /* @__PURE__ */ __name(() => Promise.resolve(), "_validateHostRequirements"),
      _isHermeticInstallation: false,
      _install: install
    };
  }
  executables() {
    return this._executables;
  }
  findExecutable(name) {
    return this._executables.find((b) => b.name === name);
  }
  defaultExecutables() {
    return this._executables.filter((e) => e.installType === "download-by-default");
  }
  _dedupe(executables) {
    return Array.from(new Set(executables));
  }
  async _validateHostRequirements(sdkLanguage, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
    if (os6.platform() === "linux")
      return await validateDependenciesLinux(sdkLanguage, linuxLddDirectories.map((d) => path8.join(browserDirectory, d)), dlOpenLibraries);
    if (os6.platform() === "win32" && os6.arch() === "x64")
      return await validateDependenciesWindows(sdkLanguage, windowsExeAndDllDirectories.map((d) => path8.join(browserDirectory, d)));
  }
  async installDeps(executablesToInstallDeps, dryRun) {
    const executables = this._dedupe(executablesToInstallDeps);
    const targets = /* @__PURE__ */ new Set();
    for (const executable of executables) {
      if (executable._dependencyGroup)
        targets.add(executable._dependencyGroup);
    }
    targets.add("tools");
    if (os6.platform() === "win32")
      return await installDependenciesWindows(targets, dryRun);
    if (os6.platform() === "linux")
      return await installDependenciesLinux(targets, dryRun);
  }
  async install(executablesToInstall, forceReinstall) {
    const executables = this._dedupe(executablesToInstall);
    await fs10.promises.mkdir(registryDirectory, { recursive: true });
    const lockfilePath = path8.join(registryDirectory, "__dirlock");
    const linksDir = path8.join(registryDirectory, ".links");
    let releaseLock;
    try {
      releaseLock = await lockfile2.lock(registryDirectory, {
        retries: {
          // Retry 20 times during 10 minutes with
          // exponential back-off.
          // See documentation at: https://www.npmjs.com/package/retry#retrytimeoutsoptions
          retries: 20,
          factor: 1.27579
        },
        onCompromised: /* @__PURE__ */ __name((err) => {
          throw new Error(`${err.message} Path: ${lockfilePath}`);
        }, "onCompromised"),
        lockfilePath
      });
      await fs10.promises.mkdir(linksDir, { recursive: true });
      await fs10.promises.writeFile(path8.join(linksDir, calculateSha1(PACKAGE_PATH)), PACKAGE_PATH);
      if (!getAsBooleanFromENV("PLAYWRIGHT_SKIP_BROWSER_GC"))
        await this._validateInstallationCache(linksDir);
      for (const executable of executables) {
        if (!executable._install)
          throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
        const { embedderName } = getEmbedderName();
        if (!getAsBooleanFromENV("CI") && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(embedderName)) {
          const command = buildPlaywrightCLICommand(embedderName, "install --force " + executable.name);
          process.stderr.write("\n" + wrapInASCIIBox([
            `ATTENTION: "${executable.name}" is already installed on the system!`,
            ``,
            `"${executable.name}" installation is not hermetic; installing newer version`,
            `requires *removal* of a current installation first.`,
            ``,
            `To *uninstall* current version and re-install latest "${executable.name}":`,
            ``,
            `- Close all running instances of "${executable.name}", if any`,
            `- Use "--force" to install browser:`,
            ``,
            `    ${command}`,
            ``,
            `<3 Playwright Team`
          ].join("\n"), 1) + "\n\n");
          return;
        }
        await executable._install();
      }
    } catch (e) {
      if (e.code === "ELOCKED") {
        const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
        throw new Error("\n" + wrapInASCIIBox([
          `An active lockfile is found at:`,
          ``,
          `  ${lockfilePath}`,
          ``,
          `Either:`,
          `- wait a few minutes if other Playwright is installing browsers in parallel`,
          `- remove lock manually with:`,
          ``,
          `    ${rmCommand} ${lockfilePath}`,
          ``,
          `<3 Playwright Team`
        ].join("\n"), 1));
      } else {
        throw e;
      }
    } finally {
      if (releaseLock)
        await releaseLock();
    }
  }
  async uninstall(all) {
    const linksDir = path8.join(registryDirectory, ".links");
    if (all) {
      const links = await fs10.promises.readdir(linksDir).catch(() => []);
      for (const link of links)
        await fs10.promises.unlink(path8.join(linksDir, link));
    } else {
      await fs10.promises.unlink(path8.join(linksDir, calculateSha1(PACKAGE_PATH))).catch(() => {
      });
    }
    await this._validateInstallationCache(linksDir);
    return {
      numberOfBrowsersLeft: (await fs10.promises.readdir(registryDirectory).catch(() => [])).filter((browserDirectory) => isBrowserDirectory(browserDirectory)).length
    };
  }
  async validateHostRequirementsForExecutablesIfNeeded(executables, sdkLanguage) {
    if (getAsBooleanFromENV("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
      process.stderr.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
      return;
    }
    for (const executable of executables)
      await this._validateHostRequirementsForExecutableIfNeeded(executable, sdkLanguage);
  }
  async _validateHostRequirementsForExecutableIfNeeded(executable, sdkLanguage) {
    const kMaximumReValidationPeriod = 30 * 24 * 60 * 60 * 1e3;
    if (!executable.directory)
      return;
    const markerFile = path8.join(executable.directory, "DEPENDENCIES_VALIDATED");
    if (await fs10.promises.stat(markerFile).then((stat) => Date.now() - stat.mtime.getTime() < kMaximumReValidationPeriod).catch(() => false))
      return;
    debugLogger.log("install", `validating host requirements for "${executable.name}"`);
    try {
      await executable._validateHostRequirements(sdkLanguage);
      debugLogger.log("install", `validation passed for ${executable.name}`);
    } catch (error3) {
      debugLogger.log("install", `validation failed for ${executable.name}`);
      throw error3;
    }
    await fs10.promises.writeFile(markerFile, "").catch(() => {
    });
  }
  _downloadURLs(descriptor) {
    const paths = DOWNLOAD_PATHS[descriptor.name];
    const downloadPathTemplate = paths[hostPlatform] || paths["<unknown>"];
    if (!downloadPathTemplate)
      return [];
    const downloadPath = require$$0$22.format(downloadPathTemplate, descriptor.revision);
    let downloadURLs = PLAYWRIGHT_CDN_MIRRORS.map((mirror) => `${mirror}/${downloadPath}`);
    let downloadHostEnv;
    if (descriptor.name.startsWith("chromium"))
      downloadHostEnv = "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST";
    else if (descriptor.name.startsWith("firefox"))
      downloadHostEnv = "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST";
    else if (descriptor.name.startsWith("webkit"))
      downloadHostEnv = "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST";
    const customHostOverride = downloadHostEnv && getFromENV(downloadHostEnv) || getFromENV("PLAYWRIGHT_DOWNLOAD_HOST");
    if (customHostOverride)
      downloadURLs = [`${customHostOverride}/${downloadPath}`];
    return downloadURLs;
  }
  async _downloadExecutable(descriptor, executablePath) {
    const downloadURLs = this._downloadURLs(descriptor);
    if (!downloadURLs.length)
      throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${hostPlatform}`);
    if (!isOfficiallySupportedPlatform)
      logPolitely(`BEWARE: your OS is not officially supported by Playwright; downloading fallback build for ${hostPlatform}.`);
    if (descriptor.hasRevisionOverride) {
      const message = `You are using a frozen ${descriptor.name} browser which does not receive updates anymore on ${hostPlatform}. Please update to the latest version of your operating system to test up-to-date browsers.`;
      if (process.env.GITHUB_ACTIONS)
        console.log(`::warning title=Playwright::${message}`);
      else
        logPolitely(message);
    }
    const displayName = descriptor.name.split("-").map((word) => {
      return word === "ffmpeg" ? "FFMPEG" : word.charAt(0).toUpperCase() + word.slice(1);
    }).join(" ");
    const title2 = descriptor.browserVersion ? `${displayName} ${descriptor.browserVersion} (playwright build v${descriptor.revision})` : `${displayName} playwright build v${descriptor.revision}`;
    const downloadFileName = `playwright-download-${descriptor.name}-${hostPlatform}-${descriptor.revision}.zip`;
    const downloadSocketTimeoutEnv = getFromENV("PLAYWRIGHT_DOWNLOAD_CONNECTION_TIMEOUT");
    const downloadSocketTimeout = +(downloadSocketTimeoutEnv || "0") || NET_DEFAULT_TIMEOUT;
    await downloadBrowserWithProgressBar(title2, descriptor.dir, executablePath, downloadURLs, downloadFileName, downloadSocketTimeout).catch((e) => {
      throw new Error(`Failed to download ${title2}, caused by
${e.stack}`);
    });
  }
  async _installMSEdgeChannel(channel2, scripts) {
    const scriptArgs = [];
    if (process.platform !== "linux") {
      const products = lowercaseAllKeys(JSON.parse(await fetchData(void 0, { url: "https://edgeupdates.microsoft.com/api/products" })));
      const productName = {
        "msedge": "Stable",
        "msedge-beta": "Beta",
        "msedge-dev": "Dev"
      }[channel2];
      const product = products.find((product2) => product2.product === productName);
      const searchConfig = {
        darwin: { platform: "MacOS", arch: "universal", artifact: "pkg" },
        win32: { platform: "Windows", arch: "x64", artifact: "msi" }
      }[process.platform];
      const release2 = searchConfig ? product.releases.find((release22) => release22.platform === searchConfig.platform && release22.architecture === searchConfig.arch && release22.artifacts.length > 0) : null;
      const artifact = release2 ? release2.artifacts.find((artifact2) => artifact2.artifactname === searchConfig.artifact) : null;
      if (artifact)
        scriptArgs.push(
          artifact.location
          /* url */
        );
      else
        throw new Error(`Cannot install ${channel2} on ${process.platform}`);
    }
    await this._installChromiumChannel(channel2, scripts, scriptArgs);
  }
  async _installChromiumChannel(channel2, scripts, scriptArgs = []) {
    const scriptName = scripts[process.platform];
    if (!scriptName)
      throw new Error(`Cannot install ${channel2} on ${process.platform}`);
    const cwd2 = BIN_PATH;
    const isPowerShell = scriptName.endsWith(".ps1");
    if (isPowerShell) {
      const args = [
        "-ExecutionPolicy",
        "Bypass",
        "-File",
        path8.join(BIN_PATH, scriptName),
        ...scriptArgs
      ];
      const { code } = await spawnAsync("powershell.exe", args, { cwd: cwd2, stdio: "inherit" });
      if (code !== 0)
        throw new Error(`Failed to install ${channel2}`);
    } else {
      const { command, args, elevatedPermissions } = await transformCommandsForRoot([`bash "${path8.join(BIN_PATH, scriptName)}" ${scriptArgs.join("")}`]);
      if (elevatedPermissions)
        console.log("Switching to root user to install dependencies...");
      const { code } = await spawnAsync(command, args, { cwd: cwd2, stdio: "inherit" });
      if (code !== 0)
        throw new Error(`Failed to install ${channel2}`);
    }
  }
  async listInstalledBrowsers() {
    const linksDir = path8.join(registryDirectory, ".links");
    const { browsers: browsers2 } = await this._traverseBrowserInstallations(linksDir);
    return browsers2.filter((browser3) => fs10.existsSync(browser3.browserPath));
  }
  async _validateInstallationCache(linksDir) {
    const { browsers: browsers2, brokenLinks } = await this._traverseBrowserInstallations(linksDir);
    await this._deleteStaleBrowsers(browsers2);
    await this._deleteBrokenInstallations(brokenLinks);
  }
  async _traverseBrowserInstallations(linksDir) {
    const browserList = [];
    const brokenLinks = [];
    for (const fileName of await fs10.promises.readdir(linksDir)) {
      const linkPath = path8.join(linksDir, fileName);
      let linkTarget = "";
      try {
        linkTarget = (await fs10.promises.readFile(linkPath)).toString();
        const browsersJSON = commonjsRequire(path8.join(linkTarget, "browsers.json"));
        const descriptors = readDescriptors(browsersJSON);
        for (const browserName of allDownloadable) {
          const descriptor = descriptors.find((d) => d.name === browserName);
          if (!descriptor)
            continue;
          const browserPath = descriptor.dir;
          const browserVersion = parseInt(descriptor.revision, 10);
          browserList.push({
            browserName,
            browserVersion,
            browserPath,
            referenceDir: linkTarget
          });
        }
      } catch (e) {
        brokenLinks.push(linkPath);
      }
    }
    return { browsers: browserList, brokenLinks };
  }
  async _deleteStaleBrowsers(browserList) {
    const usedBrowserPaths = /* @__PURE__ */ new Set();
    for (const browser3 of browserList) {
      const { browserName, browserVersion, browserPath } = browser3;
      const shouldHaveMarkerFile = browserName === "chromium" && (browserVersion >= 786218 || browserVersion < 3e5) || browserName === "firefox" && browserVersion >= 1128 || browserName === "webkit" && browserVersion >= 1307 || // All new applications have a marker file right away.
      browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
      if (!shouldHaveMarkerFile || await existsAsync(browserDirectoryToMarkerFilePath(browserPath)))
        usedBrowserPaths.add(browserPath);
    }
    let downloadedBrowsers = (await fs10.promises.readdir(registryDirectory)).map((file) => path8.join(registryDirectory, file));
    downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
    const directories = new Set(downloadedBrowsers);
    for (const browserDirectory of usedBrowserPaths)
      directories.delete(browserDirectory);
    for (const directory of directories)
      logPolitely("Removing unused browser at " + directory);
    await removeFolders([...directories]);
  }
  async _deleteBrokenInstallations(brokenLinks) {
    for (const linkPath of brokenLinks)
      await fs10.promises.unlink(linkPath).catch((e) => {
      });
  }
};
function browserDirectoryToMarkerFilePath(browserDirectory) {
  return path8.join(browserDirectory, "INSTALLATION_COMPLETE");
}
__name(browserDirectoryToMarkerFilePath, "browserDirectoryToMarkerFilePath");
function buildPlaywrightCLICommand(sdkLanguage, parameters) {
  switch (sdkLanguage) {
    case "python":
      return `playwright ${parameters}`;
    case "java":
      return `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="${parameters}"`;
    case "csharp":
      return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
    default: {
      const packageManagerCommand = getPackageManagerExecCommand();
      return `${packageManagerCommand} playwright ${parameters}`;
    }
  }
}
__name(buildPlaywrightCLICommand, "buildPlaywrightCLICommand");
function findChromiumChannelBestEffort(sdkLanguage) {
  let channel2 = null;
  for (const name of ["chromium", "chrome", "msedge"]) {
    try {
      registry.findExecutable(name).executablePathOrDie(sdkLanguage);
      channel2 = name === "chromium" ? void 0 : name;
      break;
    } catch (e) {
    }
  }
  if (channel2 === null) {
    const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
    const prettyMessage = [
      `No chromium-based browser found on the system.`,
      `Please run the following command to download one:`,
      ``,
      `    ${installCommand}`,
      ``,
      `<3 Playwright Team`
    ].join("\n");
    throw new Error("\n" + wrapInASCIIBox(prettyMessage, 1));
  }
  return channel2;
}
__name(findChromiumChannelBestEffort, "findChromiumChannelBestEffort");
function lowercaseAllKeys(json) {
  if (typeof json !== "object" || !json)
    return json;
  if (Array.isArray(json))
    return json.map(lowercaseAllKeys);
  const result = {};
  for (const [key, value] of Object.entries(json))
    result[key.toLowerCase()] = lowercaseAllKeys(value);
  return result;
}
__name(lowercaseAllKeys, "lowercaseAllKeys");
var registry = new Registry(require$$0);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/dispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter8 } from "node:events";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/eventsHelper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EventsHelper = class {
  static {
    __name(this, "EventsHelper");
  }
  static addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return { emitter, eventName, handler };
  }
  static removeEventListeners(listeners2) {
    for (const listener of listeners2)
      listener.emitter.removeListener(listener.eventName, listener.handler);
    listeners2.splice(0, listeners2.length);
  }
};
var eventsHelper = EventsHelper;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/protocol/validator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/protocol/validatorPrimitives.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ValidationError = class extends Error {
  static {
    __name(this, "ValidationError");
  }
};
var scheme = {};
function findValidator(type, method, kind) {
  const validator = maybeFindValidator(type, method, kind);
  if (!validator)
    throw new ValidationError(`Unknown scheme for ${kind}: ${type}.${method}`);
  return validator;
}
__name(findValidator, "findValidator");
function maybeFindValidator(type, method, kind) {
  const schemeName = type + (kind === "Initializer" ? "" : method[0].toUpperCase() + method.substring(1)) + kind;
  return scheme[schemeName];
}
__name(maybeFindValidator, "maybeFindValidator");
function createMetadataValidator() {
  return tOptional(scheme["Metadata"]);
}
__name(createMetadataValidator, "createMetadataValidator");
var tFloat = /* @__PURE__ */ __name((arg, path30, context2) => {
  if (arg instanceof Number)
    return arg.valueOf();
  if (typeof arg === "number")
    return arg;
  throw new ValidationError(`${path30}: expected float, got ${typeof arg}`);
}, "tFloat");
var tInt = /* @__PURE__ */ __name((arg, path30, context2) => {
  let value;
  if (arg instanceof Number)
    value = arg.valueOf();
  else if (typeof arg === "number")
    value = arg;
  else
    throw new ValidationError(`${path30}: expected integer, got ${typeof arg}`);
  if (!Number.isInteger(value))
    throw new ValidationError(`${path30}: expected integer, got float ${value}`);
  return value;
}, "tInt");
var tBoolean = /* @__PURE__ */ __name((arg, path30, context2) => {
  if (arg instanceof Boolean)
    return arg.valueOf();
  if (typeof arg === "boolean")
    return arg;
  throw new ValidationError(`${path30}: expected boolean, got ${typeof arg}`);
}, "tBoolean");
var tString = /* @__PURE__ */ __name((arg, path30, context2) => {
  if (arg instanceof String)
    return arg.valueOf();
  if (typeof arg === "string")
    return arg;
  throw new ValidationError(`${path30}: expected string, got ${typeof arg}`);
}, "tString");
var tBinary = /* @__PURE__ */ __name((arg, path30, context2) => {
  if (context2.binary === "fromBase64") {
    if (arg instanceof String)
      return Buffer.from(arg.valueOf(), "base64");
    if (typeof arg === "string")
      return Buffer.from(arg, "base64");
    throw new ValidationError(`${path30}: expected base64-encoded buffer, got ${typeof arg}`);
  }
  if (context2.binary === "toBase64") {
    if (!(arg instanceof Buffer))
      throw new ValidationError(`${path30}: expected Buffer, got ${typeof arg}`);
    return arg.toString("base64");
  }
  if (context2.binary === "buffer") {
    if (!(arg instanceof Buffer))
      throw new ValidationError(`${path30}: expected Buffer, got ${typeof arg}`);
    return arg;
  }
  throw new ValidationError(`Unsupported binary behavior "${context2.binary}"`);
}, "tBinary");
var tAny = /* @__PURE__ */ __name((arg, path30, context2) => {
  return arg;
}, "tAny");
var tOptional = /* @__PURE__ */ __name((v) => {
  return (arg, path30, context2) => {
    if (Object.is(arg, void 0))
      return arg;
    return v(arg, path30, context2);
  };
}, "tOptional");
var tArray = /* @__PURE__ */ __name((v) => {
  return (arg, path30, context2) => {
    if (!Array.isArray(arg))
      throw new ValidationError(`${path30}: expected array, got ${typeof arg}`);
    return arg.map((x, index2) => v(x, path30 + "[" + index2 + "]", context2));
  };
}, "tArray");
var tObject = /* @__PURE__ */ __name((s) => {
  return (arg, path30, context2) => {
    if (Object.is(arg, null))
      throw new ValidationError(`${path30}: expected object, got null`);
    if (typeof arg !== "object")
      throw new ValidationError(`${path30}: expected object, got ${typeof arg}`);
    const result = {};
    for (const [key, v] of Object.entries(s)) {
      const value = v(arg[key], path30 ? path30 + "." + key : key, context2);
      if (!Object.is(value, void 0))
        result[key] = value;
    }
    if (context2.isUnderTest()) {
      for (const [key, value] of Object.entries(arg)) {
        if (key.startsWith("__testHook"))
          result[key] = value;
      }
    }
    return result;
  };
}, "tObject");
var tEnum = /* @__PURE__ */ __name((e) => {
  return (arg, path30, context2) => {
    if (!e.includes(arg))
      throw new ValidationError(`${path30}: expected one of (${e.join("|")})`);
    return arg;
  };
}, "tEnum");
var tChannel = /* @__PURE__ */ __name((names) => {
  return (arg, path30, context2) => {
    return context2.tChannelImpl(names, arg, path30, context2);
  };
}, "tChannel");
var tType = /* @__PURE__ */ __name((name) => {
  return (arg, path30, context2) => {
    const v = scheme[name];
    if (!v)
      throw new ValidationError(path30 + ': unknown type "' + name + '"');
    return v(arg, path30, context2);
  };
}, "tType");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/protocol/validator.js
scheme.StackFrame = tObject({
  file: tString,
  line: tInt,
  column: tInt,
  function: tOptional(tString)
});
scheme.Metadata = tObject({
  location: tOptional(tObject({
    file: tString,
    line: tOptional(tInt),
    column: tOptional(tInt)
  })),
  title: tOptional(tString),
  internal: tOptional(tBoolean),
  stepId: tOptional(tString)
});
scheme.ClientSideCallMetadata = tObject({
  id: tInt,
  stack: tOptional(tArray(tType("StackFrame")))
});
scheme.Point = tObject({
  x: tFloat,
  y: tFloat
});
scheme.Rect = tObject({
  x: tFloat,
  y: tFloat,
  width: tFloat,
  height: tFloat
});
scheme.SerializedValue = tObject({
  n: tOptional(tFloat),
  b: tOptional(tBoolean),
  s: tOptional(tString),
  v: tOptional(tEnum(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
  d: tOptional(tString),
  u: tOptional(tString),
  bi: tOptional(tString),
  ta: tOptional(tObject({
    b: tBinary,
    k: tEnum(["i8", "ui8", "ui8c", "i16", "ui16", "i32", "ui32", "f32", "f64", "bi64", "bui64"])
  })),
  e: tOptional(tObject({
    m: tString,
    n: tString,
    s: tString
  })),
  r: tOptional(tObject({
    p: tString,
    f: tString
  })),
  a: tOptional(tArray(tType("SerializedValue"))),
  o: tOptional(tArray(tObject({
    k: tString,
    v: tType("SerializedValue")
  }))),
  h: tOptional(tInt),
  id: tOptional(tInt),
  ref: tOptional(tInt)
});
scheme.SerializedArgument = tObject({
  value: tType("SerializedValue"),
  handles: tArray(tChannel("*"))
});
scheme.ExpectedTextValue = tObject({
  string: tOptional(tString),
  regexSource: tOptional(tString),
  regexFlags: tOptional(tString),
  matchSubstring: tOptional(tBoolean),
  ignoreCase: tOptional(tBoolean),
  normalizeWhiteSpace: tOptional(tBoolean)
});
scheme.SelectorEngine = tObject({
  name: tString,
  source: tString,
  contentScript: tOptional(tBoolean)
});
scheme.AXNode = tObject({
  role: tString,
  name: tString,
  valueString: tOptional(tString),
  valueNumber: tOptional(tFloat),
  description: tOptional(tString),
  keyshortcuts: tOptional(tString),
  roledescription: tOptional(tString),
  valuetext: tOptional(tString),
  disabled: tOptional(tBoolean),
  expanded: tOptional(tBoolean),
  focused: tOptional(tBoolean),
  modal: tOptional(tBoolean),
  multiline: tOptional(tBoolean),
  multiselectable: tOptional(tBoolean),
  readonly: tOptional(tBoolean),
  required: tOptional(tBoolean),
  selected: tOptional(tBoolean),
  checked: tOptional(tEnum(["checked", "unchecked", "mixed"])),
  pressed: tOptional(tEnum(["pressed", "released", "mixed"])),
  level: tOptional(tInt),
  valuemin: tOptional(tFloat),
  valuemax: tOptional(tFloat),
  autocomplete: tOptional(tString),
  haspopup: tOptional(tString),
  invalid: tOptional(tString),
  orientation: tOptional(tString),
  children: tOptional(tArray(tType("AXNode")))
});
scheme.SetNetworkCookie = tObject({
  name: tString,
  value: tString,
  url: tOptional(tString),
  domain: tOptional(tString),
  path: tOptional(tString),
  expires: tOptional(tFloat),
  httpOnly: tOptional(tBoolean),
  secure: tOptional(tBoolean),
  sameSite: tOptional(tEnum(["Strict", "Lax", "None"])),
  partitionKey: tOptional(tString),
  _crHasCrossSiteAncestor: tOptional(tBoolean)
});
scheme.NetworkCookie = tObject({
  name: tString,
  value: tString,
  domain: tString,
  path: tString,
  expires: tFloat,
  httpOnly: tBoolean,
  secure: tBoolean,
  sameSite: tEnum(["Strict", "Lax", "None"]),
  partitionKey: tOptional(tString),
  _crHasCrossSiteAncestor: tOptional(tBoolean)
});
scheme.NameValue = tObject({
  name: tString,
  value: tString
});
scheme.IndexedDBDatabase = tObject({
  name: tString,
  version: tInt,
  stores: tArray(tObject({
    name: tString,
    autoIncrement: tBoolean,
    keyPath: tOptional(tString),
    keyPathArray: tOptional(tArray(tString)),
    records: tArray(tObject({
      key: tOptional(tAny),
      keyEncoded: tOptional(tAny),
      value: tOptional(tAny),
      valueEncoded: tOptional(tAny)
    })),
    indexes: tArray(tObject({
      name: tString,
      keyPath: tOptional(tString),
      keyPathArray: tOptional(tArray(tString)),
      multiEntry: tBoolean,
      unique: tBoolean
    }))
  }))
});
scheme.SetOriginStorage = tObject({
  origin: tString,
  localStorage: tArray(tType("NameValue")),
  indexedDB: tOptional(tArray(tType("IndexedDBDatabase")))
});
scheme.OriginStorage = tObject({
  origin: tString,
  localStorage: tArray(tType("NameValue")),
  indexedDB: tOptional(tArray(tType("IndexedDBDatabase")))
});
scheme.SerializedError = tObject({
  error: tOptional(tObject({
    message: tString,
    name: tString,
    stack: tOptional(tString)
  })),
  value: tOptional(tType("SerializedValue"))
});
scheme.RecordHarOptions = tObject({
  zip: tOptional(tBoolean),
  content: tOptional(tEnum(["embed", "attach", "omit"])),
  mode: tOptional(tEnum(["full", "minimal"])),
  urlGlob: tOptional(tString),
  urlRegexSource: tOptional(tString),
  urlRegexFlags: tOptional(tString)
});
scheme.FormField = tObject({
  name: tString,
  value: tOptional(tString),
  file: tOptional(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))
});
scheme.SDKLanguage = tEnum(["javascript", "python", "java", "csharp"]);
scheme.APIRequestContextInitializer = tObject({
  tracing: tChannel(["Tracing"])
});
scheme.APIRequestContextFetchParams = tObject({
  url: tString,
  encodedParams: tOptional(tString),
  params: tOptional(tArray(tType("NameValue"))),
  method: tOptional(tString),
  headers: tOptional(tArray(tType("NameValue"))),
  postData: tOptional(tBinary),
  jsonData: tOptional(tString),
  formData: tOptional(tArray(tType("NameValue"))),
  multipartData: tOptional(tArray(tType("FormField"))),
  timeout: tFloat,
  failOnStatusCode: tOptional(tBoolean),
  ignoreHTTPSErrors: tOptional(tBoolean),
  maxRedirects: tOptional(tInt),
  maxRetries: tOptional(tInt)
});
scheme.APIRequestContextFetchResult = tObject({
  response: tType("APIResponse")
});
scheme.APIRequestContextFetchResponseBodyParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextFetchResponseBodyResult = tObject({
  binary: tOptional(tBinary)
});
scheme.APIRequestContextFetchLogParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextFetchLogResult = tObject({
  log: tArray(tString)
});
scheme.APIRequestContextStorageStateParams = tObject({
  indexedDB: tOptional(tBoolean)
});
scheme.APIRequestContextStorageStateResult = tObject({
  cookies: tArray(tType("NetworkCookie")),
  origins: tArray(tType("OriginStorage"))
});
scheme.APIRequestContextDisposeAPIResponseParams = tObject({
  fetchUid: tString
});
scheme.APIRequestContextDisposeAPIResponseResult = tOptional(tObject({}));
scheme.APIRequestContextDisposeParams = tObject({
  reason: tOptional(tString)
});
scheme.APIRequestContextDisposeResult = tOptional(tObject({}));
scheme.APIResponse = tObject({
  fetchUid: tString,
  url: tString,
  status: tInt,
  statusText: tString,
  headers: tArray(tType("NameValue"))
});
scheme.LifecycleEvent = tEnum(["load", "domcontentloaded", "networkidle", "commit"]);
scheme.LocalUtilsInitializer = tObject({
  deviceDescriptors: tArray(tObject({
    name: tString,
    descriptor: tObject({
      userAgent: tString,
      viewport: tObject({
        width: tInt,
        height: tInt
      }),
      screen: tOptional(tObject({
        width: tInt,
        height: tInt
      })),
      deviceScaleFactor: tFloat,
      isMobile: tBoolean,
      hasTouch: tBoolean,
      defaultBrowserType: tEnum(["chromium", "firefox", "webkit"])
    })
  }))
});
scheme.LocalUtilsZipParams = tObject({
  zipFile: tString,
  entries: tArray(tType("NameValue")),
  stacksId: tOptional(tString),
  mode: tEnum(["write", "append"]),
  includeSources: tBoolean
});
scheme.LocalUtilsZipResult = tOptional(tObject({}));
scheme.LocalUtilsHarOpenParams = tObject({
  file: tString
});
scheme.LocalUtilsHarOpenResult = tObject({
  harId: tOptional(tString),
  error: tOptional(tString)
});
scheme.LocalUtilsHarLookupParams = tObject({
  harId: tString,
  url: tString,
  method: tString,
  headers: tArray(tType("NameValue")),
  postData: tOptional(tBinary),
  isNavigationRequest: tBoolean
});
scheme.LocalUtilsHarLookupResult = tObject({
  action: tEnum(["error", "redirect", "fulfill", "noentry"]),
  message: tOptional(tString),
  redirectURL: tOptional(tString),
  status: tOptional(tInt),
  headers: tOptional(tArray(tType("NameValue"))),
  body: tOptional(tBinary)
});
scheme.LocalUtilsHarCloseParams = tObject({
  harId: tString
});
scheme.LocalUtilsHarCloseResult = tOptional(tObject({}));
scheme.LocalUtilsHarUnzipParams = tObject({
  zipFile: tString,
  harFile: tString
});
scheme.LocalUtilsHarUnzipResult = tOptional(tObject({}));
scheme.LocalUtilsConnectParams = tObject({
  wsEndpoint: tString,
  headers: tOptional(tAny),
  exposeNetwork: tOptional(tString),
  slowMo: tOptional(tFloat),
  timeout: tFloat,
  socksProxyRedirectPortForTest: tOptional(tInt)
});
scheme.LocalUtilsConnectResult = tObject({
  pipe: tChannel(["JsonPipe"]),
  headers: tArray(tType("NameValue"))
});
scheme.LocalUtilsTracingStartedParams = tObject({
  tracesDir: tOptional(tString),
  traceName: tString
});
scheme.LocalUtilsTracingStartedResult = tObject({
  stacksId: tString
});
scheme.LocalUtilsAddStackToTracingNoReplyParams = tObject({
  callData: tType("ClientSideCallMetadata")
});
scheme.LocalUtilsAddStackToTracingNoReplyResult = tOptional(tObject({}));
scheme.LocalUtilsTraceDiscardedParams = tObject({
  stacksId: tString
});
scheme.LocalUtilsTraceDiscardedResult = tOptional(tObject({}));
scheme.LocalUtilsGlobToRegexParams = tObject({
  glob: tString,
  baseURL: tOptional(tString),
  webSocketUrl: tOptional(tBoolean)
});
scheme.LocalUtilsGlobToRegexResult = tObject({
  regex: tString
});
scheme.RootInitializer = tOptional(tObject({}));
scheme.RootInitializeParams = tObject({
  sdkLanguage: tType("SDKLanguage")
});
scheme.RootInitializeResult = tObject({
  playwright: tChannel(["Playwright"])
});
scheme.PlaywrightInitializer = tObject({
  chromium: tChannel(["BrowserType"]),
  firefox: tChannel(["BrowserType"]),
  webkit: tChannel(["BrowserType"]),
  _bidiChromium: tChannel(["BrowserType"]),
  _bidiFirefox: tChannel(["BrowserType"]),
  android: tChannel(["Android"]),
  electron: tChannel(["Electron"]),
  utils: tOptional(tChannel(["LocalUtils"])),
  preLaunchedBrowser: tOptional(tChannel(["Browser"])),
  preConnectedAndroidDevice: tOptional(tChannel(["AndroidDevice"])),
  socksSupport: tOptional(tChannel(["SocksSupport"]))
});
scheme.PlaywrightNewRequestParams = tObject({
  baseURL: tOptional(tString),
  userAgent: tOptional(tString),
  ignoreHTTPSErrors: tOptional(tBoolean),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  failOnStatusCode: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  maxRedirects: tOptional(tInt),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("NetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  })),
  tracesDir: tOptional(tString)
});
scheme.PlaywrightNewRequestResult = tObject({
  request: tChannel(["APIRequestContext"])
});
scheme.RecorderSource = tObject({
  isRecorded: tBoolean,
  id: tString,
  label: tString,
  text: tString,
  language: tString,
  highlight: tArray(tObject({
    line: tInt,
    type: tString
  })),
  revealLine: tOptional(tInt),
  group: tOptional(tString)
});
scheme.DebugControllerInitializer = tOptional(tObject({}));
scheme.DebugControllerInspectRequestedEvent = tObject({
  selector: tString,
  locator: tString,
  ariaSnapshot: tString
});
scheme.DebugControllerSetModeRequestedEvent = tObject({
  mode: tString
});
scheme.DebugControllerStateChangedEvent = tObject({
  pageCount: tInt,
  browsers: tArray(tObject({
    id: tString,
    name: tString,
    channel: tOptional(tString),
    contexts: tArray(tObject({
      pages: tArray(tObject({
        url: tString
      }))
    }))
  }))
});
scheme.DebugControllerSourceChangedEvent = tObject({
  text: tString,
  header: tOptional(tString),
  footer: tOptional(tString),
  actions: tOptional(tArray(tString))
});
scheme.DebugControllerPausedEvent = tObject({
  paused: tBoolean
});
scheme.DebugControllerInitializeParams = tObject({
  codegenId: tString,
  sdkLanguage: tType("SDKLanguage")
});
scheme.DebugControllerInitializeResult = tOptional(tObject({}));
scheme.DebugControllerSetReportStateChangedParams = tObject({
  enabled: tBoolean
});
scheme.DebugControllerSetReportStateChangedResult = tOptional(tObject({}));
scheme.DebugControllerSetRecorderModeParams = tObject({
  mode: tEnum(["inspecting", "recording", "none"]),
  testIdAttributeName: tOptional(tString),
  generateAutoExpect: tOptional(tBoolean)
});
scheme.DebugControllerSetRecorderModeResult = tOptional(tObject({}));
scheme.DebugControllerHighlightParams = tObject({
  selector: tOptional(tString),
  ariaTemplate: tOptional(tString)
});
scheme.DebugControllerHighlightResult = tOptional(tObject({}));
scheme.DebugControllerHideHighlightParams = tOptional(tObject({}));
scheme.DebugControllerHideHighlightResult = tOptional(tObject({}));
scheme.DebugControllerResumeParams = tOptional(tObject({}));
scheme.DebugControllerResumeResult = tOptional(tObject({}));
scheme.DebugControllerKillParams = tOptional(tObject({}));
scheme.DebugControllerKillResult = tOptional(tObject({}));
scheme.SocksSupportInitializer = tOptional(tObject({}));
scheme.SocksSupportSocksRequestedEvent = tObject({
  uid: tString,
  host: tString,
  port: tInt
});
scheme.SocksSupportSocksDataEvent = tObject({
  uid: tString,
  data: tBinary
});
scheme.SocksSupportSocksClosedEvent = tObject({
  uid: tString
});
scheme.SocksSupportSocksConnectedParams = tObject({
  uid: tString,
  host: tString,
  port: tInt
});
scheme.SocksSupportSocksConnectedResult = tOptional(tObject({}));
scheme.SocksSupportSocksFailedParams = tObject({
  uid: tString,
  errorCode: tString
});
scheme.SocksSupportSocksFailedResult = tOptional(tObject({}));
scheme.SocksSupportSocksDataParams = tObject({
  uid: tString,
  data: tBinary
});
scheme.SocksSupportSocksDataResult = tOptional(tObject({}));
scheme.SocksSupportSocksErrorParams = tObject({
  uid: tString,
  error: tString
});
scheme.SocksSupportSocksErrorResult = tOptional(tObject({}));
scheme.SocksSupportSocksEndParams = tObject({
  uid: tString
});
scheme.SocksSupportSocksEndResult = tOptional(tObject({}));
scheme.BrowserTypeInitializer = tObject({
  executablePath: tString,
  name: tString
});
scheme.BrowserTypeLaunchParams = tObject({
  channel: tOptional(tString),
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  ignoreAllDefaultArgs: tOptional(tBoolean),
  ignoreDefaultArgs: tOptional(tArray(tString)),
  assistantMode: tOptional(tBoolean),
  handleSIGINT: tOptional(tBoolean),
  handleSIGTERM: tOptional(tBoolean),
  handleSIGHUP: tOptional(tBoolean),
  timeout: tFloat,
  env: tOptional(tArray(tType("NameValue"))),
  headless: tOptional(tBoolean),
  devtools: tOptional(tBoolean),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  downloadsPath: tOptional(tString),
  tracesDir: tOptional(tString),
  chromiumSandbox: tOptional(tBoolean),
  firefoxUserPrefs: tOptional(tAny),
  cdpPort: tOptional(tInt),
  slowMo: tOptional(tFloat)
});
scheme.BrowserTypeLaunchResult = tObject({
  browser: tChannel(["Browser"])
});
scheme.BrowserTypeLaunchPersistentContextParams = tObject({
  channel: tOptional(tString),
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  ignoreAllDefaultArgs: tOptional(tBoolean),
  ignoreDefaultArgs: tOptional(tArray(tString)),
  assistantMode: tOptional(tBoolean),
  handleSIGINT: tOptional(tBoolean),
  handleSIGTERM: tOptional(tBoolean),
  handleSIGHUP: tOptional(tBoolean),
  timeout: tFloat,
  env: tOptional(tArray(tType("NameValue"))),
  headless: tOptional(tBoolean),
  devtools: tOptional(tBoolean),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  downloadsPath: tOptional(tString),
  tracesDir: tOptional(tString),
  chromiumSandbox: tOptional(tBoolean),
  firefoxUserPrefs: tOptional(tAny),
  cdpPort: tOptional(tInt),
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  screen: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tFloat),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tInt,
      height: tInt
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
  testIdAttributeName: tOptional(tString),
  userDataDir: tString,
  slowMo: tOptional(tFloat)
});
scheme.BrowserTypeLaunchPersistentContextResult = tObject({
  browser: tChannel(["Browser"]),
  context: tChannel(["BrowserContext"])
});
scheme.BrowserTypeConnectOverCDPParams = tObject({
  endpointURL: tString,
  headers: tOptional(tArray(tType("NameValue"))),
  slowMo: tOptional(tFloat),
  timeout: tFloat
});
scheme.BrowserTypeConnectOverCDPResult = tObject({
  browser: tChannel(["Browser"]),
  defaultContext: tOptional(tChannel(["BrowserContext"]))
});
scheme.BrowserInitializer = tObject({
  version: tString,
  name: tString
});
scheme.BrowserContextEvent = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserCloseEvent = tOptional(tObject({}));
scheme.BrowserCloseParams = tObject({
  reason: tOptional(tString)
});
scheme.BrowserCloseResult = tOptional(tObject({}));
scheme.BrowserKillForTestsParams = tOptional(tObject({}));
scheme.BrowserKillForTestsResult = tOptional(tObject({}));
scheme.BrowserDefaultUserAgentForTestParams = tOptional(tObject({}));
scheme.BrowserDefaultUserAgentForTestResult = tObject({
  userAgent: tString
});
scheme.BrowserNewContextParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  screen: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tFloat),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tInt,
      height: tInt
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
  testIdAttributeName: tOptional(tString),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("SetNetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  }))
});
scheme.BrowserNewContextResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserNewContextForReuseParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  screen: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tFloat),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tInt,
      height: tInt
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
  testIdAttributeName: tOptional(tString),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  })),
  storageState: tOptional(tObject({
    cookies: tOptional(tArray(tType("SetNetworkCookie"))),
    origins: tOptional(tArray(tType("SetOriginStorage")))
  }))
});
scheme.BrowserNewContextForReuseResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.BrowserDisconnectFromReusedContextParams = tObject({
  reason: tString
});
scheme.BrowserDisconnectFromReusedContextResult = tOptional(tObject({}));
scheme.BrowserNewBrowserCDPSessionParams = tOptional(tObject({}));
scheme.BrowserNewBrowserCDPSessionResult = tObject({
  session: tChannel(["CDPSession"])
});
scheme.BrowserStartTracingParams = tObject({
  page: tOptional(tChannel(["Page"])),
  screenshots: tOptional(tBoolean),
  categories: tOptional(tArray(tString))
});
scheme.BrowserStartTracingResult = tOptional(tObject({}));
scheme.BrowserStopTracingParams = tOptional(tObject({}));
scheme.BrowserStopTracingResult = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.EventTargetInitializer = tOptional(tObject({}));
scheme.EventTargetWaitForEventInfoParams = tObject({
  info: tObject({
    waitId: tString,
    phase: tEnum(["before", "after", "log"]),
    event: tOptional(tString),
    message: tOptional(tString),
    error: tOptional(tString)
  })
});
scheme.BrowserContextWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.PageWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.WebSocketWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.ElectronApplicationWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.AndroidDeviceWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
scheme.EventTargetWaitForEventInfoResult = tOptional(tObject({}));
scheme.BrowserContextWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.PageWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.WebSocketWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.ElectronApplicationWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.AndroidDeviceWaitForEventInfoResult = tType("EventTargetWaitForEventInfoResult");
scheme.BrowserContextInitializer = tObject({
  isChromium: tBoolean,
  requestContext: tChannel(["APIRequestContext"]),
  tracing: tChannel(["Tracing"]),
  options: tObject({
    noDefaultViewport: tOptional(tBoolean),
    viewport: tOptional(tObject({
      width: tInt,
      height: tInt
    })),
    screen: tOptional(tObject({
      width: tInt,
      height: tInt
    })),
    ignoreHTTPSErrors: tOptional(tBoolean),
    clientCertificates: tOptional(tArray(tObject({
      origin: tString,
      cert: tOptional(tBinary),
      key: tOptional(tBinary),
      passphrase: tOptional(tString),
      pfx: tOptional(tBinary)
    }))),
    javaScriptEnabled: tOptional(tBoolean),
    bypassCSP: tOptional(tBoolean),
    userAgent: tOptional(tString),
    locale: tOptional(tString),
    timezoneId: tOptional(tString),
    geolocation: tOptional(tObject({
      longitude: tFloat,
      latitude: tFloat,
      accuracy: tOptional(tFloat)
    })),
    permissions: tOptional(tArray(tString)),
    extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
    offline: tOptional(tBoolean),
    httpCredentials: tOptional(tObject({
      username: tString,
      password: tString,
      origin: tOptional(tString),
      send: tOptional(tEnum(["always", "unauthorized"]))
    })),
    deviceScaleFactor: tOptional(tFloat),
    isMobile: tOptional(tBoolean),
    hasTouch: tOptional(tBoolean),
    colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
    reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
    forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
    acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
    contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
    baseURL: tOptional(tString),
    recordVideo: tOptional(tObject({
      dir: tString,
      size: tOptional(tObject({
        width: tInt,
        height: tInt
      }))
    })),
    strictSelectors: tOptional(tBoolean),
    serviceWorkers: tOptional(tEnum(["allow", "block"])),
    selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
    testIdAttributeName: tOptional(tString)
  })
});
scheme.BrowserContextBindingCallEvent = tObject({
  binding: tChannel(["BindingCall"])
});
scheme.BrowserContextConsoleEvent = tObject({
  type: tString,
  text: tString,
  args: tArray(tChannel(["ElementHandle", "JSHandle"])),
  location: tObject({
    url: tString,
    lineNumber: tInt,
    columnNumber: tInt
  }),
  page: tChannel(["Page"])
});
scheme.BrowserContextCloseEvent = tOptional(tObject({}));
scheme.BrowserContextDialogEvent = tObject({
  dialog: tChannel(["Dialog"])
});
scheme.BrowserContextPageEvent = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextPageErrorEvent = tObject({
  error: tType("SerializedError"),
  page: tChannel(["Page"])
});
scheme.BrowserContextRouteEvent = tObject({
  route: tChannel(["Route"])
});
scheme.BrowserContextWebSocketRouteEvent = tObject({
  webSocketRoute: tChannel(["WebSocketRoute"])
});
scheme.BrowserContextVideoEvent = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.BrowserContextBackgroundPageEvent = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextServiceWorkerEvent = tObject({
  worker: tChannel(["Worker"])
});
scheme.BrowserContextRequestEvent = tObject({
  request: tChannel(["Request"]),
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextRequestFailedEvent = tObject({
  request: tChannel(["Request"]),
  failureText: tOptional(tString),
  responseEndTiming: tFloat,
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextRequestFinishedEvent = tObject({
  request: tChannel(["Request"]),
  response: tOptional(tChannel(["Response"])),
  responseEndTiming: tFloat,
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextResponseEvent = tObject({
  response: tChannel(["Response"]),
  page: tOptional(tChannel(["Page"]))
});
scheme.BrowserContextRecorderEventEvent = tObject({
  event: tEnum(["actionAdded", "actionUpdated", "signalAdded"]),
  data: tAny,
  page: tChannel(["Page"]),
  code: tString
});
scheme.BrowserContextAddCookiesParams = tObject({
  cookies: tArray(tType("SetNetworkCookie"))
});
scheme.BrowserContextAddCookiesResult = tOptional(tObject({}));
scheme.BrowserContextAddInitScriptParams = tObject({
  source: tString
});
scheme.BrowserContextAddInitScriptResult = tOptional(tObject({}));
scheme.BrowserContextClearCookiesParams = tObject({
  name: tOptional(tString),
  nameRegexSource: tOptional(tString),
  nameRegexFlags: tOptional(tString),
  domain: tOptional(tString),
  domainRegexSource: tOptional(tString),
  domainRegexFlags: tOptional(tString),
  path: tOptional(tString),
  pathRegexSource: tOptional(tString),
  pathRegexFlags: tOptional(tString)
});
scheme.BrowserContextClearCookiesResult = tOptional(tObject({}));
scheme.BrowserContextClearPermissionsParams = tOptional(tObject({}));
scheme.BrowserContextClearPermissionsResult = tOptional(tObject({}));
scheme.BrowserContextCloseParams = tObject({
  reason: tOptional(tString)
});
scheme.BrowserContextCloseResult = tOptional(tObject({}));
scheme.BrowserContextCookiesParams = tObject({
  urls: tArray(tString)
});
scheme.BrowserContextCookiesResult = tObject({
  cookies: tArray(tType("NetworkCookie"))
});
scheme.BrowserContextExposeBindingParams = tObject({
  name: tString,
  needsHandle: tOptional(tBoolean)
});
scheme.BrowserContextExposeBindingResult = tOptional(tObject({}));
scheme.BrowserContextGrantPermissionsParams = tObject({
  permissions: tArray(tString),
  origin: tOptional(tString)
});
scheme.BrowserContextGrantPermissionsResult = tOptional(tObject({}));
scheme.BrowserContextNewPageParams = tOptional(tObject({}));
scheme.BrowserContextNewPageResult = tObject({
  page: tChannel(["Page"])
});
scheme.BrowserContextRegisterSelectorEngineParams = tObject({
  selectorEngine: tType("SelectorEngine")
});
scheme.BrowserContextRegisterSelectorEngineResult = tOptional(tObject({}));
scheme.BrowserContextSetTestIdAttributeNameParams = tObject({
  testIdAttributeName: tString
});
scheme.BrowserContextSetTestIdAttributeNameResult = tOptional(tObject({}));
scheme.BrowserContextSetExtraHTTPHeadersParams = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.BrowserContextSetExtraHTTPHeadersResult = tOptional(tObject({}));
scheme.BrowserContextSetGeolocationParams = tObject({
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  }))
});
scheme.BrowserContextSetGeolocationResult = tOptional(tObject({}));
scheme.BrowserContextSetHTTPCredentialsParams = tObject({
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString)
  }))
});
scheme.BrowserContextSetHTTPCredentialsResult = tOptional(tObject({}));
scheme.BrowserContextSetNetworkInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.BrowserContextSetNetworkInterceptionPatternsResult = tOptional(tObject({}));
scheme.BrowserContextSetWebSocketInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.BrowserContextSetWebSocketInterceptionPatternsResult = tOptional(tObject({}));
scheme.BrowserContextSetOfflineParams = tObject({
  offline: tBoolean
});
scheme.BrowserContextSetOfflineResult = tOptional(tObject({}));
scheme.BrowserContextStorageStateParams = tObject({
  indexedDB: tOptional(tBoolean)
});
scheme.BrowserContextStorageStateResult = tObject({
  cookies: tArray(tType("NetworkCookie")),
  origins: tArray(tType("OriginStorage"))
});
scheme.BrowserContextPauseParams = tOptional(tObject({}));
scheme.BrowserContextPauseResult = tOptional(tObject({}));
scheme.BrowserContextEnableRecorderParams = tObject({
  language: tOptional(tString),
  mode: tOptional(tEnum(["inspecting", "recording"])),
  recorderMode: tOptional(tEnum(["default", "api"])),
  pauseOnNextStatement: tOptional(tBoolean),
  testIdAttributeName: tOptional(tString),
  launchOptions: tOptional(tAny),
  contextOptions: tOptional(tAny),
  device: tOptional(tString),
  saveStorage: tOptional(tString),
  outputFile: tOptional(tString),
  handleSIGINT: tOptional(tBoolean),
  omitCallTracking: tOptional(tBoolean)
});
scheme.BrowserContextEnableRecorderResult = tOptional(tObject({}));
scheme.BrowserContextDisableRecorderParams = tOptional(tObject({}));
scheme.BrowserContextDisableRecorderResult = tOptional(tObject({}));
scheme.BrowserContextNewCDPSessionParams = tObject({
  page: tOptional(tChannel(["Page"])),
  frame: tOptional(tChannel(["Frame"]))
});
scheme.BrowserContextNewCDPSessionResult = tObject({
  session: tChannel(["CDPSession"])
});
scheme.BrowserContextHarStartParams = tObject({
  page: tOptional(tChannel(["Page"])),
  options: tType("RecordHarOptions")
});
scheme.BrowserContextHarStartResult = tObject({
  harId: tString
});
scheme.BrowserContextHarExportParams = tObject({
  harId: tOptional(tString)
});
scheme.BrowserContextHarExportResult = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.BrowserContextCreateTempFilesParams = tObject({
  rootDirName: tOptional(tString),
  items: tArray(tObject({
    name: tString,
    lastModifiedMs: tOptional(tFloat)
  }))
});
scheme.BrowserContextCreateTempFilesResult = tObject({
  rootDir: tOptional(tChannel(["WritableStream"])),
  writableStreams: tArray(tChannel(["WritableStream"]))
});
scheme.BrowserContextUpdateSubscriptionParams = tObject({
  event: tEnum(["console", "dialog", "request", "response", "requestFinished", "requestFailed"]),
  enabled: tBoolean
});
scheme.BrowserContextUpdateSubscriptionResult = tOptional(tObject({}));
scheme.BrowserContextClockFastForwardParams = tObject({
  ticksNumber: tOptional(tFloat),
  ticksString: tOptional(tString)
});
scheme.BrowserContextClockFastForwardResult = tOptional(tObject({}));
scheme.BrowserContextClockInstallParams = tObject({
  timeNumber: tOptional(tFloat),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockInstallResult = tOptional(tObject({}));
scheme.BrowserContextClockPauseAtParams = tObject({
  timeNumber: tOptional(tFloat),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockPauseAtResult = tOptional(tObject({}));
scheme.BrowserContextClockResumeParams = tOptional(tObject({}));
scheme.BrowserContextClockResumeResult = tOptional(tObject({}));
scheme.BrowserContextClockRunForParams = tObject({
  ticksNumber: tOptional(tFloat),
  ticksString: tOptional(tString)
});
scheme.BrowserContextClockRunForResult = tOptional(tObject({}));
scheme.BrowserContextClockSetFixedTimeParams = tObject({
  timeNumber: tOptional(tFloat),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockSetFixedTimeResult = tOptional(tObject({}));
scheme.BrowserContextClockSetSystemTimeParams = tObject({
  timeNumber: tOptional(tFloat),
  timeString: tOptional(tString)
});
scheme.BrowserContextClockSetSystemTimeResult = tOptional(tObject({}));
scheme.PageInitializer = tObject({
  mainFrame: tChannel(["Frame"]),
  viewportSize: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  isClosed: tBoolean,
  opener: tOptional(tChannel(["Page"]))
});
scheme.PageBindingCallEvent = tObject({
  binding: tChannel(["BindingCall"])
});
scheme.PageCloseEvent = tOptional(tObject({}));
scheme.PageCrashEvent = tOptional(tObject({}));
scheme.PageDownloadEvent = tObject({
  url: tString,
  suggestedFilename: tString,
  artifact: tChannel(["Artifact"])
});
scheme.PageViewportSizeChangedEvent = tObject({
  viewportSize: tOptional(tObject({
    width: tInt,
    height: tInt
  }))
});
scheme.PageFileChooserEvent = tObject({
  element: tChannel(["ElementHandle"]),
  isMultiple: tBoolean
});
scheme.PageFrameAttachedEvent = tObject({
  frame: tChannel(["Frame"])
});
scheme.PageFrameDetachedEvent = tObject({
  frame: tChannel(["Frame"])
});
scheme.PageLocatorHandlerTriggeredEvent = tObject({
  uid: tInt
});
scheme.PageRouteEvent = tObject({
  route: tChannel(["Route"])
});
scheme.PageWebSocketRouteEvent = tObject({
  webSocketRoute: tChannel(["WebSocketRoute"])
});
scheme.PageVideoEvent = tObject({
  artifact: tChannel(["Artifact"])
});
scheme.PageWebSocketEvent = tObject({
  webSocket: tChannel(["WebSocket"])
});
scheme.PageWorkerEvent = tObject({
  worker: tChannel(["Worker"])
});
scheme.PageAddInitScriptParams = tObject({
  source: tString
});
scheme.PageAddInitScriptResult = tOptional(tObject({}));
scheme.PageCloseParams = tObject({
  runBeforeUnload: tOptional(tBoolean),
  reason: tOptional(tString)
});
scheme.PageCloseResult = tOptional(tObject({}));
scheme.PageEmulateMediaParams = tObject({
  media: tOptional(tEnum(["screen", "print", "no-override"])),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"]))
});
scheme.PageEmulateMediaResult = tOptional(tObject({}));
scheme.PageExposeBindingParams = tObject({
  name: tString,
  needsHandle: tOptional(tBoolean)
});
scheme.PageExposeBindingResult = tOptional(tObject({}));
scheme.PageGoBackParams = tObject({
  timeout: tFloat,
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageGoBackResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageGoForwardParams = tObject({
  timeout: tFloat,
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageGoForwardResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageRequestGCParams = tOptional(tObject({}));
scheme.PageRequestGCResult = tOptional(tObject({}));
scheme.PageRegisterLocatorHandlerParams = tObject({
  selector: tString,
  noWaitAfter: tOptional(tBoolean)
});
scheme.PageRegisterLocatorHandlerResult = tObject({
  uid: tInt
});
scheme.PageResolveLocatorHandlerNoReplyParams = tObject({
  uid: tInt,
  remove: tOptional(tBoolean)
});
scheme.PageResolveLocatorHandlerNoReplyResult = tOptional(tObject({}));
scheme.PageUnregisterLocatorHandlerParams = tObject({
  uid: tInt
});
scheme.PageUnregisterLocatorHandlerResult = tOptional(tObject({}));
scheme.PageReloadParams = tObject({
  timeout: tFloat,
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.PageReloadResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.PageExpectScreenshotParams = tObject({
  expected: tOptional(tBinary),
  timeout: tFloat,
  isNot: tBoolean,
  locator: tOptional(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  })),
  comparator: tOptional(tString),
  maxDiffPixels: tOptional(tInt),
  maxDiffPixelRatio: tOptional(tFloat),
  threshold: tOptional(tFloat),
  fullPage: tOptional(tBoolean),
  clip: tOptional(tType("Rect")),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.PageExpectScreenshotResult = tObject({
  diff: tOptional(tBinary),
  errorMessage: tOptional(tString),
  actual: tOptional(tBinary),
  previous: tOptional(tBinary),
  timedOut: tOptional(tBoolean),
  log: tOptional(tArray(tString))
});
scheme.PageScreenshotParams = tObject({
  timeout: tFloat,
  type: tOptional(tEnum(["png", "jpeg"])),
  quality: tOptional(tInt),
  fullPage: tOptional(tBoolean),
  clip: tOptional(tType("Rect")),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.PageScreenshotResult = tObject({
  binary: tBinary
});
scheme.PageSetExtraHTTPHeadersParams = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.PageSetExtraHTTPHeadersResult = tOptional(tObject({}));
scheme.PageSetNetworkInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.PageSetNetworkInterceptionPatternsResult = tOptional(tObject({}));
scheme.PageSetWebSocketInterceptionPatternsParams = tObject({
  patterns: tArray(tObject({
    glob: tOptional(tString),
    regexSource: tOptional(tString),
    regexFlags: tOptional(tString)
  }))
});
scheme.PageSetWebSocketInterceptionPatternsResult = tOptional(tObject({}));
scheme.PageSetViewportSizeParams = tObject({
  viewportSize: tObject({
    width: tInt,
    height: tInt
  })
});
scheme.PageSetViewportSizeResult = tOptional(tObject({}));
scheme.PageKeyboardDownParams = tObject({
  key: tString
});
scheme.PageKeyboardDownResult = tOptional(tObject({}));
scheme.PageKeyboardUpParams = tObject({
  key: tString
});
scheme.PageKeyboardUpResult = tOptional(tObject({}));
scheme.PageKeyboardInsertTextParams = tObject({
  text: tString
});
scheme.PageKeyboardInsertTextResult = tOptional(tObject({}));
scheme.PageKeyboardTypeParams = tObject({
  text: tString,
  delay: tOptional(tFloat)
});
scheme.PageKeyboardTypeResult = tOptional(tObject({}));
scheme.PageKeyboardPressParams = tObject({
  key: tString,
  delay: tOptional(tFloat)
});
scheme.PageKeyboardPressResult = tOptional(tObject({}));
scheme.PageMouseMoveParams = tObject({
  x: tFloat,
  y: tFloat,
  steps: tOptional(tInt)
});
scheme.PageMouseMoveResult = tOptional(tObject({}));
scheme.PageMouseDownParams = tObject({
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tInt)
});
scheme.PageMouseDownResult = tOptional(tObject({}));
scheme.PageMouseUpParams = tObject({
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tInt)
});
scheme.PageMouseUpResult = tOptional(tObject({}));
scheme.PageMouseClickParams = tObject({
  x: tFloat,
  y: tFloat,
  delay: tOptional(tFloat),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tInt)
});
scheme.PageMouseClickResult = tOptional(tObject({}));
scheme.PageMouseWheelParams = tObject({
  deltaX: tFloat,
  deltaY: tFloat
});
scheme.PageMouseWheelResult = tOptional(tObject({}));
scheme.PageTouchscreenTapParams = tObject({
  x: tFloat,
  y: tFloat
});
scheme.PageTouchscreenTapResult = tOptional(tObject({}));
scheme.PageAccessibilitySnapshotParams = tObject({
  interestingOnly: tOptional(tBoolean),
  root: tOptional(tChannel(["ElementHandle"]))
});
scheme.PageAccessibilitySnapshotResult = tObject({
  rootAXNode: tOptional(tType("AXNode"))
});
scheme.PagePdfParams = tObject({
  scale: tOptional(tFloat),
  displayHeaderFooter: tOptional(tBoolean),
  headerTemplate: tOptional(tString),
  footerTemplate: tOptional(tString),
  printBackground: tOptional(tBoolean),
  landscape: tOptional(tBoolean),
  pageRanges: tOptional(tString),
  format: tOptional(tString),
  width: tOptional(tString),
  height: tOptional(tString),
  preferCSSPageSize: tOptional(tBoolean),
  margin: tOptional(tObject({
    top: tOptional(tString),
    bottom: tOptional(tString),
    left: tOptional(tString),
    right: tOptional(tString)
  })),
  tagged: tOptional(tBoolean),
  outline: tOptional(tBoolean)
});
scheme.PagePdfResult = tObject({
  pdf: tBinary
});
scheme.PageSnapshotForAIParams = tObject({
  timeout: tFloat
});
scheme.PageSnapshotForAIResult = tObject({
  snapshot: tString
});
scheme.PageStartJSCoverageParams = tObject({
  resetOnNavigation: tOptional(tBoolean),
  reportAnonymousScripts: tOptional(tBoolean)
});
scheme.PageStartJSCoverageResult = tOptional(tObject({}));
scheme.PageStopJSCoverageParams = tOptional(tObject({}));
scheme.PageStopJSCoverageResult = tObject({
  entries: tArray(tObject({
    url: tString,
    scriptId: tString,
    source: tOptional(tString),
    functions: tArray(tObject({
      functionName: tString,
      isBlockCoverage: tBoolean,
      ranges: tArray(tObject({
        startOffset: tInt,
        endOffset: tInt,
        count: tInt
      }))
    }))
  }))
});
scheme.PageStartCSSCoverageParams = tObject({
  resetOnNavigation: tOptional(tBoolean)
});
scheme.PageStartCSSCoverageResult = tOptional(tObject({}));
scheme.PageStopCSSCoverageParams = tOptional(tObject({}));
scheme.PageStopCSSCoverageResult = tObject({
  entries: tArray(tObject({
    url: tString,
    text: tOptional(tString),
    ranges: tArray(tObject({
      start: tInt,
      end: tInt
    }))
  }))
});
scheme.PageBringToFrontParams = tOptional(tObject({}));
scheme.PageBringToFrontResult = tOptional(tObject({}));
scheme.PageUpdateSubscriptionParams = tObject({
  event: tEnum(["console", "dialog", "fileChooser", "request", "response", "requestFinished", "requestFailed"]),
  enabled: tBoolean
});
scheme.PageUpdateSubscriptionResult = tOptional(tObject({}));
scheme.FrameInitializer = tObject({
  url: tString,
  name: tString,
  parentFrame: tOptional(tChannel(["Frame"])),
  loadStates: tArray(tType("LifecycleEvent"))
});
scheme.FrameLoadstateEvent = tObject({
  add: tOptional(tType("LifecycleEvent")),
  remove: tOptional(tType("LifecycleEvent"))
});
scheme.FrameNavigatedEvent = tObject({
  url: tString,
  name: tString,
  newDocument: tOptional(tObject({
    request: tOptional(tChannel(["Request"]))
  })),
  error: tOptional(tString)
});
scheme.FrameEvalOnSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvalOnSelectorResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameEvalOnSelectorAllParams = tObject({
  selector: tString,
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvalOnSelectorAllResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameAddScriptTagParams = tObject({
  url: tOptional(tString),
  content: tOptional(tString),
  type: tOptional(tString)
});
scheme.FrameAddScriptTagResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameAddStyleTagParams = tObject({
  url: tOptional(tString),
  content: tOptional(tString)
});
scheme.FrameAddStyleTagResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameAriaSnapshotParams = tObject({
  selector: tString,
  timeout: tFloat
});
scheme.FrameAriaSnapshotResult = tObject({
  snapshot: tString
});
scheme.FrameBlurParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameBlurResult = tOptional(tObject({}));
scheme.FrameCheckParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameCheckResult = tOptional(tObject({}));
scheme.FrameClickParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  noWaitAfter: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tFloat),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tInt),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameClickResult = tOptional(tObject({}));
scheme.FrameContentParams = tOptional(tObject({}));
scheme.FrameContentResult = tObject({
  value: tString
});
scheme.FrameDragAndDropParams = tObject({
  source: tString,
  target: tString,
  force: tOptional(tBoolean),
  timeout: tFloat,
  trial: tOptional(tBoolean),
  sourcePosition: tOptional(tType("Point")),
  targetPosition: tOptional(tType("Point")),
  strict: tOptional(tBoolean)
});
scheme.FrameDragAndDropResult = tOptional(tObject({}));
scheme.FrameDblclickParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tFloat),
  button: tOptional(tEnum(["left", "right", "middle"])),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameDblclickResult = tOptional(tObject({}));
scheme.FrameDispatchEventParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  type: tString,
  eventInit: tType("SerializedArgument"),
  timeout: tFloat
});
scheme.FrameDispatchEventResult = tOptional(tObject({}));
scheme.FrameEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.FrameEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.FrameEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.FrameFillParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  value: tString,
  force: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameFillResult = tOptional(tObject({}));
scheme.FrameFocusParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameFocusResult = tOptional(tObject({}));
scheme.FrameFrameElementParams = tOptional(tObject({}));
scheme.FrameFrameElementResult = tObject({
  element: tChannel(["ElementHandle"])
});
scheme.FrameResolveSelectorParams = tObject({
  selector: tString
});
scheme.FrameResolveSelectorResult = tObject({
  resolvedSelector: tString
});
scheme.FrameHighlightParams = tObject({
  selector: tString
});
scheme.FrameHighlightResult = tOptional(tObject({}));
scheme.FrameGetAttributeParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  name: tString,
  timeout: tFloat
});
scheme.FrameGetAttributeResult = tObject({
  value: tOptional(tString)
});
scheme.FrameGotoParams = tObject({
  url: tString,
  timeout: tFloat,
  waitUntil: tOptional(tType("LifecycleEvent")),
  referer: tOptional(tString)
});
scheme.FrameGotoResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.FrameHoverParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameHoverResult = tOptional(tObject({}));
scheme.FrameInnerHTMLParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameInnerHTMLResult = tObject({
  value: tString
});
scheme.FrameInnerTextParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameInnerTextResult = tObject({
  value: tString
});
scheme.FrameInputValueParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameInputValueResult = tObject({
  value: tString
});
scheme.FrameIsCheckedParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameIsCheckedResult = tObject({
  value: tBoolean
});
scheme.FrameIsDisabledParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameIsDisabledResult = tObject({
  value: tBoolean
});
scheme.FrameIsEnabledParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameIsEnabledResult = tObject({
  value: tBoolean
});
scheme.FrameIsHiddenParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameIsHiddenResult = tObject({
  value: tBoolean
});
scheme.FrameIsVisibleParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameIsVisibleResult = tObject({
  value: tBoolean
});
scheme.FrameIsEditableParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameIsEditableResult = tObject({
  value: tBoolean
});
scheme.FramePressParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  key: tString,
  delay: tOptional(tFloat),
  noWaitAfter: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FramePressResult = tOptional(tObject({}));
scheme.FrameQuerySelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.FrameQuerySelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.FrameQuerySelectorAllParams = tObject({
  selector: tString
});
scheme.FrameQuerySelectorAllResult = tObject({
  elements: tArray(tChannel(["ElementHandle"]))
});
scheme.FrameQueryCountParams = tObject({
  selector: tString
});
scheme.FrameQueryCountResult = tObject({
  value: tInt
});
scheme.FrameSelectOptionParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  elements: tOptional(tArray(tChannel(["ElementHandle"]))),
  options: tOptional(tArray(tObject({
    valueOrLabel: tOptional(tString),
    value: tOptional(tString),
    label: tOptional(tString),
    index: tOptional(tInt)
  }))),
  force: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameSelectOptionResult = tObject({
  values: tArray(tString)
});
scheme.FrameSetContentParams = tObject({
  html: tString,
  timeout: tFloat,
  waitUntil: tOptional(tType("LifecycleEvent"))
});
scheme.FrameSetContentResult = tOptional(tObject({}));
scheme.FrameSetInputFilesParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  payloads: tOptional(tArray(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))),
  localDirectory: tOptional(tString),
  directoryStream: tOptional(tChannel(["WritableStream"])),
  localPaths: tOptional(tArray(tString)),
  streams: tOptional(tArray(tChannel(["WritableStream"]))),
  timeout: tFloat
});
scheme.FrameSetInputFilesResult = tOptional(tObject({}));
scheme.FrameTapParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameTapResult = tOptional(tObject({}));
scheme.FrameTextContentParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat
});
scheme.FrameTextContentResult = tObject({
  value: tOptional(tString)
});
scheme.FrameTitleParams = tOptional(tObject({}));
scheme.FrameTitleResult = tObject({
  value: tString
});
scheme.FrameTypeParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  text: tString,
  delay: tOptional(tFloat),
  timeout: tFloat
});
scheme.FrameTypeResult = tOptional(tObject({}));
scheme.FrameUncheckParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.FrameUncheckResult = tOptional(tObject({}));
scheme.FrameWaitForTimeoutParams = tObject({
  waitTimeout: tFloat
});
scheme.FrameWaitForTimeoutResult = tOptional(tObject({}));
scheme.FrameWaitForFunctionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument"),
  timeout: tFloat,
  pollingInterval: tOptional(tFloat)
});
scheme.FrameWaitForFunctionResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.FrameWaitForSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat,
  state: tOptional(tEnum(["attached", "detached", "visible", "hidden"])),
  omitReturnValue: tOptional(tBoolean)
});
scheme.FrameWaitForSelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.FrameExpectParams = tObject({
  selector: tOptional(tString),
  expression: tString,
  expressionArg: tOptional(tAny),
  expectedText: tOptional(tArray(tType("ExpectedTextValue"))),
  expectedNumber: tOptional(tFloat),
  expectedValue: tOptional(tType("SerializedArgument")),
  useInnerText: tOptional(tBoolean),
  isNot: tBoolean,
  timeout: tFloat
});
scheme.FrameExpectResult = tObject({
  matches: tBoolean,
  received: tOptional(tType("SerializedValue")),
  timedOut: tOptional(tBoolean),
  log: tOptional(tArray(tString))
});
scheme.WorkerInitializer = tObject({
  url: tString
});
scheme.WorkerCloseEvent = tOptional(tObject({}));
scheme.WorkerEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.WorkerEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.WorkerEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.WorkerEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.JSHandleInitializer = tObject({
  preview: tString
});
scheme.JSHandlePreviewUpdatedEvent = tObject({
  preview: tString
});
scheme.ElementHandlePreviewUpdatedEvent = tType("JSHandlePreviewUpdatedEvent");
scheme.JSHandleDisposeParams = tOptional(tObject({}));
scheme.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
scheme.JSHandleDisposeResult = tOptional(tObject({}));
scheme.ElementHandleDisposeResult = tType("JSHandleDisposeResult");
scheme.JSHandleEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
scheme.JSHandleEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleEvaluateExpressionResult = tType("JSHandleEvaluateExpressionResult");
scheme.JSHandleEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
scheme.JSHandleEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElementHandleEvaluateExpressionHandleResult = tType("JSHandleEvaluateExpressionHandleResult");
scheme.JSHandleGetPropertyListParams = tOptional(tObject({}));
scheme.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
scheme.JSHandleGetPropertyListResult = tObject({
  properties: tArray(tObject({
    name: tString,
    value: tChannel(["ElementHandle", "JSHandle"])
  }))
});
scheme.ElementHandleGetPropertyListResult = tType("JSHandleGetPropertyListResult");
scheme.JSHandleGetPropertyParams = tObject({
  name: tString
});
scheme.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
scheme.JSHandleGetPropertyResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElementHandleGetPropertyResult = tType("JSHandleGetPropertyResult");
scheme.JSHandleJsonValueParams = tOptional(tObject({}));
scheme.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
scheme.JSHandleJsonValueResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleJsonValueResult = tType("JSHandleJsonValueResult");
scheme.ElementHandleInitializer = tObject({
  preview: tString
});
scheme.ElementHandleEvalOnSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvalOnSelectorResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleEvalOnSelectorAllParams = tObject({
  selector: tString,
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElementHandleEvalOnSelectorAllResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElementHandleBoundingBoxParams = tOptional(tObject({}));
scheme.ElementHandleBoundingBoxResult = tObject({
  value: tOptional(tType("Rect"))
});
scheme.ElementHandleCheckParams = tObject({
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleCheckResult = tOptional(tObject({}));
scheme.ElementHandleClickParams = tObject({
  force: tOptional(tBoolean),
  noWaitAfter: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tFloat),
  button: tOptional(tEnum(["left", "right", "middle"])),
  clickCount: tOptional(tInt),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleClickResult = tOptional(tObject({}));
scheme.ElementHandleContentFrameParams = tOptional(tObject({}));
scheme.ElementHandleContentFrameResult = tObject({
  frame: tOptional(tChannel(["Frame"]))
});
scheme.ElementHandleDblclickParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  delay: tOptional(tFloat),
  button: tOptional(tEnum(["left", "right", "middle"])),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleDblclickResult = tOptional(tObject({}));
scheme.ElementHandleDispatchEventParams = tObject({
  type: tString,
  eventInit: tType("SerializedArgument")
});
scheme.ElementHandleDispatchEventResult = tOptional(tObject({}));
scheme.ElementHandleFillParams = tObject({
  value: tString,
  force: tOptional(tBoolean),
  timeout: tFloat
});
scheme.ElementHandleFillResult = tOptional(tObject({}));
scheme.ElementHandleFocusParams = tOptional(tObject({}));
scheme.ElementHandleFocusResult = tOptional(tObject({}));
scheme.ElementHandleGetAttributeParams = tObject({
  name: tString
});
scheme.ElementHandleGetAttributeResult = tObject({
  value: tOptional(tString)
});
scheme.ElementHandleHoverParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleHoverResult = tOptional(tObject({}));
scheme.ElementHandleInnerHTMLParams = tOptional(tObject({}));
scheme.ElementHandleInnerHTMLResult = tObject({
  value: tString
});
scheme.ElementHandleInnerTextParams = tOptional(tObject({}));
scheme.ElementHandleInnerTextResult = tObject({
  value: tString
});
scheme.ElementHandleInputValueParams = tOptional(tObject({}));
scheme.ElementHandleInputValueResult = tObject({
  value: tString
});
scheme.ElementHandleIsCheckedParams = tOptional(tObject({}));
scheme.ElementHandleIsCheckedResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsDisabledParams = tOptional(tObject({}));
scheme.ElementHandleIsDisabledResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsEditableParams = tOptional(tObject({}));
scheme.ElementHandleIsEditableResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsEnabledParams = tOptional(tObject({}));
scheme.ElementHandleIsEnabledResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsHiddenParams = tOptional(tObject({}));
scheme.ElementHandleIsHiddenResult = tObject({
  value: tBoolean
});
scheme.ElementHandleIsVisibleParams = tOptional(tObject({}));
scheme.ElementHandleIsVisibleResult = tObject({
  value: tBoolean
});
scheme.ElementHandleOwnerFrameParams = tOptional(tObject({}));
scheme.ElementHandleOwnerFrameResult = tObject({
  frame: tOptional(tChannel(["Frame"]))
});
scheme.ElementHandlePressParams = tObject({
  key: tString,
  delay: tOptional(tFloat),
  timeout: tFloat,
  noWaitAfter: tOptional(tBoolean)
});
scheme.ElementHandlePressResult = tOptional(tObject({}));
scheme.ElementHandleQuerySelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean)
});
scheme.ElementHandleQuerySelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.ElementHandleQuerySelectorAllParams = tObject({
  selector: tString
});
scheme.ElementHandleQuerySelectorAllResult = tObject({
  elements: tArray(tChannel(["ElementHandle"]))
});
scheme.ElementHandleScreenshotParams = tObject({
  timeout: tFloat,
  type: tOptional(tEnum(["png", "jpeg"])),
  quality: tOptional(tInt),
  omitBackground: tOptional(tBoolean),
  caret: tOptional(tEnum(["hide", "initial"])),
  animations: tOptional(tEnum(["disabled", "allow"])),
  scale: tOptional(tEnum(["css", "device"])),
  mask: tOptional(tArray(tObject({
    frame: tChannel(["Frame"]),
    selector: tString
  }))),
  maskColor: tOptional(tString),
  style: tOptional(tString)
});
scheme.ElementHandleScreenshotResult = tObject({
  binary: tBinary
});
scheme.ElementHandleScrollIntoViewIfNeededParams = tObject({
  timeout: tFloat
});
scheme.ElementHandleScrollIntoViewIfNeededResult = tOptional(tObject({}));
scheme.ElementHandleSelectOptionParams = tObject({
  elements: tOptional(tArray(tChannel(["ElementHandle"]))),
  options: tOptional(tArray(tObject({
    valueOrLabel: tOptional(tString),
    value: tOptional(tString),
    label: tOptional(tString),
    index: tOptional(tInt)
  }))),
  force: tOptional(tBoolean),
  timeout: tFloat
});
scheme.ElementHandleSelectOptionResult = tObject({
  values: tArray(tString)
});
scheme.ElementHandleSelectTextParams = tObject({
  force: tOptional(tBoolean),
  timeout: tFloat
});
scheme.ElementHandleSelectTextResult = tOptional(tObject({}));
scheme.ElementHandleSetInputFilesParams = tObject({
  payloads: tOptional(tArray(tObject({
    name: tString,
    mimeType: tOptional(tString),
    buffer: tBinary
  }))),
  localDirectory: tOptional(tString),
  directoryStream: tOptional(tChannel(["WritableStream"])),
  localPaths: tOptional(tArray(tString)),
  streams: tOptional(tArray(tChannel(["WritableStream"]))),
  timeout: tFloat
});
scheme.ElementHandleSetInputFilesResult = tOptional(tObject({}));
scheme.ElementHandleTapParams = tObject({
  force: tOptional(tBoolean),
  modifiers: tOptional(tArray(tEnum(["Alt", "Control", "ControlOrMeta", "Meta", "Shift"]))),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleTapResult = tOptional(tObject({}));
scheme.ElementHandleTextContentParams = tOptional(tObject({}));
scheme.ElementHandleTextContentResult = tObject({
  value: tOptional(tString)
});
scheme.ElementHandleTypeParams = tObject({
  text: tString,
  delay: tOptional(tFloat),
  timeout: tFloat
});
scheme.ElementHandleTypeResult = tOptional(tObject({}));
scheme.ElementHandleUncheckParams = tObject({
  force: tOptional(tBoolean),
  position: tOptional(tType("Point")),
  timeout: tFloat,
  trial: tOptional(tBoolean)
});
scheme.ElementHandleUncheckResult = tOptional(tObject({}));
scheme.ElementHandleWaitForElementStateParams = tObject({
  state: tEnum(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
  timeout: tFloat
});
scheme.ElementHandleWaitForElementStateResult = tOptional(tObject({}));
scheme.ElementHandleWaitForSelectorParams = tObject({
  selector: tString,
  strict: tOptional(tBoolean),
  timeout: tFloat,
  state: tOptional(tEnum(["attached", "detached", "visible", "hidden"]))
});
scheme.ElementHandleWaitForSelectorResult = tObject({
  element: tOptional(tChannel(["ElementHandle"]))
});
scheme.RequestInitializer = tObject({
  frame: tOptional(tChannel(["Frame"])),
  serviceWorker: tOptional(tChannel(["Worker"])),
  url: tString,
  resourceType: tString,
  method: tString,
  postData: tOptional(tBinary),
  headers: tArray(tType("NameValue")),
  isNavigationRequest: tBoolean,
  redirectedFrom: tOptional(tChannel(["Request"]))
});
scheme.RequestResponseParams = tOptional(tObject({}));
scheme.RequestResponseResult = tObject({
  response: tOptional(tChannel(["Response"]))
});
scheme.RequestRawRequestHeadersParams = tOptional(tObject({}));
scheme.RequestRawRequestHeadersResult = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.RouteInitializer = tObject({
  request: tChannel(["Request"])
});
scheme.RouteRedirectNavigationRequestParams = tObject({
  url: tString
});
scheme.RouteRedirectNavigationRequestResult = tOptional(tObject({}));
scheme.RouteAbortParams = tObject({
  errorCode: tOptional(tString)
});
scheme.RouteAbortResult = tOptional(tObject({}));
scheme.RouteContinueParams = tObject({
  url: tOptional(tString),
  method: tOptional(tString),
  headers: tOptional(tArray(tType("NameValue"))),
  postData: tOptional(tBinary),
  isFallback: tBoolean
});
scheme.RouteContinueResult = tOptional(tObject({}));
scheme.RouteFulfillParams = tObject({
  status: tOptional(tInt),
  headers: tOptional(tArray(tType("NameValue"))),
  body: tOptional(tString),
  isBase64: tOptional(tBoolean),
  fetchResponseUid: tOptional(tString)
});
scheme.RouteFulfillResult = tOptional(tObject({}));
scheme.WebSocketRouteInitializer = tObject({
  url: tString
});
scheme.WebSocketRouteMessageFromPageEvent = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteMessageFromServerEvent = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteClosePageEvent = tObject({
  code: tOptional(tInt),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteCloseServerEvent = tObject({
  code: tOptional(tInt),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteConnectParams = tOptional(tObject({}));
scheme.WebSocketRouteConnectResult = tOptional(tObject({}));
scheme.WebSocketRouteEnsureOpenedParams = tOptional(tObject({}));
scheme.WebSocketRouteEnsureOpenedResult = tOptional(tObject({}));
scheme.WebSocketRouteSendToPageParams = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteSendToPageResult = tOptional(tObject({}));
scheme.WebSocketRouteSendToServerParams = tObject({
  message: tString,
  isBase64: tBoolean
});
scheme.WebSocketRouteSendToServerResult = tOptional(tObject({}));
scheme.WebSocketRouteClosePageParams = tObject({
  code: tOptional(tInt),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteClosePageResult = tOptional(tObject({}));
scheme.WebSocketRouteCloseServerParams = tObject({
  code: tOptional(tInt),
  reason: tOptional(tString),
  wasClean: tBoolean
});
scheme.WebSocketRouteCloseServerResult = tOptional(tObject({}));
scheme.ResourceTiming = tObject({
  startTime: tFloat,
  domainLookupStart: tFloat,
  domainLookupEnd: tFloat,
  connectStart: tFloat,
  secureConnectionStart: tFloat,
  connectEnd: tFloat,
  requestStart: tFloat,
  responseStart: tFloat
});
scheme.ResponseInitializer = tObject({
  request: tChannel(["Request"]),
  url: tString,
  status: tInt,
  statusText: tString,
  headers: tArray(tType("NameValue")),
  timing: tType("ResourceTiming"),
  fromServiceWorker: tBoolean
});
scheme.ResponseBodyParams = tOptional(tObject({}));
scheme.ResponseBodyResult = tObject({
  binary: tBinary
});
scheme.ResponseSecurityDetailsParams = tOptional(tObject({}));
scheme.ResponseSecurityDetailsResult = tObject({
  value: tOptional(tType("SecurityDetails"))
});
scheme.ResponseServerAddrParams = tOptional(tObject({}));
scheme.ResponseServerAddrResult = tObject({
  value: tOptional(tType("RemoteAddr"))
});
scheme.ResponseRawResponseHeadersParams = tOptional(tObject({}));
scheme.ResponseRawResponseHeadersResult = tObject({
  headers: tArray(tType("NameValue"))
});
scheme.ResponseSizesParams = tOptional(tObject({}));
scheme.ResponseSizesResult = tObject({
  sizes: tType("RequestSizes")
});
scheme.SecurityDetails = tObject({
  issuer: tOptional(tString),
  protocol: tOptional(tString),
  subjectName: tOptional(tString),
  validFrom: tOptional(tFloat),
  validTo: tOptional(tFloat)
});
scheme.RequestSizes = tObject({
  requestBodySize: tInt,
  requestHeadersSize: tInt,
  responseBodySize: tInt,
  responseHeadersSize: tInt
});
scheme.RemoteAddr = tObject({
  ipAddress: tString,
  port: tInt
});
scheme.WebSocketInitializer = tObject({
  url: tString
});
scheme.WebSocketOpenEvent = tOptional(tObject({}));
scheme.WebSocketFrameSentEvent = tObject({
  opcode: tInt,
  data: tString
});
scheme.WebSocketFrameReceivedEvent = tObject({
  opcode: tInt,
  data: tString
});
scheme.WebSocketSocketErrorEvent = tObject({
  error: tString
});
scheme.WebSocketCloseEvent = tOptional(tObject({}));
scheme.BindingCallInitializer = tObject({
  frame: tChannel(["Frame"]),
  name: tString,
  args: tOptional(tArray(tType("SerializedValue"))),
  handle: tOptional(tChannel(["ElementHandle", "JSHandle"]))
});
scheme.BindingCallRejectParams = tObject({
  error: tType("SerializedError")
});
scheme.BindingCallRejectResult = tOptional(tObject({}));
scheme.BindingCallResolveParams = tObject({
  result: tType("SerializedArgument")
});
scheme.BindingCallResolveResult = tOptional(tObject({}));
scheme.DialogInitializer = tObject({
  page: tOptional(tChannel(["Page"])),
  type: tString,
  message: tString,
  defaultValue: tString
});
scheme.DialogAcceptParams = tObject({
  promptText: tOptional(tString)
});
scheme.DialogAcceptResult = tOptional(tObject({}));
scheme.DialogDismissParams = tOptional(tObject({}));
scheme.DialogDismissResult = tOptional(tObject({}));
scheme.TracingInitializer = tOptional(tObject({}));
scheme.TracingTracingStartParams = tObject({
  name: tOptional(tString),
  snapshots: tOptional(tBoolean),
  screenshots: tOptional(tBoolean),
  live: tOptional(tBoolean)
});
scheme.TracingTracingStartResult = tOptional(tObject({}));
scheme.TracingTracingStartChunkParams = tObject({
  name: tOptional(tString),
  title: tOptional(tString)
});
scheme.TracingTracingStartChunkResult = tObject({
  traceName: tString
});
scheme.TracingTracingGroupParams = tObject({
  name: tString,
  location: tOptional(tObject({
    file: tString,
    line: tOptional(tInt),
    column: tOptional(tInt)
  }))
});
scheme.TracingTracingGroupResult = tOptional(tObject({}));
scheme.TracingTracingGroupEndParams = tOptional(tObject({}));
scheme.TracingTracingGroupEndResult = tOptional(tObject({}));
scheme.TracingTracingStopChunkParams = tObject({
  mode: tEnum(["archive", "discard", "entries"])
});
scheme.TracingTracingStopChunkResult = tObject({
  artifact: tOptional(tChannel(["Artifact"])),
  entries: tOptional(tArray(tType("NameValue")))
});
scheme.TracingTracingStopParams = tOptional(tObject({}));
scheme.TracingTracingStopResult = tOptional(tObject({}));
scheme.ArtifactInitializer = tObject({
  absolutePath: tString
});
scheme.ArtifactPathAfterFinishedParams = tOptional(tObject({}));
scheme.ArtifactPathAfterFinishedResult = tObject({
  value: tString
});
scheme.ArtifactSaveAsParams = tObject({
  path: tString
});
scheme.ArtifactSaveAsResult = tOptional(tObject({}));
scheme.ArtifactSaveAsStreamParams = tOptional(tObject({}));
scheme.ArtifactSaveAsStreamResult = tObject({
  stream: tChannel(["Stream"])
});
scheme.ArtifactFailureParams = tOptional(tObject({}));
scheme.ArtifactFailureResult = tObject({
  error: tOptional(tString)
});
scheme.ArtifactStreamParams = tOptional(tObject({}));
scheme.ArtifactStreamResult = tObject({
  stream: tChannel(["Stream"])
});
scheme.ArtifactCancelParams = tOptional(tObject({}));
scheme.ArtifactCancelResult = tOptional(tObject({}));
scheme.ArtifactDeleteParams = tOptional(tObject({}));
scheme.ArtifactDeleteResult = tOptional(tObject({}));
scheme.StreamInitializer = tOptional(tObject({}));
scheme.StreamReadParams = tObject({
  size: tOptional(tInt)
});
scheme.StreamReadResult = tObject({
  binary: tBinary
});
scheme.StreamCloseParams = tOptional(tObject({}));
scheme.StreamCloseResult = tOptional(tObject({}));
scheme.WritableStreamInitializer = tOptional(tObject({}));
scheme.WritableStreamWriteParams = tObject({
  binary: tBinary
});
scheme.WritableStreamWriteResult = tOptional(tObject({}));
scheme.WritableStreamCloseParams = tOptional(tObject({}));
scheme.WritableStreamCloseResult = tOptional(tObject({}));
scheme.CDPSessionInitializer = tOptional(tObject({}));
scheme.CDPSessionEventEvent = tObject({
  method: tString,
  params: tOptional(tAny)
});
scheme.CDPSessionSendParams = tObject({
  method: tString,
  params: tOptional(tAny)
});
scheme.CDPSessionSendResult = tObject({
  result: tAny
});
scheme.CDPSessionDetachParams = tOptional(tObject({}));
scheme.CDPSessionDetachResult = tOptional(tObject({}));
scheme.ElectronInitializer = tOptional(tObject({}));
scheme.ElectronLaunchParams = tObject({
  executablePath: tOptional(tString),
  args: tOptional(tArray(tString)),
  cwd: tOptional(tString),
  env: tOptional(tArray(tType("NameValue"))),
  timeout: tFloat,
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  bypassCSP: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  })),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString)
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  locale: tOptional(tString),
  offline: tOptional(tBoolean),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tInt,
      height: tInt
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  timezoneId: tOptional(tString),
  tracesDir: tOptional(tString),
  selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
  testIdAttributeName: tOptional(tString)
});
scheme.ElectronLaunchResult = tObject({
  electronApplication: tChannel(["ElectronApplication"])
});
scheme.ElectronApplicationInitializer = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.ElectronApplicationCloseEvent = tOptional(tObject({}));
scheme.ElectronApplicationConsoleEvent = tObject({
  type: tString,
  text: tString,
  args: tArray(tChannel(["ElementHandle", "JSHandle"])),
  location: tObject({
    url: tString,
    lineNumber: tInt,
    columnNumber: tInt
  })
});
scheme.ElectronApplicationBrowserWindowParams = tObject({
  page: tChannel(["Page"])
});
scheme.ElectronApplicationBrowserWindowResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElectronApplicationEvaluateExpressionParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElectronApplicationEvaluateExpressionResult = tObject({
  value: tType("SerializedValue")
});
scheme.ElectronApplicationEvaluateExpressionHandleParams = tObject({
  expression: tString,
  isFunction: tOptional(tBoolean),
  arg: tType("SerializedArgument")
});
scheme.ElectronApplicationEvaluateExpressionHandleResult = tObject({
  handle: tChannel(["ElementHandle", "JSHandle"])
});
scheme.ElectronApplicationUpdateSubscriptionParams = tObject({
  event: tEnum(["console"]),
  enabled: tBoolean
});
scheme.ElectronApplicationUpdateSubscriptionResult = tOptional(tObject({}));
scheme.AndroidInitializer = tOptional(tObject({}));
scheme.AndroidDevicesParams = tObject({
  host: tOptional(tString),
  port: tOptional(tInt),
  omitDriverInstall: tOptional(tBoolean)
});
scheme.AndroidDevicesResult = tObject({
  devices: tArray(tChannel(["AndroidDevice"]))
});
scheme.AndroidSocketInitializer = tOptional(tObject({}));
scheme.AndroidSocketDataEvent = tObject({
  data: tBinary
});
scheme.AndroidSocketCloseEvent = tOptional(tObject({}));
scheme.AndroidSocketWriteParams = tObject({
  data: tBinary
});
scheme.AndroidSocketWriteResult = tOptional(tObject({}));
scheme.AndroidSocketCloseParams = tOptional(tObject({}));
scheme.AndroidSocketCloseResult = tOptional(tObject({}));
scheme.AndroidDeviceInitializer = tObject({
  model: tString,
  serial: tString
});
scheme.AndroidDeviceCloseEvent = tOptional(tObject({}));
scheme.AndroidDeviceWebViewAddedEvent = tObject({
  webView: tType("AndroidWebView")
});
scheme.AndroidDeviceWebViewRemovedEvent = tObject({
  socketName: tString
});
scheme.AndroidDeviceWaitParams = tObject({
  androidSelector: tType("AndroidSelector"),
  state: tOptional(tEnum(["gone"])),
  timeout: tFloat
});
scheme.AndroidDeviceWaitResult = tOptional(tObject({}));
scheme.AndroidDeviceFillParams = tObject({
  androidSelector: tType("AndroidSelector"),
  text: tString,
  timeout: tFloat
});
scheme.AndroidDeviceFillResult = tOptional(tObject({}));
scheme.AndroidDeviceTapParams = tObject({
  androidSelector: tType("AndroidSelector"),
  duration: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDeviceTapResult = tOptional(tObject({}));
scheme.AndroidDeviceDragParams = tObject({
  androidSelector: tType("AndroidSelector"),
  dest: tType("Point"),
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDeviceDragResult = tOptional(tObject({}));
scheme.AndroidDeviceFlingParams = tObject({
  androidSelector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDeviceFlingResult = tOptional(tObject({}));
scheme.AndroidDeviceLongTapParams = tObject({
  androidSelector: tType("AndroidSelector"),
  timeout: tFloat
});
scheme.AndroidDeviceLongTapResult = tOptional(tObject({}));
scheme.AndroidDevicePinchCloseParams = tObject({
  androidSelector: tType("AndroidSelector"),
  percent: tFloat,
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDevicePinchCloseResult = tOptional(tObject({}));
scheme.AndroidDevicePinchOpenParams = tObject({
  androidSelector: tType("AndroidSelector"),
  percent: tFloat,
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDevicePinchOpenResult = tOptional(tObject({}));
scheme.AndroidDeviceScrollParams = tObject({
  androidSelector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  percent: tFloat,
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDeviceScrollResult = tOptional(tObject({}));
scheme.AndroidDeviceSwipeParams = tObject({
  androidSelector: tType("AndroidSelector"),
  direction: tEnum(["up", "down", "left", "right"]),
  percent: tFloat,
  speed: tOptional(tFloat),
  timeout: tFloat
});
scheme.AndroidDeviceSwipeResult = tOptional(tObject({}));
scheme.AndroidDeviceInfoParams = tObject({
  androidSelector: tType("AndroidSelector")
});
scheme.AndroidDeviceInfoResult = tObject({
  info: tType("AndroidElementInfo")
});
scheme.AndroidDeviceScreenshotParams = tOptional(tObject({}));
scheme.AndroidDeviceScreenshotResult = tObject({
  binary: tBinary
});
scheme.AndroidDeviceInputTypeParams = tObject({
  text: tString
});
scheme.AndroidDeviceInputTypeResult = tOptional(tObject({}));
scheme.AndroidDeviceInputPressParams = tObject({
  key: tString
});
scheme.AndroidDeviceInputPressResult = tOptional(tObject({}));
scheme.AndroidDeviceInputTapParams = tObject({
  point: tType("Point")
});
scheme.AndroidDeviceInputTapResult = tOptional(tObject({}));
scheme.AndroidDeviceInputSwipeParams = tObject({
  segments: tArray(tType("Point")),
  steps: tInt
});
scheme.AndroidDeviceInputSwipeResult = tOptional(tObject({}));
scheme.AndroidDeviceInputDragParams = tObject({
  from: tType("Point"),
  to: tType("Point"),
  steps: tInt
});
scheme.AndroidDeviceInputDragResult = tOptional(tObject({}));
scheme.AndroidDeviceLaunchBrowserParams = tObject({
  noDefaultViewport: tOptional(tBoolean),
  viewport: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  screen: tOptional(tObject({
    width: tInt,
    height: tInt
  })),
  ignoreHTTPSErrors: tOptional(tBoolean),
  clientCertificates: tOptional(tArray(tObject({
    origin: tString,
    cert: tOptional(tBinary),
    key: tOptional(tBinary),
    passphrase: tOptional(tString),
    pfx: tOptional(tBinary)
  }))),
  javaScriptEnabled: tOptional(tBoolean),
  bypassCSP: tOptional(tBoolean),
  userAgent: tOptional(tString),
  locale: tOptional(tString),
  timezoneId: tOptional(tString),
  geolocation: tOptional(tObject({
    longitude: tFloat,
    latitude: tFloat,
    accuracy: tOptional(tFloat)
  })),
  permissions: tOptional(tArray(tString)),
  extraHTTPHeaders: tOptional(tArray(tType("NameValue"))),
  offline: tOptional(tBoolean),
  httpCredentials: tOptional(tObject({
    username: tString,
    password: tString,
    origin: tOptional(tString),
    send: tOptional(tEnum(["always", "unauthorized"]))
  })),
  deviceScaleFactor: tOptional(tFloat),
  isMobile: tOptional(tBoolean),
  hasTouch: tOptional(tBoolean),
  colorScheme: tOptional(tEnum(["dark", "light", "no-preference", "no-override"])),
  reducedMotion: tOptional(tEnum(["reduce", "no-preference", "no-override"])),
  forcedColors: tOptional(tEnum(["active", "none", "no-override"])),
  acceptDownloads: tOptional(tEnum(["accept", "deny", "internal-browser-default"])),
  contrast: tOptional(tEnum(["no-preference", "more", "no-override"])),
  baseURL: tOptional(tString),
  recordVideo: tOptional(tObject({
    dir: tString,
    size: tOptional(tObject({
      width: tInt,
      height: tInt
    }))
  })),
  strictSelectors: tOptional(tBoolean),
  serviceWorkers: tOptional(tEnum(["allow", "block"])),
  selectorEngines: tOptional(tArray(tType("SelectorEngine"))),
  testIdAttributeName: tOptional(tString),
  pkg: tOptional(tString),
  args: tOptional(tArray(tString)),
  proxy: tOptional(tObject({
    server: tString,
    bypass: tOptional(tString),
    username: tOptional(tString),
    password: tOptional(tString)
  }))
});
scheme.AndroidDeviceLaunchBrowserResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.AndroidDeviceOpenParams = tObject({
  command: tString
});
scheme.AndroidDeviceOpenResult = tObject({
  socket: tChannel(["AndroidSocket"])
});
scheme.AndroidDeviceShellParams = tObject({
  command: tString
});
scheme.AndroidDeviceShellResult = tObject({
  result: tBinary
});
scheme.AndroidDeviceInstallApkParams = tObject({
  file: tBinary,
  args: tOptional(tArray(tString))
});
scheme.AndroidDeviceInstallApkResult = tOptional(tObject({}));
scheme.AndroidDevicePushParams = tObject({
  file: tBinary,
  path: tString,
  mode: tOptional(tInt)
});
scheme.AndroidDevicePushResult = tOptional(tObject({}));
scheme.AndroidDeviceConnectToWebViewParams = tObject({
  socketName: tString
});
scheme.AndroidDeviceConnectToWebViewResult = tObject({
  context: tChannel(["BrowserContext"])
});
scheme.AndroidDeviceCloseParams = tOptional(tObject({}));
scheme.AndroidDeviceCloseResult = tOptional(tObject({}));
scheme.AndroidWebView = tObject({
  pid: tInt,
  pkg: tString,
  socketName: tString
});
scheme.AndroidSelector = tObject({
  checkable: tOptional(tBoolean),
  checked: tOptional(tBoolean),
  clazz: tOptional(tString),
  clickable: tOptional(tBoolean),
  depth: tOptional(tInt),
  desc: tOptional(tString),
  enabled: tOptional(tBoolean),
  focusable: tOptional(tBoolean),
  focused: tOptional(tBoolean),
  hasChild: tOptional(tObject({
    androidSelector: tType("AndroidSelector")
  })),
  hasDescendant: tOptional(tObject({
    androidSelector: tType("AndroidSelector"),
    maxDepth: tOptional(tInt)
  })),
  longClickable: tOptional(tBoolean),
  pkg: tOptional(tString),
  res: tOptional(tString),
  scrollable: tOptional(tBoolean),
  selected: tOptional(tBoolean),
  text: tOptional(tString)
});
scheme.AndroidElementInfo = tObject({
  children: tOptional(tArray(tType("AndroidElementInfo"))),
  clazz: tString,
  desc: tString,
  res: tString,
  pkg: tString,
  text: tString,
  bounds: tType("Rect"),
  checkable: tBoolean,
  checked: tBoolean,
  clickable: tBoolean,
  enabled: tBoolean,
  focusable: tBoolean,
  focused: tBoolean,
  longClickable: tBoolean,
  scrollable: tBoolean,
  selected: tBoolean
});
scheme.JsonPipeInitializer = tOptional(tObject({}));
scheme.JsonPipeMessageEvent = tObject({
  message: tAny
});
scheme.JsonPipeClosedEvent = tObject({
  reason: tOptional(tString)
});
scheme.JsonPipeSendParams = tObject({
  message: tAny
});
scheme.JsonPipeSendResult = tOptional(tObject({}));
scheme.JsonPipeCloseParams = tOptional(tObject({}));
scheme.JsonPipeCloseResult = tOptional(tObject({}));

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/protocolMetainfo.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var methodMetainfo = /* @__PURE__ */ new Map([
  ["APIRequestContext.fetch", { title: '{method} "{url}"' }],
  ["APIRequestContext.fetchResponseBody", { title: "Get response body", group: "getter" }],
  ["APIRequestContext.fetchLog", { internal: true }],
  ["APIRequestContext.storageState", { title: "Get storage state" }],
  ["APIRequestContext.disposeAPIResponse", { internal: true }],
  ["APIRequestContext.dispose", { internal: true }],
  ["LocalUtils.zip", { internal: true }],
  ["LocalUtils.harOpen", { internal: true }],
  ["LocalUtils.harLookup", { internal: true }],
  ["LocalUtils.harClose", { internal: true }],
  ["LocalUtils.harUnzip", { internal: true }],
  ["LocalUtils.connect", { internal: true }],
  ["LocalUtils.tracingStarted", { internal: true }],
  ["LocalUtils.addStackToTracingNoReply", { internal: true }],
  ["LocalUtils.traceDiscarded", { internal: true }],
  ["LocalUtils.globToRegex", { internal: true }],
  ["Root.initialize", { internal: true }],
  ["Playwright.newRequest", { title: "Create request context" }],
  ["DebugController.initialize", { internal: true }],
  ["DebugController.setReportStateChanged", { internal: true }],
  ["DebugController.setRecorderMode", { internal: true }],
  ["DebugController.highlight", { internal: true }],
  ["DebugController.hideHighlight", { internal: true }],
  ["DebugController.resume", { internal: true }],
  ["DebugController.kill", { internal: true }],
  ["SocksSupport.socksConnected", { internal: true }],
  ["SocksSupport.socksFailed", { internal: true }],
  ["SocksSupport.socksData", { internal: true }],
  ["SocksSupport.socksError", { internal: true }],
  ["SocksSupport.socksEnd", { internal: true }],
  ["BrowserType.launch", { title: "Launch browser" }],
  ["BrowserType.launchPersistentContext", { title: "Launch persistent context" }],
  ["BrowserType.connectOverCDP", { title: "Connect over CDP" }],
  ["Browser.close", { title: "Close browser", pausesBeforeAction: true }],
  ["Browser.killForTests", { internal: true }],
  ["Browser.defaultUserAgentForTest", { internal: true }],
  ["Browser.newContext", { title: "Create context" }],
  ["Browser.newContextForReuse", { internal: true }],
  ["Browser.disconnectFromReusedContext", { internal: true }],
  ["Browser.newBrowserCDPSession", { title: "Create CDP session", group: "configuration" }],
  ["Browser.startTracing", { title: "Start browser tracing", group: "configuration" }],
  ["Browser.stopTracing", { title: "Stop browser tracing", group: "configuration" }],
  ["EventTarget.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["BrowserContext.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["Page.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["WebSocket.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["ElectronApplication.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["AndroidDevice.waitForEventInfo", { title: 'Wait for event "{info.event}"', snapshot: true }],
  ["BrowserContext.addCookies", { title: "Add cookies", group: "configuration" }],
  ["BrowserContext.addInitScript", { title: "Add init script", group: "configuration" }],
  ["BrowserContext.clearCookies", { title: "Clear cookies", group: "configuration" }],
  ["BrowserContext.clearPermissions", { title: "Clear permissions", group: "configuration" }],
  ["BrowserContext.close", { title: "Close context", pausesBeforeAction: true }],
  ["BrowserContext.cookies", { title: "Get cookies", group: "getter" }],
  ["BrowserContext.exposeBinding", { title: "Expose binding", group: "configuration" }],
  ["BrowserContext.grantPermissions", { title: "Grant permissions", group: "configuration" }],
  ["BrowserContext.newPage", { title: "Create page" }],
  ["BrowserContext.registerSelectorEngine", { internal: true }],
  ["BrowserContext.setTestIdAttributeName", { internal: true }],
  ["BrowserContext.setExtraHTTPHeaders", { title: "Set extra HTTP headers", group: "configuration" }],
  ["BrowserContext.setGeolocation", { title: "Set geolocation", group: "configuration" }],
  ["BrowserContext.setHTTPCredentials", { title: "Set HTTP credentials", group: "configuration" }],
  ["BrowserContext.setNetworkInterceptionPatterns", { title: "Route requests", group: "route" }],
  ["BrowserContext.setWebSocketInterceptionPatterns", { title: "Route WebSockets", group: "route" }],
  ["BrowserContext.setOffline", { title: "Set offline mode" }],
  ["BrowserContext.storageState", { title: "Get storage state" }],
  ["BrowserContext.pause", { title: "Pause" }],
  ["BrowserContext.enableRecorder", { internal: true }],
  ["BrowserContext.disableRecorder", { internal: true }],
  ["BrowserContext.newCDPSession", { title: "Create CDP session", group: "configuration" }],
  ["BrowserContext.harStart", { internal: true }],
  ["BrowserContext.harExport", { internal: true }],
  ["BrowserContext.createTempFiles", { internal: true }],
  ["BrowserContext.updateSubscription", { internal: true }],
  ["BrowserContext.clockFastForward", { title: 'Fast forward clock "{ticksNumber|ticksString}"' }],
  ["BrowserContext.clockInstall", { title: 'Install clock "{timeNumber|timeString}"' }],
  ["BrowserContext.clockPauseAt", { title: 'Pause clock "{timeNumber|timeString}"' }],
  ["BrowserContext.clockResume", { title: "Resume clock" }],
  ["BrowserContext.clockRunFor", { title: 'Run clock "{ticksNumber|ticksString}"' }],
  ["BrowserContext.clockSetFixedTime", { title: 'Set fixed time "{timeNumber|timeString}"' }],
  ["BrowserContext.clockSetSystemTime", { title: 'Set system time "{timeNumber|timeString}"' }],
  ["Page.addInitScript", { title: "Add init script", group: "configuration" }],
  ["Page.close", { title: "Close page", pausesBeforeAction: true }],
  ["Page.emulateMedia", { title: "Emulate media", snapshot: true, pausesBeforeAction: true }],
  ["Page.exposeBinding", { title: "Expose binding", group: "configuration" }],
  ["Page.goBack", { title: "Go back", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.goForward", { title: "Go forward", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.requestGC", { title: "Request garbage collection", group: "configuration" }],
  ["Page.registerLocatorHandler", { title: "Register locator handler" }],
  ["Page.resolveLocatorHandlerNoReply", { internal: true }],
  ["Page.unregisterLocatorHandler", { title: "Unregister locator handler" }],
  ["Page.reload", { title: "Reload", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.expectScreenshot", { title: "Expect screenshot", snapshot: true, pausesBeforeAction: true }],
  ["Page.screenshot", { title: "Screenshot", snapshot: true, pausesBeforeAction: true }],
  ["Page.setExtraHTTPHeaders", { title: "Set extra HTTP headers", group: "configuration" }],
  ["Page.setNetworkInterceptionPatterns", { title: "Route requests", group: "route" }],
  ["Page.setWebSocketInterceptionPatterns", { title: "Route WebSockets", group: "route" }],
  ["Page.setViewportSize", { title: "Set viewport size", snapshot: true, pausesBeforeAction: true }],
  ["Page.keyboardDown", { title: 'Key down "{key}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.keyboardUp", { title: 'Key up "{key}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.keyboardInsertText", { title: 'Insert "{text}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.keyboardType", { title: 'Type "{text}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.keyboardPress", { title: 'Press "{key}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.mouseMove", { title: "Mouse move", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.mouseDown", { title: "Mouse down", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.mouseUp", { title: "Mouse up", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.mouseClick", { title: "Click", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.mouseWheel", { title: "Mouse wheel", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.touchscreenTap", { title: "Tap", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Page.accessibilitySnapshot", { title: "Accessibility snapshot", group: "getter" }],
  ["Page.pdf", { title: "PDF" }],
  ["Page.snapshotForAI", { internal: true }],
  ["Page.startJSCoverage", { title: "Start JS coverage", group: "configuration" }],
  ["Page.stopJSCoverage", { title: "Stop JS coverage", group: "configuration" }],
  ["Page.startCSSCoverage", { title: "Start CSS coverage", group: "configuration" }],
  ["Page.stopCSSCoverage", { title: "Stop CSS coverage", group: "configuration" }],
  ["Page.bringToFront", { title: "Bring to front" }],
  ["Page.updateSubscription", { internal: true }],
  ["Frame.evalOnSelector", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["Frame.evalOnSelectorAll", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["Frame.addScriptTag", { title: "Add script tag", snapshot: true, pausesBeforeAction: true }],
  ["Frame.addStyleTag", { title: "Add style tag", snapshot: true, pausesBeforeAction: true }],
  ["Frame.ariaSnapshot", { title: "Aria snapshot", snapshot: true, pausesBeforeAction: true }],
  ["Frame.blur", { title: "Blur", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Frame.check", { title: "Check", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.click", { title: "Click", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.content", { title: "Get content", snapshot: true, pausesBeforeAction: true }],
  ["Frame.dragAndDrop", { title: "Drag and drop", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.dblclick", { title: "Double click", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.dispatchEvent", { title: 'Dispatch "{type}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Frame.evaluateExpression", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["Frame.evaluateExpressionHandle", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["Frame.fill", { title: 'Fill "{value}"', slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.focus", { title: "Focus", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Frame.frameElement", { title: "Get frame element", group: "getter" }],
  ["Frame.resolveSelector", { internal: true }],
  ["Frame.highlight", { title: "Highlight element", group: "configuration" }],
  ["Frame.getAttribute", { title: 'Get attribute "{name}"', snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.goto", { title: 'Navigate to "{url}"', slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["Frame.hover", { title: "Hover", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.innerHTML", { title: "Get HTML", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.innerText", { title: "Get inner text", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.inputValue", { title: "Get input value", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isChecked", { title: "Is checked", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isDisabled", { title: "Is disabled", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isEnabled", { title: "Is enabled", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isHidden", { title: "Is hidden", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isVisible", { title: "Is visible", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.isEditable", { title: "Is editable", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.press", { title: 'Press "{key}"', slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.querySelector", { title: "Query selector", snapshot: true }],
  ["Frame.querySelectorAll", { title: "Query selector all", snapshot: true }],
  ["Frame.queryCount", { title: "Query count", snapshot: true, pausesBeforeAction: true }],
  ["Frame.selectOption", { title: "Select option", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.setContent", { title: "Set content", snapshot: true, pausesBeforeAction: true }],
  ["Frame.setInputFiles", { title: "Set input files", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.tap", { title: "Tap", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.textContent", { title: "Get text content", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["Frame.title", { title: "Get page title", group: "getter" }],
  ["Frame.type", { title: 'Type "{text}"', slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.uncheck", { title: "Uncheck", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["Frame.waitForTimeout", { title: "Wait for timeout", snapshot: true }],
  ["Frame.waitForFunction", { title: "Wait for function", snapshot: true, pausesBeforeAction: true }],
  ["Frame.waitForSelector", { title: "Wait for selector", snapshot: true }],
  ["Frame.expect", { title: 'Expect "{expression}"', snapshot: true, pausesBeforeAction: true }],
  ["Worker.evaluateExpression", { title: "Evaluate" }],
  ["Worker.evaluateExpressionHandle", { title: "Evaluate" }],
  ["JSHandle.dispose", { internal: true }],
  ["ElementHandle.dispose", { internal: true }],
  ["JSHandle.evaluateExpression", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.evaluateExpression", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["JSHandle.evaluateExpressionHandle", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.evaluateExpressionHandle", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["JSHandle.getPropertyList", { title: "Get property list", group: "getter" }],
  ["ElementHandle.getPropertyList", { title: "Get property list", group: "getter" }],
  ["JSHandle.getProperty", { title: "Get JS property", group: "getter" }],
  ["ElementHandle.getProperty", { title: "Get JS property", group: "getter" }],
  ["JSHandle.jsonValue", { title: "Get JSON value", group: "getter" }],
  ["ElementHandle.jsonValue", { title: "Get JSON value", group: "getter" }],
  ["ElementHandle.evalOnSelector", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.evalOnSelectorAll", { title: "Evaluate", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.boundingBox", { title: "Get bounding box", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.check", { title: "Check", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.click", { title: "Click", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.contentFrame", { title: "Get content frame", group: "getter" }],
  ["ElementHandle.dblclick", { title: "Double click", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.dispatchEvent", { title: "Dispatch event", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.fill", { title: 'Fill "{value}"', slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.focus", { title: "Focus", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.getAttribute", { title: "Get attribute", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.hover", { title: "Hover", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.innerHTML", { title: "Get HTML", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.innerText", { title: "Get inner text", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.inputValue", { title: "Get input value", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isChecked", { title: "Is checked", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isDisabled", { title: "Is disabled", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isEditable", { title: "Is editable", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isEnabled", { title: "Is enabled", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isHidden", { title: "Is hidden", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.isVisible", { title: "Is visible", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.ownerFrame", { title: "Get owner frame", group: "getter" }],
  ["ElementHandle.press", { title: 'Press "{key}"', slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.querySelector", { title: "Query selector", snapshot: true }],
  ["ElementHandle.querySelectorAll", { title: "Query selector all", snapshot: true }],
  ["ElementHandle.screenshot", { title: "Screenshot", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.scrollIntoViewIfNeeded", { title: "Scroll into view", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.selectOption", { title: "Select option", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.selectText", { title: "Select text", slowMo: true, snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.setInputFiles", { title: "Set input files", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.tap", { title: "Tap", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.textContent", { title: "Get text content", snapshot: true, pausesBeforeAction: true, group: "getter" }],
  ["ElementHandle.type", { title: "Type", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.uncheck", { title: "Uncheck", slowMo: true, snapshot: true, pausesBeforeInput: true }],
  ["ElementHandle.waitForElementState", { title: "Wait for state", snapshot: true, pausesBeforeAction: true }],
  ["ElementHandle.waitForSelector", { title: "Wait for selector", snapshot: true }],
  ["Request.response", { internal: true }],
  ["Request.rawRequestHeaders", { internal: true }],
  ["Route.redirectNavigationRequest", { internal: true }],
  ["Route.abort", { title: "Abort request", group: "route" }],
  ["Route.continue", { title: "Continue request", group: "route" }],
  ["Route.fulfill", { title: "Fulfill request", group: "route" }],
  ["WebSocketRoute.connect", { title: "Connect WebSocket to server", group: "route" }],
  ["WebSocketRoute.ensureOpened", { internal: true }],
  ["WebSocketRoute.sendToPage", { title: "Send WebSocket message", group: "route" }],
  ["WebSocketRoute.sendToServer", { title: "Send WebSocket message", group: "route" }],
  ["WebSocketRoute.closePage", { internal: true }],
  ["WebSocketRoute.closeServer", { internal: true }],
  ["Response.body", { title: "Get response body", group: "getter" }],
  ["Response.securityDetails", { internal: true }],
  ["Response.serverAddr", { internal: true }],
  ["Response.rawResponseHeaders", { internal: true }],
  ["Response.sizes", { internal: true }],
  ["BindingCall.reject", { internal: true }],
  ["BindingCall.resolve", { internal: true }],
  ["Dialog.accept", { title: "Accept dialog" }],
  ["Dialog.dismiss", { title: "Dismiss dialog" }],
  ["Tracing.tracingStart", { title: "Start tracing", group: "configuration" }],
  ["Tracing.tracingStartChunk", { title: "Start tracing", group: "configuration" }],
  ["Tracing.tracingGroup", { title: 'Trace "{name}"' }],
  ["Tracing.tracingGroupEnd", { title: "Group end" }],
  ["Tracing.tracingStopChunk", { title: "Stop tracing", group: "configuration" }],
  ["Tracing.tracingStop", { title: "Stop tracing", group: "configuration" }],
  ["Artifact.pathAfterFinished", { internal: true }],
  ["Artifact.saveAs", { internal: true }],
  ["Artifact.saveAsStream", { internal: true }],
  ["Artifact.failure", { internal: true }],
  ["Artifact.stream", { internal: true }],
  ["Artifact.cancel", { internal: true }],
  ["Artifact.delete", { internal: true }],
  ["Stream.read", { internal: true }],
  ["Stream.close", { internal: true }],
  ["WritableStream.write", { internal: true }],
  ["WritableStream.close", { internal: true }],
  ["CDPSession.send", { title: "Send CDP command", group: "configuration" }],
  ["CDPSession.detach", { title: "Detach CDP session", group: "configuration" }],
  ["Electron.launch", { title: "Launch electron" }],
  ["ElectronApplication.browserWindow", { internal: true }],
  ["ElectronApplication.evaluateExpression", { title: "Evaluate" }],
  ["ElectronApplication.evaluateExpressionHandle", { title: "Evaluate" }],
  ["ElectronApplication.updateSubscription", { internal: true }],
  ["Android.devices", { internal: true }],
  ["AndroidSocket.write", { internal: true }],
  ["AndroidSocket.close", { internal: true }],
  ["AndroidDevice.wait", { title: "Wait" }],
  ["AndroidDevice.fill", { title: 'Fill "{text}"' }],
  ["AndroidDevice.tap", { title: "Tap" }],
  ["AndroidDevice.drag", { title: "Drag" }],
  ["AndroidDevice.fling", { title: "Fling" }],
  ["AndroidDevice.longTap", { title: "Long tap" }],
  ["AndroidDevice.pinchClose", { title: "Pinch close" }],
  ["AndroidDevice.pinchOpen", { title: "Pinch open" }],
  ["AndroidDevice.scroll", { title: "Scroll" }],
  ["AndroidDevice.swipe", { title: "Swipe" }],
  ["AndroidDevice.info", { internal: true }],
  ["AndroidDevice.screenshot", { title: "Screenshot" }],
  ["AndroidDevice.inputType", { title: "Type" }],
  ["AndroidDevice.inputPress", { title: "Press" }],
  ["AndroidDevice.inputTap", { title: "Tap" }],
  ["AndroidDevice.inputSwipe", { title: "Swipe" }],
  ["AndroidDevice.inputDrag", { title: "Drag" }],
  ["AndroidDevice.launchBrowser", { title: "Launch browser" }],
  ["AndroidDevice.open", { title: "Open app" }],
  ["AndroidDevice.shell", { title: "Execute shell command", group: "configuration" }],
  ["AndroidDevice.installApk", { title: "Install apk" }],
  ["AndroidDevice.push", { title: "Push" }],
  ["AndroidDevice.connectToWebView", { title: "Connect to Web View" }],
  ["AndroidDevice.close", { internal: true }],
  ["JsonPipe.send", { internal: true }],
  ["JsonPipe.close", { internal: true }]
]);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/dispatcher.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/protocol/serializers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseSerializedValue(value, handles) {
  return innerParseSerializedValue(value, handles, /* @__PURE__ */ new Map(), []);
}
__name(parseSerializedValue, "parseSerializedValue");
function innerParseSerializedValue(value, handles, refs, accessChain) {
  if (value.ref !== void 0)
    return refs.get(value.ref);
  if (value.n !== void 0)
    return value.n;
  if (value.s !== void 0)
    return value.s;
  if (value.b !== void 0)
    return value.b;
  if (value.v !== void 0) {
    if (value.v === "undefined")
      return void 0;
    if (value.v === "null")
      return null;
    if (value.v === "NaN")
      return NaN;
    if (value.v === "Infinity")
      return Infinity;
    if (value.v === "-Infinity")
      return -Infinity;
    if (value.v === "-0")
      return -0;
  }
  if (value.d !== void 0)
    return new Date(value.d);
  if (value.u !== void 0)
    return new URL(value.u);
  if (value.bi !== void 0)
    return BigInt(value.bi);
  if (value.e !== void 0) {
    const error3 = new Error(value.e.m);
    error3.name = value.e.n;
    error3.stack = value.e.s;
    return error3;
  }
  if (value.r !== void 0)
    return new RegExp(value.r.p, value.r.f);
  if (value.ta !== void 0) {
    const ctor = typedArrayKindToConstructor[value.ta.k];
    return new ctor(value.ta.b.buffer, value.ta.b.byteOffset, value.ta.b.length / ctor.BYTES_PER_ELEMENT);
  }
  if (value.a !== void 0) {
    const result = [];
    refs.set(value.id, result);
    for (let i = 0; i < value.a.length; i++)
      result.push(innerParseSerializedValue(value.a[i], handles, refs, [...accessChain, i]));
    return result;
  }
  if (value.o !== void 0) {
    const result = {};
    refs.set(value.id, result);
    for (const { k, v } of value.o)
      result[k] = innerParseSerializedValue(v, handles, refs, [...accessChain, k]);
    return result;
  }
  if (value.h !== void 0) {
    if (handles === void 0)
      throw new Error("Unexpected handle");
    return handles[value.h];
  }
  throw new Error(`Attempting to deserialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);
}
__name(innerParseSerializedValue, "innerParseSerializedValue");
function serializeValue(value, handleSerializer) {
  return innerSerializeValue(value, handleSerializer, { lastId: 0, visited: /* @__PURE__ */ new Map() }, []);
}
__name(serializeValue, "serializeValue");
function innerSerializeValue(value, handleSerializer, visitorInfo, accessChain) {
  const handle = handleSerializer(value);
  if ("fallThrough" in handle)
    value = handle.fallThrough;
  else
    return handle;
  if (typeof value === "symbol")
    return { v: "undefined" };
  if (Object.is(value, void 0))
    return { v: "undefined" };
  if (Object.is(value, null))
    return { v: "null" };
  if (Object.is(value, NaN))
    return { v: "NaN" };
  if (Object.is(value, Infinity))
    return { v: "Infinity" };
  if (Object.is(value, -Infinity))
    return { v: "-Infinity" };
  if (Object.is(value, -0))
    return { v: "-0" };
  if (typeof value === "boolean")
    return { b: value };
  if (typeof value === "number")
    return { n: value };
  if (typeof value === "string")
    return { s: value };
  if (typeof value === "bigint")
    return { bi: value.toString() };
  if (isError(value))
    return { e: { n: value.name, m: value.message, s: value.stack || "" } };
  if (isDate(value))
    return { d: value.toJSON() };
  if (isURL(value))
    return { u: value.toJSON() };
  if (isRegExp(value))
    return { r: { p: value.source, f: value.flags } };
  const typedArrayKind = constructorToTypedArrayKind.get(value.constructor);
  if (typedArrayKind)
    return { ta: { b: Buffer.from(value.buffer, value.byteOffset, value.byteLength), k: typedArrayKind } };
  const id = visitorInfo.visited.get(value);
  if (id)
    return { ref: id };
  if (Array.isArray(value)) {
    const a = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (let i = 0; i < value.length; ++i)
      a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo, [...accessChain, i]));
    return { a, id: id2 };
  }
  if (typeof value === "object") {
    const o = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (const name of Object.keys(value))
      o.push({ k: name, v: innerSerializeValue(value[name], handleSerializer, visitorInfo, [...accessChain, name]) });
    return { o, id: id2 };
  }
  throw new Error(`Attempting to serialize unexpected value${accessChainToDisplayString(accessChain)}: ${value}`);
}
__name(innerSerializeValue, "innerSerializeValue");
function accessChainToDisplayString(accessChain) {
  const chainString = accessChain.map((accessor, i) => {
    if (typeof accessor === "string")
      return i ? `.${accessor}` : accessor;
    return `[${accessor}]`;
  }).join("");
  return chainString.length > 0 ? ` at position "${chainString}"` : "";
}
__name(accessChainToDisplayString, "accessChainToDisplayString");
function isRegExp(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function isDate(obj) {
  return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
}
__name(isDate, "isDate");
function isURL(obj) {
  return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
}
__name(isURL, "isURL");
function isError(obj) {
  const proto = obj ? Object.getPrototypeOf(obj) : null;
  return obj instanceof Error || proto?.name === "Error" || proto && isError(proto);
}
__name(isError, "isError");
var typedArrayKindToConstructor = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array,
  bi64: BigInt64Array,
  bui64: BigUint64Array
};
var constructorToTypedArrayKind = new Map(Object.entries(typedArrayKindToConstructor).map(([k, v]) => [v, k]));

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/rtti.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isRegExp2(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
__name(isObject, "isObject");
function isError2(obj) {
  return obj instanceof Error || obj && Object.getPrototypeOf(obj)?.name === "Error";
}
__name(isError2, "isError");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/errors.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var CustomError = class extends Error {
  static {
    __name(this, "CustomError");
  }
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var TimeoutError = class extends CustomError {
  static {
    __name(this, "TimeoutError");
  }
};
var TargetClosedError = class extends CustomError {
  static {
    __name(this, "TargetClosedError");
  }
  constructor(cause, logs) {
    super((cause || "Target page, context or browser has been closed") + (logs || ""));
  }
};
function isTargetClosedError(error3) {
  return error3 instanceof TargetClosedError || error3.name === "TargetClosedError";
}
__name(isTargetClosedError, "isTargetClosedError");
function serializeError(e) {
  if (isError2(e))
    return { error: { message: e.message, stack: e.stack, name: e.name } };
  return { value: serializeValue(e, (value) => ({ fallThrough: value })) };
}
__name(serializeError, "serializeError");
function parseError(error3) {
  if (!error3.error) {
    if (error3.value === void 0)
      throw new Error("Serialized error must have either an error or a value");
    return parseSerializedValue(error3.value, void 0);
  }
  const e = new Error(error3.error.message);
  e.stack = error3.error.stack || "";
  e.name = error3.error.name;
  return e;
}
__name(parseError, "parseError");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/instrumentation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter7 } from "node:events";
var SdkObject = class extends EventEmitter7 {
  static {
    __name(this, "SdkObject");
  }
  constructor(parent, guidPrefix, guid) {
    super();
    this.guid = guid || `${guidPrefix || ""}@${createGuid()}`;
    this.setMaxListeners(0);
    this.attribution = { ...parent.attribution };
    this.instrumentation = parent.instrumentation;
  }
};
function createRootSdkObject() {
  const fakeParent = { attribution: {}, instrumentation: createInstrumentation() };
  const root = new SdkObject(fakeParent);
  root.guid = "";
  return root;
}
__name(createRootSdkObject, "createRootSdkObject");
function createInstrumentation() {
  const listeners2 = /* @__PURE__ */ new Map();
  return new Proxy({}, {
    get: /* @__PURE__ */ __name((obj, prop) => {
      if (typeof prop !== "string")
        return obj[prop];
      if (prop === "addListener")
        return (listener, context2) => listeners2.set(listener, context2);
      if (prop === "removeListener")
        return (listener) => listeners2.delete(listener);
      if (!prop.startsWith("on"))
        return obj[prop];
      return async (sdkObject, ...params) => {
        for (const [listener, context2] of listeners2) {
          if (!context2 || sdkObject.attribution.context === context2)
            await listener[prop]?.(sdkObject, ...params);
        }
      };
    }, "get")
  });
}
__name(createInstrumentation, "createInstrumentation");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/protocolError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ProtocolError = class extends Error {
  static {
    __name(this, "ProtocolError");
  }
  constructor(type, method, logs) {
    super();
    this.type = type;
    this.method = method;
    this.logs = logs;
  }
  setMessage(message) {
    rewriteErrorMessage(this, `Protocol error (${this.method}): ${message}`);
  }
  browserLogMessage() {
    return this.logs ? "\nBrowser logs:\n" + this.logs : "";
  }
};
function isProtocolError(e) {
  return e instanceof ProtocolError;
}
__name(isProtocolError, "isProtocolError");
function isSessionClosedError(e) {
  return e instanceof ProtocolError && (e.type === "closed" || e.type === "crashed");
}
__name(isSessionClosedError, "isSessionClosedError");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/callLog.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function compressCallLog(log3) {
  const lines = [];
  for (const block of findRepeatedSubsequences(log3)) {
    for (let i = 0; i < block.sequence.length; i++) {
      const line = block.sequence[i];
      const leadingWhitespace = line.match(/^\s*/);
      const whitespacePrefix = "  " + leadingWhitespace?.[0] || "";
      const countPrefix = `${block.count} \xD7 `;
      if (block.count > 1 && i === 0)
        lines.push(whitespacePrefix + countPrefix + line.trim());
      else if (block.count > 1)
        lines.push(whitespacePrefix + " ".repeat(countPrefix.length - 2) + "- " + line.trim());
      else
        lines.push(whitespacePrefix + "- " + line.trim());
    }
  }
  return lines;
}
__name(compressCallLog, "compressCallLog");
function findRepeatedSubsequences(s) {
  const n = s.length;
  const result = [];
  let i = 0;
  const arraysEqual = /* @__PURE__ */ __name((a1, a2) => {
    if (a1.length !== a2.length)
      return false;
    for (let j = 0; j < a1.length; j++) {
      if (a1[j] !== a2[j])
        return false;
    }
    return true;
  }, "arraysEqual");
  while (i < n) {
    let maxRepeatCount = 1;
    let maxRepeatSubstr = [s[i]];
    let maxRepeatLength = 1;
    for (let p = 1; p <= n - i; p++) {
      const substr = s.slice(i, i + p);
      let k = 1;
      while (i + p * k <= n && arraysEqual(s.slice(i + p * (k - 1), i + p * k), substr))
        k += 1;
      k -= 1;
      if (k > 1 && k * p > maxRepeatCount * maxRepeatLength) {
        maxRepeatCount = k;
        maxRepeatSubstr = substr;
        maxRepeatLength = p;
      }
    }
    result.push({ sequence: maxRepeatSubstr, count: maxRepeatCount });
    i += maxRepeatLength * maxRepeatCount;
  }
  return result;
}
__name(findRepeatedSubsequences, "findRepeatedSubsequences");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/progress.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var ProgressController = class {
  static {
    __name(this, "ProgressController");
  }
  constructor(metadata, onCallLog) {
    this._forceAbortPromise = new ManualPromise();
    this._donePromise = new ManualPromise();
    this._state = "before";
    this.metadata = metadata || { id: "", startTime: 0, endTime: 0, type: "Internal", method: "", params: {}, log: [], internal: true };
    this._onCallLog = onCallLog;
    this._forceAbortPromise.catch((e) => null);
  }
  async abort(error3) {
    if (this._state === "running") {
      error3[kAbortErrorSymbol] = true;
      this._state = { error: error3 };
      this._forceAbortPromise.reject(error3);
    }
    await this._donePromise;
  }
  async run(task, timeout) {
    assert3(this._state === "before");
    this._state = "running";
    const progress3 = {
      log: /* @__PURE__ */ __name((message) => {
        if (this._state === "running")
          this.metadata.log.push(message);
        this._onCallLog?.(message);
      }, "log"),
      metadata: this.metadata,
      race: /* @__PURE__ */ __name((promise) => {
        const promises = Array.isArray(promise) ? promise : [promise];
        return Promise.race([...promises, this._forceAbortPromise]);
      }, "race"),
      wait: /* @__PURE__ */ __name(async (timeout2) => {
        let timer2;
        const promise = new Promise((f) => timer2 = setTimeout(f, timeout2));
        return progress3.race(promise).finally(() => clearTimeout(timer2));
      }, "wait")
    };
    let timer;
    if (timeout) {
      const timeoutError = new TimeoutError(`Timeout ${timeout}ms exceeded.`);
      timer = setTimeout(() => {
        if (this._state === "running") {
          timeoutError[kAbortErrorSymbol] = true;
          this._state = { error: timeoutError };
          this._forceAbortPromise.reject(timeoutError);
        }
      }, timeout);
    }
    try {
      const result = await task(progress3);
      this._state = "finished";
      return result;
    } catch (error3) {
      this._state = { error: error3 };
      throw error3;
    } finally {
      clearTimeout(timer);
      this._donePromise.resolve();
    }
  }
};
var kAbortErrorSymbol = Symbol("kAbortError");
function isAbortError(error3) {
  return !!error3[kAbortErrorSymbol];
}
__name(isAbortError, "isAbortError");
async function raceUncancellableOperationWithCleanup(progress3, run, cleanup) {
  let aborted = false;
  try {
    return await progress3.race(run().then(async (t) => {
      if (aborted)
        await cleanup(t);
      return t;
    }));
  } catch (error3) {
    aborted = true;
    throw error3;
  }
}
__name(raceUncancellableOperationWithCleanup, "raceUncancellableOperationWithCleanup");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/dispatcher.js
var metadataValidator = createMetadataValidator();
function maxDispatchersForBucket(gcBucket) {
  return {
    "JSHandle": 1e5,
    "ElementHandle": 1e5
  }[gcBucket] ?? 1e4;
}
__name(maxDispatchersForBucket, "maxDispatchersForBucket");
var Dispatcher = class extends EventEmitter8 {
  static {
    __name(this, "Dispatcher");
  }
  constructor(parent, object, type, initializer, gcBucket) {
    super();
    this._dispatchers = /* @__PURE__ */ new Map();
    this._disposed = false;
    this._eventListeners = [];
    this._activeProgressControllers = /* @__PURE__ */ new Set();
    this.connection = parent instanceof DispatcherConnection ? parent : parent.connection;
    this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
    const guid = object.guid;
    this._guid = guid;
    this._type = type;
    this._object = object;
    this._gcBucket = gcBucket ?? type;
    this.connection.registerDispatcher(this);
    if (this._parent) {
      assert3(!this._parent._dispatchers.has(guid));
      this._parent._dispatchers.set(guid, this);
    }
    if (this._parent)
      this.connection.sendCreate(this._parent, type, guid, initializer);
    this.connection.maybeDisposeStaleDispatchers(this._gcBucket);
  }
  parentScope() {
    return this._parent;
  }
  addObjectListener(eventName, handler) {
    this._eventListeners.push(eventsHelper.addEventListener(this._object, eventName, handler));
  }
  adopt(child) {
    if (child._parent === this)
      return;
    const oldParent = child._parent;
    oldParent._dispatchers.delete(child._guid);
    this._dispatchers.set(child._guid, child);
    child._parent = this;
    this.connection.sendAdopt(this, child);
  }
  async _runCommand(callMetadata, method, validParams) {
    const controller = new ProgressController(callMetadata, (message) => {
      const logName = this._object.logName || "api";
      debugLogger.log(logName, message);
      this._object.instrumentation.onCallLog(this._object, callMetadata, logName, message);
    });
    this._activeProgressControllers.add(controller);
    try {
      return await controller.run((progress3) => this[method](validParams, progress3), validParams?.timeout);
    } finally {
      this._activeProgressControllers.delete(controller);
    }
  }
  _dispatchEvent(method, params) {
    if (this._disposed) {
      if (isUnderTest())
        throw new Error(`${this._guid} is sending "${String(method)}" event after being disposed`);
      return;
    }
    this.connection.sendEvent(this, method, params);
  }
  _dispose(reason) {
    this._disposeRecursively(new TargetClosedError());
    this.connection.sendDispose(this, reason);
  }
  _onDispose() {
  }
  async stopPendingOperations(error3) {
    const controllers = [];
    const collect = /* @__PURE__ */ __name((dispatcher) => {
      controllers.push(...dispatcher._activeProgressControllers);
      for (const child of [...dispatcher._dispatchers.values()])
        collect(child);
    }, "collect");
    collect(this);
    await Promise.all(controllers.map((controller) => controller.abort(error3)));
  }
  _disposeRecursively(error3) {
    assert3(!this._disposed, `${this._guid} is disposed more than once`);
    for (const controller of this._activeProgressControllers) {
      if (!controller.metadata.potentiallyClosesScope)
        controller.abort(error3).catch(() => {
        });
    }
    this._onDispose();
    this._disposed = true;
    eventsHelper.removeEventListeners(this._eventListeners);
    this._parent?._dispatchers.delete(this._guid);
    const list = this.connection._dispatchersByBucket.get(this._gcBucket);
    list?.delete(this._guid);
    this.connection._dispatcherByGuid.delete(this._guid);
    this.connection._dispatcherByObject.delete(this._object);
    for (const dispatcher of [...this._dispatchers.values()])
      dispatcher._disposeRecursively(error3);
    this._dispatchers.clear();
  }
  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
    };
  }
  async waitForEventInfo() {
  }
};
var RootDispatcher = class extends Dispatcher {
  static {
    __name(this, "RootDispatcher");
  }
  constructor(connection, createPlaywright2) {
    super(connection, createRootSdkObject(), "Root", {});
    this.createPlaywright = createPlaywright2;
    this._initialized = false;
  }
  async initialize(params, progress3) {
    assert3(this.createPlaywright);
    assert3(!this._initialized);
    this._initialized = true;
    return {
      playwright: await this.createPlaywright(this, params)
    };
  }
};
var DispatcherConnection = class {
  static {
    __name(this, "DispatcherConnection");
  }
  constructor(isLocal) {
    this._dispatcherByGuid = /* @__PURE__ */ new Map();
    this._dispatcherByObject = /* @__PURE__ */ new Map();
    this._dispatchersByBucket = /* @__PURE__ */ new Map();
    this.onmessage = (message) => {
    };
    this._waitOperations = /* @__PURE__ */ new Map();
    this._isLocal = !!isLocal;
  }
  sendEvent(dispatcher, event, params) {
    const validator = findValidator(dispatcher._type, event, "Event");
    params = validator(params, "", this._validatorToWireContext());
    this.onmessage({ guid: dispatcher._guid, method: event, params });
  }
  sendCreate(parent, type, guid, initializer) {
    const validator = findValidator(type, "", "Initializer");
    initializer = validator(initializer, "", this._validatorToWireContext());
    this.onmessage({ guid: parent._guid, method: "__create__", params: { type, initializer, guid } });
  }
  sendAdopt(parent, dispatcher) {
    this.onmessage({ guid: parent._guid, method: "__adopt__", params: { guid: dispatcher._guid } });
  }
  sendDispose(dispatcher, reason) {
    this.onmessage({ guid: dispatcher._guid, method: "__dispose__", params: { reason } });
  }
  _validatorToWireContext() {
    return {
      tChannelImpl: this._tChannelImplToWire.bind(this),
      binary: this._isLocal ? "buffer" : "toBase64",
      isUnderTest
    };
  }
  _validatorFromWireContext() {
    return {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this._isLocal ? "buffer" : "fromBase64",
      isUnderTest
    };
  }
  _tChannelImplFromWire(names, arg, path30, context2) {
    if (arg && typeof arg === "object" && typeof arg.guid === "string") {
      const guid = arg.guid;
      const dispatcher = this._dispatcherByGuid.get(guid);
      if (!dispatcher)
        throw new ValidationError(`${path30}: no object with guid ${guid}`);
      if (names !== "*" && !names.includes(dispatcher._type))
        throw new ValidationError(`${path30}: object with guid ${guid} has type ${dispatcher._type}, expected ${names.toString()}`);
      return dispatcher;
    }
    throw new ValidationError(`${path30}: expected guid for ${names.toString()}`);
  }
  _tChannelImplToWire(names, arg, path30, context2) {
    if (arg instanceof Dispatcher) {
      if (names !== "*" && !names.includes(arg._type))
        throw new ValidationError(`${path30}: dispatcher with guid ${arg._guid} has type ${arg._type}, expected ${names.toString()}`);
      return { guid: arg._guid };
    }
    throw new ValidationError(`${path30}: expected dispatcher ${names.toString()}`);
  }
  existingDispatcher(object) {
    return this._dispatcherByObject.get(object);
  }
  registerDispatcher(dispatcher) {
    assert3(!this._dispatcherByGuid.has(dispatcher._guid));
    this._dispatcherByGuid.set(dispatcher._guid, dispatcher);
    this._dispatcherByObject.set(dispatcher._object, dispatcher);
    let list = this._dispatchersByBucket.get(dispatcher._gcBucket);
    if (!list) {
      list = /* @__PURE__ */ new Set();
      this._dispatchersByBucket.set(dispatcher._gcBucket, list);
    }
    list.add(dispatcher._guid);
  }
  maybeDisposeStaleDispatchers(gcBucket) {
    const maxDispatchers = maxDispatchersForBucket(gcBucket);
    const list = this._dispatchersByBucket.get(gcBucket);
    if (!list || list.size <= maxDispatchers)
      return;
    const dispatchersArray = [...list];
    const disposeCount = maxDispatchers / 10 | 0;
    this._dispatchersByBucket.set(gcBucket, new Set(dispatchersArray.slice(disposeCount)));
    for (let i = 0; i < disposeCount; ++i) {
      const d = this._dispatcherByGuid.get(dispatchersArray[i]);
      if (!d)
        continue;
      d._dispose("gc");
    }
  }
  async dispatch(message) {
    const { id, guid, method, params, metadata } = message;
    const dispatcher = this._dispatcherByGuid.get(guid);
    if (!dispatcher) {
      this.onmessage({ id, error: serializeError(new TargetClosedError()) });
      return;
    }
    let validParams;
    let validMetadata;
    try {
      const validator = findValidator(dispatcher._type, method, "Params");
      const validatorContext = this._validatorFromWireContext();
      validParams = validator(params, "", validatorContext);
      validMetadata = metadataValidator(metadata, "", validatorContext);
      if (typeof dispatcher[method] !== "function")
        throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
    } catch (e) {
      this.onmessage({ id, error: serializeError(e) });
      return;
    }
    const metainfo = methodMetainfo.get(dispatcher._type + "." + method);
    if (metainfo?.internal) {
      validMetadata.internal = true;
    }
    const sdkObject = dispatcher._object;
    const callMetadata = {
      id: `call@${id}`,
      location: validMetadata.location,
      title: validMetadata.title,
      internal: validMetadata.internal,
      stepId: validMetadata.stepId,
      objectId: sdkObject.guid,
      pageId: sdkObject.attribution?.page?.guid,
      frameId: sdkObject.attribution?.frame?.guid,
      startTime: monotonicTime(),
      endTime: 0,
      type: dispatcher._type,
      method,
      params: params || {},
      log: []
    };
    if (params?.info?.waitId) {
      const info3 = params.info;
      switch (info3.phase) {
        case "before": {
          this._waitOperations.set(info3.waitId, callMetadata);
          await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
          this.onmessage({ id });
          return;
        }
        case "log": {
          const originalMetadata = this._waitOperations.get(info3.waitId);
          originalMetadata.log.push(info3.message);
          sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, "api", info3.message);
          this.onmessage({ id });
          return;
        }
        case "after": {
          const originalMetadata = this._waitOperations.get(info3.waitId);
          originalMetadata.endTime = monotonicTime();
          originalMetadata.error = info3.error ? { error: { name: "Error", message: info3.error } } : void 0;
          this._waitOperations.delete(info3.waitId);
          await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
          this.onmessage({ id });
          return;
        }
      }
    }
    await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
    const response = { id };
    try {
      if (this._dispatcherByGuid.get(guid) !== dispatcher)
        throw new TargetClosedError(closeReason(sdkObject));
      const result = await dispatcher._runCommand(callMetadata, method, validParams);
      const validator = findValidator(dispatcher._type, method, "Result");
      response.result = validator(result, "", this._validatorToWireContext());
      callMetadata.result = result;
    } catch (e) {
      if (isTargetClosedError(e)) {
        const reason = closeReason(sdkObject);
        if (reason)
          rewriteErrorMessage(e, reason);
      } else if (isProtocolError(e)) {
        if (e.type === "closed")
          e = new TargetClosedError(closeReason(sdkObject), e.browserLogMessage());
        else if (e.type === "crashed")
          rewriteErrorMessage(e, "Target crashed " + e.browserLogMessage());
      }
      response.error = serializeError(e);
      callMetadata.error = response.error;
    } finally {
      callMetadata.endTime = monotonicTime();
      await sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata);
      if (metainfo?.slowMo)
        await this._doSlowMo(sdkObject);
    }
    if (response.error)
      response.log = compressCallLog(callMetadata.log);
    this.onmessage(response);
  }
  async _doSlowMo(sdkObject) {
    const slowMo = sdkObject.attribution.browser?.options.slowMo;
    if (slowMo)
      await new Promise((f) => setTimeout(f, slowMo));
  }
};
function closeReason(sdkObject) {
  return sdkObject.attribution.page?.closeReason || sdkObject.attribution.context?._closeReason || sdkObject.attribution.browser?._closeReason;
}
__name(closeReason, "closeReason");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/playwrightDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/fetch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import http3 from "node:http";
import https3 from "node:https";
import { pipeline as pipeline2, Transform } from "node:stream";
import { TLSSocket } from "node:tls";
import * as zlib from "node:zlib";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/urlMatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/stringUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function escapeWithQuotes(text, char = "'") {
  const stringified = JSON.stringify(text);
  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
  if (char === "'")
    return char + escapedText.replace(/[']/g, "\\'") + char;
  if (char === '"')
    return char + escapedText.replace(/["]/g, '\\"') + char;
  if (char === "`")
    return char + escapedText.replace(/[`]/g, "\\`") + char;
  throw new Error("Invalid escape char");
}
__name(escapeWithQuotes, "escapeWithQuotes");
function isString(obj) {
  return typeof obj === "string" || obj instanceof String;
}
__name(isString, "isString");
function toTitleCase(name) {
  return name.charAt(0).toUpperCase() + name.substring(1);
}
__name(toTitleCase, "toTitleCase");
function toSnakeCase(name) {
  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();
}
__name(toSnakeCase, "toSnakeCase");
function quoteCSSAttributeValue(text) {
  return `"${text.replace(/["\\]/g, (char) => "\\" + char)}"`;
}
__name(quoteCSSAttributeValue, "quoteCSSAttributeValue");
function normalizeEscapedRegexQuotes(source8) {
  return source8.replace(/(^|[^\\])(\\\\)*\\(['"`])/g, "$1$2$3");
}
__name(normalizeEscapedRegexQuotes, "normalizeEscapedRegexQuotes");
function escapeRegexForSelector(re2) {
  if (re2.unicode || re2.unicodeSets)
    return String(re2);
  return String(re2).replace(/(^|[^\\])(\\\\)*(["'`])/g, "$1$2\\$3").replace(/>>/g, "\\>\\>");
}
__name(escapeRegexForSelector, "escapeRegexForSelector");
function escapeForTextSelector(text, exact) {
  if (typeof text !== "string")
    return escapeRegexForSelector(text);
  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;
}
__name(escapeForTextSelector, "escapeForTextSelector");
function escapeForAttributeSelector(value, exact) {
  if (typeof value !== "string")
    return escapeRegexForSelector(value);
  return `"${value.replace(/\\/g, "\\\\").replace(/["]/g, '\\"')}"${exact ? "s" : "i"}`;
}
__name(escapeForAttributeSelector, "escapeForAttributeSelector");
function trimString(input, cap, suffix = "") {
  if (input.length <= cap)
    return input;
  const chars = [...input];
  if (chars.length > cap)
    return chars.slice(0, cap - suffix.length).join("") + suffix;
  return chars.join("");
}
__name(trimString, "trimString");
function trimStringWithEllipsis(input, cap) {
  return trimString(input, cap, "\u2026");
}
__name(trimStringWithEllipsis, "trimStringWithEllipsis");
var escaped = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
function escapeHTML2(s) {
  return s.replace(/[&<]/ug, (char) => escaped[char]);
}
__name(escapeHTML2, "escapeHTML");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/urlMatch.js
var escapedChars = /* @__PURE__ */ new Set(["$", "^", "+", ".", "*", "(", ")", "|", "\\", "?", "{", "}", "[", "]"]);
function globToRegexPattern(glob) {
  const tokens = ["^"];
  let inGroup = false;
  for (let i = 0; i < glob.length; ++i) {
    const c = glob[i];
    if (c === "\\" && i + 1 < glob.length) {
      const char = glob[++i];
      tokens.push(escapedChars.has(char) ? "\\" + char : char);
      continue;
    }
    if (c === "*") {
      const beforeDeep = glob[i - 1];
      let starCount = 1;
      while (glob[i + 1] === "*") {
        starCount++;
        i++;
      }
      const afterDeep = glob[i + 1];
      const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
      if (isDeep) {
        tokens.push("((?:[^/]*(?:/|$))*)");
        i++;
      } else {
        tokens.push("([^/]*)");
      }
      continue;
    }
    switch (c) {
      case "{":
        inGroup = true;
        tokens.push("(");
        break;
      case "}":
        inGroup = false;
        tokens.push(")");
        break;
      case ",":
        if (inGroup) {
          tokens.push("|");
          break;
        }
        tokens.push("\\" + c);
        break;
      default:
        tokens.push(escapedChars.has(c) ? "\\" + c : c);
    }
  }
  tokens.push("$");
  return tokens.join("");
}
__name(globToRegexPattern, "globToRegexPattern");
function isRegExp3(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp3, "isRegExp");
function urlMatchesEqual(match1, match2) {
  if (isRegExp3(match1) && isRegExp3(match2))
    return match1.source === match2.source && match1.flags === match2.flags;
  return match1 === match2;
}
__name(urlMatchesEqual, "urlMatchesEqual");
function urlMatches(baseURL, urlString, match, webSocketUrl) {
  if (match === void 0 || match === "")
    return true;
  if (isString(match))
    match = new RegExp(resolveGlobToRegexPattern(baseURL, match, webSocketUrl));
  if (isRegExp3(match)) {
    const r = match.test(urlString);
    return r;
  }
  const url4 = parseURL(urlString);
  if (!url4)
    return false;
  if (typeof match !== "function")
    throw new Error("url parameter should be string, RegExp or function");
  return match(url4);
}
__name(urlMatches, "urlMatches");
function resolveGlobToRegexPattern(baseURL, glob, webSocketUrl) {
  if (webSocketUrl)
    baseURL = toWebSocketBaseUrl(baseURL);
  glob = resolveGlobBase(baseURL, glob);
  return globToRegexPattern(glob);
}
__name(resolveGlobToRegexPattern, "resolveGlobToRegexPattern");
function toWebSocketBaseUrl(baseURL) {
  if (baseURL && /^https?:\/\//.test(baseURL))
    baseURL = baseURL.replace(/^http/, "ws");
  return baseURL;
}
__name(toWebSocketBaseUrl, "toWebSocketBaseUrl");
function resolveGlobBase(baseURL, match) {
  if (!match.startsWith("*")) {
    let mapToken = /* @__PURE__ */ __name(function(original, replacement) {
      if (original.length === 0)
        return "";
      tokenMap.set(replacement, original);
      return replacement;
    }, "mapToken");
    const tokenMap = /* @__PURE__ */ new Map();
    match = match.replaceAll(/\\\\\?/g, "?");
    if (match.startsWith("about:") || match.startsWith("data:") || match.startsWith("chrome:") || match.startsWith("edge:") || match.startsWith("file:"))
      return match;
    const relativePath = match.split("/").map((token, index2) => {
      if (token === "." || token === ".." || token === "")
        return token;
      if (index2 === 0 && token.endsWith(":"))
        return mapToken(token, "http:");
      const questionIndex = token.indexOf("?");
      if (questionIndex === -1)
        return mapToken(token, `$_${index2}_$`);
      const newPrefix = mapToken(token.substring(0, questionIndex), `$_${index2}_$`);
      const newSuffix = mapToken(token.substring(questionIndex), `?$_${index2}_$`);
      return newPrefix + newSuffix;
    }).join("/");
    const result = resolveBaseURL(baseURL, relativePath);
    let resolved = result.resolved;
    for (const [token, original] of tokenMap) {
      const normalize = result.caseInsensitivePart?.includes(token);
      resolved = resolved.replace(token, normalize ? original.toLowerCase() : original);
    }
    match = resolved;
  }
  return match;
}
__name(resolveGlobBase, "resolveGlobBase");
function parseURL(url4) {
  try {
    return new URL(url4);
  } catch (e) {
    return null;
  }
}
__name(parseURL, "parseURL");
function constructURLBasedOnBaseURL(baseURL, givenURL) {
  try {
    return resolveBaseURL(baseURL, givenURL).resolved;
  } catch (e) {
    return givenURL;
  }
}
__name(constructURLBasedOnBaseURL, "constructURLBasedOnBaseURL");
function resolveBaseURL(baseURL, givenURL) {
  try {
    const url4 = new URL(givenURL, baseURL);
    const resolved = url4.toString();
    const caseInsensitivePrefix = url4.origin;
    return { resolved, caseInsensitivePart: caseInsensitivePrefix };
  } catch (e) {
    return { resolved: givenURL };
  }
}
__name(resolveBaseURL, "resolveBaseURL");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/fetch.js
import "node:fs";
import "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browserContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs20 from "node:fs";
import path14 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/clock.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/clockSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/clock.ts\nvar clock_exports = {};\n__export(clock_exports, {\n  ClockController: () => ClockController,\n  createClock: () => createClock,\n  inject: () => inject,\n  install: () => install\n});\nmodule.exports = __toCommonJS(clock_exports);\nvar ClockController = class {\n  constructor(embedder) {\n    this._duringTick = false;\n    this._uniqueTimerId = idCounterStart;\n    this.disposables = [];\n    this._log = [];\n    this._timers = /* @__PURE__ */ new Map();\n    this._now = { time: asWallTime(0), isFixedTime: false, ticks: 0, origin: asWallTime(-1) };\n    this._embedder = embedder;\n  }\n  uninstall() {\n    this.disposables.forEach((dispose) => dispose());\n    this.disposables.length = 0;\n  }\n  now() {\n    this._replayLogOnce();\n    this._syncRealTime();\n    return this._now.time;\n  }\n  install(time) {\n    this._replayLogOnce();\n    this._innerSetTime(asWallTime(time));\n  }\n  setSystemTime(time) {\n    this._replayLogOnce();\n    this._innerSetTime(asWallTime(time));\n  }\n  setFixedTime(time) {\n    this._replayLogOnce();\n    this._innerSetFixedTime(asWallTime(time));\n  }\n  performanceNow() {\n    this._replayLogOnce();\n    this._syncRealTime();\n    return this._now.ticks;\n  }\n  _syncRealTime() {\n    if (!this._realTime)\n      return;\n    const now = this._embedder.performanceNow();\n    const sinceLastSync = now - this._realTime.lastSyncTicks;\n    if (sinceLastSync > 0) {\n      this._advanceNow(shiftTicks(this._now.ticks, sinceLastSync));\n      this._realTime.lastSyncTicks = now;\n    }\n  }\n  _innerSetTime(time) {\n    this._now.time = time;\n    this._now.isFixedTime = false;\n    if (this._now.origin < 0)\n      this._now.origin = this._now.time;\n  }\n  _innerSetFixedTime(time) {\n    this._innerSetTime(time);\n    this._now.isFixedTime = true;\n  }\n  _advanceNow(to) {\n    if (!this._now.isFixedTime)\n      this._now.time = asWallTime(this._now.time + to - this._now.ticks);\n    this._now.ticks = to;\n  }\n  async log(type, time, param) {\n    this._log.push({ type, time, param });\n  }\n  async runFor(ticks) {\n    this._replayLogOnce();\n    if (ticks < 0)\n      throw new TypeError("Negative ticks are not supported");\n    await this._runTo(shiftTicks(this._now.ticks, ticks));\n  }\n  async _runTo(to) {\n    to = Math.ceil(to);\n    if (this._now.ticks > to)\n      return;\n    let firstException;\n    while (true) {\n      const result = await this._callFirstTimer(to);\n      if (!result.timerFound)\n        break;\n      firstException = firstException || result.error;\n    }\n    this._advanceNow(to);\n    if (firstException)\n      throw firstException;\n  }\n  async pauseAt(time) {\n    this._replayLogOnce();\n    this._innerPause();\n    const toConsume = time - this._now.time;\n    await this._innerFastForwardTo(shiftTicks(this._now.ticks, toConsume));\n    return toConsume;\n  }\n  _innerPause() {\n    this._realTime = void 0;\n    this._updateRealTimeTimer();\n  }\n  resume() {\n    this._replayLogOnce();\n    this._innerResume();\n  }\n  _innerResume() {\n    const now = this._embedder.performanceNow();\n    this._realTime = { startTicks: now, lastSyncTicks: now };\n    this._updateRealTimeTimer();\n  }\n  _updateRealTimeTimer() {\n    var _a;\n    if (!this._realTime) {\n      (_a = this._currentRealTimeTimer) == null ? void 0 : _a.dispose();\n      this._currentRealTimeTimer = void 0;\n      return;\n    }\n    const firstTimer = this._firstTimer();\n    const callAt = Math.min(firstTimer ? firstTimer.callAt : this._now.ticks + maxTimeout, this._now.ticks + 100);\n    if (this._currentRealTimeTimer && this._currentRealTimeTimer.callAt < callAt)\n      return;\n    if (this._currentRealTimeTimer) {\n      this._currentRealTimeTimer.dispose();\n      this._currentRealTimeTimer = void 0;\n    }\n    this._currentRealTimeTimer = {\n      callAt,\n      dispose: this._embedder.setTimeout(() => {\n        this._currentRealTimeTimer = void 0;\n        this._syncRealTime();\n        void this._runTo(this._now.ticks).catch((e) => console.error(e)).then(() => this._updateRealTimeTimer());\n      }, callAt - this._now.ticks)\n    };\n  }\n  async fastForward(ticks) {\n    this._replayLogOnce();\n    await this._innerFastForwardTo(shiftTicks(this._now.ticks, ticks | 0));\n  }\n  async _innerFastForwardTo(to) {\n    if (to < this._now.ticks)\n      throw new Error("Cannot fast-forward to the past");\n    for (const timer of this._timers.values()) {\n      if (to > timer.callAt)\n        timer.callAt = to;\n    }\n    await this._runTo(to);\n  }\n  addTimer(options) {\n    this._replayLogOnce();\n    if (options.type === "AnimationFrame" /* AnimationFrame */ && !options.func)\n      throw new Error("Callback must be provided to requestAnimationFrame calls");\n    if (options.type === "IdleCallback" /* IdleCallback */ && !options.func)\n      throw new Error("Callback must be provided to requestIdleCallback calls");\n    if (["Timeout" /* Timeout */, "Interval" /* Interval */].includes(options.type) && !options.func && options.delay === void 0)\n      throw new Error("Callback must be provided to timer calls");\n    let delay = options.delay ? +options.delay : 0;\n    if (!Number.isFinite(delay))\n      delay = 0;\n    delay = delay > maxTimeout ? 1 : delay;\n    delay = Math.max(0, delay);\n    const timer = {\n      type: options.type,\n      func: options.func,\n      args: options.args || [],\n      delay,\n      callAt: shiftTicks(this._now.ticks, delay || (this._duringTick ? 1 : 0)),\n      createdAt: this._now.ticks,\n      id: this._uniqueTimerId++,\n      error: new Error()\n    };\n    this._timers.set(timer.id, timer);\n    if (this._realTime)\n      this._updateRealTimeTimer();\n    return timer.id;\n  }\n  countTimers() {\n    return this._timers.size;\n  }\n  _firstTimer(beforeTick) {\n    let firstTimer = null;\n    for (const timer of this._timers.values()) {\n      const isInRange = beforeTick === void 0 || timer.callAt <= beforeTick;\n      if (isInRange && (!firstTimer || compareTimers(firstTimer, timer) === 1))\n        firstTimer = timer;\n    }\n    return firstTimer;\n  }\n  _takeFirstTimer(beforeTick) {\n    const timer = this._firstTimer(beforeTick);\n    if (!timer)\n      return null;\n    this._advanceNow(timer.callAt);\n    if (timer.type === "Interval" /* Interval */)\n      timer.callAt = shiftTicks(timer.callAt, timer.delay);\n    else\n      this._timers.delete(timer.id);\n    return timer;\n  }\n  async _callFirstTimer(beforeTick) {\n    const timer = this._takeFirstTimer(beforeTick);\n    if (!timer)\n      return { timerFound: false };\n    this._duringTick = true;\n    try {\n      if (typeof timer.func !== "function") {\n        let error2;\n        try {\n          (() => {\n            globalThis.eval(timer.func);\n          })();\n        } catch (e) {\n          error2 = e;\n        }\n        await new Promise((f) => this._embedder.setTimeout(f));\n        return { timerFound: true, error: error2 };\n      }\n      let args = timer.args;\n      if (timer.type === "AnimationFrame" /* AnimationFrame */)\n        args = [this._now.ticks];\n      else if (timer.type === "IdleCallback" /* IdleCallback */)\n        args = [{ didTimeout: false, timeRemaining: () => 0 }];\n      let error;\n      try {\n        timer.func.apply(null, args);\n      } catch (e) {\n        error = e;\n      }\n      await new Promise((f) => this._embedder.setTimeout(f));\n      return { timerFound: true, error };\n    } finally {\n      this._duringTick = false;\n    }\n  }\n  getTimeToNextFrame() {\n    return 16 - this._now.ticks % 16;\n  }\n  clearTimer(timerId, type) {\n    this._replayLogOnce();\n    if (!timerId) {\n      return;\n    }\n    const id = Number(timerId);\n    if (Number.isNaN(id) || id < idCounterStart) {\n      const handlerName = getClearHandler(type);\n      new Error(`Clock: ${handlerName} was invoked to clear a native timer instead of one created by the clock library.`);\n    }\n    const timer = this._timers.get(id);\n    if (timer) {\n      if (timer.type === type || timer.type === "Timeout" && type === "Interval" || timer.type === "Interval" && type === "Timeout") {\n        this._timers.delete(id);\n      } else {\n        const clear = getClearHandler(type);\n        const schedule = getScheduleHandler(timer.type);\n        throw new Error(\n          `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`\n        );\n      }\n    }\n  }\n  _replayLogOnce() {\n    if (!this._log.length)\n      return;\n    let lastLogTime = -1;\n    let isPaused = false;\n    for (const { type, time, param } of this._log) {\n      if (!isPaused && lastLogTime !== -1)\n        this._advanceNow(shiftTicks(this._now.ticks, time - lastLogTime));\n      lastLogTime = time;\n      if (type === "install") {\n        this._innerSetTime(asWallTime(param));\n      } else if (type === "fastForward" || type === "runFor") {\n        this._advanceNow(shiftTicks(this._now.ticks, param));\n      } else if (type === "pauseAt") {\n        isPaused = true;\n        this._innerPause();\n        this._innerSetTime(asWallTime(param));\n      } else if (type === "resume") {\n        this._innerResume();\n        isPaused = false;\n      } else if (type === "setFixedTime") {\n        this._innerSetFixedTime(asWallTime(param));\n      } else if (type === "setSystemTime") {\n        this._innerSetTime(asWallTime(param));\n      }\n    }\n    if (!isPaused && lastLogTime > 0)\n      this._advanceNow(shiftTicks(this._now.ticks, this._embedder.dateNow() - lastLogTime));\n    this._log.length = 0;\n  }\n};\nfunction mirrorDateProperties(target, source) {\n  for (const prop in source) {\n    if (source.hasOwnProperty(prop))\n      target[prop] = source[prop];\n  }\n  target.toString = () => source.toString();\n  target.prototype = source.prototype;\n  target.parse = source.parse;\n  target.UTC = source.UTC;\n  target.prototype.toUTCString = source.prototype.toUTCString;\n  target.isFake = true;\n  return target;\n}\nfunction createDate(clock, NativeDate) {\n  function ClockDate(year, month, date, hour, minute, second, ms) {\n    if (!(this instanceof ClockDate))\n      return new NativeDate(clock.now()).toString();\n    switch (arguments.length) {\n      case 0:\n        return new NativeDate(clock.now());\n      case 1:\n        return new NativeDate(year);\n      case 2:\n        return new NativeDate(year, month);\n      case 3:\n        return new NativeDate(year, month, date);\n      case 4:\n        return new NativeDate(year, month, date, hour);\n      case 5:\n        return new NativeDate(year, month, date, hour, minute);\n      case 6:\n        return new NativeDate(\n          year,\n          month,\n          date,\n          hour,\n          minute,\n          second\n        );\n      default:\n        return new NativeDate(\n          year,\n          month,\n          date,\n          hour,\n          minute,\n          second,\n          ms\n        );\n    }\n  }\n  ClockDate.now = () => clock.now();\n  return mirrorDateProperties(ClockDate, NativeDate);\n}\nfunction createIntl(clock, NativeIntl) {\n  const ClockIntl = {};\n  for (const key of Object.getOwnPropertyNames(NativeIntl))\n    ClockIntl[key] = NativeIntl[key];\n  ClockIntl.DateTimeFormat = function(...args) {\n    const realFormatter = new NativeIntl.DateTimeFormat(...args);\n    const formatter = {\n      formatRange: realFormatter.formatRange.bind(realFormatter),\n      formatRangeToParts: realFormatter.formatRangeToParts.bind(realFormatter),\n      resolvedOptions: realFormatter.resolvedOptions.bind(realFormatter),\n      format: (date) => realFormatter.format(date || clock.now()),\n      formatToParts: (date) => realFormatter.formatToParts(date || clock.now())\n    };\n    return formatter;\n  };\n  ClockIntl.DateTimeFormat.prototype = Object.create(\n    NativeIntl.DateTimeFormat.prototype\n  );\n  ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf;\n  return ClockIntl;\n}\nfunction compareTimers(a, b) {\n  if (a.callAt < b.callAt)\n    return -1;\n  if (a.callAt > b.callAt)\n    return 1;\n  if (a.type === "Immediate" /* Immediate */ && b.type !== "Immediate" /* Immediate */)\n    return -1;\n  if (a.type !== "Immediate" /* Immediate */ && b.type === "Immediate" /* Immediate */)\n    return 1;\n  if (a.createdAt < b.createdAt)\n    return -1;\n  if (a.createdAt > b.createdAt)\n    return 1;\n  if (a.id < b.id)\n    return -1;\n  if (a.id > b.id)\n    return 1;\n}\nvar maxTimeout = Math.pow(2, 31) - 1;\nvar idCounterStart = 1e12;\nfunction platformOriginals(globalObject) {\n  const raw = {\n    setTimeout: globalObject.setTimeout,\n    clearTimeout: globalObject.clearTimeout,\n    setInterval: globalObject.setInterval,\n    clearInterval: globalObject.clearInterval,\n    requestAnimationFrame: globalObject.requestAnimationFrame ? globalObject.requestAnimationFrame : void 0,\n    cancelAnimationFrame: globalObject.cancelAnimationFrame ? globalObject.cancelAnimationFrame : void 0,\n    requestIdleCallback: globalObject.requestIdleCallback ? globalObject.requestIdleCallback : void 0,\n    cancelIdleCallback: globalObject.cancelIdleCallback ? globalObject.cancelIdleCallback : void 0,\n    Date: globalObject.Date,\n    performance: globalObject.performance,\n    Intl: globalObject.Intl\n  };\n  const bound = { ...raw };\n  for (const key of Object.keys(bound)) {\n    if (key !== "Date" && typeof bound[key] === "function")\n      bound[key] = bound[key].bind(globalObject);\n  }\n  return { raw, bound };\n}\nfunction getScheduleHandler(type) {\n  if (type === "IdleCallback" || type === "AnimationFrame")\n    return `request${type}`;\n  return `set${type}`;\n}\nfunction createApi(clock, originals) {\n  return {\n    setTimeout: (func, timeout, ...args) => {\n      const delay = timeout ? +timeout : timeout;\n      return clock.addTimer({\n        type: "Timeout" /* Timeout */,\n        func,\n        args,\n        delay\n      });\n    },\n    clearTimeout: (timerId) => {\n      if (timerId)\n        clock.clearTimer(timerId, "Timeout" /* Timeout */);\n    },\n    setInterval: (func, timeout, ...args) => {\n      const delay = timeout ? +timeout : timeout;\n      return clock.addTimer({\n        type: "Interval" /* Interval */,\n        func,\n        args,\n        delay\n      });\n    },\n    clearInterval: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "Interval" /* Interval */);\n    },\n    requestAnimationFrame: (callback) => {\n      return clock.addTimer({\n        type: "AnimationFrame" /* AnimationFrame */,\n        func: callback,\n        delay: clock.getTimeToNextFrame()\n      });\n    },\n    cancelAnimationFrame: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "AnimationFrame" /* AnimationFrame */);\n    },\n    requestIdleCallback: (callback, options) => {\n      let timeToNextIdlePeriod = 0;\n      if (clock.countTimers() > 0)\n        timeToNextIdlePeriod = 50;\n      return clock.addTimer({\n        type: "IdleCallback" /* IdleCallback */,\n        func: callback,\n        delay: (options == null ? void 0 : options.timeout) ? Math.min(options == null ? void 0 : options.timeout, timeToNextIdlePeriod) : timeToNextIdlePeriod\n      });\n    },\n    cancelIdleCallback: (timerId) => {\n      if (timerId)\n        return clock.clearTimer(timerId, "IdleCallback" /* IdleCallback */);\n    },\n    Intl: originals.Intl ? createIntl(clock, originals.Intl) : void 0,\n    Date: createDate(clock, originals.Date),\n    performance: originals.performance ? fakePerformance(clock, originals.performance) : void 0\n  };\n}\nfunction getClearHandler(type) {\n  if (type === "IdleCallback" || type === "AnimationFrame")\n    return `cancel${type}`;\n  return `clear${type}`;\n}\nfunction fakePerformance(clock, performance) {\n  const result = {\n    now: () => clock.performanceNow()\n  };\n  result.__defineGetter__("timeOrigin", () => clock._now.origin || 0);\n  for (const key of Object.keys(performance.__proto__)) {\n    if (key === "now" || key === "timeOrigin")\n      continue;\n    if (key === "getEntries" || key === "getEntriesByName" || key === "getEntriesByType")\n      result[key] = () => [];\n    else\n      result[key] = () => {\n      };\n  }\n  return result;\n}\nfunction createClock(globalObject) {\n  const originals = platformOriginals(globalObject);\n  const embedder = {\n    dateNow: () => originals.raw.Date.now(),\n    performanceNow: () => Math.ceil(originals.raw.performance.now()),\n    setTimeout: (task, timeout) => {\n      const timerId = originals.bound.setTimeout(task, timeout);\n      return () => originals.bound.clearTimeout(timerId);\n    },\n    setInterval: (task, delay) => {\n      const intervalId = originals.bound.setInterval(task, delay);\n      return () => originals.bound.clearInterval(intervalId);\n    }\n  };\n  const clock = new ClockController(embedder);\n  const api = createApi(clock, originals.bound);\n  return { clock, api, originals: originals.raw };\n}\nfunction install(globalObject, config = {}) {\n  var _a, _b;\n  if ((_a = globalObject.Date) == null ? void 0 : _a.isFake) {\n    throw new TypeError(`Can\'t install fake timers twice on the same global object.`);\n  }\n  const { clock, api, originals } = createClock(globalObject);\n  const toFake = ((_b = config.toFake) == null ? void 0 : _b.length) ? config.toFake : Object.keys(originals);\n  for (const method of toFake) {\n    if (method === "Date") {\n      globalObject.Date = mirrorDateProperties(api.Date, globalObject.Date);\n    } else if (method === "Intl") {\n      globalObject.Intl = api[method];\n    } else if (method === "performance") {\n      globalObject.performance = api[method];\n      const kEventTimeStamp = Symbol("playwrightEventTimeStamp");\n      Object.defineProperty(Event.prototype, "timeStamp", {\n        get() {\n          var _a2;\n          if (!this[kEventTimeStamp])\n            this[kEventTimeStamp] = (_a2 = api.performance) == null ? void 0 : _a2.now();\n          return this[kEventTimeStamp];\n        }\n      });\n    } else {\n      globalObject[method] = (...args) => {\n        return api[method].apply(api, args);\n      };\n    }\n    clock.disposables.push(() => {\n      globalObject[method] = originals[method];\n    });\n  }\n  return { clock, api, originals };\n}\nfunction inject(globalObject) {\n  const builtins = platformOriginals(globalObject).bound;\n  const { clock: controller } = install(globalObject);\n  controller.resume();\n  return {\n    controller,\n    builtins\n  };\n}\nfunction asWallTime(n) {\n  return n;\n}\nfunction shiftTicks(ticks, ms) {\n  return ticks + ms;\n}\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/clock.js
var Clock = class {
  static {
    __name(this, "Clock");
  }
  constructor(browserContext) {
    this._initScripts = [];
    this._browserContext = browserContext;
  }
  async uninstall(progress3) {
    await progress3.race(this._browserContext.removeInitScripts(this._initScripts));
    this._initScripts = [];
  }
  async fastForward(progress3, ticks) {
    await this._installIfNeeded(progress3);
    const ticksMillis = parseTicks(ticks);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('fastForward', ${Date.now()}, ${ticksMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.fastForward(${ticksMillis})`));
  }
  async install(progress3, time3) {
    await this._installIfNeeded(progress3);
    const timeMillis = time3 !== void 0 ? parseTime(time3) : Date.now();
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('install', ${Date.now()}, ${timeMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.install(${timeMillis})`));
  }
  async pauseAt(progress3, ticks) {
    await this._installIfNeeded(progress3);
    const timeMillis = parseTime(ticks);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('pauseAt', ${Date.now()}, ${timeMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.pauseAt(${timeMillis})`));
  }
  resumeNoReply() {
    if (!this._initScripts.length)
      return;
    const doResume = /* @__PURE__ */ __name(async () => {
      this._initScripts.push(await this._browserContext.addInitScript(void 0, `globalThis.__pwClock.controller.log('resume', ${Date.now()})`));
      await this._evaluateInFrames(`globalThis.__pwClock.controller.resume()`);
    }, "doResume");
    doResume().catch(() => {
    });
  }
  async resume(progress3) {
    await this._installIfNeeded(progress3);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('resume', ${Date.now()})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.resume()`));
  }
  async setFixedTime(progress3, time3) {
    await this._installIfNeeded(progress3);
    const timeMillis = parseTime(time3);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('setFixedTime', ${Date.now()}, ${timeMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.setFixedTime(${timeMillis})`));
  }
  async setSystemTime(progress3, time3) {
    await this._installIfNeeded(progress3);
    const timeMillis = parseTime(time3);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('setSystemTime', ${Date.now()}, ${timeMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.setSystemTime(${timeMillis})`));
  }
  async runFor(progress3, ticks) {
    await this._installIfNeeded(progress3);
    const ticksMillis = parseTicks(ticks);
    this._initScripts.push(await this._browserContext.addInitScript(progress3, `globalThis.__pwClock.controller.log('runFor', ${Date.now()}, ${ticksMillis})`));
    await progress3.race(this._evaluateInFrames(`globalThis.__pwClock.controller.runFor(${ticksMillis})`));
  }
  async _installIfNeeded(progress3) {
    if (this._initScripts.length)
      return;
    const script = `(() => {
      const module = {};
      ${source}
      if (!globalThis.__pwClock)
        globalThis.__pwClock = (module.exports.inject())(globalThis);
    })();`;
    const initScript = await this._browserContext.addInitScript(progress3, script);
    await progress3.race(this._evaluateInFrames(script));
    this._initScripts.push(initScript);
  }
  async _evaluateInFrames(script) {
    await this._browserContext.safeNonStallingEvaluateInAllFrames(script, "main", { throwOnJSErrors: true });
  }
};
function parseTicks(value) {
  if (typeof value === "number")
    return value;
  if (!value)
    return 0;
  const str = value;
  const strings = str.split(":");
  const l = strings.length;
  let i = l;
  let ms3 = 0;
  let parsed;
  if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
    throw new Error(
      `Clock only understands numbers, 'mm:ss' and 'hh:mm:ss'`
    );
  }
  while (i--) {
    parsed = parseInt(strings[i], 10);
    if (parsed >= 60)
      throw new Error(`Invalid time ${str}`);
    ms3 += parsed * Math.pow(60, l - i - 1);
  }
  return ms3 * 1e3;
}
__name(parseTicks, "parseTicks");
function parseTime(epoch) {
  if (!epoch)
    return 0;
  if (typeof epoch === "number")
    return epoch;
  const parsed = new Date(epoch);
  if (!isFinite(parsed.getTime()))
    throw new Error(`Invalid date: ${epoch}`);
  return parsed.getTime();
}
__name(parseTime, "parseTime");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/debugger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter9 } from "node:events";
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var symbol = Symbol("Debugger");
var Debugger = class _Debugger extends EventEmitter9 {
  static {
    __name(this, "Debugger");
  }
  constructor(context2) {
    super();
    this._pauseOnNextStatement = false;
    this._pausedCallsMetadata = /* @__PURE__ */ new Map();
    this._muted = false;
    this._context = context2;
    this._context[symbol] = this;
    this._enabled = debugMode() === "inspector";
    if (this._enabled)
      this.pauseOnNextStatement();
    context2.instrumentation.addListener(this, context2);
    this._context.once(BrowserContext.Events.Close, () => {
      this._context.instrumentation.removeListener(this);
    });
  }
  static {
    this.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
  }
  async setMuted(muted) {
    this._muted = muted;
  }
  async onBeforeCall(sdkObject, metadata) {
    if (this._muted)
      return;
    if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
      await this.pause(sdkObject, metadata);
  }
  async onBeforeInputAction(sdkObject, metadata) {
    if (this._muted)
      return;
    if (this._enabled && this._pauseOnNextStatement)
      await this.pause(sdkObject, metadata);
  }
  async pause(sdkObject, metadata) {
    if (this._muted)
      return;
    this._enabled = true;
    metadata.pauseStartTime = monotonicTime();
    const result = new Promise((resolve) => {
      this._pausedCallsMetadata.set(metadata, { resolve, sdkObject });
    });
    this.emit(_Debugger.Events.PausedStateChanged);
    return result;
  }
  resume(step) {
    if (!this.isPaused())
      return;
    this._pauseOnNextStatement = step;
    const endTime = monotonicTime();
    for (const [metadata, { resolve }] of this._pausedCallsMetadata) {
      metadata.pauseEndTime = endTime;
      resolve();
    }
    this._pausedCallsMetadata.clear();
    this.emit(_Debugger.Events.PausedStateChanged);
  }
  pauseOnNextStatement() {
    this._pauseOnNextStatement = true;
  }
  isPaused(metadata) {
    if (metadata)
      return this._pausedCallsMetadata.has(metadata);
    return !!this._pausedCallsMetadata.size;
  }
  pausedDetails() {
    const result = [];
    for (const [metadata, { sdkObject }] of this._pausedCallsMetadata)
      result.push({ metadata, sdkObject });
    return result;
  }
};
function shouldPauseOnCall(sdkObject, metadata) {
  if (sdkObject.attribution.playwright.options.isServer)
    return false;
  if (!sdkObject.attribution.browser?.options.headful && !isUnderTest())
    return false;
  return metadata.method === "pause";
}
__name(shouldPauseOnCall, "shouldPauseOnCall");
function shouldPauseBeforeStep(metadata) {
  if (metadata.internal)
    return false;
  const metainfo = methodMetainfo.get(metadata.type + "." + metadata.method);
  return !!metainfo?.pausesBeforeAction;
}
__name(shouldPauseBeforeStep, "shouldPauseBeforeStep");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dialog.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var Dialog = class extends SdkObject {
  static {
    __name(this, "Dialog");
  }
  constructor(page, type, message, onHandle, defaultValue) {
    super(page, "dialog");
    this._handled = false;
    this._page = page;
    this._type = type;
    this._message = message;
    this._onHandle = onHandle;
    this._defaultValue = defaultValue || "";
  }
  page() {
    return this._page;
  }
  type() {
    return this._type;
  }
  message() {
    return this._message;
  }
  defaultValue() {
    return this._defaultValue;
  }
  async accept(promptText) {
    assert3(!this._handled, "Cannot accept dialog which is already handled!");
    this._handled = true;
    this._page.browserContext.dialogManager.dialogWillClose(this);
    await this._onHandle(true, promptText);
  }
  async dismiss() {
    assert3(!this._handled, "Cannot dismiss dialog which is already handled!");
    this._handled = true;
    this._page.browserContext.dialogManager.dialogWillClose(this);
    await this._onHandle(false);
  }
  async close() {
    if (this._type === "beforeunload")
      await this.accept();
    else
      await this.dismiss();
  }
};
var DialogManager = class {
  static {
    __name(this, "DialogManager");
  }
  constructor(instrumentation) {
    this._dialogHandlers = /* @__PURE__ */ new Set();
    this._openedDialogs = /* @__PURE__ */ new Set();
    this._instrumentation = instrumentation;
  }
  dialogDidOpen(dialog) {
    for (const frame of dialog.page().frameManager.frames())
      frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
    this._openedDialogs.add(dialog);
    this._instrumentation.onDialog(dialog);
    let hasHandlers = false;
    for (const handler of this._dialogHandlers) {
      if (handler(dialog))
        hasHandlers = true;
    }
    if (!hasHandlers)
      dialog.close().then(() => {
      });
  }
  dialogWillClose(dialog) {
    this._openedDialogs.delete(dialog);
  }
  addDialogHandler(handler) {
    this._dialogHandlers.add(handler);
  }
  removeDialogHandler(handler) {
    this._dialogHandlers.delete(handler);
    if (!this._dialogHandlers.size) {
      for (const dialog of this._openedDialogs)
        dialog.close().catch(() => {
        });
    }
  }
  hasOpenDialogsForPage(page) {
    return [...this._openedDialogs].some((dialog) => dialog.page() === page);
  }
  async closeBeforeUnloadDialogs() {
    await Promise.all([...this._openedDialogs].map(async (dialog) => {
      if (dialog.type() === "beforeunload")
        await dialog.dismiss();
    }));
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/har/harRecorder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs14 from "node:fs";
import path10 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/artifact.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs11 from "node:fs";
import "node:crypto";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var Artifact = class extends SdkObject {
  static {
    __name(this, "Artifact");
  }
  constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
    super(parent, "artifact");
    this._finishedPromise = new ManualPromise();
    this._saveCallbacks = [];
    this._finished = false;
    this._deleted = false;
    this._localPath = localPath;
    this._unaccessibleErrorMessage = unaccessibleErrorMessage;
    this._cancelCallback = cancelCallback;
  }
  finishedPromise() {
    return this._finishedPromise;
  }
  localPath() {
    return this._localPath;
  }
  async localPathAfterFinished() {
    if (this._unaccessibleErrorMessage)
      throw new Error(this._unaccessibleErrorMessage);
    await this._finishedPromise;
    if (this._failureError)
      throw this._failureError;
    return this._localPath;
  }
  saveAs(saveCallback) {
    if (this._unaccessibleErrorMessage)
      throw new Error(this._unaccessibleErrorMessage);
    if (this._deleted)
      throw new Error(`File already deleted. Save before deleting.`);
    if (this._failureError)
      throw this._failureError;
    if (this._finished) {
      saveCallback(this._localPath).catch(() => {
      });
      return;
    }
    this._saveCallbacks.push(saveCallback);
  }
  async failureError() {
    if (this._unaccessibleErrorMessage)
      return this._unaccessibleErrorMessage;
    await this._finishedPromise;
    return this._failureError?.message || null;
  }
  async cancel() {
    assert3(this._cancelCallback !== void 0);
    return this._cancelCallback();
  }
  async delete() {
    if (this._unaccessibleErrorMessage)
      return;
    const fileName = await this.localPathAfterFinished();
    if (this._deleted)
      return;
    this._deleted = true;
    if (fileName)
      await fs11.promises.unlink(fileName).catch((e) => {
      });
  }
  async deleteOnContextClose() {
    if (this._deleted)
      return;
    this._deleted = true;
    if (!this._unaccessibleErrorMessage)
      await fs11.promises.unlink(this._localPath).catch((e) => {
      });
    await this.reportFinished(new TargetClosedError());
  }
  async reportFinished(error3) {
    if (this._finished)
      return;
    this._finished = true;
    this._failureError = error3;
    if (error3) {
      for (const callback of this._saveCallbacks)
        await callback("", error3);
    } else {
      for (const callback of this._saveCallbacks)
        await callback(this._localPath);
    }
    this._saveCallbacks = [];
    this._finishedPromise.resolve();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/har/harTracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/mimeType.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isTextualMimeType(mimeType) {
  return !!mimeType.match(/^(text\/.*?|application\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\/svg(\+xml)?|application\/.*?(\+json|\+xml))(;\s*charset=.*)?$/);
}
__name(isTextualMimeType, "isTextualMimeType");
function getMimeTypeForPath(path30) {
  const dotIndex = path30.lastIndexOf(".");
  if (dotIndex === -1)
    return null;
  const extension = path30.substring(dotIndex + 1);
  return types.get(extension) || null;
}
__name(getMimeTypeForPath, "getMimeTypeForPath");
var types = /* @__PURE__ */ new Map([
  ["ez", "application/andrew-inset"],
  ["aw", "application/applixware"],
  ["atom", "application/atom+xml"],
  ["atomcat", "application/atomcat+xml"],
  ["atomdeleted", "application/atomdeleted+xml"],
  ["atomsvc", "application/atomsvc+xml"],
  ["dwd", "application/atsc-dwd+xml"],
  ["held", "application/atsc-held+xml"],
  ["rsat", "application/atsc-rsat+xml"],
  ["bdoc", "application/bdoc"],
  ["xcs", "application/calendar+xml"],
  ["ccxml", "application/ccxml+xml"],
  ["cdfx", "application/cdfx+xml"],
  ["cdmia", "application/cdmi-capability"],
  ["cdmic", "application/cdmi-container"],
  ["cdmid", "application/cdmi-domain"],
  ["cdmio", "application/cdmi-object"],
  ["cdmiq", "application/cdmi-queue"],
  ["cu", "application/cu-seeme"],
  ["mpd", "application/dash+xml"],
  ["davmount", "application/davmount+xml"],
  ["dbk", "application/docbook+xml"],
  ["dssc", "application/dssc+der"],
  ["xdssc", "application/dssc+xml"],
  ["ecma", "application/ecmascript"],
  ["es", "application/ecmascript"],
  ["emma", "application/emma+xml"],
  ["emotionml", "application/emotionml+xml"],
  ["epub", "application/epub+zip"],
  ["exi", "application/exi"],
  ["exp", "application/express"],
  ["fdt", "application/fdt+xml"],
  ["pfr", "application/font-tdpfr"],
  ["geojson", "application/geo+json"],
  ["gml", "application/gml+xml"],
  ["gpx", "application/gpx+xml"],
  ["gxf", "application/gxf"],
  ["gz", "application/gzip"],
  ["hjson", "application/hjson"],
  ["stk", "application/hyperstudio"],
  ["ink", "application/inkml+xml"],
  ["inkml", "application/inkml+xml"],
  ["ipfix", "application/ipfix"],
  ["its", "application/its+xml"],
  ["ear", "application/java-archive"],
  ["jar", "application/java-archive"],
  ["war", "application/java-archive"],
  ["ser", "application/java-serialized-object"],
  ["class", "application/java-vm"],
  ["js", "application/javascript"],
  ["mjs", "application/javascript"],
  ["json", "application/json"],
  ["map", "application/json"],
  ["json5", "application/json5"],
  ["jsonml", "application/jsonml+json"],
  ["jsonld", "application/ld+json"],
  ["lgr", "application/lgr+xml"],
  ["lostxml", "application/lost+xml"],
  ["hqx", "application/mac-binhex40"],
  ["cpt", "application/mac-compactpro"],
  ["mads", "application/mads+xml"],
  ["webmanifest", "application/manifest+json"],
  ["mrc", "application/marc"],
  ["mrcx", "application/marcxml+xml"],
  ["ma", "application/mathematica"],
  ["mb", "application/mathematica"],
  ["nb", "application/mathematica"],
  ["mathml", "application/mathml+xml"],
  ["mbox", "application/mbox"],
  ["mscml", "application/mediaservercontrol+xml"],
  ["metalink", "application/metalink+xml"],
  ["meta4", "application/metalink4+xml"],
  ["mets", "application/mets+xml"],
  ["maei", "application/mmt-aei+xml"],
  ["musd", "application/mmt-usd+xml"],
  ["mods", "application/mods+xml"],
  ["m21", "application/mp21"],
  ["mp21", "application/mp21"],
  ["m4p", "application/mp4"],
  ["mp4s", "application/mp4"],
  ["doc", "application/msword"],
  ["dot", "application/msword"],
  ["mxf", "application/mxf"],
  ["nq", "application/n-quads"],
  ["nt", "application/n-triples"],
  ["cjs", "application/node"],
  ["bin", "application/octet-stream"],
  ["bpk", "application/octet-stream"],
  ["buffer", "application/octet-stream"],
  ["deb", "application/octet-stream"],
  ["deploy", "application/octet-stream"],
  ["dist", "application/octet-stream"],
  ["distz", "application/octet-stream"],
  ["dll", "application/octet-stream"],
  ["dmg", "application/octet-stream"],
  ["dms", "application/octet-stream"],
  ["dump", "application/octet-stream"],
  ["elc", "application/octet-stream"],
  ["exe", "application/octet-stream"],
  ["img", "application/octet-stream"],
  ["iso", "application/octet-stream"],
  ["lrf", "application/octet-stream"],
  ["mar", "application/octet-stream"],
  ["msi", "application/octet-stream"],
  ["msm", "application/octet-stream"],
  ["msp", "application/octet-stream"],
  ["pkg", "application/octet-stream"],
  ["so", "application/octet-stream"],
  ["oda", "application/oda"],
  ["opf", "application/oebps-package+xml"],
  ["ogx", "application/ogg"],
  ["omdoc", "application/omdoc+xml"],
  ["onepkg", "application/onenote"],
  ["onetmp", "application/onenote"],
  ["onetoc", "application/onenote"],
  ["onetoc2", "application/onenote"],
  ["oxps", "application/oxps"],
  ["relo", "application/p2p-overlay+xml"],
  ["xer", "application/patch-ops-error+xml"],
  ["pdf", "application/pdf"],
  ["pgp", "application/pgp-encrypted"],
  ["asc", "application/pgp-signature"],
  ["sig", "application/pgp-signature"],
  ["prf", "application/pics-rules"],
  ["p10", "application/pkcs10"],
  ["p7c", "application/pkcs7-mime"],
  ["p7m", "application/pkcs7-mime"],
  ["p7s", "application/pkcs7-signature"],
  ["p8", "application/pkcs8"],
  ["ac", "application/pkix-attr-cert"],
  ["cer", "application/pkix-cert"],
  ["crl", "application/pkix-crl"],
  ["pkipath", "application/pkix-pkipath"],
  ["pki", "application/pkixcmp"],
  ["pls", "application/pls+xml"],
  ["ai", "application/postscript"],
  ["eps", "application/postscript"],
  ["ps", "application/postscript"],
  ["provx", "application/provenance+xml"],
  ["pskcxml", "application/pskc+xml"],
  ["raml", "application/raml+yaml"],
  ["owl", "application/rdf+xml"],
  ["rdf", "application/rdf+xml"],
  ["rif", "application/reginfo+xml"],
  ["rnc", "application/relax-ng-compact-syntax"],
  ["rl", "application/resource-lists+xml"],
  ["rld", "application/resource-lists-diff+xml"],
  ["rs", "application/rls-services+xml"],
  ["rapd", "application/route-apd+xml"],
  ["sls", "application/route-s-tsid+xml"],
  ["rusd", "application/route-usd+xml"],
  ["gbr", "application/rpki-ghostbusters"],
  ["mft", "application/rpki-manifest"],
  ["roa", "application/rpki-roa"],
  ["rsd", "application/rsd+xml"],
  ["rss", "application/rss+xml"],
  ["rtf", "application/rtf"],
  ["sbml", "application/sbml+xml"],
  ["scq", "application/scvp-cv-request"],
  ["scs", "application/scvp-cv-response"],
  ["spq", "application/scvp-vp-request"],
  ["spp", "application/scvp-vp-response"],
  ["sdp", "application/sdp"],
  ["senmlx", "application/senml+xml"],
  ["sensmlx", "application/sensml+xml"],
  ["setpay", "application/set-payment-initiation"],
  ["setreg", "application/set-registration-initiation"],
  ["shf", "application/shf+xml"],
  ["sieve", "application/sieve"],
  ["siv", "application/sieve"],
  ["smi", "application/smil+xml"],
  ["smil", "application/smil+xml"],
  ["rq", "application/sparql-query"],
  ["srx", "application/sparql-results+xml"],
  ["gram", "application/srgs"],
  ["grxml", "application/srgs+xml"],
  ["sru", "application/sru+xml"],
  ["ssdl", "application/ssdl+xml"],
  ["ssml", "application/ssml+xml"],
  ["swidtag", "application/swid+xml"],
  ["tei", "application/tei+xml"],
  ["teicorpus", "application/tei+xml"],
  ["tfi", "application/thraud+xml"],
  ["tsd", "application/timestamped-data"],
  ["toml", "application/toml"],
  ["trig", "application/trig"],
  ["ttml", "application/ttml+xml"],
  ["ubj", "application/ubjson"],
  ["rsheet", "application/urc-ressheet+xml"],
  ["td", "application/urc-targetdesc+xml"],
  ["vxml", "application/voicexml+xml"],
  ["wasm", "application/wasm"],
  ["wgt", "application/widget"],
  ["hlp", "application/winhlp"],
  ["wsdl", "application/wsdl+xml"],
  ["wspolicy", "application/wspolicy+xml"],
  ["xaml", "application/xaml+xml"],
  ["xav", "application/xcap-att+xml"],
  ["xca", "application/xcap-caps+xml"],
  ["xdf", "application/xcap-diff+xml"],
  ["xel", "application/xcap-el+xml"],
  ["xns", "application/xcap-ns+xml"],
  ["xenc", "application/xenc+xml"],
  ["xht", "application/xhtml+xml"],
  ["xhtml", "application/xhtml+xml"],
  ["xlf", "application/xliff+xml"],
  ["rng", "application/xml"],
  ["xml", "application/xml"],
  ["xsd", "application/xml"],
  ["xsl", "application/xml"],
  ["dtd", "application/xml-dtd"],
  ["xop", "application/xop+xml"],
  ["xpl", "application/xproc+xml"],
  ["*xsl", "application/xslt+xml"],
  ["xslt", "application/xslt+xml"],
  ["xspf", "application/xspf+xml"],
  ["mxml", "application/xv+xml"],
  ["xhvml", "application/xv+xml"],
  ["xvm", "application/xv+xml"],
  ["xvml", "application/xv+xml"],
  ["yang", "application/yang"],
  ["yin", "application/yin+xml"],
  ["zip", "application/zip"],
  ["*3gpp", "audio/3gpp"],
  ["adp", "audio/adpcm"],
  ["amr", "audio/amr"],
  ["au", "audio/basic"],
  ["snd", "audio/basic"],
  ["kar", "audio/midi"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["rmi", "audio/midi"],
  ["mxmf", "audio/mobile-xmf"],
  ["*mp3", "audio/mp3"],
  ["m4a", "audio/mp4"],
  ["mp4a", "audio/mp4"],
  ["m2a", "audio/mpeg"],
  ["m3a", "audio/mpeg"],
  ["mp2", "audio/mpeg"],
  ["mp2a", "audio/mpeg"],
  ["mp3", "audio/mpeg"],
  ["mpga", "audio/mpeg"],
  ["oga", "audio/ogg"],
  ["ogg", "audio/ogg"],
  ["opus", "audio/ogg"],
  ["spx", "audio/ogg"],
  ["s3m", "audio/s3m"],
  ["sil", "audio/silk"],
  ["wav", "audio/wav"],
  ["*wav", "audio/wave"],
  ["weba", "audio/webm"],
  ["xm", "audio/xm"],
  ["ttc", "font/collection"],
  ["otf", "font/otf"],
  ["ttf", "font/ttf"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["exr", "image/aces"],
  ["apng", "image/apng"],
  ["avif", "image/avif"],
  ["bmp", "image/bmp"],
  ["cgm", "image/cgm"],
  ["drle", "image/dicom-rle"],
  ["emf", "image/emf"],
  ["fits", "image/fits"],
  ["g3", "image/g3fax"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heics", "image/heic-sequence"],
  ["heif", "image/heif"],
  ["heifs", "image/heif-sequence"],
  ["hej2", "image/hej2k"],
  ["hsj2", "image/hsj2"],
  ["ief", "image/ief"],
  ["jls", "image/jls"],
  ["jp2", "image/jp2"],
  ["jpg2", "image/jp2"],
  ["jpe", "image/jpeg"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["jph", "image/jph"],
  ["jhc", "image/jphc"],
  ["jpm", "image/jpm"],
  ["jpf", "image/jpx"],
  ["jpx", "image/jpx"],
  ["jxr", "image/jxr"],
  ["jxra", "image/jxra"],
  ["jxrs", "image/jxrs"],
  ["jxs", "image/jxs"],
  ["jxsc", "image/jxsc"],
  ["jxsi", "image/jxsi"],
  ["jxss", "image/jxss"],
  ["ktx", "image/ktx"],
  ["ktx2", "image/ktx2"],
  ["png", "image/png"],
  ["sgi", "image/sgi"],
  ["svg", "image/svg+xml"],
  ["svgz", "image/svg+xml"],
  ["t38", "image/t38"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["tfx", "image/tiff-fx"],
  ["webp", "image/webp"],
  ["wmf", "image/wmf"],
  ["disposition-notification", "message/disposition-notification"],
  ["u8msg", "message/global"],
  ["u8dsn", "message/global-delivery-status"],
  ["u8mdn", "message/global-disposition-notification"],
  ["u8hdr", "message/global-headers"],
  ["eml", "message/rfc822"],
  ["mime", "message/rfc822"],
  ["3mf", "model/3mf"],
  ["gltf", "model/gltf+json"],
  ["glb", "model/gltf-binary"],
  ["iges", "model/iges"],
  ["igs", "model/iges"],
  ["mesh", "model/mesh"],
  ["msh", "model/mesh"],
  ["silo", "model/mesh"],
  ["mtl", "model/mtl"],
  ["obj", "model/obj"],
  ["stpx", "model/step+xml"],
  ["stpz", "model/step+zip"],
  ["stpxz", "model/step-xml+zip"],
  ["stl", "model/stl"],
  ["vrml", "model/vrml"],
  ["wrl", "model/vrml"],
  ["*x3db", "model/x3d+binary"],
  ["x3dbz", "model/x3d+binary"],
  ["x3db", "model/x3d+fastinfoset"],
  ["*x3dv", "model/x3d+vrml"],
  ["x3dvz", "model/x3d+vrml"],
  ["x3d", "model/x3d+xml"],
  ["x3dz", "model/x3d+xml"],
  ["x3dv", "model/x3d-vrml"],
  ["appcache", "text/cache-manifest"],
  ["manifest", "text/cache-manifest"],
  ["ics", "text/calendar"],
  ["ifb", "text/calendar"],
  ["coffee", "text/coffeescript"],
  ["litcoffee", "text/coffeescript"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["shtml", "text/html"],
  ["jade", "text/jade"],
  ["jsx", "text/jsx"],
  ["less", "text/less"],
  ["markdown", "text/markdown"],
  ["md", "text/markdown"],
  ["mml", "text/mathml"],
  ["mdx", "text/mdx"],
  ["n3", "text/n3"],
  ["conf", "text/plain"],
  ["def", "text/plain"],
  ["in", "text/plain"],
  ["ini", "text/plain"],
  ["list", "text/plain"],
  ["log", "text/plain"],
  ["text", "text/plain"],
  ["txt", "text/plain"],
  ["rtx", "text/richtext"],
  ["*rtf", "text/rtf"],
  ["sgm", "text/sgml"],
  ["sgml", "text/sgml"],
  ["shex", "text/shex"],
  ["slim", "text/slim"],
  ["slm", "text/slim"],
  ["spdx", "text/spdx"],
  ["styl", "text/stylus"],
  ["stylus", "text/stylus"],
  ["tsv", "text/tab-separated-values"],
  ["man", "text/troff"],
  ["me", "text/troff"],
  ["ms", "text/troff"],
  ["roff", "text/troff"],
  ["t", "text/troff"],
  ["tr", "text/troff"],
  ["ttl", "text/turtle"],
  ["uri", "text/uri-list"],
  ["uris", "text/uri-list"],
  ["urls", "text/uri-list"],
  ["vcard", "text/vcard"],
  ["vtt", "text/vtt"],
  ["*xml", "text/xml"],
  ["yaml", "text/yaml"],
  ["yml", "text/yaml"],
  ["3gp", "video/3gpp"],
  ["3gpp", "video/3gpp"],
  ["3g2", "video/3gpp2"],
  ["h261", "video/h261"],
  ["h263", "video/h263"],
  ["h264", "video/h264"],
  ["m4s", "video/iso.segment"],
  ["jpgv", "video/jpeg"],
  ["jpm", "video/jpm"],
  ["jpgm", "video/jpm"],
  ["mj2", "video/mj2"],
  ["mjp2", "video/mj2"],
  ["ts", "video/mp2t"],
  ["mp4", "video/mp4"],
  ["mp4v", "video/mp4"],
  ["mpg4", "video/mp4"],
  ["m1v", "video/mpeg"],
  ["m2v", "video/mpeg"],
  ["mpe", "video/mpeg"],
  ["mpeg", "video/mpeg"],
  ["mpg", "video/mpeg"],
  ["ogv", "video/ogg"],
  ["mov", "video/quicktime"],
  ["qt", "video/quicktime"],
  ["webm", "video/webm"]
]);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/har/harTracer.js
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/frames.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dom.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs13 from "node:fs";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/javascript.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/utilityScriptSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source2 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a;\n  try {\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++)\n    bytes[i] = binary.charCodeAt(i);\n  return new TypedArrayConstructor(bytes.buffer);\n}\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("ref" in value)\n      return refs.get(value.ref);\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value) {\n      return new Date(value.d);\n    }\n    if ("u" in value)\n      return new URL(value.u);\n    if ("bi" in value)\n      return BigInt(value.bi);\n    if ("e" in value) {\n      const error = new Error(value.e.m);\n      error.name = value.e.n;\n      error.stack = value.e.s;\n      return error;\n    }\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value) {\n      const result = [];\n      refs.set(value.id, result);\n      for (const a of value.a)\n        result.push(parseEvaluationResultValue(a, handles, refs));\n      return result;\n    }\n    if ("o" in value) {\n      const result = {};\n      refs.set(value.id, result);\n      for (const { k, v } of value.o) {\n        if (k === "__proto__")\n          continue;\n        result[k] = parseEvaluationResultValue(v, handles, refs);\n      }\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n    if ("ta" in value)\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(global, isUnderTest) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.global = global;\n    this.isUnderTest = isUnderTest;\n    if (global.__pwClock) {\n      this.builtins = global.__pwClock.builtins;\n    } else {\n      this.builtins = {\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n        performance: global.performance,\n        Intl: global.Intl,\n        Date: global.Date\n      };\n    }\n    if (this.isUnderTest)\n      global.builtins = this.builtins;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\n    let result = this.global.eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/javascript.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isRegExp4(obj) {
  try {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
  } catch (error3) {
    return false;
  }
}
__name(isRegExp4, "isRegExp");
function isDate2(obj) {
  try {
    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
  } catch (error3) {
    return false;
  }
}
__name(isDate2, "isDate");
function isURL2(obj) {
  try {
    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
  } catch (error3) {
    return false;
  }
}
__name(isURL2, "isURL");
function isError3(obj) {
  try {
    return obj instanceof Error || obj && Object.getPrototypeOf(obj)?.name === "Error";
  } catch (error3) {
    return false;
  }
}
__name(isError3, "isError");
function isTypedArray(obj, constructor) {
  try {
    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
  } catch (error3) {
    return false;
  }
}
__name(isTypedArray, "isTypedArray");
var typedArrayConstructors = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  // TODO: add Float16Array once it's in baseline
  f32: Float32Array,
  f64: Float64Array,
  bi64: BigInt64Array,
  bui64: BigUint64Array
};
function typedArrayToBase64(array) {
  if ("toBase64" in array)
    return array.toBase64();
  const binary2 = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");
  return btoa(binary2);
}
__name(typedArrayToBase64, "typedArrayToBase64");
function base64ToTypedArray(base64, TypedArrayConstructor) {
  const binary2 = atob(base64);
  const bytes = new Uint8Array(binary2.length);
  for (let i = 0; i < binary2.length; i++)
    bytes[i] = binary2.charCodeAt(i);
  return new TypedArrayConstructor(bytes.buffer);
}
__name(base64ToTypedArray, "base64ToTypedArray");
function parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {
  if (Object.is(value, void 0))
    return void 0;
  if (typeof value === "object" && value) {
    if ("ref" in value)
      return refs.get(value.ref);
    if ("v" in value) {
      if (value.v === "undefined")
        return void 0;
      if (value.v === "null")
        return null;
      if (value.v === "NaN")
        return NaN;
      if (value.v === "Infinity")
        return Infinity;
      if (value.v === "-Infinity")
        return -Infinity;
      if (value.v === "-0")
        return -0;
      return void 0;
    }
    if ("d" in value) {
      return new Date(value.d);
    }
    if ("u" in value)
      return new URL(value.u);
    if ("bi" in value)
      return BigInt(value.bi);
    if ("e" in value) {
      const error3 = new Error(value.e.m);
      error3.name = value.e.n;
      error3.stack = value.e.s;
      return error3;
    }
    if ("r" in value)
      return new RegExp(value.r.p, value.r.f);
    if ("a" in value) {
      const result = [];
      refs.set(value.id, result);
      for (const a of value.a)
        result.push(parseEvaluationResultValue(a, handles, refs));
      return result;
    }
    if ("o" in value) {
      const result = {};
      refs.set(value.id, result);
      for (const { k, v } of value.o) {
        if (k === "__proto__")
          continue;
        result[k] = parseEvaluationResultValue(v, handles, refs);
      }
      return result;
    }
    if ("h" in value)
      return handles[value.h];
    if ("ta" in value)
      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
  }
  return value;
}
__name(parseEvaluationResultValue, "parseEvaluationResultValue");
function serializeAsCallArgument(value, handleSerializer) {
  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });
}
__name(serializeAsCallArgument, "serializeAsCallArgument");
function serialize(value, handleSerializer, visitorInfo) {
  if (value && typeof value === "object") {
    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)
      return "ref: <Window>";
    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)
      return "ref: <Document>";
    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)
      return "ref: <Node>";
  }
  return innerSerialize(value, handleSerializer, visitorInfo);
}
__name(serialize, "serialize");
function innerSerialize(value, handleSerializer, visitorInfo) {
  const result = handleSerializer(value);
  if ("fallThrough" in result)
    value = result.fallThrough;
  else
    return result;
  if (typeof value === "symbol")
    return { v: "undefined" };
  if (Object.is(value, void 0))
    return { v: "undefined" };
  if (Object.is(value, null))
    return { v: "null" };
  if (Object.is(value, NaN))
    return { v: "NaN" };
  if (Object.is(value, Infinity))
    return { v: "Infinity" };
  if (Object.is(value, -Infinity))
    return { v: "-Infinity" };
  if (Object.is(value, -0))
    return { v: "-0" };
  if (typeof value === "boolean")
    return value;
  if (typeof value === "number")
    return value;
  if (typeof value === "string")
    return value;
  if (typeof value === "bigint")
    return { bi: value.toString() };
  if (isError3(value)) {
    let stack;
    if (value.stack?.startsWith(value.name + ": " + value.message)) {
      stack = value.stack;
    } else {
      stack = `${value.name}: ${value.message}
${value.stack}`;
    }
    return { e: { n: value.name, m: value.message, s: stack } };
  }
  if (isDate2(value))
    return { d: value.toJSON() };
  if (isURL2(value))
    return { u: value.toJSON() };
  if (isRegExp4(value))
    return { r: { p: value.source, f: value.flags } };
  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {
    if (isTypedArray(value, ctor))
      return { ta: { b: typedArrayToBase64(value), k } };
  }
  const id = visitorInfo.visited.get(value);
  if (id)
    return { ref: id };
  if (Array.isArray(value)) {
    const a = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (let i = 0; i < value.length; ++i)
      a.push(serialize(value[i], handleSerializer, visitorInfo));
    return { a, id: id2 };
  }
  if (typeof value === "object") {
    const o = [];
    const id2 = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id2);
    for (const name of Object.keys(value)) {
      let item;
      try {
        item = value[name];
      } catch (e) {
        continue;
      }
      if (name === "toJSON" && typeof item === "function")
        o.push({ k: name, v: { o: [], id: 0 } });
      else
        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
    }
    let jsonWrapper;
    try {
      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")
        jsonWrapper = { value: value.toJSON() };
    } catch (e) {
    }
    if (jsonWrapper)
      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
    return { o, id: id2 };
  }
}
__name(innerSerialize, "innerSerialize");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/javascript.js
var ExecutionContext = class extends SdkObject {
  static {
    __name(this, "ExecutionContext");
  }
  constructor(parent, delegate, worldNameForTest) {
    super(parent, "execution-context");
    this._contextDestroyedScope = new LongStandingScope();
    this.worldNameForTest = worldNameForTest;
    this.delegate = delegate;
  }
  contextDestroyed(reason) {
    this._contextDestroyedScope.close(new Error(reason));
  }
  async _raceAgainstContextDestroyed(promise) {
    return this._contextDestroyedScope.race(promise);
  }
  rawEvaluateJSON(expression) {
    return this._raceAgainstContextDestroyed(this.delegate.rawEvaluateJSON(expression));
  }
  rawEvaluateHandle(expression) {
    return this._raceAgainstContextDestroyed(this.delegate.rawEvaluateHandle(this, expression));
  }
  async evaluateWithArguments(expression, returnByValue, values, handles) {
    const utilityScript = await this.utilityScript();
    return this._raceAgainstContextDestroyed(this.delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, handles));
  }
  getProperties(object) {
    return this._raceAgainstContextDestroyed(this.delegate.getProperties(object));
  }
  releaseHandle(handle) {
    return this.delegate.releaseHandle(handle);
  }
  adoptIfNeeded(handle) {
    return null;
  }
  utilityScript() {
    if (!this._utilityScriptPromise) {
      const source$1 = `
      (() => {
        const module = {};
        ${source2}
        return new (module.exports.UtilityScript())(globalThis, ${isUnderTest()});
      })();`;
      this._utilityScriptPromise = this._raceAgainstContextDestroyed(this.delegate.rawEvaluateHandle(this, source$1)).then((handle) => {
        handle._setPreview("UtilityScript");
        return handle;
      });
    }
    return this._utilityScriptPromise;
  }
  async doSlowMo() {
  }
};
var JSHandle = class extends SdkObject {
  static {
    __name(this, "JSHandle");
  }
  constructor(context2, type, preview, objectId, value) {
    super(context2, "handle");
    this.__jshandle = true;
    this._disposed = false;
    this._context = context2;
    this._objectId = objectId;
    this._value = value;
    this._objectType = type;
    this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
    if (this._objectId && globalThis.leakedJSHandles)
      globalThis.leakedJSHandles.set(this, new Error("Leaked JSHandle"));
  }
  async evaluate(pageFunction, arg) {
    return evaluate(this._context, true, pageFunction, this, arg);
  }
  async evaluateHandle(pageFunction, arg) {
    return evaluate(this._context, false, pageFunction, this, arg);
  }
  async evaluateExpression(expression, options2, arg) {
    const value = await evaluateExpression(this._context, expression, { ...options2, returnByValue: true }, this, arg);
    await this._context.doSlowMo();
    return value;
  }
  async evaluateExpressionHandle(expression, options2, arg) {
    const value = await evaluateExpression(this._context, expression, { ...options2, returnByValue: false }, this, arg);
    await this._context.doSlowMo();
    return value;
  }
  async getProperty(propertyName) {
    const objectHandle = await this.evaluateHandle((object, propertyName2) => {
      const result2 = { __proto__: null };
      result2[propertyName2] = object[propertyName2];
      return result2;
    }, propertyName);
    const properties = await objectHandle.getProperties();
    const result = properties.get(propertyName);
    objectHandle.dispose();
    return result;
  }
  async getProperties() {
    if (!this._objectId)
      return /* @__PURE__ */ new Map();
    return this._context.getProperties(this);
  }
  rawValue() {
    return this._value;
  }
  async jsonValue() {
    if (!this._objectId)
      return this._value;
    const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
    return this._context.evaluateWithArguments(script, true, [true], [this]);
  }
  asElement() {
    return null;
  }
  dispose() {
    if (this._disposed)
      return;
    this._disposed = true;
    if (this._objectId) {
      this._context.releaseHandle(this).catch((e) => {
      });
      if (globalThis.leakedJSHandles)
        globalThis.leakedJSHandles.delete(this);
    }
  }
  toString() {
    return this._preview;
  }
  _setPreviewCallback(callback) {
    this._previewCallback = callback;
  }
  preview() {
    return this._preview;
  }
  worldNameForTest() {
    return this._context.worldNameForTest;
  }
  _setPreview(preview) {
    this._preview = preview;
    if (this._previewCallback)
      this._previewCallback(preview);
  }
};
async function evaluate(context2, returnByValue, pageFunction, ...args) {
  return evaluateExpression(context2, String(pageFunction), { returnByValue, isFunction: typeof pageFunction === "function" }, ...args);
}
__name(evaluate, "evaluate");
async function evaluateExpression(context2, expression, options2, ...args) {
  expression = normalizeEvaluationExpression(expression, options2.isFunction);
  const handles = [];
  const toDispose = [];
  const pushHandle = /* @__PURE__ */ __name((handle) => {
    handles.push(handle);
    return handles.length - 1;
  }, "pushHandle");
  args = args.map((arg) => serializeAsCallArgument(arg, (handle) => {
    if (handle instanceof JSHandle) {
      if (!handle._objectId)
        return { fallThrough: handle._value };
      if (handle._disposed)
        throw new JavaScriptErrorInEvaluate("JSHandle is disposed!");
      const adopted = context2.adoptIfNeeded(handle);
      if (adopted === null)
        return { h: pushHandle(Promise.resolve(handle)) };
      toDispose.push(adopted);
      return { h: pushHandle(adopted) };
    }
    return { fallThrough: handle };
  }));
  const utilityScriptObjects = [];
  for (const handle of await Promise.all(handles)) {
    if (handle._context !== context2)
      throw new JavaScriptErrorInEvaluate("JSHandles can be evaluated only in the context they were created!");
    utilityScriptObjects.push(handle);
  }
  const utilityScriptValues = [options2.isFunction, options2.returnByValue, expression, args.length, ...args];
  const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
  try {
    return await context2.evaluateWithArguments(script, options2.returnByValue || false, utilityScriptValues, utilityScriptObjects);
  } finally {
    toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
  }
}
__name(evaluateExpression, "evaluateExpression");
function parseUnserializableValue(unserializableValue) {
  if (unserializableValue === "NaN")
    return NaN;
  if (unserializableValue === "Infinity")
    return Infinity;
  if (unserializableValue === "-Infinity")
    return -Infinity;
  if (unserializableValue === "-0")
    return -0;
}
__name(parseUnserializableValue, "parseUnserializableValue");
function normalizeEvaluationExpression(expression, isFunction) {
  expression = expression.trim();
  if (isFunction) {
    if (globalThis.navigator?.userAgent === "Cloudflare-Workers") {
      expression = `((__name => (${expression}))(t => t))`;
    } else {
      try {
        new Function("(" + expression + ")");
      } catch (e1) {
        if (expression.startsWith("async "))
          expression = "async function " + expression.substring("async ".length);
        else
          expression = "function " + expression;
        try {
          new Function("(" + expression + ")");
        } catch (e2) {
          throw new Error("Passed function is not well-serializable!");
        }
      }
    }
  }
  if (/^(async)?\s*function(\s|\()/.test(expression))
    expression = "(" + expression + ")";
  return expression;
}
__name(normalizeEvaluationExpression, "normalizeEvaluationExpression");
var JavaScriptErrorInEvaluate = class extends Error {
  static {
    __name(this, "JavaScriptErrorInEvaluate");
  }
};
function isJavaScriptErrorInEvaluate(error3) {
  return error3 instanceof JavaScriptErrorInEvaluate;
}
__name(isJavaScriptErrorInEvaluate, "isJavaScriptErrorInEvaluate");
function sparseArrayToString(entries) {
  const arrayEntries = [];
  for (const { name, value } of entries) {
    const index2 = +name;
    if (isNaN(index2) || index2 < 0)
      continue;
    arrayEntries.push({ index: index2, value });
  }
  arrayEntries.sort((a, b) => a.index - b.index);
  let lastIndex = -1;
  const tokens = [];
  for (const { index: index2, value } of arrayEntries) {
    const emptyItems = index2 - lastIndex - 1;
    if (emptyItems === 1)
      tokens.push(`empty`);
    else if (emptyItems > 1)
      tokens.push(`empty x ${emptyItems}`);
    tokens.push(String(value));
    lastIndex = index2;
  }
  return "[" + tokens.join(", ") + "]";
}
__name(sparseArrayToString, "sparseArrayToString");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dom.js
import "node:crypto";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/fileUploadUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs12 from "node:fs";
import path9 from "node:path";
var fileUploadSizeLimit = 50 * 1024 * 1024;
async function filesExceedUploadLimit(files) {
  const sizes = await Promise.all(files.map(async (file) => (await fs12.promises.stat(file)).size));
  return sizes.reduce((total, size) => total + size, 0) >= fileUploadSizeLimit;
}
__name(filesExceedUploadLimit, "filesExceedUploadLimit");
async function prepareFilesForUpload(frame, params) {
  const { payloads, streams, directoryStream } = params;
  let { localPaths, localDirectory } = params;
  if ([payloads, localPaths, localDirectory, streams, directoryStream].filter(Boolean).length !== 1)
    throw new Error("Exactly one of payloads, localPaths and streams must be provided");
  if (streams)
    localPaths = streams.map((c) => c.path());
  if (directoryStream)
    localDirectory = directoryStream.path();
  if (localPaths) {
    for (const p of localPaths)
      assert3(path9.isAbsolute(p) && path9.resolve(p) === p, "Paths provided to localPaths must be absolute and fully resolved.");
  }
  let fileBuffers = payloads;
  if (!frame._page.browserContext._browser._isCollocatedWithServer) {
    if (localPaths) {
      if (await filesExceedUploadLimit(localPaths))
        throw new Error("Cannot transfer files larger than 50Mb to a browser not co-located with the server");
      fileBuffers = await Promise.all(localPaths.map(async (item) => {
        return {
          name: path9.basename(item),
          buffer: await fs12.promises.readFile(item),
          lastModifiedMs: (await fs12.promises.stat(item)).mtimeMs
        };
      }));
      localPaths = void 0;
    }
  }
  const filePayloads = fileBuffers?.map((payload) => ({
    name: payload.name,
    mimeType: payload.mimeType || mime2.getType(payload.name) || "application/octet-stream",
    buffer: payload.buffer.toString("base64"),
    lastModifiedMs: payload.lastModifiedMs
  }));
  return { localPaths, localDirectory, filePayloads };
}
__name(prepareFilesForUpload, "prepareFilesForUpload");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/injectedScriptSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source3 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/ariaSnapshot.ts\nfunction parseAriaSnapshot(yaml, text, options = {}) {\n  var _a;\n  const lineCounter = new yaml.LineCounter();\n  const parseOptions = {\n    keepSourceTokens: true,\n    lineCounter,\n    ...options\n  };\n  const yamlDoc = yaml.parseDocument(text, parseOptions);\n  const errors = [];\n  const convertRange = (range) => {\n    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];\n  };\n  const addError = (error) => {\n    errors.push({\n      message: error.message,\n      range: [lineCounter.linePos(error.pos[0]), lineCounter.linePos(error.pos[1])]\n    });\n  };\n  const convertSeq = (container, seq) => {\n    for (const item of seq.items) {\n      const itemIsString = item instanceof yaml.Scalar && typeof item.value === "string";\n      if (itemIsString) {\n        const childNode = KeyParser.parse(item, parseOptions, errors);\n        if (childNode) {\n          container.children = container.children || [];\n          container.children.push(childNode);\n        }\n        continue;\n      }\n      const itemIsMap = item instanceof yaml.YAMLMap;\n      if (itemIsMap) {\n        convertMap(container, item);\n        continue;\n      }\n      errors.push({\n        message: "Sequence items should be strings or maps",\n        range: convertRange(item.range || seq.range)\n      });\n    }\n  };\n  const convertMap = (container, map) => {\n    var _a2;\n    for (const entry of map.items) {\n      container.children = container.children || [];\n      const keyIsString = entry.key instanceof yaml.Scalar && typeof entry.key.value === "string";\n      if (!keyIsString) {\n        errors.push({\n          message: "Only string keys are supported",\n          range: convertRange(entry.key.range || map.range)\n        });\n        continue;\n      }\n      const key = entry.key;\n      const value = entry.value;\n      if (key.value === "text") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Text value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          kind: "text",\n          text: valueOrRegex(value.value)\n        });\n        continue;\n      }\n      if (key.value === "/children") {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString || value.value !== "contain" && value.value !== "equal" && value.value !== "deep-equal") {\n          errors.push({\n            message: \'Strict value should be "contain", "equal" or "deep-equal"\',\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.containerMode = value.value;\n        continue;\n      }\n      if (key.value.startsWith("/")) {\n        const valueIsString = value instanceof yaml.Scalar && typeof value.value === "string";\n        if (!valueIsString) {\n          errors.push({\n            message: "Property value should be a string",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.props = (_a2 = container.props) != null ? _a2 : {};\n        container.props[key.value.slice(1)] = valueOrRegex(value.value);\n        continue;\n      }\n      const childNode = KeyParser.parse(key, parseOptions, errors);\n      if (!childNode)\n        continue;\n      const valueIsScalar = value instanceof yaml.Scalar;\n      if (valueIsScalar) {\n        const type = typeof value.value;\n        if (type !== "string" && type !== "number" && type !== "boolean") {\n          errors.push({\n            message: "Node value should be a string or a sequence",\n            range: convertRange(entry.value.range || map.range)\n          });\n          continue;\n        }\n        container.children.push({\n          ...childNode,\n          children: [{\n            kind: "text",\n            text: valueOrRegex(String(value.value))\n          }]\n        });\n        continue;\n      }\n      const valueIsSequence = value instanceof yaml.YAMLSeq;\n      if (valueIsSequence) {\n        container.children.push(childNode);\n        convertSeq(childNode, value);\n        continue;\n      }\n      errors.push({\n        message: "Map values should be strings or sequences",\n        range: convertRange(entry.value.range || map.range)\n      });\n    }\n  };\n  const fragment = { kind: "role", role: "fragment" };\n  yamlDoc.errors.forEach(addError);\n  if (errors.length)\n    return { errors, fragment };\n  if (!(yamlDoc.contents instanceof yaml.YAMLSeq)) {\n    errors.push({\n      message: \'Aria snapshot must be a YAML sequence, elements starting with " -"\',\n      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]\n    });\n  }\n  if (errors.length)\n    return { errors, fragment };\n  convertSeq(fragment, yamlDoc.contents);\n  if (errors.length)\n    return { errors, fragment: emptyFragment };\n  if (((_a = fragment.children) == null ? void 0 : _a.length) === 1 && (!fragment.containerMode || fragment.containerMode === "contain"))\n    return { fragment: fragment.children[0], errors: [] };\n  return { fragment, errors: [] };\n}\nvar emptyFragment = { kind: "role", role: "fragment" };\nfunction normalizeWhitespace(text) {\n  return text.replace(/[\\u200b\\u00ad]/g, "").replace(/[\\r\\n\\s\\t]+/g, " ").trim();\n}\nfunction valueOrRegex(value) {\n  return value.startsWith("/") && value.endsWith("/") && value.length > 1 ? { pattern: value.slice(1, -1) } : normalizeWhitespace(value);\n}\nvar KeyParser = class _KeyParser {\n  static parse(text, options, errors) {\n    try {\n      return new _KeyParser(text.value, options)._parse();\n    } catch (e) {\n      if (e instanceof ParserError) {\n        const message = options.prettyErrors === false ? e.message : e.message + ":\\n\\n" + text.value + "\\n" + " ".repeat(e.pos) + "^\\n";\n        errors.push({\n          message,\n          range: [options.lineCounter.linePos(text.range[0]), options.lineCounter.linePos(text.range[0] + e.pos)]\n        });\n        return null;\n      }\n      throw e;\n    }\n  }\n  constructor(input, options) {\n    this._input = input;\n    this._pos = 0;\n    this._length = input.length;\n    this._options = options;\n  }\n  _peek() {\n    return this._input[this._pos] || "";\n  }\n  _next() {\n    if (this._pos < this._length)\n      return this._input[this._pos++];\n    return null;\n  }\n  _eof() {\n    return this._pos >= this._length;\n  }\n  _isWhitespace() {\n    return !this._eof() && /\\s/.test(this._peek());\n  }\n  _skipWhitespace() {\n    while (this._isWhitespace())\n      this._pos++;\n  }\n  _readIdentifier(type) {\n    if (this._eof())\n      this._throwError(`Unexpected end of input when expecting ${type}`);\n    const start = this._pos;\n    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))\n      this._pos++;\n    return this._input.slice(start, this._pos);\n  }\n  _readString() {\n    let result = "";\n    let escaped = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n      } else if (ch === \'"\') {\n        return result;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated string");\n  }\n  _throwError(message, offset = 0) {\n    throw new ParserError(message, offset || this._pos);\n  }\n  _readRegex() {\n    let result = "";\n    let escaped = false;\n    let insideClass = false;\n    while (!this._eof()) {\n      const ch = this._next();\n      if (escaped) {\n        result += ch;\n        escaped = false;\n      } else if (ch === "\\\\") {\n        escaped = true;\n        result += ch;\n      } else if (ch === "/" && !insideClass) {\n        return { pattern: result };\n      } else if (ch === "[") {\n        insideClass = true;\n        result += ch;\n      } else if (ch === "]" && insideClass) {\n        result += ch;\n        insideClass = false;\n      } else {\n        result += ch;\n      }\n    }\n    this._throwError("Unterminated regex");\n  }\n  _readStringOrRegex() {\n    const ch = this._peek();\n    if (ch === \'"\') {\n      this._next();\n      return normalizeWhitespace(this._readString());\n    }\n    if (ch === "/") {\n      this._next();\n      return this._readRegex();\n    }\n    return null;\n  }\n  _readAttributes(result) {\n    let errorPos = this._pos;\n    while (true) {\n      this._skipWhitespace();\n      if (this._peek() === "[") {\n        this._next();\n        this._skipWhitespace();\n        errorPos = this._pos;\n        const flagName = this._readIdentifier("attribute");\n        this._skipWhitespace();\n        let flagValue = "";\n        if (this._peek() === "=") {\n          this._next();\n          this._skipWhitespace();\n          errorPos = this._pos;\n          while (this._peek() !== "]" && !this._isWhitespace() && !this._eof())\n            flagValue += this._next();\n        }\n        this._skipWhitespace();\n        if (this._peek() !== "]")\n          this._throwError("Expected ]");\n        this._next();\n        this._applyAttribute(result, flagName, flagValue || "true", errorPos);\n      } else {\n        break;\n      }\n    }\n  }\n  _parse() {\n    this._skipWhitespace();\n    const role = this._readIdentifier("role");\n    this._skipWhitespace();\n    const name = this._readStringOrRegex() || "";\n    const result = { kind: "role", role, name };\n    this._readAttributes(result);\n    this._skipWhitespace();\n    if (!this._eof())\n      this._throwError("Unexpected input");\n    return result;\n  }\n  _applyAttribute(node, key, value, errorPos) {\n    if (key === "checked") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "checked" attribute must be a boolean or "mixed"\', errorPos);\n      node.checked = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "disabled") {\n      this._assert(value === "true" || value === "false", \'Value of "disabled" attribute must be a boolean\', errorPos);\n      node.disabled = value === "true";\n      return;\n    }\n    if (key === "expanded") {\n      this._assert(value === "true" || value === "false", \'Value of "expanded" attribute must be a boolean\', errorPos);\n      node.expanded = value === "true";\n      return;\n    }\n    if (key === "active") {\n      this._assert(value === "true" || value === "false", \'Value of "active" attribute must be a boolean\', errorPos);\n      node.active = value === "true";\n      return;\n    }\n    if (key === "level") {\n      this._assert(!isNaN(Number(value)), \'Value of "level" attribute must be a number\', errorPos);\n      node.level = Number(value);\n      return;\n    }\n    if (key === "pressed") {\n      this._assert(value === "true" || value === "false" || value === "mixed", \'Value of "pressed" attribute must be a boolean or "mixed"\', errorPos);\n      node.pressed = value === "true" ? true : value === "false" ? false : "mixed";\n      return;\n    }\n    if (key === "selected") {\n      this._assert(value === "true" || value === "false", \'Value of "selected" attribute must be a boolean\', errorPos);\n      node.selected = value === "true";\n      return;\n    }\n    this._assert(false, `Unsupported attribute [${key}]`, errorPos);\n  }\n  _assert(value, message, valuePos) {\n    if (!value)\n      this._throwError(message || "Assertion error", valuePos);\n  }\n};\nvar ParserError = class extends Error {\n  constructor(message, pos) {\n    super(message);\n    this.pos = pos;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing css selector "${selector}". Did you mean to CSS.escape it?`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.\n    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }\n    // Or this way :xpath( {complex-xpath-goes-here("hello")} )\n    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?\n    token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isOpenParen(p = pos) {\n    return tokens[p] instanceof OpenParenToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isFunction(p = pos) {\n    return tokens[p] instanceof FunctionToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (isFunction()) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    let balance = 1;\n    while (!isEOF()) {\n      if (isOpenParen() || isFunction())\n        balance++;\n      if (isCloseParen())\n        balance--;\n      if (!balance)\n        break;\n      s += tokens[pos++].toSource();\n    }\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw unexpected();\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing css selector "${selector}". Did you mean to CSS.escape it?`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "internal:chain", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector, forceEngineName) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    let includeEngine = true;\n    if (!forceEngineName && i !== selector.capture) {\n      if (p.name === "css")\n        includeEngine = false;\n      else if (p.name === "xpath" && p.source.startsWith("//") || p.source.startsWith(".."))\n        includeEngine = false;\n    }\n    const prefix = includeEngine ? p.name + "=" : "";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction visitAllSelectorParts(selector, visitor) {\n  const visit = (selector2, nested) => {\n    for (const part of selector2.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed, true);\n    }\n  };\n  visit(selector, false);\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expression");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "\\\\`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction quoteCSSAttributeValue(text) {\n  return `"${text.replace(/["\\\\]/g, (char) => "\\\\" + char)}"`;\n}\nvar normalizedWhitespaceCache;\nfunction cacheNormalizedWhitespaces() {\n  normalizedWhitespaceCache = /* @__PURE__ */ new Map();\n}\nfunction normalizeWhiteSpace(text) {\n  let result = normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.get(text);\n  if (result === void 0) {\n    result = text.replace(/[\\u200b\\u00ad]/g, "").trim().replace(/\\s+/g, " ");\n    normalizedWhitespaceCache == null ? void 0 : normalizedWhitespaceCache.set(text, result);\n  }\n  return result;\n}\nfunction normalizeEscapedRegexQuotes(source) {\n  return source.replace(/(^|[^\\\\])(\\\\\\\\)*\\\\([\'"`])/g, "$1$2$3");\n}\nfunction escapeRegexForSelector(re) {\n  if (re.unicode || re.unicodeSets)\n    return String(re);\n  return String(re).replace(/(^|[^\\\\])(\\\\\\\\)*(["\'`])/g, "$1$2\\\\$3").replace(/>>/g, "\\\\>\\\\>");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return escapeRegexForSelector(text);\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return escapeRegexForSelector(value);\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\nfunction trimString(input, cap, suffix = "") {\n  if (input.length <= cap)\n    return input;\n  const chars = [...input];\n  if (chars.length > cap)\n    return chars.slice(0, cap - suffix.length).join("") + suffix;\n  return chars.join("");\n}\nfunction trimStringWithEllipsis(input, cap) {\n  return trimString(input, cap, "\\u2026");\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction longestCommonSubstring(s1, s2) {\n  const n = s1.length;\n  const m = s2.length;\n  let maxLen = 0;\n  let endingIndex = 0;\n  const dp = Array(n + 1).fill(null).map(() => Array(m + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      if (s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n        if (dp[i][j] > maxLen) {\n          maxLen = dp[i][j];\n          endingIndex = i;\n        }\n      }\n    }\n  }\n  return s1.slice(endingIndex - maxLen, endingIndex);\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false) {\n  return asLocators(lang, selector, isFrameLocator, 1)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {\n  try {\n    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);\n  } catch (e) {\n    return [selector];\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "internal:describe")\n      continue;\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "visible") {\n      tokens.push([factory.generateLocator(base, "visible", part.body), factory.generateLocator(base, "default", `visible=${part.body}`)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:chain") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "chain", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:control" && part.body === "enter-frame") {\n      const lastTokens = tokens[tokens.length - 1];\n      const lastPart = parts[index - 1];\n      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, "frame", "")]));\n      if (["xpath", "css"].includes(lastPart.name)) {\n        transformed.push(\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] })),\n          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] }, true))\n        );\n      }\n      lastTokens.splice(0, lastTokens.length, ...transformed);\n      nextBase = "frame-locator";\n      continue;\n    }\n    const nextPart = parts[index + 1];\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, "default", selectorPart);\n    if (nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    let locatorPartWithEngine;\n    if (["xpath", "css"].includes(part.name)) {\n      const selectorPart2 = stringifySelector(\n        { parts: [part] },\n        /* forceEngineName */\n        true\n      );\n      locatorPartWithEngine = factory.generateLocator(base, "default", selectorPart2);\n    }\n    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return result.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  constructor(preferredQuote) {\n    this.preferredQuote = preferredQuote;\n  }\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter({ visible: ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${this.regexToSourceString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToSourceString(re) {\n    return normalizeEscapedRegexQuotes(String(re));\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToSourceString(body)})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToSourceString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToSourceString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    var _a;\n    return escapeWithQuotes(text, (_a = this.preferredQuote) != null ? _a : "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frame_locator(${this.quote(body)})`;\n      case "frame":\n        return `content_frame`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "visible":\n        return `filter(visible=${body === "true" ? "True" : "False"})`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${normalizeEscapedRegexQuotes(body.source).replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `frameLocator(${this.quote(body)})`;\n      case "frame":\n        return `contentFrame()`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "visible":\n        return `filter(new ${clazz}.FilterOptions().setVisible(${body === "true" ? "true" : "false"}))`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "chain":\n        return `locator(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame-locator":\n        return `FrameLocator(${this.quote(body)})`;\n      case "frame":\n        return `ContentFrame`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "visible":\n        return `Filter(new() { Visible = ${body === "true" ? "true" : "false"} })`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "chain":\n        return `Locator(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: JavaScriptLocatorFactory,\n  python: PythonLocatorFactory,\n  java: JavaLocatorFactory,\n  csharp: CSharpLocatorFactory,\n  jsonl: JsonlLocatorFactory\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/injected/src/domUtils.ts\nvar globalOptions = {};\nfunction setGlobalOptions(options) {\n  globalOptions = options;\n}\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility && globalOptions.browserNameForWorkarounds !== "webkit") {\n    if (!element.checkVisibility())\n      return false;\n  } else {\n    const detailsOrSummary = element.closest("details,summary");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== "visible")\n    return false;\n  return true;\n}\nfunction box(element) {\n  const style = getElementComputedStyle(element);\n  if (!style)\n    return { visible: true };\n  if (style.display === "contents") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return { visible: true, style };\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return { visible: true, style };\n    }\n    return { visible: false, style };\n  }\n  if (!isElementStyleVisibilityVisible(element, style))\n    return { style, visible: false };\n  const rect = element.getBoundingClientRect();\n  return { rect, style, visible: rect.width > 0 && rect.height > 0 };\n}\nfunction isElementVisible(element) {\n  return box(element).visible;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction elementSafeTagName(element) {\n  if (element instanceof HTMLFormElement)\n    return "FORM";\n  return element.tagName.toUpperCase();\n}\n\n// packages/injected/src/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  ["aria-atomic", void 0],\n  ["aria-busy", void 0],\n  ["aria-controls", void 0],\n  ["aria-current", void 0],\n  ["aria-describedby", void 0],\n  ["aria-details", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-disabled\', undefined],\n  ["aria-dropeffect", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-errormessage\', undefined],\n  ["aria-flowto", void 0],\n  ["aria-grabbed", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-haspopup\', undefined],\n  ["aria-hidden", void 0],\n  // Global use deprecated in ARIA 1.2\n  // [\'aria-invalid\', undefined],\n  ["aria-keyshortcuts", void 0],\n  ["aria-label", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-labelledby", ["caption", "code", "deletion", "emphasis", "generic", "insertion", "paragraph", "presentation", "strong", "subscript", "superscript"]],\n  ["aria-live", void 0],\n  ["aria-owns", void 0],\n  ["aria-relevant", void 0],\n  ["aria-roledescription", ["generic"]]\n];\nfunction hasGlobalAriaAttribute(element, forRole) {\n  return kGlobalAriaAttributes.some(([attr, prohibited]) => {\n    return !(prohibited == null ? void 0 : prohibited.includes(forRole || "")) && element.hasAttribute(attr);\n  });\n}\nfunction hasTabIndex(element) {\n  return !Number.isNaN(Number(String(element.getAttribute("tabindex"))));\n}\nfunction isFocusable(element) {\n  return !isNativelyDisabled(element) && (isNativelyFocusable(element) || hasTabIndex(element));\n}\nfunction isNativelyFocusable(element) {\n  const tagName = elementSafeTagName(element);\n  if (["BUTTON", "DETAILS", "SELECT", "TEXTAREA"].includes(tagName))\n    return true;\n  if (tagName === "A" || tagName === "AREA")\n    return element.hasAttribute("href");\n  if (tagName === "INPUT")\n    return !element.hidden;\n  return false;\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !e.getAttribute("title") && !hasGlobalAriaAttribute(e) && !hasTabIndex(e) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && elementSafeTagName(list) === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return null;\n    if (type === "file")\n      return "button";\n    return inputTypeToRole[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SEARCH": () => "search",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  // For <svg> we default to Chrome behavior:\n  // - Chrome reports \'img\'.\n  // - Firefox reports \'diagram\' that is not in official ARIA spec yet.\n  // - Safari reports \'no role\', but still computes accessible name.\n  "SVG": () => "img",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    if (e.getAttribute("scope") === "col")\n      return "columnheader";\n    if (e.getAttribute("scope") === "row")\n      return "rowheader";\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[elementSafeTagName(element)]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[elementSafeTagName(ancestor)];\n    if (!parents || !parent || !parents.includes(elementSafeTagName(parent)))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent, parentExplicitRole))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar validRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "complementary",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "insertion",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "mark",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "region",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem"\n];\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element, role) {\n  return hasGlobalAriaAttribute(element, role) || isFocusable(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if (explicitRole === "none" || explicitRole === "presentation") {\n    const implicitRole = getImplicitAriaRole(element);\n    if (hasPresentationConflictResolution(element, implicitRole))\n      return implicitRole;\n  }\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction isElementIgnoredForAria(element) {\n  return ["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(elementSafeTagName(element));\n}\nfunction isElementHiddenForAria(element) {\n  if (isElementIgnoredForAria(element))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === "SLOT";\n  if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlottedOrInert(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlottedOrInert(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true || element.getAttribute("inert") !== null;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlottedOrInert(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const result = [];\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement && !result.includes(firstElement))\n        result.push(firstElement);\n    }\n    return result;\n  } catch (e) {\n    return [];\n  }\n}\nfunction trimFlatString(s) {\n  return s.trim();\n}\nfunction asFlatString(s) {\n  return s.split("\\xA0").map((chunk) => chunk.replace(/\\r\\n/g, "\\n").replace(/[\\u200b\\u00ad]/g, "").replace(/\\s\\s*/g, " ")).join("\\xA0").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getCSSContent(element, pseudo) {\n  const cache = pseudo === "::before" ? cachePseudoContentBefore : pseudo === "::after" ? cachePseudoContentAfter : cachePseudoContent;\n  if (cache == null ? void 0 : cache.has(element))\n    return cache == null ? void 0 : cache.get(element);\n  const style = getElementComputedStyle(element, pseudo);\n  let content;\n  if (style && style.display !== "none" && style.visibility !== "hidden") {\n    content = parseCSSContentPropertyAsString(element, style.content, !!pseudo);\n  }\n  if (pseudo && content !== void 0) {\n    const display = (style == null ? void 0 : style.display) || "inline";\n    if (display !== "inline")\n      content = " " + content + " ";\n  }\n  if (cache)\n    cache.set(element, content);\n  return content;\n}\nfunction parseCSSContentPropertyAsString(element, content, isPseudo) {\n  if (!content || content === "none" || content === "normal") {\n    return;\n  }\n  try {\n    let tokens = tokenize(content).filter((token) => !(token instanceof WhitespaceToken));\n    const delimIndex = tokens.findIndex((token) => token instanceof DelimToken && token.value === "/");\n    if (delimIndex !== -1) {\n      tokens = tokens.slice(delimIndex + 1);\n    } else if (!isPseudo) {\n      return;\n    }\n    const accumulated = [];\n    let index = 0;\n    while (index < tokens.length) {\n      if (tokens[index] instanceof StringToken) {\n        accumulated.push(tokens[index].value);\n        index++;\n      } else if (index + 2 < tokens.length && tokens[index] instanceof FunctionToken && tokens[index].value === "attr" && tokens[index + 1] instanceof IdentToken && tokens[index + 2] instanceof CloseParenToken) {\n        const attrName = tokens[index + 1].value;\n        accumulated.push(element.getAttribute(attrName) || "");\n        index += 3;\n      } else {\n        return;\n      }\n    }\n    return accumulated.join("");\n  } catch {\n  }\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute("aria-labelledby");\n  if (ref === null)\n    return null;\n  const refs = getIdRefs(element, ref);\n  return refs.length ? refs : null;\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = "";\n    const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n    if (!elementProhibitsNaming) {\n      accessibleName = asFlatString(getTextAlternativeInternal(element, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInTargetElement: "self"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleDescription(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleDescriptionHidden : cacheAccessibleDescription;\n  let accessibleDescription = cache == null ? void 0 : cache.get(element);\n  if (accessibleDescription === void 0) {\n    accessibleDescription = "";\n    if (element.hasAttribute("aria-describedby")) {\n      const describedBy = getIdRefs(element, element.getAttribute("aria-describedby"));\n      accessibleDescription = asFlatString(describedBy.map((ref) => getTextAlternativeInternal(ref, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInDescribedBy: { element: ref, hidden: isElementHiddenForAria(ref) }\n      })).join(" "));\n    } else if (element.hasAttribute("aria-description")) {\n      accessibleDescription = asFlatString(element.getAttribute("aria-description") || "");\n    } else {\n      accessibleDescription = asFlatString(element.getAttribute("title") || "");\n    }\n    cache == null ? void 0 : cache.set(element, accessibleDescription);\n  }\n  return accessibleDescription;\n}\nfunction getAriaInvalid(element) {\n  const ariaInvalid = element.getAttribute("aria-invalid");\n  if (!ariaInvalid || ariaInvalid.trim() === "" || ariaInvalid.toLocaleLowerCase() === "false")\n    return "false";\n  if (ariaInvalid === "true" || ariaInvalid === "grammar" || ariaInvalid === "spelling")\n    return ariaInvalid;\n  return "true";\n}\nfunction getValidityInvalid(element) {\n  if ("validity" in element) {\n    const validity = element.validity;\n    return (validity == null ? void 0 : validity.valid) === false;\n  }\n  return false;\n}\nfunction getElementAccessibleErrorMessage(element) {\n  const cache = cacheAccessibleErrorMessage;\n  let accessibleErrorMessage = cacheAccessibleErrorMessage == null ? void 0 : cacheAccessibleErrorMessage.get(element);\n  if (accessibleErrorMessage === void 0) {\n    accessibleErrorMessage = "";\n    const isAriaInvalid = getAriaInvalid(element) !== "false";\n    const isValidityInvalid = getValidityInvalid(element);\n    if (isAriaInvalid || isValidityInvalid) {\n      const errorMessageId = element.getAttribute("aria-errormessage");\n      const errorMessages = getIdRefs(element, errorMessageId);\n      const parts = errorMessages.map((errorMessage) => asFlatString(\n        getTextAlternativeInternal(errorMessage, {\n          visitedElements: /* @__PURE__ */ new Set(),\n          embeddedInDescribedBy: { element: errorMessage, hidden: isElementHiddenForAria(errorMessage) }\n        })\n      ));\n      accessibleErrorMessage = parts.join(" ").trim();\n    }\n    cache == null ? void 0 : cache.set(element, accessibleErrorMessage);\n  }\n  return accessibleErrorMessage;\n}\nfunction getTextAlternativeInternal(element, options) {\n  var _a, _b, _c, _d;\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden) {\n    const isEmbeddedInHiddenReferenceTraversal = !!((_a = options.embeddedInLabelledBy) == null ? void 0 : _a.hidden) || !!((_b = options.embeddedInDescribedBy) == null ? void 0 : _b.hidden) || !!((_c = options.embeddedInNativeTextAlternative) == null ? void 0 : _c.hidden) || !!((_d = options.embeddedInLabel) == null ? void 0 : _d.hidden);\n    if (isElementIgnoredForAria(element) || !isEmbeddedInHiddenReferenceTraversal && isElementHiddenForAria(element)) {\n      options.visitedElements.add(element);\n      return "";\n    }\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (!options.embeddedInLabelledBy) {\n    const accessibleName = (labelledBy || []).map((ref) => getTextAlternativeInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: { element: ref, hidden: isElementHiddenForAria(ref) },\n      embeddedInDescribedBy: void 0,\n      embeddedInTargetElement: void 0,\n      embeddedInLabel: void 0,\n      embeddedInNativeTextAlternative: void 0\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  const tagName = elementSafeTagName(element);\n  if (!!options.embeddedInLabel || !!options.embeddedInLabelledBy || options.embeddedInTargetElement === "descendant") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (tagName === "INPUT" || tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        if (!selectedOptions.length && tagName === "INPUT") {\n          return element.value;\n        }\n        return selectedOptions.map((option) => getTextAlternativeInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (trimFlatString(ariaLabel)) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (trimFlatString(value))\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "INPUT" && element.type === "file") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return "Choose File";\n    }\n    if (tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && !options.embeddedInLabelledBy)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      if (trimFlatString(title))\n        return title;\n      return "Submit";\n    }\n    if (!labelledBy && tagName === "BUTTON") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n    }\n    if (!labelledBy && tagName === "OUTPUT") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      return element.getAttribute("title") || "";\n    }\n    if (!labelledBy && (tagName === "TEXTAREA" || tagName === "SELECT" || tagName === "INPUT")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length)\n        return getAccessibleNameFromAssociatedLabels(labels, options);\n      const usePlaceholder = tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "LEGEND") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!labelledBy && tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "FIGCAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "CAPTION") {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInNativeTextAlternative: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (trimFlatString(alt))\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (tagName === "SVG" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (elementSafeTagName(child) === "TITLE" && child.ownerSVGElement) {\n          return getTextAlternativeInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: { element: child, hidden: isElementHiddenForAria(child) }\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && tagName === "A") {\n      const title = element.getAttribute("xlink:title") || "";\n      if (trimFlatString(title)) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  const shouldNameFromContentForSummary = tagName === "SUMMARY" && !["presentation", "none"].includes(role);\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || shouldNameFromContentForSummary || !!options.embeddedInLabelledBy || !!options.embeddedInDescribedBy || !!options.embeddedInLabel || !!options.embeddedInNativeTextAlternative) {\n    options.visitedElements.add(element);\n    const accessibleName = innerAccumulatedElementText(element, childOptions);\n    const maybeTrimmedAccessibleName = options.embeddedInTargetElement === "self" ? trimFlatString(accessibleName) : accessibleName;\n    if (maybeTrimmedAccessibleName)\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (trimFlatString(title))\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nfunction innerAccumulatedElementText(element, options) {\n  const tokens = [];\n  const visit = (node, skipSlotted) => {\n    var _a;\n    if (skipSlotted && node.assignedSlot)\n      return;\n    if (node.nodeType === 1) {\n      const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n      let token = getTextAlternativeInternal(node, options);\n      if (display !== "inline" || node.nodeName === "BR")\n        token = " " + token + " ";\n      tokens.push(token);\n    } else if (node.nodeType === 3) {\n      tokens.push(node.textContent || "");\n    }\n  };\n  tokens.push(getCSSContent(element, "::before") || "");\n  const content = getCSSContent(element);\n  if (content !== void 0) {\n    tokens.push(content);\n  } else {\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(child, false);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n      }\n      for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n        visit(owned, true);\n    }\n  }\n  tokens.push(getCSSContent(element, "::after") || "");\n  return tokens.join("");\n}\nvar kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\nfunction getAriaSelected(element) {\n  if (elementSafeTagName(element) === "OPTION")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\nfunction getAriaChecked(element) {\n  const result = getChecked(element, true);\n  return result === "error" ? false : result;\n}\nfunction getCheckedAllowMixed(element) {\n  return getChecked(element, true);\n}\nfunction getCheckedWithoutMixed(element) {\n  const result = getChecked(element, false);\n  return result;\n}\nfunction getChecked(element, allowMixed) {\n  const tagName = elementSafeTagName(element);\n  if (allowMixed && tagName === "INPUT" && element.indeterminate)\n    return "mixed";\n  if (tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n    const checked = element.getAttribute("aria-checked");\n    if (checked === "true")\n      return true;\n    if (allowMixed && checked === "mixed")\n      return "mixed";\n    return false;\n  }\n  return "error";\n}\nvar kAriaReadonlyRoles = ["checkbox", "combobox", "grid", "gridcell", "listbox", "radiogroup", "slider", "spinbutton", "textbox", "columnheader", "rowheader", "searchbox", "switch", "treegrid"];\nfunction getReadonly(element) {\n  const tagName = elementSafeTagName(element);\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(tagName))\n    return element.hasAttribute("readonly");\n  if (kAriaReadonlyRoles.includes(getAriaRole(element) || ""))\n    return element.getAttribute("aria-readonly") === "true";\n  if (element.isContentEditable)\n    return false;\n  return "error";\n}\nvar kAriaPressedRoles = ["button"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n    const pressed = element.getAttribute("aria-pressed");\n    if (pressed === "true")\n      return true;\n    if (pressed === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\nfunction getAriaExpanded(element) {\n  if (elementSafeTagName(element) === "DETAILS")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n    const expanded = element.getAttribute("aria-expanded");\n    if (expanded === null)\n      return void 0;\n    if (expanded === "true")\n      return true;\n    return false;\n  }\n  return void 0;\n}\nvar kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\nfunction getAriaLevel(element) {\n  const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[elementSafeTagName(element)];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n    const attr = element.getAttribute("aria-level");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\nfunction getAriaDisabled(element) {\n  return isNativelyDisabled(element) || hasExplicitAriaDisabled(element);\n}\nfunction isNativelyDisabled(element) {\n  const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(elementSafeTagName(element));\n  return isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledOptGroup(element) || belongsToDisabledFieldSet(element));\n}\nfunction belongsToDisabledOptGroup(element) {\n  return elementSafeTagName(element) === "OPTION" && !!element.closest("OPTGROUP[DISABLED]");\n}\nfunction belongsToDisabledFieldSet(element) {\n  const fieldSetElement = element == null ? void 0 : element.closest("FIELDSET[DISABLED]");\n  if (!fieldSetElement)\n    return false;\n  const legendElement = fieldSetElement.querySelector(":scope > LEGEND");\n  return !legendElement || !legendElement.contains(element);\n}\nfunction hasExplicitAriaDisabled(element, isAncestor = false) {\n  if (!element)\n    return false;\n  if (isAncestor || kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n    const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n    if (attribute === "true")\n      return true;\n    if (attribute === "false")\n      return false;\n    return hasExplicitAriaDisabled(parentElementOrShadowHost(element), true);\n  }\n  return false;\n}\nfunction getAccessibleNameFromAssociatedLabels(labels, options) {\n  return [...labels].map((label) => getTextAlternativeInternal(label, {\n    ...options,\n    embeddedInLabel: { element: label, hidden: isElementHiddenForAria(label) },\n    embeddedInNativeTextAlternative: void 0,\n    embeddedInLabelledBy: void 0,\n    embeddedInDescribedBy: void 0,\n    embeddedInTargetElement: void 0\n  })).filter((accessibleName) => !!accessibleName).join(" ");\n}\nfunction receivesPointerEvents(element) {\n  const cache = cachePointerEvents;\n  let e = element;\n  let result;\n  const parents = [];\n  for (; e; e = parentElementOrShadowHost(e)) {\n    const cached = cache.get(e);\n    if (cached !== void 0) {\n      result = cached;\n      break;\n    }\n    parents.push(e);\n    const style = getElementComputedStyle(e);\n    if (!style) {\n      result = true;\n      break;\n    }\n    const value = style.pointerEvents;\n    if (value) {\n      result = value !== "none";\n      break;\n    }\n  }\n  if (result === void 0)\n    result = true;\n  for (const parent of parents)\n    cache.set(parent, result);\n  return result;\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheAccessibleDescription;\nvar cacheAccessibleDescriptionHidden;\nvar cacheAccessibleErrorMessage;\nvar cacheIsHidden;\nvar cachePseudoContent;\nvar cachePseudoContentBefore;\nvar cachePseudoContentAfter;\nvar cachePointerEvents;\nvar cachesCounter = 0;\nfunction beginAriaCaches() {\n  ++cachesCounter;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = /* @__PURE__ */ new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = /* @__PURE__ */ new Map();\n  cacheAccessibleDescription != null ? cacheAccessibleDescription : cacheAccessibleDescription = /* @__PURE__ */ new Map();\n  cacheAccessibleDescriptionHidden != null ? cacheAccessibleDescriptionHidden : cacheAccessibleDescriptionHidden = /* @__PURE__ */ new Map();\n  cacheAccessibleErrorMessage != null ? cacheAccessibleErrorMessage : cacheAccessibleErrorMessage = /* @__PURE__ */ new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = /* @__PURE__ */ new Map();\n  cachePseudoContent != null ? cachePseudoContent : cachePseudoContent = /* @__PURE__ */ new Map();\n  cachePseudoContentBefore != null ? cachePseudoContentBefore : cachePseudoContentBefore = /* @__PURE__ */ new Map();\n  cachePseudoContentAfter != null ? cachePseudoContentAfter : cachePseudoContentAfter = /* @__PURE__ */ new Map();\n  cachePointerEvents != null ? cachePointerEvents : cachePointerEvents = /* @__PURE__ */ new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheAccessibleDescription = void 0;\n    cacheAccessibleDescriptionHidden = void 0;\n    cacheAccessibleErrorMessage = void 0;\n    cacheIsHidden = void 0;\n    cachePseudoContent = void 0;\n    cachePseudoContentBefore = void 0;\n    cachePseudoContentAfter = void 0;\n    cachePointerEvents = void 0;\n  }\n}\nvar inputTypeToRole = {\n  "button": "button",\n  "checkbox": "checkbox",\n  "image": "button",\n  "number": "spinbutton",\n  "radio": "radio",\n  "range": "slider",\n  "reset": "button",\n  "submit": "button"\n};\n\n// packages/injected/src/yaml.ts\nfunction yamlEscapeKeyIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return `\'` + str.replace(/\'/g, `\'\'`) + `\'`;\n}\nfunction yamlEscapeValueIfNeeded(str) {\n  if (!yamlStringNeedsQuotes(str))\n    return str;\n  return \'"\' + str.replace(/[\\\\"\\x00-\\x1f\\x7f-\\x9f]/g, (c) => {\n    switch (c) {\n      case "\\\\":\n        return "\\\\\\\\";\n      case \'"\':\n        return \'\\\\"\';\n      case "\\b":\n        return "\\\\b";\n      case "\\f":\n        return "\\\\f";\n      case "\\n":\n        return "\\\\n";\n      case "\\r":\n        return "\\\\r";\n      case "	":\n        return "\\\\t";\n      default:\n        const code = c.charCodeAt(0);\n        return "\\\\x" + code.toString(16).padStart(2, "0");\n    }\n  }) + \'"\';\n}\nfunction yamlStringNeedsQuotes(str) {\n  if (str.length === 0)\n    return true;\n  if (/^\\s|\\s$/.test(str))\n    return true;\n  if (/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f-\\x9f]/.test(str))\n    return true;\n  if (/^-/.test(str))\n    return true;\n  if (/[\\n:](\\s|$)/.test(str))\n    return true;\n  if (/\\s#/.test(str))\n    return true;\n  if (/[\\n\\r]/.test(str))\n    return true;\n  if (/^[&*\\],?!>|@"\'#%]/.test(str))\n    return true;\n  if (/[{}`]/.test(str))\n    return true;\n  if (/^\\[/.test(str))\n    return true;\n  if (!isNaN(Number(str)) || ["y", "n", "yes", "no", "true", "false", "on", "off", "null"].includes(str.toLowerCase()))\n    return true;\n  return false;\n}\n\n// packages/injected/src/ariaSnapshot.ts\nvar lastRef = 0;\nfunction toInternalOptions(options) {\n  if (options.mode === "ai") {\n    return {\n      visibility: "ariaOrVisible",\n      refs: "interactable",\n      refPrefix: options.refPrefix,\n      includeGenericRole: true,\n      renderActive: true,\n      renderCursorPointer: true\n    };\n  }\n  if (options.mode === "autoexpect") {\n    return { visibility: "ariaAndVisible", refs: "none" };\n  }\n  if (options.mode === "codegen") {\n    return { visibility: "aria", refs: "none", renderStringsAsRegex: true };\n  }\n  return { visibility: "aria", refs: "none" };\n}\nfunction generateAriaTree(rootElement, publicOptions) {\n  const options = toInternalOptions(publicOptions);\n  const visited = /* @__PURE__ */ new Set();\n  const snapshot = {\n    root: { role: "fragment", name: "", children: [], element: rootElement, props: {}, box: box(rootElement), receivesPointerEvents: true },\n    elements: /* @__PURE__ */ new Map(),\n    refs: /* @__PURE__ */ new Map()\n  };\n  const visit = (ariaNode, node, parentElementVisible) => {\n    if (visited.has(node))\n      return;\n    visited.add(node);\n    if (node.nodeType === Node.TEXT_NODE && node.nodeValue) {\n      if (!parentElementVisible)\n        return;\n      const text = node.nodeValue;\n      if (ariaNode.role !== "textbox" && text)\n        ariaNode.children.push(node.nodeValue || "");\n      return;\n    }\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return;\n    const element = node;\n    const isElementVisibleForAria = !isElementHiddenForAria(element);\n    let visible = isElementVisibleForAria;\n    if (options.visibility === "ariaOrVisible")\n      visible = isElementVisibleForAria || isElementVisible(element);\n    if (options.visibility === "ariaAndVisible")\n      visible = isElementVisibleForAria && isElementVisible(element);\n    if (options.visibility === "aria" && !visible)\n      return;\n    const ariaChildren = [];\n    if (element.hasAttribute("aria-owns")) {\n      const ids = element.getAttribute("aria-owns").split(/\\s+/);\n      for (const id of ids) {\n        const ownedElement = rootElement.ownerDocument.getElementById(id);\n        if (ownedElement)\n          ariaChildren.push(ownedElement);\n      }\n    }\n    const childAriaNode = visible ? toAriaNode(element, options) : null;\n    if (childAriaNode) {\n      if (childAriaNode.ref) {\n        snapshot.elements.set(childAriaNode.ref, element);\n        snapshot.refs.set(element, childAriaNode.ref);\n      }\n      ariaNode.children.push(childAriaNode);\n    }\n    processElement(childAriaNode || ariaNode, element, ariaChildren, visible);\n  };\n  function processElement(ariaNode, element, ariaChildren, parentElementVisible) {\n    var _a;\n    const display = ((_a = getElementComputedStyle(element)) == null ? void 0 : _a.display) || "inline";\n    const treatAsBlock = display !== "inline" || element.nodeName === "BR" ? " " : "";\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    ariaNode.children.push(getCSSContent(element, "::before") || "");\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(ariaNode, child, parentElementVisible);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling) {\n        if (!child.assignedSlot)\n          visit(ariaNode, child, parentElementVisible);\n      }\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(ariaNode, child, parentElementVisible);\n      }\n    }\n    for (const child of ariaChildren)\n      visit(ariaNode, child, parentElementVisible);\n    ariaNode.children.push(getCSSContent(element, "::after") || "");\n    if (treatAsBlock)\n      ariaNode.children.push(treatAsBlock);\n    if (ariaNode.children.length === 1 && ariaNode.name === ariaNode.children[0])\n      ariaNode.children = [];\n    if (ariaNode.role === "link" && element.hasAttribute("href")) {\n      const href = element.getAttribute("href");\n      ariaNode.props["url"] = href;\n    }\n  }\n  beginAriaCaches();\n  try {\n    visit(snapshot.root, rootElement, true);\n  } finally {\n    endAriaCaches();\n  }\n  normalizeStringChildren(snapshot.root);\n  normalizeGenericRoles(snapshot.root);\n  return snapshot;\n}\nfunction computeAriaRef(ariaNode, options) {\n  var _a;\n  if (options.refs === "none")\n    return;\n  if (options.refs === "interactable" && (!ariaNode.box.visible || !ariaNode.receivesPointerEvents))\n    return;\n  let ariaRef;\n  ariaRef = ariaNode.element._ariaRef;\n  if (!ariaRef || ariaRef.role !== ariaNode.role || ariaRef.name !== ariaNode.name) {\n    ariaRef = { role: ariaNode.role, name: ariaNode.name, ref: ((_a = options.refPrefix) != null ? _a : "") + "e" + ++lastRef };\n    ariaNode.element._ariaRef = ariaRef;\n  }\n  ariaNode.ref = ariaRef.ref;\n}\nfunction toAriaNode(element, options) {\n  var _a;\n  const active = element.ownerDocument.activeElement === element;\n  if (element.nodeName === "IFRAME") {\n    const ariaNode = {\n      role: "iframe",\n      name: "",\n      children: [],\n      props: {},\n      element,\n      box: box(element),\n      receivesPointerEvents: true,\n      active\n    };\n    computeAriaRef(ariaNode, options);\n    return ariaNode;\n  }\n  const defaultRole = options.includeGenericRole ? "generic" : null;\n  const role = (_a = getAriaRole(element)) != null ? _a : defaultRole;\n  if (!role || role === "presentation" || role === "none")\n    return null;\n  const name = normalizeWhiteSpace(getElementAccessibleName(element, false) || "");\n  const receivesPointerEvents2 = receivesPointerEvents(element);\n  const result = {\n    role,\n    name,\n    children: [],\n    props: {},\n    element,\n    box: box(element),\n    receivesPointerEvents: receivesPointerEvents2,\n    active\n  };\n  computeAriaRef(result, options);\n  if (kAriaCheckedRoles.includes(role))\n    result.checked = getAriaChecked(element);\n  if (kAriaDisabledRoles.includes(role))\n    result.disabled = getAriaDisabled(element);\n  if (kAriaExpandedRoles.includes(role))\n    result.expanded = getAriaExpanded(element);\n  if (kAriaLevelRoles.includes(role))\n    result.level = getAriaLevel(element);\n  if (kAriaPressedRoles.includes(role))\n    result.pressed = getAriaPressed(element);\n  if (kAriaSelectedRoles.includes(role))\n    result.selected = getAriaSelected(element);\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    if (element.type !== "checkbox" && element.type !== "radio" && element.type !== "file")\n      result.children = [element.value];\n  }\n  return result;\n}\nfunction normalizeGenericRoles(node) {\n  const normalizeChildren = (node2) => {\n    const result = [];\n    for (const child of node2.children || []) {\n      if (typeof child === "string") {\n        result.push(child);\n        continue;\n      }\n      const normalized = normalizeChildren(child);\n      result.push(...normalized);\n    }\n    const removeSelf = node2.role === "generic" && result.length <= 1 && result.every((c) => typeof c !== "string" && !!c.ref);\n    if (removeSelf)\n      return result;\n    node2.children = result;\n    return [node2];\n  };\n  normalizeChildren(node);\n}\nfunction normalizeStringChildren(rootA11yNode) {\n  const flushChildren = (buffer, normalizedChildren) => {\n    if (!buffer.length)\n      return;\n    const text = normalizeWhiteSpace(buffer.join(""));\n    if (text)\n      normalizedChildren.push(text);\n    buffer.length = 0;\n  };\n  const visit = (ariaNode) => {\n    const normalizedChildren = [];\n    const buffer = [];\n    for (const child of ariaNode.children || []) {\n      if (typeof child === "string") {\n        buffer.push(child);\n      } else {\n        flushChildren(buffer, normalizedChildren);\n        visit(child);\n        normalizedChildren.push(child);\n      }\n    }\n    flushChildren(buffer, normalizedChildren);\n    ariaNode.children = normalizedChildren.length ? normalizedChildren : [];\n    if (ariaNode.children.length === 1 && ariaNode.children[0] === ariaNode.name)\n      ariaNode.children = [];\n  };\n  visit(rootA11yNode);\n}\nfunction matchesText(text, template) {\n  if (!template)\n    return true;\n  if (!text)\n    return false;\n  if (typeof template === "string")\n    return text === template;\n  return !!text.match(new RegExp(template.pattern));\n}\nfunction matchesTextNode(text, template) {\n  return matchesText(text, template.text);\n}\nfunction matchesName(text, template) {\n  return matchesText(text, template.name);\n}\nfunction matchesExpectAriaTemplate(rootElement, template) {\n  const snapshot = generateAriaTree(rootElement, { mode: "expect" });\n  const matches = matchesNodeDeep(snapshot.root, template, false, false);\n  return {\n    matches,\n    received: {\n      raw: renderAriaTree(snapshot, { mode: "expect" }),\n      regex: renderAriaTree(snapshot, { mode: "codegen" })\n    }\n  };\n}\nfunction getAllElementsMatchingExpectAriaTemplate(rootElement, template) {\n  const root = generateAriaTree(rootElement, { mode: "expect" }).root;\n  const matches = matchesNodeDeep(root, template, true, false);\n  return matches.map((n) => n.element);\n}\nfunction matchesNode(node, template, isDeepEqual) {\n  var _a;\n  if (typeof node === "string" && template.kind === "text")\n    return matchesTextNode(node, template);\n  if (node === null || typeof node !== "object" || template.kind !== "role")\n    return false;\n  if (template.role !== "fragment" && template.role !== node.role)\n    return false;\n  if (template.checked !== void 0 && template.checked !== node.checked)\n    return false;\n  if (template.disabled !== void 0 && template.disabled !== node.disabled)\n    return false;\n  if (template.expanded !== void 0 && template.expanded !== node.expanded)\n    return false;\n  if (template.level !== void 0 && template.level !== node.level)\n    return false;\n  if (template.pressed !== void 0 && template.pressed !== node.pressed)\n    return false;\n  if (template.selected !== void 0 && template.selected !== node.selected)\n    return false;\n  if (!matchesName(node.name, template))\n    return false;\n  if (!matchesText(node.props.url, (_a = template.props) == null ? void 0 : _a.url))\n    return false;\n  if (template.containerMode === "contain")\n    return containsList(node.children || [], template.children || []);\n  if (template.containerMode === "equal")\n    return listEqual(node.children || [], template.children || [], false);\n  if (template.containerMode === "deep-equal" || isDeepEqual)\n    return listEqual(node.children || [], template.children || [], true);\n  return containsList(node.children || [], template.children || []);\n}\nfunction listEqual(children, template, isDeepEqual) {\n  if (template.length !== children.length)\n    return false;\n  for (let i = 0; i < template.length; ++i) {\n    if (!matchesNode(children[i], template[i], isDeepEqual))\n      return false;\n  }\n  return true;\n}\nfunction containsList(children, template) {\n  if (template.length > children.length)\n    return false;\n  const cc = children.slice();\n  const tt = template.slice();\n  for (const t of tt) {\n    let c = cc.shift();\n    while (c) {\n      if (matchesNode(c, t, false))\n        break;\n      c = cc.shift();\n    }\n    if (!c)\n      return false;\n  }\n  return true;\n}\nfunction matchesNodeDeep(root, template, collectAll, isDeepEqual) {\n  const results = [];\n  const visit = (node, parent) => {\n    if (matchesNode(node, template, isDeepEqual)) {\n      const result = typeof node === "string" ? parent : node;\n      if (result)\n        results.push(result);\n      return !collectAll;\n    }\n    if (typeof node === "string")\n      return false;\n    for (const child of node.children || []) {\n      if (visit(child, node))\n        return true;\n    }\n    return false;\n  };\n  visit(root, null);\n  return results;\n}\nfunction renderAriaTree(ariaSnapshot, publicOptions) {\n  const options = toInternalOptions(publicOptions);\n  const lines = [];\n  const includeText = options.renderStringsAsRegex ? textContributesInfo : () => true;\n  const renderString = options.renderStringsAsRegex ? convertToBestGuessRegex : (str) => str;\n  const visit = (ariaNode2, parentAriaNode, indent) => {\n    if (typeof ariaNode2 === "string") {\n      if (parentAriaNode && !includeText(parentAriaNode, ariaNode2))\n        return;\n      const text = yamlEscapeValueIfNeeded(renderString(ariaNode2));\n      if (text)\n        lines.push(indent + "- text: " + text);\n      return;\n    }\n    let key = ariaNode2.role;\n    if (ariaNode2.name && ariaNode2.name.length <= 900) {\n      const name = renderString(ariaNode2.name);\n      if (name) {\n        const stringifiedName = name.startsWith("/") && name.endsWith("/") ? name : JSON.stringify(name);\n        key += " " + stringifiedName;\n      }\n    }\n    if (ariaNode2.checked === "mixed")\n      key += ` [checked=mixed]`;\n    if (ariaNode2.checked === true)\n      key += ` [checked]`;\n    if (ariaNode2.disabled)\n      key += ` [disabled]`;\n    if (ariaNode2.expanded)\n      key += ` [expanded]`;\n    if (ariaNode2.active && options.renderActive)\n      key += ` [active]`;\n    if (ariaNode2.level)\n      key += ` [level=${ariaNode2.level}]`;\n    if (ariaNode2.pressed === "mixed")\n      key += ` [pressed=mixed]`;\n    if (ariaNode2.pressed === true)\n      key += ` [pressed]`;\n    if (ariaNode2.selected === true)\n      key += ` [selected]`;\n    if (ariaNode2.ref) {\n      key += ` [ref=${ariaNode2.ref}]`;\n      if (options.renderCursorPointer && hasPointerCursor(ariaNode2))\n        key += " [cursor=pointer]";\n    }\n    const escapedKey = indent + "- " + yamlEscapeKeyIfNeeded(key);\n    const hasProps = !!Object.keys(ariaNode2.props).length;\n    if (!ariaNode2.children.length && !hasProps) {\n      lines.push(escapedKey);\n    } else if (ariaNode2.children.length === 1 && typeof ariaNode2.children[0] === "string" && !hasProps) {\n      const text = includeText(ariaNode2, ariaNode2.children[0]) ? renderString(ariaNode2.children[0]) : null;\n      if (text)\n        lines.push(escapedKey + ": " + yamlEscapeValueIfNeeded(text));\n      else\n        lines.push(escapedKey);\n    } else {\n      lines.push(escapedKey + ":");\n      for (const [name, value] of Object.entries(ariaNode2.props))\n        lines.push(indent + "  - /" + name + ": " + yamlEscapeValueIfNeeded(value));\n      for (const child of ariaNode2.children || [])\n        visit(child, ariaNode2, indent + "  ");\n    }\n  };\n  const ariaNode = ariaSnapshot.root;\n  if (ariaNode.role === "fragment") {\n    for (const child of ariaNode.children || [])\n      visit(child, ariaNode, "");\n  } else {\n    visit(ariaNode, null, "");\n  }\n  return lines.join("\\n");\n}\nfunction convertToBestGuessRegex(text) {\n  const dynamicContent = [\n    // 2mb\n    { regex: /\\b[\\d,.]+[bkmBKM]+\\b/, replacement: "[\\\\d,.]+[bkmBKM]+" },\n    // 2ms, 20s\n    { regex: /\\b\\d+[hmsp]+\\b/, replacement: "\\\\d+[hmsp]+" },\n    { regex: /\\b[\\d,.]+[hmsp]+\\b/, replacement: "[\\\\d,.]+[hmsp]+" },\n    // Do not replace single digits with regex by default.\n    // 2+ digits: [Issue 22, 22.3, 2.33, 2,333]\n    { regex: /\\b\\d+,\\d+\\b/, replacement: "\\\\d+,\\\\d+" },\n    { regex: /\\b\\d+\\.\\d{2,}\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\.\\d+\\b/, replacement: "\\\\d+\\\\.\\\\d+" },\n    { regex: /\\b\\d{2,}\\b/, replacement: "\\\\d+" }\n  ];\n  let pattern = "";\n  let lastIndex = 0;\n  const combinedRegex = new RegExp(dynamicContent.map((r) => "(" + r.regex.source + ")").join("|"), "g");\n  text.replace(combinedRegex, (match, ...args) => {\n    const offset = args[args.length - 2];\n    const groups = args.slice(0, -2);\n    pattern += escapeRegExp(text.slice(lastIndex, offset));\n    for (let i = 0; i < groups.length; i++) {\n      if (groups[i]) {\n        const { replacement } = dynamicContent[i];\n        pattern += replacement;\n        break;\n      }\n    }\n    lastIndex = offset + match.length;\n    return match;\n  });\n  if (!pattern)\n    return text;\n  pattern += escapeRegExp(text.slice(lastIndex));\n  return String(new RegExp(pattern));\n}\nfunction textContributesInfo(node, text) {\n  if (!text.length)\n    return false;\n  if (!node.name)\n    return true;\n  if (node.name.length > text.length)\n    return false;\n  const substr = text.length <= 200 && node.name.length <= 200 ? longestCommonSubstring(text, node.name) : "";\n  let filtered = text;\n  while (substr && filtered.includes(substr))\n    filtered = filtered.replace(substr, "");\n  return filtered.trim().length / text.length > 0.1;\n}\nfunction hasPointerCursor(ariaNode) {\n  var _a;\n  return ((_a = ariaNode.box.style) == null ? void 0 : _a.cursor) === "pointer";\n}\n\n// packages/injected/src/highlight.css?inline\nvar highlight_default = ":host{font-size:13px;font-family:system-ui,Ubuntu,Droid Sans,sans-serif;color:#333}svg{position:absolute;height:0}x-pw-tooltip{backdrop-filter:blur(5px);background-color:#fff;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:none;font-size:12.8px;font-weight:400;left:0;line-height:1.5;max-width:600px;position:absolute;top:0;padding:0;flex-direction:column;overflow:hidden}x-pw-tooltip-line{display:flex;max-width:600px;padding:6px;user-select:none;cursor:pointer}x-pw-tooltip-line.selectable:hover{background-color:#f2f2f2;overflow:hidden}x-pw-tooltip-footer{display:flex;max-width:600px;padding:6px;user-select:none;color:#777}x-pw-dialog{background-color:#fff;pointer-events:auto;border-radius:6px;box-shadow:0 .5rem 1.2rem #0000004d;display:flex;flex-direction:column;position:absolute;width:400px;height:150px;z-index:10;font-size:13px}x-pw-dialog-body{display:flex;flex-direction:column;flex:auto}x-pw-dialog-body label{margin:5px 8px;display:flex;flex-direction:row;align-items:center}x-pw-highlight{position:absolute;top:0;left:0;width:0;height:0}x-pw-action-point{position:absolute;width:20px;height:20px;background:red;border-radius:10px;margin:-10px 0 0 -10px;z-index:2}x-pw-separator{height:1px;margin:6px 9px;background:#949494e5}x-pw-tool-gripper{height:28px;width:24px;margin:2px 0;cursor:grab}x-pw-tool-gripper:active{cursor:grabbing}x-pw-tool-gripper>x-div{width:16px;height:16px;margin:6px 4px;clip-path:url(#icon-gripper);background-color:#555}x-pw-tools-list>label{display:flex;align-items:center;margin:0 10px;user-select:none}x-pw-tools-list{display:flex;width:100%;border-bottom:1px solid #dddddd}x-pw-tool-item{pointer-events:auto;height:28px;width:28px;border-radius:3px}x-pw-tool-item:not(.disabled){cursor:pointer}x-pw-tool-item:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.toggled{background-color:#8acae480}x-pw-tool-item.toggled:not(.disabled):hover{background-color:#8acae4c4}x-pw-tool-item>x-div{width:16px;height:16px;margin:6px;background-color:#3a3a3a}x-pw-tool-item.disabled>x-div{background-color:#61616180;cursor:default}x-pw-tool-item.record.toggled{background-color:transparent}x-pw-tool-item.record.toggled:not(.disabled):hover{background-color:#dbdbdb}x-pw-tool-item.record.toggled>x-div{background-color:#a1260d}x-pw-tool-item.record.disabled.toggled>x-div{opacity:.8}x-pw-tool-item.accept>x-div{background-color:#388a34}x-pw-tool-item.record>x-div{clip-path:url(#icon-circle-large-filled)}x-pw-tool-item.pick-locator>x-div{clip-path:url(#icon-inspect)}x-pw-tool-item.text>x-div{clip-path:url(#icon-whole-word)}x-pw-tool-item.visibility>x-div{clip-path:url(#icon-eye)}x-pw-tool-item.value>x-div{clip-path:url(#icon-symbol-constant)}x-pw-tool-item.snapshot>x-div{clip-path:url(#icon-gist)}x-pw-tool-item.accept>x-div{clip-path:url(#icon-check)}x-pw-tool-item.cancel>x-div{clip-path:url(#icon-close)}x-pw-tool-item.succeeded>x-div{clip-path:url(#icon-pass);background-color:#388a34!important}x-pw-overlay{position:absolute;top:0;max-width:min-content;z-index:2147483647;background:transparent;pointer-events:auto}x-pw-overlay x-pw-tools-list{background-color:#fffd;box-shadow:#0000001a 0 5px 5px;border-radius:3px;border-bottom:none}x-pw-overlay x-pw-tool-item{margin:2px}textarea.text-editor{font-family:system-ui,Ubuntu,Droid Sans,sans-serif;flex:auto;border:none;margin:6px 10px;color:#333;outline:1px solid transparent!important;resize:none;padding:0;font-size:13px}textarea.text-editor.does-not-match{outline:1px solid red!important}x-div{display:block}x-spacer{flex:auto}*{box-sizing:border-box}*[hidden]{display:none!important}x-locator-editor{flex:none;width:100%;height:60px;padding:4px;border-bottom:1px solid #dddddd;outline:1px solid transparent}x-locator-editor.does-not-match{outline:1px solid red}.CodeMirror{width:100%!important;height:100%!important}\\n";\n\n// packages/injected/src/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._renderedEntries = [];\n    this._language = "javascript";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement("x-pw-glass");\n    this._glassPaneElement.style.position = "fixed";\n    this._glassPaneElement.style.top = "0";\n    this._glassPaneElement.style.right = "0";\n    this._glassPaneElement.style.bottom = "0";\n    this._glassPaneElement.style.left = "0";\n    this._glassPaneElement.style.zIndex = "2147483647";\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.display = "flex";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    for (const eventName of ["click", "auxclick", "dragstart", "input", "keydown", "keyup", "pointerdown", "pointerup", "mousedown", "mouseup", "mouseleave", "focus", "scroll"]) {\n      this._glassPaneElement.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      });\n    }\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? "open" : "closed" });\n    if (typeof this._glassPaneShadow.adoptedStyleSheets.push === "function") {\n      const sheet = new this._injectedScript.window.CSSStyleSheet();\n      sheet.replaceSync(highlight_default);\n      this._glassPaneShadow.adoptedStyleSheets.push(sheet);\n    } else {\n      const styleElement = this._injectedScript.document.createElement("style");\n      styleElement.textContent = highlight_default;\n      this._glassPaneShadow.appendChild(styleElement);\n    }\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n  }\n  install() {\n    if (!this._injectedScript.document.documentElement)\n      return;\n    if (!this._injectedScript.document.documentElement.contains(this._glassPaneElement) || this._glassPaneElement.nextElementSibling)\n      this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\n    const elements = this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement);\n    const locator = asLocator(this._language, stringifySelector(selector));\n    const color = elements.length > 1 ? "#f6b26b7f" : "#6fa8dc7f";\n    this.updateHighlight(elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : "";\n      return { element, color, tooltipText: locator + suffix };\n    }));\n    this._rafRequest = this._injectedScript.utils.builtins.requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      this._injectedScript.utils.builtins.cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._renderedEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._renderedEntries = [];\n  }\n  maskElements(elements, color) {\n    this.updateHighlight(elements.map((element) => ({ element, color })));\n  }\n  updateHighlight(entries) {\n    if (this._highlightIsUpToDate(entries))\n      return;\n    this.clearHighlight();\n    for (const entry of entries) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (entry.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement("x-pw-tooltip");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        tooltipElement.style.top = "0";\n        tooltipElement.style.left = "0";\n        tooltipElement.style.display = "flex";\n        const lineElement = this._injectedScript.document.createElement("x-pw-tooltip-line");\n        lineElement.textContent = entry.tooltipText;\n        tooltipElement.appendChild(lineElement);\n      }\n      this._renderedEntries.push({ targetElement: entry.element, color: entry.color, tooltipElement, highlightElement });\n    }\n    for (const entry of this._renderedEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const { anchorLeft, anchorTop } = this.tooltipPosition(entry.box, entry.tooltipElement);\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._renderedEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + "px";\n        entry.tooltipElement.style.left = entry.tooltipLeft + "px";\n      }\n      const box2 = entry.box;\n      entry.highlightElement.style.backgroundColor = entry.color;\n      entry.highlightElement.style.left = box2.x + "px";\n      entry.highlightElement.style.top = box2.y + "px";\n      entry.highlightElement.style.width = box2.width + "px";\n      entry.highlightElement.style.height = box2.height + "px";\n      entry.highlightElement.style.display = "block";\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box2.x, y: box2.y, width: box2.width, height: box2.height }));\n    }\n  }\n  firstBox() {\n    var _a;\n    return (_a = this._renderedEntries[0]) == null ? void 0 : _a.box;\n  }\n  tooltipPosition(box2, tooltipElement) {\n    const tooltipWidth = tooltipElement.offsetWidth;\n    const tooltipHeight = tooltipElement.offsetHeight;\n    const totalWidth = this._glassPaneElement.offsetWidth;\n    const totalHeight = this._glassPaneElement.offsetHeight;\n    let anchorLeft = box2.left;\n    if (anchorLeft + tooltipWidth > totalWidth - 5)\n      anchorLeft = totalWidth - tooltipWidth - 5;\n    let anchorTop = box2.bottom + 5;\n    if (anchorTop + tooltipHeight > totalHeight - 5) {\n      if (box2.top > tooltipHeight + 5) {\n        anchorTop = box2.top - tooltipHeight - 5;\n      } else {\n        anchorTop = totalHeight - 5 - tooltipHeight;\n      }\n    }\n    return { anchorLeft, anchorTop };\n  }\n  _highlightIsUpToDate(entries) {\n    if (entries.length !== this._renderedEntries.length)\n      return false;\n    for (let i = 0; i < this._renderedEntries.length; ++i) {\n      if (entries[i].element !== this._renderedEntries[i].targetElement)\n        return false;\n      if (entries[i].color !== this._renderedEntries[i].color)\n        return false;\n      const oldBox = this._renderedEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box2 = entries[i].element.getBoundingClientRect();\n      if (box2.top !== oldBox.top || box2.right !== oldBox.right || box2.bottom !== oldBox.bottom || box2.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    return this._injectedScript.document.createElement("x-pw-highlight");\n  }\n  appendChild(element) {\n    this._glassPaneShadow.appendChild(element);\n  }\n};\n\n// packages/injected/src/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = ["left-of", "right-of", "above", "below", "near"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box2 = element.getBoundingClientRect();\n  const scorer = { "left-of": boxLeftOf, "right-of": boxRightOf, "above": boxAbove, "below": boxBelow, "near": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box2, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/injected/src/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === "string" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === "string" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === "<truthy>")\n    return !!objValue;\n  if (attr.op === "=") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === "string" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== "string" || typeof attrValue !== "string")\n    return false;\n  if (attr.op === "*=")\n    return objValue.includes(attrValue);\n  if (attr.op === "^=")\n    return objValue.startsWith(attrValue);\n  if (attr.op === "$=")\n    return objValue.endsWith(attrValue);\n  if (attr.op === "|=")\n    return objValue === attrValue || objValue.startsWith(attrValue + "-");\n  if (attr.op === "~=")\n    return objValue.split(" ").includes(attrValue);\n  return false;\n}\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === "SCRIPT" || element.nodeName === "NOSCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: "", normalized: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, normalized: normalizeWhiteSpace(root.value), immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else if (child.nodeType === Node.COMMENT_NODE) {\n            continue;\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n        if (value.full)\n          value.normalized = normalizeWhiteSpace(value.full);\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return "none";\n  if (!matcher(elementText(cache, element)))\n    return "none";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return "selfAndChildren";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return "selfAndChildren";\n  return "self";\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute("aria-label");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, normalized: normalizeWhiteSpace(ariaLabel), immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === "INPUT" && element.type !== "hidden";\n  if (["BUTTON", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/injected/src/reactSelectorEngine.ts\nfunction getFunctionComponentName(component) {\n  return component.displayName || component.name || "Anonymous";\n}\nfunction getComponentName(reactElement) {\n  if (reactElement.type) {\n    switch (typeof reactElement.type) {\n      case "function":\n        return getFunctionComponentName(reactElement.type);\n      case "string":\n        return reactElement.type;\n      case "object":\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : "");\n    }\n  }\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === "string")\n      return elementType;\n    if (typeof elementType === "function")\n      return elementType.displayName || elementType.name || "Anonymous";\n  }\n  return "";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === "function" || typeof elementType === "string";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = (\n    // React 16+\n    reactElement.memoizedProps || // React 15\n    ((_a = reactElement._currentElement) == null ? void 0 : _a.props)\n  );\n  if (!props || typeof props === "string")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = (\n    // React 16+\n    // @see https://github.com/baruchvlz/resq/blob/5c15a5e04d3f7174087248f5a158c3d6dcc1ec72/src/utils.js#L29\n    reactElement.stateNode || // React 15\n    reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode)\n  );\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const reactNode = node;\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith("__reactContainer") && reactNode[key] !== null);\n    if (rootKey) {\n      roots.push(reactNode[rootKey].stateNode.current);\n    } else {\n      const legacyRootKey = "_reactRootContainer";\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\n      }\n    }\n    if (node instanceof Element && node.hasAttribute("data-reactroot")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar createReactEngine = () => ({\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/roleSelectorEngine.ts\nvar kSupportedAttributes = ["selected", "checked", "pressed", "expanded", "level", "disabled", "name", "include-hidden"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`"${attr}" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `"${role2}"`).join(", ")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== "<truthy>" && !values.includes(attr.value))\n    throw new Error(`"${attr.name}" must be one of ${values.map((v) => JSON.stringify(v)).join(", ")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`"${attr.name}" does not support "${attr.op}" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  const options = { role };\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case "checked": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.checked = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "pressed": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.pressed = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "selected": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.selected = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "expanded": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.expanded = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "level": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === "string")\n          attr.value = +attr.value;\n        if (attr.op !== "=" || typeof attr.value !== "number" || Number.isNaN(attr.value))\n          throw new Error(`"level" attribute must be compared to a number`);\n        options.level = attr.value;\n        break;\n      }\n      case "disabled": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.disabled = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "name": {\n        if (attr.op === "<truthy>")\n          throw new Error(`"name" attribute must have a value`);\n        if (typeof attr.value !== "string" && !(attr.value instanceof RegExp))\n          throw new Error(`"name" attribute must be a string or a regular expression`);\n        options.name = attr.value;\n        options.nameOp = attr.op;\n        options.exact = attr.caseSensitive;\n        break;\n      }\n      case "include-hidden": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.includeHidden = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute "${attr.name}", must be one of ${kSupportedAttributes.map((a) => `"${a}"`).join(", ")}.`);\n      }\n    }\n  }\n  return options;\n}\nfunction queryRole(scope, options, internal) {\n  const result = [];\n  const match = (element) => {\n    if (getAriaRole(element) !== options.role)\n      return;\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\n      return;\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\n      return;\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\n      return;\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\n      return;\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\n      return;\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\n      return;\n    if (!options.includeHidden) {\n      const isHidden = isElementHiddenForAria(element);\n      if (isHidden)\n        return;\n    }\n    if (options.name !== void 0) {\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\n      if (typeof options.name === "string")\n        options.name = normalizeWhiteSpace(options.name);\n      if (internal && !options.exact && options.nameOp === "=")\n        options.nameOp = "*=";\n      if (!matchesAttributePart(accessibleName, { name: "", jsonPath: [], op: options.nameOp || "=", value: options.name, caseSensitive: !!options.exact }))\n        return;\n    }\n    result.push(element);\n  };\n  const query = (root) => {\n    const shadows = [];\n    if (root.shadowRoot)\n      shadows.push(root.shadowRoot);\n    for (const element of root.querySelectorAll("*")) {\n      match(element);\n      if (element.shadowRoot)\n        shadows.push(element.shadowRoot);\n    }\n    shadows.forEach(query);\n  };\n  query(scope);\n  return result;\n}\nfunction createRoleEngine(internal) {\n  return {\n    queryAll: (scope, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      const role = parsed.name.toLowerCase();\n      if (!role)\n        throw new Error(`Role must not be empty`);\n      const options = validateAttributes(parsed.attributes, role);\n      beginAriaCaches();\n      try {\n        return queryRole(scope, options, internal);\n      } finally {\n        endAriaCaches();\n      }\n    }\n  };\n}\n\n// packages/injected/src/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor() {\n    this._retainCacheCounter = 0;\n    this._cacheText = /* @__PURE__ */ new Map();\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\n    this._cacheMatches = /* @__PURE__ */ new Map();\n    this._cacheQuery = /* @__PURE__ */ new Map();\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("not", notEngine);\n    this._engines.set("is", isEngine);\n    this._engines.set("where", isEngine);\n    this._engines.set("has", hasEngine);\n    this._engines.set("scope", scopeEngine);\n    this._engines.set("light", lightEngine);\n    this._engines.set("visible", visibleEngine);\n    this._engines.set("text", textEngine);\n    this._engines.set("text-is", textIsEngine);\n    this._engines.set("text-matches", textMatchesEngine);\n    this._engines.set("has-text", hasTextEngine);\n    this._engines.set("right-of", createLayoutEngine("right-of"));\n    this._engines.set("left-of", createLayoutEngine("left-of"));\n    this._engines.set("above", createLayoutEngine("above"));\n    this._engines.set("below", createLayoutEngine("below"));\n    this._engines.set("near", createLayoutEngine("near"));\n    this._engines.set("nth-match", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join("|") !== parserNames.join("|"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join("|")} vs ${parserNames.join("|")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === "object" && s && (Array.isArray(s) || "simples" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector "${s}"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = /* @__PURE__ */ new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _hasScopeClause(selector) {\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === "scope"));\n  }\n  _expandContextForScopeMatching(context) {\n    if (context.scope.nodeType !== 1)\n      return context;\n    const scope = parentElementOrShadowHost(context.scope);\n    if (!scope)\n      return context;\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\n      if (element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || "*");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === "*" && funcs.length)\n        css = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css !== void 0) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === ">") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === "+") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === "") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === "~") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "~")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === ">=") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator "${combinator}"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, "*").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll("*")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine "${name}"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"has" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n  // TODO: we can implement efficient "query" by matching "args" and returning\n  // all parents/descendants, just have to be careful with the ":scope" matching.\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9)\n      return element === actualScope.documentElement;\n    return element === actualScope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9) {\n      const root = actualScope.documentElement;\n      return root ? [root] : [];\n    }\n    if (actualScope.nodeType === 1)\n      return [actualScope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"not" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`"visible" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text-is" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]);\n    const matcher = (elementText2) => {\n      if (!text && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\n    };\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== "none";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== "string" || args.length > 2 || args.length === 2 && typeof args[1] !== "string")\n      throw new Error(`"text-matches" engine expects a regexp body and optional regexp flags`);\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\n    const matcher = (elementText2) => re.test(elementText2.full);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"has-text" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => elementText2.normalized.toLowerCase().includes(text);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === "number" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`"${name}" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`"nth-match" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== "number" || index < 1)\n      throw new Error(`"nth-match" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = /* @__PURE__ */ new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  for (const e of elements)\n    append(e).taken = true;\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/injected/src/selectorGenerator.ts\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kRoleWithNameScore = 100;\nvar kPlaceholderScore = 120;\nvar kLabelScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nvar kScoreThresholdForTextExpect = 1e3;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  const cache = { allowText: /* @__PURE__ */ new Map(), disallowText: /* @__PURE__ */ new Map() };\n  beginAriaCaches();\n  try {\n    let selectors = [];\n    if (options.forTextExpect) {\n      let targetTokens = cssFallback(injectedScript, targetElement.ownerDocument.documentElement, options);\n      for (let element = targetElement; element; element = parentElementOrShadowHost(element)) {\n        const tokens = generateSelectorFor(cache, injectedScript, element, { ...options, noText: true });\n        if (!tokens)\n          continue;\n        const score = combineScores(tokens);\n        if (score <= kScoreThresholdForTextExpect) {\n          targetTokens = tokens;\n          break;\n        }\n      }\n      selectors = [joinTokens(targetTokens)];\n    } else {\n      if (!targetElement.matches("input,textarea,select") && !targetElement.isContentEditable) {\n        const interactiveParent = closestCrossShadow(targetElement, "button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]", options.root);\n        if (interactiveParent && isElementVisible(interactiveParent))\n          targetElement = interactiveParent;\n      }\n      if (options.multiple) {\n        const withText = generateSelectorFor(cache, injectedScript, targetElement, options);\n        const withoutText = generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true });\n        let tokens = [withText, withoutText];\n        cache.allowText.clear();\n        cache.disallowText.clear();\n        if (withText && hasCSSIdToken(withText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noCSSId: true }));\n        if (withoutText && hasCSSIdToken(withoutText))\n          tokens.push(generateSelectorFor(cache, injectedScript, targetElement, { ...options, noText: true, noCSSId: true }));\n        tokens = tokens.filter(Boolean);\n        if (!tokens.length) {\n          const css = cssFallback(injectedScript, targetElement, options);\n          tokens.push(css);\n          if (hasCSSIdToken(css))\n            tokens.push(cssFallback(injectedScript, targetElement, { ...options, noCSSId: true }));\n        }\n        selectors = [...new Set(tokens.map((t) => joinTokens(t)))];\n      } else {\n        const targetTokens = generateSelectorFor(cache, injectedScript, targetElement, options) || cssFallback(injectedScript, targetElement, options);\n        selectors = [joinTokens(targetTokens)];\n      }\n    }\n    const selector = selectors[0];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      selectors,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(cache, injectedScript, targetElement, options) {\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root\'s subtree`);\n  if (targetElement === options.root)\n    return [{ engine: "css", selector: ":scope", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    var _a;\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildNoTextCandidates(injectedScript, element, options).filter((token) => !options.omitInternalEngines || !token.engine.startsWith("internal:")).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, (_a = options.root) != null ? _a : targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const map = allowText ? cache.allowText : cache.disallowText;\n    let value = map.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      map.set(element, value);\n    }\n    return value;\n  };\n  return calculate(targetElement, !options.noText);\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of ["data-testid", "data-test-id", "data-test"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: "css", selector: `[${attr}=${quoteCSSAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    if (!options.noCSSId) {\n      const idAttr = element.getAttribute("id");\n      if (idAttr && !isGuidLike(idAttr))\n        candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    }\n    candidates.push({ engine: "css", selector: escapeNodeName(element), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === "IFRAME") {\n    for (const attribute of ["name", "title"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[${attribute}=${quoteCSSAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: "css", selector: `[${options.testIdAttributeName}=${quoteCSSAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: "internal:testid", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n      for (const alternative of suitableTextAlternatives(input.placeholder))\n        candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(alternative.text, false)}]`, score: kPlaceholderScore - alternative.scoreBonus });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.normalized;\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n    for (const alternative of suitableTextAlternatives(labelText))\n      candidates.push({ engine: "internal:label", selector: escapeForTextSelector(alternative.text, false), score: kLabelScore - alternative.scoreBonus });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole))\n    candidates.push({ engine: "internal:role", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "FRAME", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[name=${quoteCSSAttributeValue(element.getAttribute("name"))}]`, score: kCSSInputTypeNameScore });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${escapeNodeName(element)}[type=${quoteCSSAttributeValue(element.getAttribute("type"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.getAttribute("type") !== "hidden")\n    candidates.push({ engine: "css", selector: escapeNodeName(element), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const candidates = [];\n  const title = element.getAttribute("title");\n  if (title) {\n    candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(title, true)}]`, score: kTitleScoreExact }]);\n    for (const alternative of suitableTextAlternatives(title))\n      candidates.push([{ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(alternative.text, false)}]`, score: kTitleScore - alternative.scoreBonus }]);\n  }\n  const alt = element.getAttribute("alt");\n  if (alt && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName)) {\n    candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alt, true)}]`, score: kAltTextScoreExact }]);\n    for (const alternative of suitableTextAlternatives(alt))\n      candidates.push([{ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(alternative.text, false)}]`, score: kAltTextScore - alternative.scoreBonus }]);\n  }\n  const text = elementText(injectedScript._evaluator._cacheText, element).normalized;\n  const textAlternatives = text ? suitableTextAlternatives(text) : [];\n  if (text) {\n    if (isTargetNode) {\n      if (text.length <= 80)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n      for (const alternative of textAlternatives)\n        candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    }\n    const cssToken = { engine: "css", selector: escapeNodeName(element), score: kCSSTagNameScore };\n    for (const alternative of textAlternatives)\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n    if (text.length <= 80) {\n      const re = new RegExp("^" + escapeRegExp(text) + "$");\n      candidates.push([cssToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n    }\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName) {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact };\n      candidates.push([roleToken]);\n      for (const alternative of suitableTextAlternatives(ariaName))\n        candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(alternative.text, false)}]`, score: kRoleWithNameScore - alternative.scoreBonus }]);\n    } else {\n      const roleToken = { engine: "internal:role", selector: `${ariaRole}`, score: kRoleWithoutNameScore };\n      for (const alternative of textAlternatives)\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(alternative.text, false), score: kTextScore - alternative.scoreBonus }]);\n      if (text.length <= 80) {\n        const re = new RegExp("^" + escapeRegExp(text) + "$");\n        candidates.push([roleToken, { engine: "internal:has-text", selector: escapeForTextSelector(re, false), score: kTextScoreRegex }]);\n      }\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id=${quoteCSSAttributeValue(id)}]`;\n}\nfunction hasCSSIdToken(tokens) {\n  return tokens.some((token) => token.engine === "css" && (token.selector.startsWith("#") || token.selector.startsWith(\'[id="\')));\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" > ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    let bestTokenForLevel = "";\n    if (element.id && !options.noCSSId) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList].map(escapeClassName);\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + classes.slice(0, i + 1).join(".");\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const nodeName = element.nodeName;\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? escapeNodeName(element) : `${escapeNodeName(element)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = escapeNodeName(element);\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    if (result[0] === targetElement && result.length === 1) {\n      return tokens;\n    }\n    const index = result.indexOf(targetElement);\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction trimWordBoundary(text, maxLength) {\n  if (text.length <= maxLength)\n    return text;\n  text = text.substring(0, maxLength);\n  const match = text.match(/^(.*)\\b(.+?)$/);\n  if (!match)\n    return "";\n  return match[1].trimEnd();\n}\nfunction suitableTextAlternatives(text) {\n  let result = [];\n  {\n    const match = text.match(/^([\\d.,]+)[^.,\\w]/);\n    const leadingNumberLength = match ? match[1].length : 0;\n    if (leadingNumberLength) {\n      const alt = trimWordBoundary(text.substring(leadingNumberLength).trimStart(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  {\n    const match = text.match(/[^.,\\w]([\\d.,]+)$/);\n    const trailingNumberLength = match ? match[1].length : 0;\n    if (trailingNumberLength) {\n      const alt = trimWordBoundary(text.substring(0, text.length - trailingNumberLength).trimEnd(), 80);\n      result.push({ text: alt, scoreBonus: alt.length <= 30 ? 2 : 1 });\n    }\n  }\n  if (text.length <= 30) {\n    result.push({ text, scoreBonus: 0 });\n  } else {\n    result.push({ text: trimWordBoundary(text, 80), scoreBonus: 0 });\n    result.push({ text: trimWordBoundary(text, 30), scoreBonus: 1 });\n  }\n  result = result.filter((r) => r.text);\n  if (!result.length)\n    result.push({ text: text.substring(0, 80), scoreBonus: 0 });\n  return result;\n}\nfunction escapeNodeName(node) {\n  return node.nodeName.toLocaleLowerCase().replace(/[:\\.]/g, (char) => "\\\\" + char);\n}\nfunction escapeClassName(className) {\n  let result = "";\n  for (let i = 0; i < className.length; i++)\n    result += cssEscapeCharacter(className, i);\n  return result;\n}\nfunction cssEscapeCharacter(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\n\n// packages/injected/src/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, "").replace(/\\\\/g, "/");\n  let result = normalized.substring(normalized.lastIndexOf("/") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : "";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function saveComponentName(instance2, key) {\n    instance2.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance2) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance2.type || {});\n    if (name)\n      return name;\n    if (instance2.root === instance2)\n      return "Root";\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components) {\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\n        return saveComponentName(instance2, key);\n    }\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components) {\n      if (instance2.appContext.components[key] === instance2.type)\n        return saveComponentName(instance2, key);\n    }\n    return "Anonymous Component";\n  }\n  function isBeingDestroyed(instance2) {\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\n  }\n  function isFragment(instance2) {\n    return instance2.subTree.type.toString() === "Symbol(Fragment)";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance2) {\n    if (isFragment(instance2))\n      return getFragmentRootElements(instance2.subTree);\n    return [instance2.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance2),\n      props: instance2.props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction buildComponentsTreeVue2(instance) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function getInstanceName(instance2) {\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\n    if (name)\n      return name;\n    return instance2.$root === instance2 ? "Root" : "Anonymous Component";\n  }\n  function getInternalInstanceChildren(instance2) {\n    if (instance2.$children)\n      return instance2.$children;\n    if (Array.isArray(instance2.subTree.children))\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\n      rootElements: [instance2.$el],\n      props: instance2._props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = /* @__PURE__ */ new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar createVueEngine = () => ({\n  queryAll(scope, selector) {\n    const document = scope.ownerDocument || scope;\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n});\n\n// packages/injected/src/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith("/") && root.nodeType !== Node.DOCUMENT_NODE)\n      selector = "." + selector;\n    const result = [];\n    const document = root.ownerDocument || root;\n    if (!document)\n      return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\nfunction getByAttributeTextSelector(attrName, text, options) {\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\n}\nfunction getByTestIdSelector(testIdAttributeName, testId) {\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\n}\nfunction getByLabelSelector(text, options) {\n  return "internal:label=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByAltTextSelector(text, options) {\n  return getByAttributeTextSelector("alt", text, options);\n}\nfunction getByTitleSelector(text, options) {\n  return getByAttributeTextSelector("title", text, options);\n}\nfunction getByPlaceholderSelector(text, options) {\n  return getByAttributeTextSelector("placeholder", text, options);\n}\nfunction getByTextSelector(text, options) {\n  return "internal:text=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByRoleSelector(role, options = {}) {\n  const props = [];\n  if (options.checked !== void 0)\n    props.push(["checked", String(options.checked)]);\n  if (options.disabled !== void 0)\n    props.push(["disabled", String(options.disabled)]);\n  if (options.selected !== void 0)\n    props.push(["selected", String(options.selected)]);\n  if (options.expanded !== void 0)\n    props.push(["expanded", String(options.expanded)]);\n  if (options.includeHidden !== void 0)\n    props.push(["include-hidden", String(options.includeHidden)]);\n  if (options.level !== void 0)\n    props.push(["level", String(options.level)]);\n  if (options.name !== void 0)\n    props.push(["name", escapeForAttributeSelector(options.name, !!options.exact)]);\n  if (options.pressed !== void 0)\n    props.push(["pressed", String(options.pressed)]);\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;\n}\n\n// packages/injected/src/consoleApi.ts\nvar selectorSymbol = Symbol("selector");\nselectorSymbol;\nvar _Locator = class _Locator {\n  constructor(injectedScript, selector, options) {\n    if (options == null ? void 0 : options.hasText)\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\n    if (options == null ? void 0 : options.hasNotText)\n      selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\n    if (options == null ? void 0 : options.has)\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\n    if (options == null ? void 0 : options.hasNot)\n      selector += ` >> internal:has-not=` + JSON.stringify(options.hasNot[selectorSymbol]);\n    if ((options == null ? void 0 : options.visible) !== void 0)\n      selector += ` >> visible=${options.visible ? "true" : "false"}`;\n    this[selectorSymbol] = selector;\n    if (selector) {\n      const parsed = injectedScript.parseSelector(selector);\n      this.element = injectedScript.querySelector(parsed, injectedScript.document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, injectedScript.document);\n    }\n    const selectorBase = selector;\n    const self = this;\n    self.locator = (selector2, options2) => {\n      return new _Locator(injectedScript, selectorBase ? selectorBase + " >> " + selector2 : selector2, options2);\n    };\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\n    self.filter = (options2) => new _Locator(injectedScript, selector, options2);\n    self.first = () => self.locator("nth=0");\n    self.last = () => self.locator("nth=-1");\n    self.nth = (index) => self.locator(`nth=${index}`);\n    self.and = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:and=` + JSON.stringify(locator[selectorSymbol]));\n    self.or = (locator) => new _Locator(injectedScript, selectorBase + ` >> internal:or=` + JSON.stringify(locator[selectorSymbol]));\n  }\n};\nvar Locator = _Locator;\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n  }\n  install() {\n    if (this._injectedScript.window.playwright)\n      return;\n    this._injectedScript.window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      generateLocator: (element, language) => this._generateLocator(element, language),\n      ariaSnapshot: (element) => {\n        return this._injectedScript.ariaSnapshot(element || this._injectedScript.document.body, { mode: "expect" });\n      },\n      resume: () => this._resume(),\n      ...new Locator(this._injectedScript, "")\n    };\n    delete this._injectedScript.window.playwright.filter;\n    delete this._injectedScript.window.playwright.first;\n    delete this._injectedScript.window.playwright.last;\n    delete this._injectedScript.window.playwright.nth;\n    delete this._injectedScript.window.playwright.and;\n    delete this._injectedScript.window.playwright.or;\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.query(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, this._injectedScript.document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.$$(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, this._injectedScript.document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.inspect(\'Playwright >> selector\').`);\n    this._injectedScript.window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return this._injectedScript.generateSelectorSimple(element);\n  }\n  _generateLocator(element, language) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.locator(element).`);\n    const selector = this._injectedScript.generateSelectorSimple(element);\n    return asLocator(language || "javascript", selector);\n  }\n  _resume() {\n    if (!this._injectedScript.window.__pw_resume)\n      return false;\n    this._injectedScript.window.__pw_resume().catch(() => {\n    });\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp2(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a;\n  try {\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++)\n    bytes[i] = binary.charCodeAt(i);\n  return new TypedArrayConstructor(bytes.buffer);\n}\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("ref" in value)\n      return refs.get(value.ref);\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value) {\n      return new Date(value.d);\n    }\n    if ("u" in value)\n      return new URL(value.u);\n    if ("bi" in value)\n      return BigInt(value.bi);\n    if ("e" in value) {\n      const error = new Error(value.e.m);\n      error.name = value.e.n;\n      error.stack = value.e.s;\n      return error;\n    }\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value) {\n      const result = [];\n      refs.set(value.id, result);\n      for (const a of value.a)\n        result.push(parseEvaluationResultValue(a, handles, refs));\n      return result;\n    }\n    if ("o" in value) {\n      const result = {};\n      refs.set(value.id, result);\n      for (const { k, v } of value.o) {\n        if (k === "__proto__")\n          continue;\n        result[k] = parseEvaluationResultValue(v, handles, refs);\n      }\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n    if ("ta" in value)\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp2(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/utilityScript.ts\nvar UtilityScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(global, isUnderTest) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    this.global = global;\n    this.isUnderTest = isUnderTest;\n    if (global.__pwClock) {\n      this.builtins = global.__pwClock.builtins;\n    } else {\n      this.builtins = {\n        setTimeout: (_a = global.setTimeout) == null ? void 0 : _a.bind(global),\n        clearTimeout: (_b = global.clearTimeout) == null ? void 0 : _b.bind(global),\n        setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n        clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n        requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n        cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n        requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n        cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n        performance: global.performance,\n        Intl: global.Intl,\n        Date: global.Date\n      };\n    }\n    if (this.isUnderTest)\n      global.builtins = this.builtins;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\n    let result = this.global.eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n\n// packages/injected/src/injectedScript.ts\nvar InjectedScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(window, options) {\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = "data-testid";\n    // Recorder must use any external dependencies through InjectedScript.\n    // Otherwise it will end up with a copy of all modules it uses, and any\n    // module-level globals will be duplicated, which leads to subtle bugs.\n    this.utils = {\n      asLocator,\n      cacheNormalizedWhitespaces,\n      elementText,\n      getAriaRole,\n      getElementAccessibleDescription,\n      getElementAccessibleName,\n      isElementVisible,\n      isInsideScope,\n      normalizeWhiteSpace,\n      parseAriaSnapshot,\n      generateAriaTree,\n      // Builtins protect injected code from clock emulation.\n      builtins: null\n    };\n    this.window = window;\n    this.document = window.document;\n    this.isUnderTest = options.isUnderTest;\n    this.utils.builtins = new UtilityScript(window, options.isUnderTest).builtins;\n    this._sdkLanguage = options.sdkLanguage;\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = options.testIdAttributeName;\n    this._evaluator = new SelectorEvaluatorImpl();\n    this.consoleApi = new ConsoleAPI(this);\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\n    this._autoClosingTags = /* @__PURE__ */ new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);\n    this._booleanAttributes = /* @__PURE__ */ new Set(["checked", "selected", "disabled", "readonly", "multiple"]);\n    this._eventTypes = /* @__PURE__ */ new Map([\n      ["auxclick", "mouse"],\n      ["click", "mouse"],\n      ["dblclick", "mouse"],\n      ["mousedown", "mouse"],\n      ["mouseeenter", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousemove", "mouse"],\n      ["mouseout", "mouse"],\n      ["mouseover", "mouse"],\n      ["mouseup", "mouse"],\n      ["mouseleave", "mouse"],\n      ["mousewheel", "mouse"],\n      ["keydown", "keyboard"],\n      ["keyup", "keyboard"],\n      ["keypress", "keyboard"],\n      ["textInput", "keyboard"],\n      ["touchstart", "touch"],\n      ["touchmove", "touch"],\n      ["touchend", "touch"],\n      ["touchcancel", "touch"],\n      ["pointerover", "pointer"],\n      ["pointerout", "pointer"],\n      ["pointerenter", "pointer"],\n      ["pointerleave", "pointer"],\n      ["pointerdown", "pointer"],\n      ["pointerup", "pointer"],\n      ["pointermove", "pointer"],\n      ["pointercancel", "pointer"],\n      ["gotpointercapture", "pointer"],\n      ["lostpointercapture", "pointer"],\n      ["focus", "focus"],\n      ["blur", "focus"],\n      ["drag", "drag"],\n      ["dragstart", "drag"],\n      ["dragend", "drag"],\n      ["dragover", "drag"],\n      ["dragenter", "drag"],\n      ["dragleave", "drag"],\n      ["dragexit", "drag"],\n      ["drop", "drag"],\n      ["wheel", "wheel"],\n      ["deviceorientation", "deviceorientation"],\n      ["deviceorientationabsolute", "deviceorientation"],\n      ["devicemotion", "devicemotion"]\n    ]);\n    this._hoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousemove"]);\n    this._tapHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["pointerdown", "pointerup", "touchstart", "touchend", "touchcancel"]);\n    this._mouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousedown", "mouseup", "pointerdown", "pointerup", "click", "auxclick", "dblclick", "contextmenu"]);\n    this._allHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...this._hoverHitTargetInterceptorEvents, ...this._tapHitTargetInterceptorEvents, ...this._mouseHitTargetInterceptorEvents]);\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("xpath", XPathEngine);\n    this._engines.set("xpath:light", XPathEngine);\n    this._engines.set("_react", createReactEngine());\n    this._engines.set("_vue", createVueEngine());\n    this._engines.set("role", createRoleEngine(false));\n    this._engines.set("text", this._createTextEngine(true, false));\n    this._engines.set("text:light", this._createTextEngine(false, false));\n    this._engines.set("id", this._createAttributeEngine("id", true));\n    this._engines.set("id:light", this._createAttributeEngine("id", false));\n    this._engines.set("data-testid", this._createAttributeEngine("data-testid", true));\n    this._engines.set("data-testid:light", this._createAttributeEngine("data-testid", false));\n    this._engines.set("data-test-id", this._createAttributeEngine("data-test-id", true));\n    this._engines.set("data-test-id:light", this._createAttributeEngine("data-test-id", false));\n    this._engines.set("data-test", this._createAttributeEngine("data-test", true));\n    this._engines.set("data-test:light", this._createAttributeEngine("data-test", false));\n    this._engines.set("css", this._createCSSEngine());\n    this._engines.set("nth", { queryAll: () => [] });\n    this._engines.set("visible", this._createVisibleEngine());\n    this._engines.set("internal:control", this._createControlEngine());\n    this._engines.set("internal:has", this._createHasEngine());\n    this._engines.set("internal:has-not", this._createHasNotEngine());\n    this._engines.set("internal:and", { queryAll: () => [] });\n    this._engines.set("internal:or", { queryAll: () => [] });\n    this._engines.set("internal:chain", this._createInternalChainEngine());\n    this._engines.set("internal:label", this._createInternalLabelEngine());\n    this._engines.set("internal:text", this._createTextEngine(true, true));\n    this._engines.set("internal:has-text", this._createInternalHasTextEngine());\n    this._engines.set("internal:has-not-text", this._createInternalHasNotTextEngine());\n    this._engines.set("internal:attr", this._createNamedAttributeEngine());\n    this._engines.set("internal:testid", this._createNamedAttributeEngine());\n    this._engines.set("internal:role", createRoleEngine(true));\n    this._engines.set("internal:describe", this._createDescribeEngine());\n    this._engines.set("aria-ref", this._createAriaRefEngine());\n    for (const { name, source } of options.customEngines)\n      this._engines.set(name, this.eval(source));\n    this._stableRafCount = options.stableRafCount;\n    this._browserName = options.browserName;\n    setGlobalOptions({ browserNameForWorkarounds: options.browserName });\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (this.isUnderTest)\n      this.window.__injectedScript = this;\n  }\n  eval(expression) {\n    return this.window.eval(expression);\n  }\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    visitAllSelectorParts(result, (part) => {\n      if (!this._engines.has(part.name))\n        throw this.createStacklessError(`Unknown engine "${part.name}" while parsing selector ${selector}`);\n    });\n    return result;\n  }\n  generateSelector(targetElement, options) {\n    return generateSelector(this, targetElement, options);\n  }\n  generateSelectorSimple(targetElement, options) {\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  ariaSnapshot(node, options) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Can only capture aria snapshot of Element nodes.");\n    this._lastAriaSnapshot = generateAriaTree(node, options);\n    return renderAriaTree(this._lastAriaSnapshot, options);\n  }\n  ariaSnapshotForRecorder() {\n    const tree = generateAriaTree(this.document.body, { mode: "ai" });\n    const ariaSnapshot = renderAriaTree(tree, { mode: "ai" });\n    return { ariaSnapshot, refs: tree.refs };\n  }\n  getAllElementsMatchingExpectAriaTemplate(document, template) {\n    return getAllElementsMatchingExpectAriaTemplate(document.documentElement, template);\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === "nth"))\n        throw this.createStacklessError(`Can\'t query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: "internal:has", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root["querySelectorAll"])\n      throw this.createStacklessError("Node is not queryable.");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError("Internal error: there should not be a capture in the selector.");\n    }\n    if (root.nodeType === 11 && selector.parts.length === 1 && selector.parts[0].name === "css" && selector.parts[0].source === ":scope")\n      return [root];\n    this._evaluator.begin();\n    try {\n      let roots = /* @__PURE__ */ new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === "nth") {\n          roots = this._queryNth(roots, part);\n        } else if (part.name === "internal:and") {\n          const andElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(andElements.filter((e) => roots.has(e)));\n        } else if (part.name === "internal:or") {\n          const orElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(sortInDOMOrder(/* @__PURE__ */ new Set([...roots, ...orElements])));\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = /* @__PURE__ */ new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!("nodeName" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: "" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    return {\n      queryAll: (root, body) => {\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow, internal) {\n    const queryAll = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector, internal);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === "lax" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === "none")\n          lastDidNotMatchSelf = element;\n        if (matches === "self" || matches === "selfAndChildren" && kind === "strict" && !internal)\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, "*");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return { queryAll };\n  }\n  _createInternalHasTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [element] : [];\n      }\n    };\n  }\n  _createInternalHasNotTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [] : [element];\n      }\n    };\n  }\n  _createInternalLabelEngine() {\n    return {\n      queryAll: (root, selector) => {\n        const { matcher } = createTextMatcher(selector, true);\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, "*");\n        return allElements.filter((element) => {\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\n        });\n      }\n    };\n  }\n  _createNamedAttributeEngine() {\n    const queryAll = (root, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      if (parsed.name || parsed.attributes.length !== 1)\n        throw new Error("Malformed attribute selector: " + selector);\n      const { name, value, caseSensitive } = parsed.attributes[0];\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\n      let matcher;\n      if (value instanceof RegExp)\n        matcher = (s) => !!s.match(value);\n      else if (caseSensitive)\n        matcher = (s) => s === value;\n      else\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\n      return elements.filter((e) => matcher(e.getAttribute(name)));\n    };\n    return { queryAll };\n  }\n  _createDescribeEngine() {\n    const queryAll = (root) => {\n      if (root.nodeType !== 1)\n        return [];\n      return [root];\n    };\n    return { queryAll };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === "enter-frame")\n          return [];\n        if (body === "return-empty")\n          return [];\n        if (body === "component") {\n          if (root.nodeType !== 1)\n            return [];\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\n        }\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createHasNotEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [] : [root];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const visible = body === "true";\n      return isElementVisible(root) === visible ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createInternalChainEngine() {\n    const queryAll = (root, body) => {\n      return this.querySelectorAll(body.parsed, root);\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = this.window.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports.default();\n    })()`);\n    return new constrFunction(this, params);\n  }\n  async viewportRatio(element) {\n    return await new Promise((resolve) => {\n      const observer = new IntersectionObserver((entries) => {\n        resolve(entries[0].intersectionRatio);\n        observer.disconnect();\n      });\n      observer.observe(element);\n      this.utils.builtins.requestAnimationFrame(() => {\n      });\n    });\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || "", 10), top: parseInt(style.borderTopWidth || "", 10) };\n  }\n  describeIFrameStyle(iframe) {\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\n      return "error:notconnected";\n    const defaultView = iframe.ownerDocument.defaultView;\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\n      if (defaultView.getComputedStyle(e).transform !== "none")\n        return "transformed";\n    }\n    const iframeStyle = defaultView.getComputedStyle(iframe);\n    return {\n      left: parseInt(iframeStyle.borderLeftWidth || "", 10) + parseInt(iframeStyle.paddingLeft || "", 10),\n      top: parseInt(iframeStyle.borderTopWidth || "", 10) + parseInt(iframeStyle.paddingTop || "", 10)\n    };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === "none")\n      return element;\n    if (!element.matches("input, textarea, select") && !element.isContentEditable) {\n      if (behavior === "button-link")\n        element = element.closest("button, [role=button], a, [role=link]") || element;\n      else\n        element = element.closest("button, [role=button], [role=checkbox], [role=radio]") || element;\n    }\n    if (behavior === "follow-label") {\n      if (!element.matches("a, input, textarea, button, select, [role=link], [role=button], [role=checkbox], [role=radio]") && !element.isContentEditable) {\n        const enclosingLabel = element.closest("label");\n        if (enclosingLabel && enclosingLabel.control)\n          element = enclosingLabel.control;\n      }\n    }\n    return element;\n  }\n  async checkElementStates(node, states) {\n    if (states.includes("stable")) {\n      const stableResult = await this._checkElementIsStable(node);\n      if (stableResult === false)\n        return { missingState: "stable" };\n      if (stableResult === "error:notconnected")\n        return "error:notconnected";\n    }\n    for (const state of states) {\n      if (state !== "stable") {\n        const result = this.elementState(node, state);\n        if (result.received === "error:notconnected")\n          return "error:notconnected";\n        if (!result.matches)\n          return { missingState: state };\n      }\n    }\n  }\n  async _checkElementIsStable(node) {\n    const continuePolling = Symbol("continuePolling");\n    let lastRect;\n    let stableRafCounter = 0;\n    let lastTime = 0;\n    const check = () => {\n      const element = this.retarget(node, "no-follow-label");\n      if (!element)\n        return "error:notconnected";\n      const time = this.utils.builtins.performance.now();\n      if (this._stableRafCount > 1 && time - lastTime < 15)\n        return continuePolling;\n      lastTime = time;\n      const clientRect = element.getBoundingClientRect();\n      const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n      if (lastRect) {\n        const samePosition = rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (!samePosition)\n          return false;\n        if (++stableRafCounter >= this._stableRafCount)\n          return true;\n      }\n      lastRect = rect;\n      return continuePolling;\n    };\n    let fulfill;\n    let reject;\n    const result = new Promise((f, r) => {\n      fulfill = f;\n      reject = r;\n    });\n    const raf = () => {\n      try {\n        const success = check();\n        if (success !== continuePolling)\n          fulfill(success);\n        else\n          this.utils.builtins.requestAnimationFrame(raf);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    this.utils.builtins.requestAnimationFrame(raf);\n    return result;\n  }\n  _createAriaRefEngine() {\n    const queryAll = (root, selector) => {\n      var _a, _b;\n      const result = (_b = (_a = this._lastAriaSnapshot) == null ? void 0 : _a.elements) == null ? void 0 : _b.get(selector);\n      return result && result.isConnected ? [result] : [];\n    };\n    return { queryAll };\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, ["visible", "hidden"].includes(state) ? "none" : "follow-label");\n    if (!element || !element.isConnected) {\n      if (state === "hidden")\n        return { matches: true, received: "hidden" };\n      return { matches: false, received: "error:notconnected" };\n    }\n    if (state === "visible" || state === "hidden") {\n      const visible = isElementVisible(element);\n      return {\n        matches: state === "visible" ? visible : !visible,\n        received: visible ? "visible" : "hidden"\n      };\n    }\n    if (state === "disabled" || state === "enabled") {\n      const disabled = getAriaDisabled(element);\n      return {\n        matches: state === "disabled" ? disabled : !disabled,\n        received: disabled ? "disabled" : "enabled"\n      };\n    }\n    if (state === "editable") {\n      const disabled = getAriaDisabled(element);\n      const readonly = getReadonly(element);\n      if (readonly === "error")\n        throw this.createStacklessError("Element is not an <input>, <textarea>, <select> or [contenteditable] and does not have a role allowing [aria-readonly]");\n      return {\n        matches: !disabled && !readonly,\n        received: disabled ? "disabled" : readonly ? "readOnly" : "editable"\n      };\n    }\n    if (state === "checked" || state === "unchecked") {\n      const need = state === "checked";\n      const checked = getCheckedWithoutMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return {\n        matches: need === checked,\n        received: checked ? "checked" : "unchecked"\n      };\n    }\n    if (state === "indeterminate") {\n      const checked = getCheckedAllowMixed(element);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return {\n        matches: checked === "mixed",\n        received: checked === true ? "checked" : checked === false ? "unchecked" : "mixed"\n      };\n    }\n    throw this.createStacklessError(`Unexpected element state "${state}"`);\n  }\n  selectOptions(node, optionsToSelect) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() !== "select")\n      throw this.createStacklessError("Element is not a <select> element");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.valueOrLabel !== void 0)\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      if (!this.elementState(option, "enabled").matches)\n        return "error:optionnotenabled";\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length)\n      return "error:optionsnotfound";\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    select.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    select.dispatchEvent(new Event("change", { bubbles: true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(node, value) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set(["color", "date", "time", "datetime-local", "month", "range", "week"]);\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set(["", "email", "number", "password", "search", "tel", "text", "url"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type))\n        throw this.createStacklessError(`Input of type "${type}" cannot be filled`);\n      if (type === "number") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError("Cannot type text into input[type=number]");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError("Malformed value");\n        element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n        element.dispatchEvent(new Event("change", { bubbles: true }));\n        return "done";\n      }\n    } else if (element.nodeName.toLowerCase() === "textarea") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");\n    }\n    this.selectText(element);\n    return "needsinput";\n  }\n  selectText(node) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      input.select();\n      input.focus();\n      return "done";\n    }\n    if (element.nodeName.toLowerCase() === "textarea") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return "done";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return "done";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === "input") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return "done";\n  }\n  blurNode(node) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    node.blur();\n    return "done";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return "Node is not of type HTMLElement";\n    const element = node;\n    if (element.nodeName !== "INPUT")\n      return "Not an <input> element";\n    const input = element;\n    const type = (input.getAttribute("type") || "").toLowerCase();\n    if (type !== "file")\n      return "Not an input[type=file] element";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType, lastModified: file.lastModifiedMs });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event("input", { bubbles: true, composed: true }));\n    input.dispatchEvent(new Event("change", { bubbles: true }));\n  }\n  expectHitTarget(hitPoint, targetElement) {\n    const roots = [];\n    let parentElement = targetElement;\n    while (parentElement) {\n      const root = enclosingShadowRootOrDocument(parentElement);\n      if (!root)\n        break;\n      roots.push(root);\n      if (root.nodeType === 9)\n        break;\n      parentElement = root.host;\n    }\n    let hitElement;\n    for (let index = roots.length - 1; index >= 0; index--) {\n      const root = roots[index];\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = this.window.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === "contents") {\n          elements.unshift(singleElement);\n        }\n      }\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\n        elements.shift();\n      }\n      const innerElement = elements[0];\n      if (!innerElement)\n        break;\n      hitElement = innerElement;\n      if (index && innerElement !== roots[index - 1].host)\n        break;\n    }\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return "done";\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  // Life of a pointer action, for example click.\n  //\n  // 0. Retry items 1 and 2 while action fails due to navigation or element being detached.\n  //   1. Resolve selector to an element.\n  //   2. Retry the following steps until the element is detached or frame navigates away.\n  //     2a. Wait for the element to be stable (not moving), visible and enabled.\n  //     2b. Scroll element into view. Scrolling alternates between:\n  //         - Built-in protocol scrolling.\n  //         - Anchoring to the top/left, bottom/right and center/center.\n  //         This is to scroll elements from under sticky headers/footers.\n  //     2c. Click point is calculated, either based on explicitly specified position,\n  //         or some visible point of the element based on protocol content quads.\n  //     2d. Click point relative to page viewport is converted relative to the target iframe\n  //         for the next hit-point check.\n  //     2e. (injected) Hit target at the click point must be a descendant of the target element.\n  //         This prevents mis-clicking in edge cases like <iframe> overlaying the target.\n  //     2f. (injected) Events specific for click (or some other action type) are intercepted on\n  //         the Window with capture:true. See 2i for details.\n  //         Note: this step is skipped for drag&drop (see inline comments for the reason).\n  //     2g. Necessary keyboard modifiers are pressed.\n  //     2h. Click event is issued (mousemove + mousedown + mouseup).\n  //     2i. (injected) For each event, we check that hit target at the event point\n  //         is a descendant of the target element.\n  //         This guarantees no race between issuing the event and handling it in the page,\n  //         for example due to layout shift.\n  //         When hit target check fails, we block all future events in the page.\n  //     2j. Keyboard modifiers are restored.\n  //     2k. (injected) Event interceptor is removed.\n  //     2l. All navigations triggered between 2g-2k are awaited to be either committed or canceled.\n  //     2m. If failed, wait for increasing amount of time before the next retry.\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = this.retarget(node, "button-link");\n    if (!element || !element.isConnected)\n      return "error:notconnected";\n    if (hitPoint) {\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\n      if (preliminaryResult !== "done")\n        return preliminaryResult.hitTargetDescription;\n    }\n    if (action === "drag")\n      return { stop: () => "done" };\n    const events = {\n      "hover": this._hoverHitTargetInterceptorEvents,\n      "tap": this._tapHitTargetInterceptorEvents,\n      "mouse": this._mouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point)\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\n      if (blockAllEvents || result !== "done" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || "done";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInitObj) {\n    var _a, _b, _c, _d, _e;\n    let event;\n    const eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInitObj };\n    switch (this._eventTypes.get(type)) {\n      case "mouse":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case "keyboard":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case "touch": {\n        if (this._browserName === "webkit") {\n          const createTouch = (t) => {\n            var _a2, _b2, _c2;\n            if (t instanceof Touch)\n              return t;\n            let pageX = t.pageX;\n            if (pageX === void 0 && t.clientX !== void 0)\n              pageX = t.clientX + (((_a2 = this.document.scrollingElement) == null ? void 0 : _a2.scrollLeft) || 0);\n            let pageY = t.pageY;\n            if (pageY === void 0 && t.clientY !== void 0)\n              pageY = t.clientY + (((_b2 = this.document.scrollingElement) == null ? void 0 : _b2.scrollTop) || 0);\n            return this.document.createTouch(this.window, (_c2 = t.target) != null ? _c2 : node, t.identifier, pageX, pageY, t.screenX, t.screenY, t.radiusX, t.radiusY, t.rotationAngle, t.force);\n          };\n          const createTouchList = (touches) => {\n            if (touches instanceof TouchList || !touches)\n              return touches;\n            return this.document.createTouchList(...touches.map(createTouch));\n          };\n          (_a = eventInit.target) != null ? _a : eventInit.target = node;\n          eventInit.touches = createTouchList(eventInit.touches);\n          eventInit.targetTouches = createTouchList(eventInit.targetTouches);\n          eventInit.changedTouches = createTouchList(eventInit.changedTouches);\n          event = new TouchEvent(type, eventInit);\n        } else {\n          (_b = eventInit.target) != null ? _b : eventInit.target = node;\n          eventInit.touches = (_c = eventInit.touches) == null ? void 0 : _c.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.targetTouches = (_d = eventInit.targetTouches) == null ? void 0 : _d.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          eventInit.changedTouches = (_e = eventInit.changedTouches) == null ? void 0 : _e.map((t) => {\n            var _a2;\n            return t instanceof Touch ? t : new Touch({ ...t, target: (_a2 = t.target) != null ? _a2 : node });\n          });\n          event = new TouchEvent(type, eventInit);\n        }\n        break;\n      }\n      case "pointer":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case "focus":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case "drag":\n        event = new DragEvent(type, eventInit);\n        break;\n      case "wheel":\n        event = new WheelEvent(type, eventInit);\n        break;\n      case "deviceorientation":\n        try {\n          event = new DeviceOrientationEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, alpha, beta, gamma, absolute } = eventInit;\n          event = this.document.createEvent("DeviceOrientationEvent");\n          event.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);\n        }\n        break;\n      case "devicemotion":\n        try {\n          event = new DeviceMotionEvent(type, eventInit);\n        } catch {\n          const { bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval } = eventInit;\n          event = this.document.createEvent("DeviceMotionEvent");\n          event.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);\n        }\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || ""}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === "style")\n        continue;\n      if (!value && this._booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}="${value}"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    const attrText = trimStringWithEllipsis(attrs.join(""), 500);\n    if (this._autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    const text = onlyText ? element.textContent || "" : children.length ? "\\u2026" : "";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${trimStringWithEllipsis(text, 50)}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelectorSimple(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\n    if (infos.length < matches.length)\n      lines.push("\\n    ...");\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join("")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === "firefox") {\n      const error2 = new Error("Error: " + message);\n      error2.stack = "";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  createHighlight() {\n    return new Highlight(this);\n  }\n  maskSelectors(selectors, color) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\n    this._highlight.maskElements(elements.flat(), color);\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  markTargetElements(markedElements, callId) {\n    var _a, _b;\n    if (((_a = this._markedElements) == null ? void 0 : _a.callId) !== callId)\n      this._markedElements = void 0;\n    const previous = ((_b = this._markedElements) == null ? void 0 : _b.elements) || /* @__PURE__ */ new Set();\n    const unmarkEvent = new CustomEvent("__playwright_unmark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of previous) {\n      if (!markedElements.has(element))\n        element.dispatchEvent(unmarkEvent);\n    }\n    const markEvent = new CustomEvent("__playwright_mark_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: true\n    });\n    for (const element of markedElements) {\n      if (!previous.has(element))\n        element.dispatchEvent(markEvent);\n    }\n    this._markedElements = { callId, elements: markedElements };\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = "__playwright_global_listeners_check__";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    this.window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      this.window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      this.window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(this.document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of this._allHitTargetInterceptorEvents)\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  async expect(element, options, elements) {\n    var _a, _b;\n    const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");\n    if (isArray)\n      return this.expectArray(elements, options);\n    if (!element) {\n      if (!options.isNot && options.expression === "to.be.hidden")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.visible")\n        return { matches: false };\n      if (!options.isNot && options.expression === "to.be.detached")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.attached")\n        return { matches: false };\n      if (options.isNot && options.expression === "to.be.in.viewport")\n        return { matches: false };\n      if (options.expression === "to.have.title" && ((_a = options == null ? void 0 : options.expectedText) == null ? void 0 : _a[0])) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        const received = this.document.title;\n        return { received, matches: matcher.matches(received) };\n      }\n      if (options.expression === "to.have.url" && ((_b = options == null ? void 0 : options.expectedText) == null ? void 0 : _b[0])) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        const received = this.document.location.href;\n        return { received, matches: matcher.matches(received) };\n      }\n      return { matches: options.isNot, missingReceived: true };\n    }\n    return await this.expectSingleElement(element, options);\n  }\n  async expectSingleElement(element, options) {\n    var _a, _b;\n    const expression = options.expression;\n    {\n      let result;\n      if (expression === "to.have.attribute") {\n        const hasAttribute = element.hasAttribute(options.expressionArg);\n        result = {\n          matches: hasAttribute,\n          received: hasAttribute ? "attribute present" : "attribute not present"\n        };\n      } else if (expression === "to.be.checked") {\n        const { checked, indeterminate } = options.expectedValue;\n        if (indeterminate) {\n          if (checked !== void 0)\n            throw this.createStacklessError("Can\'t assert indeterminate and checked at the same time");\n          result = this.elementState(element, "indeterminate");\n        } else {\n          result = this.elementState(element, checked === false ? "unchecked" : "checked");\n        }\n      } else if (expression === "to.be.disabled") {\n        result = this.elementState(element, "disabled");\n      } else if (expression === "to.be.editable") {\n        result = this.elementState(element, "editable");\n      } else if (expression === "to.be.readonly") {\n        result = this.elementState(element, "editable");\n        result.matches = !result.matches;\n      } else if (expression === "to.be.empty") {\n        if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n          const value = element.value;\n          result = { matches: !value, received: value ? "notEmpty" : "empty" };\n        } else {\n          const text = (_a = element.textContent) == null ? void 0 : _a.trim();\n          result = { matches: !text, received: text ? "notEmpty" : "empty" };\n        }\n      } else if (expression === "to.be.enabled") {\n        result = this.elementState(element, "enabled");\n      } else if (expression === "to.be.focused") {\n        const focused = this._activelyFocused(element).isFocused;\n        result = {\n          matches: focused,\n          received: focused ? "focused" : "inactive"\n        };\n      } else if (expression === "to.be.hidden") {\n        result = this.elementState(element, "hidden");\n      } else if (expression === "to.be.visible") {\n        result = this.elementState(element, "visible");\n      } else if (expression === "to.be.attached") {\n        result = {\n          matches: true,\n          received: "attached"\n        };\n      } else if (expression === "to.be.detached") {\n        result = {\n          matches: false,\n          received: "attached"\n        };\n      }\n      if (result) {\n        if (result.received === "error:notconnected")\n          throw this.createStacklessError("Element is not connected");\n        return result;\n      }\n    }\n    {\n      if (expression === "to.have.property") {\n        let target = element;\n        const properties = options.expressionArg.split(".");\n        for (let i = 0; i < properties.length - 1; i++) {\n          if (typeof target !== "object" || !(properties[i] in target))\n            return { received: void 0, matches: false };\n          target = target[properties[i]];\n        }\n        const received = target[properties[properties.length - 1]];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === "to.be.in.viewport") {\n        const ratio = await this.viewportRatio(element);\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\n      }\n    }\n    {\n      if (expression === "to.have.values") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "SELECT" || !element.multiple)\n          throw this.createStacklessError("Not a select element with a multiple attribute");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      if (expression === "to.match.aria") {\n        const result = matchesExpectAriaTemplate(element, options.expectedValue);\n        return {\n          received: result.received,\n          matches: !!result.matches.length\n        };\n      }\n    }\n    {\n      let received;\n      if (expression === "to.have.attribute.value") {\n        const value = element.getAttribute(options.expressionArg);\n        if (value === null)\n          return { received: null, matches: false };\n        received = value;\n      } else if (["to.have.class", "to.contain.class"].includes(expression)) {\n        if (!options.expectedText)\n          throw this.createStacklessError("Expected text is not provided for " + expression);\n        return {\n          received: element.classList.toString(),\n          matches: new ExpectedTextMatcher(options.expectedText[0]).matchesClassList(\n            this,\n            element.classList,\n            /* partial */\n            expression === "to.contain.class"\n          )\n        };\n      } else if (expression === "to.have.css") {\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === "to.have.id") {\n        received = element.id;\n      } else if (expression === "to.have.text") {\n        received = options.useInnerText ? element.innerText : elementText(/* @__PURE__ */ new Map(), element).full;\n      } else if (expression === "to.have.accessible.name") {\n        received = getElementAccessibleName(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.description") {\n        received = getElementAccessibleDescription(\n          element,\n          false\n          /* includeHidden */\n        );\n      } else if (expression === "to.have.accessible.error.message") {\n        received = getElementAccessibleErrorMessage(element);\n      } else if (expression === "to.have.role") {\n        received = getAriaRole(element) || "";\n      } else if (expression === "to.have.value") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")\n          throw this.createStacklessError("Not an input element");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === "to.have.count") {\n      const received2 = elements.length;\n      const matches2 = received2 === options.expectedNumber;\n      return { received: received2, matches: matches2 };\n    }\n    if (!options.expectedText)\n      throw this.createStacklessError("Expected text is not provided for " + expression);\n    if (["to.have.class.array", "to.contain.class.array"].includes(expression)) {\n      const receivedClassLists = elements.map((e) => e.classList);\n      const received2 = receivedClassLists.map(String);\n      if (receivedClassLists.length !== options.expectedText.length)\n        return { received: received2, matches: false };\n      const matches2 = this._matchSequentially(\n        options.expectedText,\n        receivedClassLists,\n        (matcher, r) => matcher.matchesClassList(\n          this,\n          r,\n          /* partial */\n          expression === "to.contain.class.array"\n        )\n      );\n      return {\n        received: received2,\n        matches: matches2\n      };\n    }\n    if (!["to.contain.text.array", "to.have.text.array"].includes(expression))\n      throw this.createStacklessError("Unknown expect matcher: " + expression);\n    const received = elements.map((e) => options.useInnerText ? e.innerText : elementText(/* @__PURE__ */ new Map(), e).full);\n    const lengthShouldMatch = expression !== "to.contain.text.array";\n    const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n    if (!matchesLength)\n      return { received, matches: false };\n    const matches = this._matchSequentially(options.expectedText, received, (matcher, r) => matcher.matches(r));\n    return { received, matches };\n  }\n  _matchSequentially(expectedText, received, matchFn) {\n    const matchers = expectedText.map((e) => new ExpectedTextMatcher(e));\n    let mIndex = 0;\n    let rIndex = 0;\n    while (mIndex < matchers.length && rIndex < received.length) {\n      if (matchFn(matchers[mIndex], received[rIndex]))\n        ++mIndex;\n      ++rIndex;\n    }\n    return mIndex === matchers.length;\n  }\n};\nfunction oneLine(s) {\n  return s.replace(/\\n/g, "\\u21B5").replace(/\\t/g, "\\u21C6");\n}\nfunction cssUnquote(s) {\n  s = s.substring(1, s.length - 1);\n  if (!s.includes("\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === "\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join("");\n}\nfunction createTextMatcher(selector, internal) {\n  if (selector[0] === "/" && selector.lastIndexOf("/") > 0) {\n    const lastSlash = selector.lastIndexOf("/");\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: "regex" };\n  }\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\n  let strict = false;\n  if (selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 1] === \'"\') {\n    selector = unquote(selector);\n    strict = true;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "i") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = false;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "s") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = true;\n  } else if (selector.length > 1 && selector[0] === "\'" && selector[selector.length - 1] === "\'") {\n    selector = unquote(selector);\n    strict = true;\n  }\n  selector = normalizeWhiteSpace(selector);\n  if (strict) {\n    if (internal)\n      return { kind: "strict", matcher: (elementText2) => elementText2.normalized === selector };\n    const strictTextNodeMatcher = (elementText2) => {\n      if (!selector && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\n    };\n    return { matcher: strictTextNodeMatcher, kind: "strict" };\n  }\n  selector = selector.toLowerCase();\n  return { kind: "lax", matcher: (elementText2) => elementText2.normalized.toLowerCase().includes(selector) };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || "").split(""));\n      if (expected.ignoreCase === false)\n        flags.delete("i");\n      if (expected.ignoreCase === true)\n        flags.add("i");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(""));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  matchesClassList(injectedScript, classList, partial) {\n    if (partial) {\n      if (this._regex)\n        throw injectedScript.createStacklessError("Partial matching does not support regular expressions. Please provide a string value.");\n      return this._string.split(/\\s+/g).filter(Boolean).every((className) => classList.contains(className));\n    }\n    return this.matches(classList.toString());\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = normalizeWhiteSpace(s);\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === "object" && typeof b === "object") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === "number" && typeof b === "number")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dom.js
var NonRecoverableDOMError = class extends Error {
  static {
    __name(this, "NonRecoverableDOMError");
  }
};
function isNonRecoverableDOMError(error3) {
  return error3 instanceof NonRecoverableDOMError;
}
__name(isNonRecoverableDOMError, "isNonRecoverableDOMError");
var FrameExecutionContext = class extends ExecutionContext {
  static {
    __name(this, "FrameExecutionContext");
  }
  constructor(delegate, frame, world) {
    super(frame, delegate, world || "content-script");
    this.frame = frame;
    this.world = world;
  }
  adoptIfNeeded(handle) {
    if (handle instanceof ElementHandle && handle._context !== this)
      return this.frame._page.delegate.adoptElementHandle(handle, this);
    return null;
  }
  async evaluate(pageFunction, arg) {
    return evaluate(this, true, pageFunction, arg);
  }
  async evaluateHandle(pageFunction, arg) {
    return evaluate(this, false, pageFunction, arg);
  }
  async evaluateExpression(expression, options2, arg) {
    return evaluateExpression(this, expression, { ...options2, returnByValue: true }, arg);
  }
  async evaluateExpressionHandle(expression, options2, arg) {
    return evaluateExpression(this, expression, { ...options2, returnByValue: false }, arg);
  }
  injectedScript() {
    if (!this._injectedScriptPromise) {
      const customEngines = [];
      const selectorsRegistry = this.frame._page.browserContext.selectors();
      for (const [name, { source: source22 }] of selectorsRegistry._engines)
        customEngines.push({ name, source: `(${source22})` });
      const sdkLanguage = this.frame._page.browserContext._browser.sdkLanguage();
      const options2 = {
        isUnderTest: isUnderTest(),
        sdkLanguage,
        testIdAttributeName: selectorsRegistry.testIdAttributeName(),
        stableRafCount: this.frame._page.delegate.rafCountForStablePosition(),
        browserName: this.frame._page.browserContext._browser.options.name,
        customEngines
      };
      const source$1 = `
        (() => {
        const module = {};
        ${source3}
        return new (module.exports.InjectedScript())(globalThis, ${JSON.stringify(options2)});
        })();
      `;
      this._injectedScriptPromise = this.rawEvaluateHandle(source$1).then((handle) => {
        handle._setPreview("InjectedScript");
        return handle;
      });
    }
    return this._injectedScriptPromise;
  }
};
var ElementHandle = class extends JSHandle {
  static {
    __name(this, "ElementHandle");
  }
  constructor(context2, objectId) {
    super(context2, "node", void 0, objectId);
    this.__elementhandle = true;
    this._page = context2.frame._page;
    this._frame = context2.frame;
    this._initializePreview().catch((e) => {
    });
  }
  async _initializePreview() {
    const utility = await this._context.injectedScript();
    this._setPreview(await utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
  }
  asElement() {
    return this;
  }
  async evaluateInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (this._frame.isNonRetriableError(e))
        throw e;
      return "error:notconnected";
    }
  }
  async evaluateHandleInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (this._frame.isNonRetriableError(e))
        throw e;
      return "error:notconnected";
    }
  }
  async ownerFrame() {
    const frameId = await this._page.delegate.getOwnerFrame(this);
    if (!frameId)
      return null;
    const frame = this._page.frameManager.frame(frameId);
    if (frame)
      return frame;
    for (const page of this._page.browserContext.pages()) {
      const frame2 = page.frameManager.frame(frameId);
      if (frame2)
        return frame2;
    }
    return null;
  }
  async isIframeElement() {
    return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
  }
  async contentFrame() {
    const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());
    if (!isFrameElement)
      return null;
    return this._page.delegate.getContentFrame(this);
  }
  async getAttribute(progress3, name) {
    return this._frame.getAttribute(progress3, ":scope", name, {}, this);
  }
  async inputValue(progress3) {
    return this._frame.inputValue(progress3, ":scope", {}, this);
  }
  async textContent(progress3) {
    return this._frame.textContent(progress3, ":scope", {}, this);
  }
  async innerText(progress3) {
    return this._frame.innerText(progress3, ":scope", {}, this);
  }
  async innerHTML(progress3) {
    return this._frame.innerHTML(progress3, ":scope", {}, this);
  }
  async dispatchEvent(progress3, type, eventInit = {}) {
    return this._frame.dispatchEvent(progress3, ":scope", type, eventInit, {}, this);
  }
  async _scrollRectIntoViewIfNeeded(progress3, rect) {
    return await progress3.race(this._page.delegate.scrollRectIntoViewIfNeeded(this, rect));
  }
  async _waitAndScrollIntoViewIfNeeded(progress3, waitForVisible) {
    const result = await this._retryAction(progress3, "scroll into view", async () => {
      progress3.log(`  waiting for element to be stable`);
      const waitResult = await progress3.race(this.evaluateInUtility(async ([injected, node, { waitForVisible: waitForVisible2 }]) => {
        return await injected.checkElementStates(node, waitForVisible2 ? ["visible", "stable"] : ["stable"]);
      }, { waitForVisible }));
      if (waitResult)
        return waitResult;
      return await this._scrollRectIntoViewIfNeeded(progress3);
    }, {});
    assertDone(throwRetargetableDOMError(result));
  }
  async scrollIntoViewIfNeeded(progress3) {
    await this._waitAndScrollIntoViewIfNeeded(
      progress3,
      false
      /* waitForVisible */
    );
  }
  async _clickablePoint() {
    const intersectQuadWithViewport = /* @__PURE__ */ __name((quad) => {
      return quad.map((point) => ({
        x: Math.min(Math.max(point.x, 0), metrics.width),
        y: Math.min(Math.max(point.y, 0), metrics.height)
      }));
    }, "intersectQuadWithViewport");
    const computeQuadArea = /* @__PURE__ */ __name((quad) => {
      let area = 0;
      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }
      return Math.abs(area);
    }, "computeQuadArea");
    const [quads, metrics] = await Promise.all([
      this._page.delegate.getContentQuads(this),
      this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({ width: innerWidth, height: innerHeight })))
    ]);
    if (quads === "error:notconnected")
      return quads;
    if (!quads || !quads.length)
      return "error:notvisible";
    const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
    if (!filtered.length)
      return "error:notinviewport";
    if (this._page.browserContext._browser.options.name === "firefox") {
      for (const quad of filtered) {
        const integerPoint = findIntegerPointInsideQuad(quad);
        if (integerPoint)
          return integerPoint;
      }
    }
    return quadMiddlePoint(filtered[0]);
  }
  async _offsetPoint(offset) {
    const [box, border] = await Promise.all([
      this.boundingBox(),
      this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
      })
    ]);
    if (!box || !border)
      return "error:notvisible";
    if (border === "error:notconnected")
      return border;
    return {
      x: box.x + border.left + offset.x,
      y: box.y + border.top + offset.y
    };
  }
  async _retryAction(progress3, actionName, action, options2) {
    let retry2 = 0;
    const waitTime = [0, 20, 100, 100, 500];
    while (true) {
      if (retry2) {
        progress3.log(`retrying ${actionName} action${options2.trial ? " (trial run)" : ""}`);
        const timeout = waitTime[Math.min(retry2 - 1, waitTime.length - 1)];
        if (timeout) {
          progress3.log(`  waiting ${timeout}ms`);
          const result2 = await progress3.race(this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout));
          if (result2 === "error:notconnected")
            return result2;
        }
      } else {
        progress3.log(`attempting ${actionName} action${options2.trial ? " (trial run)" : ""}`);
      }
      if (!options2.skipActionPreChecks && !options2.force)
        await this._frame._page.performActionPreChecks(progress3);
      const result = await action(retry2);
      ++retry2;
      if (result === "error:notvisible") {
        if (options2.force)
          throw new NonRecoverableDOMError("Element is not visible");
        progress3.log("  element is not visible");
        continue;
      }
      if (result === "error:notinviewport") {
        if (options2.force)
          throw new NonRecoverableDOMError("Element is outside of the viewport");
        progress3.log("  element is outside of the viewport");
        continue;
      }
      if (result === "error:optionsnotfound") {
        progress3.log("  did not find some options");
        continue;
      }
      if (result === "error:optionnotenabled") {
        progress3.log("  option being selected is not enabled");
        continue;
      }
      if (typeof result === "object" && "hitTargetDescription" in result) {
        progress3.log(`  ${result.hitTargetDescription} intercepts pointer events`);
        continue;
      }
      if (typeof result === "object" && "missingState" in result) {
        progress3.log(`  element is not ${result.missingState}`);
        continue;
      }
      return result;
    }
  }
  async _retryPointerAction(progress3, actionName, waitForEnabled, action, options2) {
    const skipActionPreChecks = actionName === "move and up";
    return await this._retryAction(progress3, actionName, async (retry2) => {
      const scrollOptions = [
        void 0,
        { block: "end", inline: "end" },
        { block: "center", inline: "center" },
        { block: "start", inline: "start" }
      ];
      const forceScrollOptions = scrollOptions[retry2 % scrollOptions.length];
      return await this._performPointerAction(progress3, actionName, waitForEnabled, action, forceScrollOptions, options2);
    }, { ...options2, skipActionPreChecks });
  }
  async _performPointerAction(progress3, actionName, waitForEnabled, action, forceScrollOptions, options2) {
    const { force = false, position } = options2;
    const doScrollIntoView = /* @__PURE__ */ __name(async () => {
      if (forceScrollOptions) {
        return await this.evaluateInUtility(([injected, node, options22]) => {
          if (node.nodeType === 1)
            node.scrollIntoView(options22);
          return "done";
        }, forceScrollOptions);
      }
      return await this._scrollRectIntoViewIfNeeded(progress3, position ? { x: position.x, y: position.y, width: 0, height: 0 } : void 0);
    }, "doScrollIntoView");
    if (this._frame.parentFrame()) {
      await progress3.race(doScrollIntoView().catch(() => {
      }));
    }
    if (options2.__testHookBeforeStable)
      await progress3.race(options2.__testHookBeforeStable());
    if (!force) {
      const elementStates = waitForEnabled ? ["visible", "enabled", "stable"] : ["visible", "stable"];
      progress3.log(`  waiting for element to be ${waitForEnabled ? "visible, enabled and stable" : "visible and stable"}`);
      const result = await progress3.race(this.evaluateInUtility(async ([injected, node, { elementStates: elementStates2 }]) => {
        return await injected.checkElementStates(node, elementStates2);
      }, { elementStates }));
      if (result)
        return result;
      progress3.log(`  element is ${waitForEnabled ? "visible, enabled and stable" : "visible and stable"}`);
    }
    if (options2.__testHookAfterStable)
      await progress3.race(options2.__testHookAfterStable());
    progress3.log("  scrolling into view if needed");
    const scrolled = await progress3.race(doScrollIntoView());
    if (scrolled !== "done")
      return scrolled;
    progress3.log("  done scrolling");
    const maybePoint = position ? await progress3.race(this._offsetPoint(position)) : await progress3.race(this._clickablePoint());
    if (typeof maybePoint === "string")
      return maybePoint;
    const point = roundPoint(maybePoint);
    progress3.metadata.point = point;
    await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
    let hitTargetInterceptionHandle;
    if (force) {
      progress3.log(`  forcing action`);
    } else {
      if (options2.__testHookBeforeHitTarget)
        await progress3.race(options2.__testHookBeforeHitTarget());
      const frameCheckResult = await progress3.race(this._checkFrameIsHitTarget(point));
      if (frameCheckResult === "error:notconnected" || "hitTargetDescription" in frameCheckResult)
        return frameCheckResult;
      const hitPoint = frameCheckResult.framePoint;
      const actionType = actionName === "move and up" ? "drag" : actionName === "hover" || actionName === "tap" ? actionName : "mouse";
      const handle = await progress3.race(this.evaluateHandleInUtility(([injected, node, { actionType: actionType2, hitPoint: hitPoint2, trial }]) => injected.setupHitTargetInterceptor(node, actionType2, hitPoint2, trial), { actionType, hitPoint, trial: !!options2.trial }));
      if (handle === "error:notconnected")
        return handle;
      if (!handle._objectId) {
        const error3 = handle.rawValue();
        if (error3 === "error:notconnected")
          return error3;
        return { hitTargetDescription: error3 };
      }
      hitTargetInterceptionHandle = handle;
    }
    const actionResult = await this._page.frameManager.waitForSignalsCreatedBy(progress3, options2.waitAfter === true, async () => {
      if (options2.__testHookBeforePointerAction)
        await progress3.race(options2.__testHookBeforePointerAction());
      let restoreModifiers;
      if (options2 && options2.modifiers)
        restoreModifiers = await this._page.keyboard.ensureModifiers(progress3, options2.modifiers);
      progress3.log(`  performing ${actionName} action`);
      await action(point);
      if (restoreModifiers)
        await this._page.keyboard.ensureModifiers(progress3, restoreModifiers);
      if (hitTargetInterceptionHandle) {
        const stopHitTargetInterception = this._frame.raceAgainstEvaluationStallingEvents(() => {
          return hitTargetInterceptionHandle.evaluate((h) => h.stop());
        }).catch((e) => "done").finally(() => {
          hitTargetInterceptionHandle?.dispose();
        });
        if (options2.waitAfter !== false) {
          const hitTargetResult = await progress3.race(stopHitTargetInterception);
          if (hitTargetResult !== "done")
            return hitTargetResult;
        }
      }
      progress3.log(`  ${options2.trial ? "trial " : ""}${actionName} action done`);
      progress3.log("  waiting for scheduled navigations to finish");
      if (options2.__testHookAfterPointerAction)
        await progress3.race(options2.__testHookAfterPointerAction());
      return "done";
    }).finally(() => {
      const stopPromise = hitTargetInterceptionHandle?.evaluate((h) => h.stop()).catch(() => {
      });
      stopPromise?.then(() => hitTargetInterceptionHandle?.dispose());
    });
    if (actionResult !== "done")
      return actionResult;
    progress3.log("  navigations have finished");
    return "done";
  }
  async _markAsTargetElement(progress3) {
    if (!progress3.metadata.id)
      return;
    await progress3.race(this.evaluateInUtility(([injected, node, callId]) => {
      if (node.nodeType === 1)
        injected.markTargetElements(/* @__PURE__ */ new Set([node]), callId);
    }, progress3.metadata.id));
  }
  async hover(progress3, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._hover(progress3, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  _hover(progress3, options2) {
    return this._retryPointerAction(progress3, "hover", false, (point) => this._page.mouse.move(progress3, point.x, point.y), { ...options2, waitAfter: "disabled" });
  }
  async click(progress3, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._click(progress3, { ...options2, waitAfter: !options2.noWaitAfter });
    return assertDone(throwRetargetableDOMError(result));
  }
  _click(progress3, options2) {
    return this._retryPointerAction(progress3, "click", true, (point) => this._page.mouse.click(progress3, point.x, point.y, options2), options2);
  }
  async dblclick(progress3, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._dblclick(progress3, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  _dblclick(progress3, options2) {
    return this._retryPointerAction(progress3, "dblclick", true, (point) => this._page.mouse.click(progress3, point.x, point.y, { ...options2, clickCount: 2 }), { ...options2, waitAfter: "disabled" });
  }
  async tap(progress3, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._tap(progress3, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  _tap(progress3, options2) {
    return this._retryPointerAction(progress3, "tap", true, (point) => this._page.touchscreen.tap(progress3, point.x, point.y), { ...options2, waitAfter: "disabled" });
  }
  async selectOption(progress3, elements, values, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._selectOption(progress3, elements, values, options2);
    return throwRetargetableDOMError(result);
  }
  async _selectOption(progress3, elements, values, options2) {
    let resultingOptions = [];
    const result = await this._retryAction(progress3, "select option", async () => {
      await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
      if (!options2.force)
        progress3.log(`  waiting for element to be visible and enabled`);
      const optionsToSelect = [...elements, ...values];
      const result2 = await progress3.race(this.evaluateInUtility(async ([injected, node, { optionsToSelect: optionsToSelect2, force }]) => {
        if (!force) {
          const checkResult = await injected.checkElementStates(node, ["visible", "enabled"]);
          if (checkResult)
            return checkResult;
        }
        return injected.selectOptions(node, optionsToSelect2);
      }, { optionsToSelect, force: options2.force }));
      if (Array.isArray(result2)) {
        progress3.log("  selected specified option(s)");
        resultingOptions = result2;
        return "done";
      }
      return result2;
    }, options2);
    if (result === "error:notconnected")
      return result;
    return resultingOptions;
  }
  async fill(progress3, value, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._fill(progress3, value, options2);
    assertDone(throwRetargetableDOMError(result));
  }
  async _fill(progress3, value, options2) {
    progress3.log(`  fill("${value}")`);
    return await this._retryAction(progress3, "fill", async () => {
      await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
      if (!options2.force)
        progress3.log("  waiting for element to be visible, enabled and editable");
      const result = await progress3.race(this.evaluateInUtility(async ([injected, node, { value: value2, force }]) => {
        if (!force) {
          const checkResult = await injected.checkElementStates(node, ["visible", "enabled", "editable"]);
          if (checkResult)
            return checkResult;
        }
        return injected.fill(node, value2);
      }, { value, force: options2.force }));
      if (result === "needsinput") {
        if (value)
          await this._page.keyboard.insertText(progress3, value);
        else
          await this._page.keyboard.press(progress3, "Delete");
        return "done";
      } else {
        return result;
      }
    }, options2);
  }
  async selectText(progress3, options2) {
    const result = await this._retryAction(progress3, "selectText", async () => {
      if (!options2.force)
        progress3.log("  waiting for element to be visible");
      return await progress3.race(this.evaluateInUtility(async ([injected, node, { force }]) => {
        if (!force) {
          const checkResult = await injected.checkElementStates(node, ["visible"]);
          if (checkResult)
            return checkResult;
        }
        return injected.selectText(node);
      }, { force: options2.force }));
    }, options2);
    assertDone(throwRetargetableDOMError(result));
  }
  async setInputFiles(progress3, params) {
    const inputFileItems = await progress3.race(prepareFilesForUpload(this._frame, params));
    await this._markAsTargetElement(progress3);
    const result = await this._setInputFiles(progress3, inputFileItems);
    return assertDone(throwRetargetableDOMError(result));
  }
  async _setInputFiles(progress3, items) {
    const { filePayloads, localPaths, localDirectory } = items;
    const multiple = filePayloads && filePayloads.length > 1 || localPaths && localPaths.length > 1;
    const result = await progress3.race(this.evaluateHandleInUtility(([injected, node, { multiple: multiple2, directoryUpload }]) => {
      const element = injected.retarget(node, "follow-label");
      if (!element)
        return;
      if (element.tagName !== "INPUT")
        throw injected.createStacklessError("Node is not an HTMLInputElement");
      const inputElement = element;
      if (multiple2 && !inputElement.multiple && !inputElement.webkitdirectory)
        throw injected.createStacklessError("Non-multiple file input can only accept single file");
      if (directoryUpload && !inputElement.webkitdirectory)
        throw injected.createStacklessError("File input does not support directories, pass individual files instead");
      if (!directoryUpload && inputElement.webkitdirectory)
        throw injected.createStacklessError("[webkitdirectory] input requires passing a path to a directory");
      return inputElement;
    }, { multiple, directoryUpload: !!localDirectory }));
    if (result === "error:notconnected" || !result.asElement())
      return "error:notconnected";
    const retargeted = result.asElement();
    await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
    if (localPaths || localDirectory) {
      const localPathsOrDirectory = localDirectory ? [localDirectory] : localPaths;
      await progress3.race(Promise.all(localPathsOrDirectory.map((localPath) => fs13.promises.access(localPath, fs13.constants.F_OK))));
      const waitForInputEvent = localDirectory ? this.evaluate((node) => new Promise((fulfill) => {
        node.addEventListener("input", fulfill, { once: true });
      })).catch(() => {
      }) : Promise.resolve();
      await progress3.race(this._page.delegate.setInputFilePaths(retargeted, localPathsOrDirectory));
      await progress3.race(waitForInputEvent);
    } else {
      await progress3.race(retargeted.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), filePayloads));
    }
    return "done";
  }
  async focus(progress3) {
    await this._markAsTargetElement(progress3);
    const result = await this._focus(progress3);
    return assertDone(throwRetargetableDOMError(result));
  }
  async _focus(progress3, resetSelectionIfNotFocused) {
    return await progress3.race(this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused));
  }
  async _blur(progress3) {
    return await progress3.race(this.evaluateInUtility(([injected, node]) => injected.blurNode(node), {}));
  }
  async type(progress3, text, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._type(progress3, text, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  async _type(progress3, text, options2) {
    progress3.log(`elementHandle.type("${text}")`);
    await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
    const result = await this._focus(
      progress3,
      true
      /* resetSelectionIfNotFocused */
    );
    if (result !== "done")
      return result;
    await this._page.keyboard.type(progress3, text, options2);
    return "done";
  }
  async press(progress3, key, options2) {
    await this._markAsTargetElement(progress3);
    const result = await this._press(progress3, key, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  async _press(progress3, key, options2) {
    progress3.log(`elementHandle.press("${key}")`);
    await progress3.race(this.instrumentation.onBeforeInputAction(this, progress3.metadata));
    return this._page.frameManager.waitForSignalsCreatedBy(progress3, !options2.noWaitAfter, async () => {
      const result = await this._focus(
        progress3,
        true
        /* resetSelectionIfNotFocused */
      );
      if (result !== "done")
        return result;
      await this._page.keyboard.press(progress3, key, options2);
      return "done";
    });
  }
  async check(progress3, options2) {
    const result = await this._setChecked(progress3, true, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  async uncheck(progress3, options2) {
    const result = await this._setChecked(progress3, false, options2);
    return assertDone(throwRetargetableDOMError(result));
  }
  async _setChecked(progress3, state, options2) {
    const isChecked = /* @__PURE__ */ __name(async () => {
      const result2 = await progress3.race(this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {}));
      if (result2 === "error:notconnected" || result2.received === "error:notconnected")
        throwElementIsNotAttached();
      return result2.matches;
    }, "isChecked");
    await this._markAsTargetElement(progress3);
    if (await isChecked() === state)
      return "done";
    const result = await this._click(progress3, { ...options2, waitAfter: "disabled" });
    if (result !== "done")
      return result;
    if (options2.trial)
      return "done";
    if (await isChecked() !== state)
      throw new NonRecoverableDOMError("Clicking the checkbox did not change its state");
    return "done";
  }
  async boundingBox() {
    return this._page.delegate.getBoundingBox(this);
  }
  async ariaSnapshot() {
    return await this.evaluateInUtility(([injected, element]) => injected.ariaSnapshot(element, { mode: "expect" }), {});
  }
  async screenshot(progress3, options2) {
    return await this._page.screenshotter.screenshotElement(progress3, this, options2);
  }
  async querySelector(selector, options2) {
    return this._frame.selectors.query(selector, options2, this);
  }
  async querySelectorAll(selector) {
    return this._frame.selectors.queryAll(selector, this);
  }
  async evalOnSelector(selector, strict, expression, isFunction, arg) {
    return this._frame.evalOnSelector(selector, strict, expression, isFunction, arg, this);
  }
  async evalOnSelectorAll(selector, expression, isFunction, arg) {
    return this._frame.evalOnSelectorAll(selector, expression, isFunction, arg, this);
  }
  async isVisible(progress3) {
    return this._frame.isVisible(progress3, ":scope", {}, this);
  }
  async isHidden(progress3) {
    return this._frame.isHidden(progress3, ":scope", {}, this);
  }
  async isEnabled(progress3) {
    return this._frame.isEnabled(progress3, ":scope", {}, this);
  }
  async isDisabled(progress3) {
    return this._frame.isDisabled(progress3, ":scope", {}, this);
  }
  async isEditable(progress3) {
    return this._frame.isEditable(progress3, ":scope", {}, this);
  }
  async isChecked(progress3) {
    return this._frame.isChecked(progress3, ":scope", {}, this);
  }
  async waitForElementState(progress3, state) {
    const actionName = `wait for ${state}`;
    const result = await this._retryAction(progress3, actionName, async () => {
      return await progress3.race(this.evaluateInUtility(async ([injected, node, state2]) => {
        return await injected.checkElementStates(node, [state2]) || "done";
      }, state));
    }, {});
    assertDone(throwRetargetableDOMError(result));
  }
  async waitForSelector(progress3, selector, options2) {
    return await this._frame.waitForSelector(progress3, selector, true, options2, this);
  }
  async _adoptTo(context2) {
    if (this._context !== context2) {
      const adopted = await this._page.delegate.adoptElementHandle(this, context2);
      this.dispose();
      return adopted;
    }
    return this;
  }
  async _checkFrameIsHitTarget(point) {
    let frame = this._frame;
    const data = [];
    while (frame.parentFrame()) {
      const frameElement = await frame.frameElement();
      const box = await frameElement.boundingBox();
      const style = await frameElement.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch((e) => "error:notconnected");
      if (!box || style === "error:notconnected")
        return "error:notconnected";
      if (style === "transformed") {
        return { framePoint: void 0 };
      }
      const pointInFrame = { x: point.x - box.x - style.left, y: point.y - box.y - style.top };
      data.push({ frame, frameElement, pointInFrame });
      frame = frame.parentFrame();
    }
    data.push({ frame, frameElement: null, pointInFrame: point });
    for (let i = data.length - 1; i > 0; i--) {
      const element = data[i - 1].frameElement;
      const point2 = data[i].pointInFrame;
      const hitTargetResult = await element.evaluateInUtility(([injected, element2, hitPoint]) => {
        return injected.expectHitTarget(hitPoint, element2);
      }, point2);
      if (hitTargetResult !== "done")
        return hitTargetResult;
    }
    return { framePoint: data[0].pointInFrame };
  }
};
function throwRetargetableDOMError(result) {
  if (result === "error:notconnected")
    throwElementIsNotAttached();
  return result;
}
__name(throwRetargetableDOMError, "throwRetargetableDOMError");
function throwElementIsNotAttached() {
  throw new Error("Element is not attached to the DOM");
}
__name(throwElementIsNotAttached, "throwElementIsNotAttached");
function assertDone(result) {
}
__name(assertDone, "assertDone");
function roundPoint(point) {
  return {
    x: (point.x * 100 | 0) / 100,
    y: (point.y * 100 | 0) / 100
  };
}
__name(roundPoint, "roundPoint");
function quadMiddlePoint(quad) {
  const result = { x: 0, y: 0 };
  for (const point of quad) {
    result.x += point.x / 4;
    result.y += point.y / 4;
  }
  return result;
}
__name(quadMiddlePoint, "quadMiddlePoint");
function triangleArea(p1, p2, p3) {
  return Math.abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2;
}
__name(triangleArea, "triangleArea");
function isPointInsideQuad(point, quad) {
  const area1 = triangleArea(point, quad[0], quad[1]) + triangleArea(point, quad[1], quad[2]) + triangleArea(point, quad[2], quad[3]) + triangleArea(point, quad[3], quad[0]);
  const area2 = triangleArea(quad[0], quad[1], quad[2]) + triangleArea(quad[1], quad[2], quad[3]);
  if (Math.abs(area1 - area2) > 0.1)
    return false;
  return point.x < Math.max(quad[0].x, quad[1].x, quad[2].x, quad[3].x) && point.y < Math.max(quad[0].y, quad[1].y, quad[2].y, quad[3].y);
}
__name(isPointInsideQuad, "isPointInsideQuad");
function findIntegerPointInsideQuad(quad) {
  const point = quadMiddlePoint(quad);
  point.x = Math.floor(point.x);
  point.y = Math.floor(point.y);
  if (isPointInsideQuad(point, quad))
    return point;
  point.x += 1;
  if (isPointInsideQuad(point, quad))
    return point;
  point.y += 1;
  if (isPointInsideQuad(point, quad))
    return point;
  point.x -= 1;
  if (isPointInsideQuad(point, quad))
    return point;
}
__name(findIntegerPointInsideQuad, "findIntegerPointInsideQuad");
var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/frameSelectors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/locatorGenerators.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/selectorParser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/cssParser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/cssTokenizer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var between = /* @__PURE__ */ __name(function(num, first, last) {
  return num >= first && num <= last;
}, "between");
function digit(code) {
  return between(code, 48, 57);
}
__name(digit, "digit");
function hexdigit(code) {
  return digit(code) || between(code, 65, 70) || between(code, 97, 102);
}
__name(hexdigit, "hexdigit");
function uppercaseletter(code) {
  return between(code, 65, 90);
}
__name(uppercaseletter, "uppercaseletter");
function lowercaseletter(code) {
  return between(code, 97, 122);
}
__name(lowercaseletter, "lowercaseletter");
function letter(code) {
  return uppercaseletter(code) || lowercaseletter(code);
}
__name(letter, "letter");
function nonascii(code) {
  return code >= 128;
}
__name(nonascii, "nonascii");
function namestartchar(code) {
  return letter(code) || nonascii(code) || code === 95;
}
__name(namestartchar, "namestartchar");
function namechar(code) {
  return namestartchar(code) || digit(code) || code === 45;
}
__name(namechar, "namechar");
function nonprintable(code) {
  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;
}
__name(nonprintable, "nonprintable");
function newline(code) {
  return code === 10;
}
__name(newline, "newline");
function whitespace(code) {
  return newline(code) || code === 9 || code === 32;
}
__name(whitespace, "whitespace");
var maximumallowedcodepoint = 1114111;
var InvalidCharacterError = class extends Error {
  static {
    __name(this, "InvalidCharacterError");
  }
  constructor(message) {
    super(message);
    this.name = "InvalidCharacterError";
  }
};
function preprocess(str) {
  const codepoints = [];
  for (let i = 0; i < str.length; i++) {
    let code = str.charCodeAt(i);
    if (code === 13 && str.charCodeAt(i + 1) === 10) {
      code = 10;
      i++;
    }
    if (code === 13 || code === 12)
      code = 10;
    if (code === 0)
      code = 65533;
    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
      const lead = code - 55296;
      const trail = str.charCodeAt(i + 1) - 56320;
      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
      i++;
    }
    codepoints.push(code);
  }
  return codepoints;
}
__name(preprocess, "preprocess");
function stringFromCode(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= Math.pow(2, 16);
  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;
  const trail = code % Math.pow(2, 10) + 56320;
  return String.fromCharCode(lead) + String.fromCharCode(trail);
}
__name(stringFromCode, "stringFromCode");
function tokenize2(str1) {
  const str = preprocess(str1);
  let i = -1;
  const tokens = [];
  let code;
  const codepoint = /* @__PURE__ */ __name(function(i2) {
    if (i2 >= str.length)
      return -1;
    return str[i2];
  }, "codepoint");
  const next = /* @__PURE__ */ __name(function(num) {
    if (num === void 0)
      num = 1;
    if (num > 3)
      throw "Spec Error: no more than three codepoints of lookahead.";
    return codepoint(i + num);
  }, "next");
  const consume = /* @__PURE__ */ __name(function(num) {
    if (num === void 0)
      num = 1;
    i += num;
    code = codepoint(i);
    return true;
  }, "consume");
  const reconsume = /* @__PURE__ */ __name(function() {
    i -= 1;
    return true;
  }, "reconsume");
  const eof = /* @__PURE__ */ __name(function(codepoint2) {
    if (codepoint2 === void 0)
      codepoint2 = code;
    return codepoint2 === -1;
  }, "eof");
  const consumeAToken = /* @__PURE__ */ __name(function() {
    consumeComments();
    consume();
    if (whitespace(code)) {
      while (whitespace(next()))
        consume();
      return new WhitespaceToken();
    } else if (code === 34) {
      return consumeAStringToken();
    } else if (code === 35) {
      if (namechar(next()) || areAValidEscape(next(1), next(2))) {
        const token = new HashToken("");
        if (wouldStartAnIdentifier(next(1), next(2), next(3)))
          token.type = "id";
        token.value = consumeAName();
        return token;
      } else {
        return new DelimToken(code);
      }
    } else if (code === 36) {
      if (next() === 61) {
        consume();
        return new SuffixMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 39) {
      return consumeAStringToken();
    } else if (code === 40) {
      return new OpenParenToken();
    } else if (code === 41) {
      return new CloseParenToken();
    } else if (code === 42) {
      if (next() === 61) {
        consume();
        return new SubstringMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 43) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 44) {
      return new CommaToken();
    } else if (code === 45) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else if (next(1) === 45 && next(2) === 62) {
        consume(2);
        return new CDCToken();
      } else if (startsWithAnIdentifier()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 46) {
      if (startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 58) {
      return new ColonToken();
    } else if (code === 59) {
      return new SemicolonToken();
    } else if (code === 60) {
      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {
        consume(3);
        return new CDOToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 64) {
      if (wouldStartAnIdentifier(next(1), next(2), next(3)))
        return new AtKeywordToken(consumeAName());
      else
        return new DelimToken(code);
    } else if (code === 91) {
      return new OpenSquareToken();
    } else if (code === 92) {
      if (startsWithAValidEscape()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 93) {
      return new CloseSquareToken();
    } else if (code === 94) {
      if (next() === 61) {
        consume();
        return new PrefixMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 123) {
      return new OpenCurlyToken();
    } else if (code === 124) {
      if (next() === 61) {
        consume();
        return new DashMatchToken();
      } else if (next() === 124) {
        consume();
        return new ColumnToken();
      } else {
        return new DelimToken(code);
      }
    } else if (code === 125) {
      return new CloseCurlyToken();
    } else if (code === 126) {
      if (next() === 61) {
        consume();
        return new IncludeMatchToken();
      } else {
        return new DelimToken(code);
      }
    } else if (digit(code)) {
      reconsume();
      return consumeANumericToken();
    } else if (namestartchar(code)) {
      reconsume();
      return consumeAnIdentlikeToken();
    } else if (eof()) {
      return new EOFToken();
    } else {
      return new DelimToken(code);
    }
  }, "consumeAToken");
  const consumeComments = /* @__PURE__ */ __name(function() {
    while (next(1) === 47 && next(2) === 42) {
      consume(2);
      while (true) {
        consume();
        if (code === 42 && next() === 47) {
          consume();
          break;
        } else if (eof()) {
          return;
        }
      }
    }
  }, "consumeComments");
  const consumeANumericToken = /* @__PURE__ */ __name(function() {
    const num = consumeANumber();
    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
      const token = new DimensionToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      token.unit = consumeAName();
      return token;
    } else if (next() === 37) {
      consume();
      const token = new PercentageToken();
      token.value = num.value;
      token.repr = num.repr;
      return token;
    } else {
      const token = new NumberToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      return token;
    }
  }, "consumeANumericToken");
  const consumeAnIdentlikeToken = /* @__PURE__ */ __name(function() {
    const str2 = consumeAName();
    if (str2.toLowerCase() === "url" && next() === 40) {
      consume();
      while (whitespace(next(1)) && whitespace(next(2)))
        consume();
      if (next() === 34 || next() === 39)
        return new FunctionToken(str2);
      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))
        return new FunctionToken(str2);
      else
        return consumeAURLToken();
    } else if (next() === 40) {
      consume();
      return new FunctionToken(str2);
    } else {
      return new IdentToken(str2);
    }
  }, "consumeAnIdentlikeToken");
  const consumeAStringToken = /* @__PURE__ */ __name(function(endingCodePoint) {
    if (endingCodePoint === void 0)
      endingCodePoint = code;
    let string2 = "";
    while (consume()) {
      if (code === endingCodePoint || eof()) {
        return new StringToken(string2);
      } else if (newline(code)) {
        reconsume();
        return new BadStringToken();
      } else if (code === 92) {
        if (eof(next()))
          ;
        else if (newline(next()))
          consume();
        else
          string2 += stringFromCode(consumeEscape());
      } else {
        string2 += stringFromCode(code);
      }
    }
    throw new Error("Internal error");
  }, "consumeAStringToken");
  const consumeAURLToken = /* @__PURE__ */ __name(function() {
    const token = new URLToken("");
    while (whitespace(next()))
      consume();
    if (eof(next()))
      return token;
    while (consume()) {
      if (code === 41 || eof()) {
        return token;
      } else if (whitespace(code)) {
        while (whitespace(next()))
          consume();
        if (next() === 41 || eof(next())) {
          consume();
          return token;
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {
        consumeTheRemnantsOfABadURL();
        return new BadURLToken();
      } else if (code === 92) {
        if (startsWithAValidEscape()) {
          token.value += stringFromCode(consumeEscape());
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else {
        token.value += stringFromCode(code);
      }
    }
    throw new Error("Internal error");
  }, "consumeAURLToken");
  const consumeEscape = /* @__PURE__ */ __name(function() {
    consume();
    if (hexdigit(code)) {
      const digits = [code];
      for (let total = 0; total < 5; total++) {
        if (hexdigit(next())) {
          consume();
          digits.push(code);
        } else {
          break;
        }
      }
      if (whitespace(next()))
        consume();
      let value = parseInt(digits.map(function(x) {
        return String.fromCharCode(x);
      }).join(""), 16);
      if (value > maximumallowedcodepoint)
        value = 65533;
      return value;
    } else if (eof()) {
      return 65533;
    } else {
      return code;
    }
  }, "consumeEscape");
  const areAValidEscape = /* @__PURE__ */ __name(function(c1, c2) {
    if (c1 !== 92)
      return false;
    if (newline(c2))
      return false;
    return true;
  }, "areAValidEscape");
  const startsWithAValidEscape = /* @__PURE__ */ __name(function() {
    return areAValidEscape(code, next());
  }, "startsWithAValidEscape");
  const wouldStartAnIdentifier = /* @__PURE__ */ __name(function(c1, c2, c3) {
    if (c1 === 45)
      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);
    else if (namestartchar(c1))
      return true;
    else if (c1 === 92)
      return areAValidEscape(c1, c2);
    else
      return false;
  }, "wouldStartAnIdentifier");
  const startsWithAnIdentifier = /* @__PURE__ */ __name(function() {
    return wouldStartAnIdentifier(code, next(1), next(2));
  }, "startsWithAnIdentifier");
  const wouldStartANumber = /* @__PURE__ */ __name(function(c1, c2, c3) {
    if (c1 === 43 || c1 === 45) {
      if (digit(c2))
        return true;
      if (c2 === 46 && digit(c3))
        return true;
      return false;
    } else if (c1 === 46) {
      if (digit(c2))
        return true;
      return false;
    } else if (digit(c1)) {
      return true;
    } else {
      return false;
    }
  }, "wouldStartANumber");
  const startsWithANumber = /* @__PURE__ */ __name(function() {
    return wouldStartANumber(code, next(1), next(2));
  }, "startsWithANumber");
  const consumeAName = /* @__PURE__ */ __name(function() {
    let result = "";
    while (consume()) {
      if (namechar(code)) {
        result += stringFromCode(code);
      } else if (startsWithAValidEscape()) {
        result += stringFromCode(consumeEscape());
      } else {
        reconsume();
        return result;
      }
    }
    throw new Error("Internal parse error");
  }, "consumeAName");
  const consumeANumber = /* @__PURE__ */ __name(function() {
    let repr = "";
    let type = "integer";
    if (next() === 43 || next() === 45) {
      consume();
      repr += stringFromCode(code);
    }
    while (digit(next())) {
      consume();
      repr += stringFromCode(code);
    }
    if (next(1) === 46 && digit(next(2))) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    const c1 = next(1), c2 = next(2), c3 = next(3);
    if ((c1 === 69 || c1 === 101) && digit(c2)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while (digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    const value = convertAStringToANumber(repr);
    return { type, value, repr };
  }, "consumeANumber");
  const convertAStringToANumber = /* @__PURE__ */ __name(function(string2) {
    return +string2;
  }, "convertAStringToANumber");
  const consumeTheRemnantsOfABadURL = /* @__PURE__ */ __name(function() {
    while (consume()) {
      if (code === 41 || eof()) {
        return;
      } else if (startsWithAValidEscape()) {
        consumeEscape();
      } else ;
    }
  }, "consumeTheRemnantsOfABadURL");
  let iterationCount = 0;
  while (!eof(next())) {
    tokens.push(consumeAToken());
    iterationCount++;
    if (iterationCount > str.length * 2)
      throw new Error("I'm infinite-looping!");
  }
  return tokens;
}
__name(tokenize2, "tokenize");
var CSSParserToken = class {
  static {
    __name(this, "CSSParserToken");
  }
  constructor() {
    this.tokenType = "";
  }
  toJSON() {
    return { token: this.tokenType };
  }
  toString() {
    return this.tokenType;
  }
  toSource() {
    return "" + this;
  }
};
var BadStringToken = class extends CSSParserToken {
  static {
    __name(this, "BadStringToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "BADSTRING";
  }
};
var BadURLToken = class extends CSSParserToken {
  static {
    __name(this, "BadURLToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "BADURL";
  }
};
var WhitespaceToken = class extends CSSParserToken {
  static {
    __name(this, "WhitespaceToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "WHITESPACE";
  }
  toString() {
    return "WS";
  }
  toSource() {
    return " ";
  }
};
var CDOToken = class extends CSSParserToken {
  static {
    __name(this, "CDOToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "CDO";
  }
  toSource() {
    return "<!--";
  }
};
var CDCToken = class extends CSSParserToken {
  static {
    __name(this, "CDCToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "CDC";
  }
  toSource() {
    return "-->";
  }
};
var ColonToken = class extends CSSParserToken {
  static {
    __name(this, "ColonToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ":";
  }
};
var SemicolonToken = class extends CSSParserToken {
  static {
    __name(this, "SemicolonToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ";";
  }
};
var CommaToken = class extends CSSParserToken {
  static {
    __name(this, "CommaToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = ",";
  }
};
var GroupingToken = class extends CSSParserToken {
  static {
    __name(this, "GroupingToken");
  }
  constructor() {
    super(...arguments);
    this.value = "";
    this.mirror = "";
  }
};
var OpenCurlyToken = class extends GroupingToken {
  static {
    __name(this, "OpenCurlyToken");
  }
  constructor() {
    super();
    this.tokenType = "{";
    this.value = "{";
    this.mirror = "}";
  }
};
var CloseCurlyToken = class extends GroupingToken {
  static {
    __name(this, "CloseCurlyToken");
  }
  constructor() {
    super();
    this.tokenType = "}";
    this.value = "}";
    this.mirror = "{";
  }
};
var OpenSquareToken = class extends GroupingToken {
  static {
    __name(this, "OpenSquareToken");
  }
  constructor() {
    super();
    this.tokenType = "[";
    this.value = "[";
    this.mirror = "]";
  }
};
var CloseSquareToken = class extends GroupingToken {
  static {
    __name(this, "CloseSquareToken");
  }
  constructor() {
    super();
    this.tokenType = "]";
    this.value = "]";
    this.mirror = "[";
  }
};
var OpenParenToken = class extends GroupingToken {
  static {
    __name(this, "OpenParenToken");
  }
  constructor() {
    super();
    this.tokenType = "(";
    this.value = "(";
    this.mirror = ")";
  }
};
var CloseParenToken = class extends GroupingToken {
  static {
    __name(this, "CloseParenToken");
  }
  constructor() {
    super();
    this.tokenType = ")";
    this.value = ")";
    this.mirror = "(";
  }
};
var IncludeMatchToken = class extends CSSParserToken {
  static {
    __name(this, "IncludeMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "~=";
  }
};
var DashMatchToken = class extends CSSParserToken {
  static {
    __name(this, "DashMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "|=";
  }
};
var PrefixMatchToken = class extends CSSParserToken {
  static {
    __name(this, "PrefixMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "^=";
  }
};
var SuffixMatchToken = class extends CSSParserToken {
  static {
    __name(this, "SuffixMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "$=";
  }
};
var SubstringMatchToken = class extends CSSParserToken {
  static {
    __name(this, "SubstringMatchToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "*=";
  }
};
var ColumnToken = class extends CSSParserToken {
  static {
    __name(this, "ColumnToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "||";
  }
};
var EOFToken = class extends CSSParserToken {
  static {
    __name(this, "EOFToken");
  }
  constructor() {
    super(...arguments);
    this.tokenType = "EOF";
  }
  toSource() {
    return "";
  }
};
var DelimToken = class extends CSSParserToken {
  static {
    __name(this, "DelimToken");
  }
  constructor(code) {
    super();
    this.tokenType = "DELIM";
    this.value = "";
    this.value = stringFromCode(code);
  }
  toString() {
    return "DELIM(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
  toSource() {
    if (this.value === "\\")
      return "\\\n";
    else
      return this.value;
  }
};
var StringValuedToken = class extends CSSParserToken {
  static {
    __name(this, "StringValuedToken");
  }
  constructor() {
    super(...arguments);
    this.value = "";
  }
  ASCIIMatch(str) {
    return this.value.toLowerCase() === str.toLowerCase();
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    return json;
  }
};
var IdentToken = class extends StringValuedToken {
  static {
    __name(this, "IdentToken");
  }
  constructor(val) {
    super();
    this.tokenType = "IDENT";
    this.value = val;
  }
  toString() {
    return "IDENT(" + this.value + ")";
  }
  toSource() {
    return escapeIdent(this.value);
  }
};
var FunctionToken = class extends StringValuedToken {
  static {
    __name(this, "FunctionToken");
  }
  constructor(val) {
    super();
    this.tokenType = "FUNCTION";
    this.value = val;
    this.mirror = ")";
  }
  toString() {
    return "FUNCTION(" + this.value + ")";
  }
  toSource() {
    return escapeIdent(this.value) + "(";
  }
};
var AtKeywordToken = class extends StringValuedToken {
  static {
    __name(this, "AtKeywordToken");
  }
  constructor(val) {
    super();
    this.tokenType = "AT-KEYWORD";
    this.value = val;
  }
  toString() {
    return "AT(" + this.value + ")";
  }
  toSource() {
    return "@" + escapeIdent(this.value);
  }
};
var HashToken = class extends StringValuedToken {
  static {
    __name(this, "HashToken");
  }
  constructor(val) {
    super();
    this.tokenType = "HASH";
    this.value = val;
    this.type = "unrestricted";
  }
  toString() {
    return "HASH(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    return json;
  }
  toSource() {
    if (this.type === "id")
      return "#" + escapeIdent(this.value);
    else
      return "#" + escapeHash(this.value);
  }
};
var StringToken = class extends StringValuedToken {
  static {
    __name(this, "StringToken");
  }
  constructor(val) {
    super();
    this.tokenType = "STRING";
    this.value = val;
  }
  toString() {
    return '"' + escapeString(this.value) + '"';
  }
};
var URLToken = class extends StringValuedToken {
  static {
    __name(this, "URLToken");
  }
  constructor(val) {
    super();
    this.tokenType = "URL";
    this.value = val;
  }
  toString() {
    return "URL(" + this.value + ")";
  }
  toSource() {
    return 'url("' + escapeString(this.value) + '")';
  }
};
var NumberToken = class extends CSSParserToken {
  static {
    __name(this, "NumberToken");
  }
  constructor() {
    super();
    this.tokenType = "NUMBER";
    this.type = "integer";
    this.repr = "";
  }
  toString() {
    if (this.type === "integer")
      return "INT(" + this.value + ")";
    return "NUMBER(" + this.value + ")";
  }
  toJSON() {
    const json = super.toJSON();
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    return json;
  }
  toSource() {
    return this.repr;
  }
};
var PercentageToken = class extends CSSParserToken {
  static {
    __name(this, "PercentageToken");
  }
  constructor() {
    super();
    this.tokenType = "PERCENTAGE";
    this.repr = "";
  }
  toString() {
    return "PERCENTAGE(" + this.value + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.repr = this.repr;
    return json;
  }
  toSource() {
    return this.repr + "%";
  }
};
var DimensionToken = class extends CSSParserToken {
  static {
    __name(this, "DimensionToken");
  }
  constructor() {
    super();
    this.tokenType = "DIMENSION";
    this.type = "integer";
    this.repr = "";
    this.unit = "";
  }
  toString() {
    return "DIM(" + this.value + "," + this.unit + ")";
  }
  toJSON() {
    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
    json.value = this.value;
    json.type = this.type;
    json.repr = this.repr;
    json.unit = this.unit;
    return json;
  }
  toSource() {
    const source8 = this.repr;
    let unit = escapeIdent(this.unit);
    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {
      unit = "\\65 " + unit.slice(1, unit.length);
    }
    return source8 + unit;
  }
};
function escapeIdent(string2) {
  string2 = "" + string2;
  let result = "";
  const firstcode = string2.charCodeAt(0);
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)
      result += "\\" + code.toString(16) + " ";
    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string2[i];
    else
      result += "\\" + string2[i];
  }
  return result;
}
__name(escapeIdent, "escapeIdent");
function escapeHash(string2) {
  string2 = "" + string2;
  let result = "";
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
      result += string2[i];
    else
      result += "\\" + code.toString(16) + " ";
  }
  return result;
}
__name(escapeHash, "escapeHash");
function escapeString(string2) {
  string2 = "" + string2;
  let result = "";
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code === 0)
      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
    if (between(code, 1, 31) || code === 127)
      result += "\\" + code.toString(16) + " ";
    else if (code === 34 || code === 92)
      result += "\\" + string2[i];
    else
      result += string2[i];
  }
  return result;
}
__name(escapeString, "escapeString");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/cssParser.js
var InvalidSelectorError = class extends Error {
  static {
    __name(this, "InvalidSelectorError");
  }
};
function isInvalidSelectorError(error3) {
  return error3 instanceof InvalidSelectorError;
}
__name(isInvalidSelectorError, "isInvalidSelectorError");
function parseCSS(selector, customNames) {
  let tokens;
  try {
    tokens = tokenize2(selector);
    if (!(tokens[tokens.length - 1] instanceof EOFToken))
      tokens.push(new EOFToken());
  } catch (e) {
    const newMessage = e.message + ` while parsing css selector "${selector}". Did you mean to CSS.escape it?`;
    const index2 = (e.stack || "").indexOf(e.message);
    if (index2 !== -1)
      e.stack = e.stack.substring(0, index2) + newMessage + e.stack.substring(index2 + e.message.length);
    e.message = newMessage;
    throw e;
  }
  const unsupportedToken = tokens.find((token) => {
    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.
    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
    // Or this way :xpath( {complex-xpath-goes-here("hello")} )
    token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || // TODO: Consider treating these as strings?
    token instanceof URLToken || token instanceof PercentageToken;
  });
  if (unsupportedToken)
    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  let pos = 0;
  const names = /* @__PURE__ */ new Set();
  function unexpected() {
    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  }
  __name(unexpected, "unexpected");
  function skipWhitespace() {
    while (tokens[pos] instanceof WhitespaceToken)
      pos++;
  }
  __name(skipWhitespace, "skipWhitespace");
  function isIdent(p = pos) {
    return tokens[p] instanceof IdentToken;
  }
  __name(isIdent, "isIdent");
  function isString2(p = pos) {
    return tokens[p] instanceof StringToken;
  }
  __name(isString2, "isString");
  function isNumber(p = pos) {
    return tokens[p] instanceof NumberToken;
  }
  __name(isNumber, "isNumber");
  function isComma(p = pos) {
    return tokens[p] instanceof CommaToken;
  }
  __name(isComma, "isComma");
  function isOpenParen(p = pos) {
    return tokens[p] instanceof OpenParenToken;
  }
  __name(isOpenParen, "isOpenParen");
  function isCloseParen(p = pos) {
    return tokens[p] instanceof CloseParenToken;
  }
  __name(isCloseParen, "isCloseParen");
  function isFunction(p = pos) {
    return tokens[p] instanceof FunctionToken;
  }
  __name(isFunction, "isFunction");
  function isStar(p = pos) {
    return tokens[p] instanceof DelimToken && tokens[p].value === "*";
  }
  __name(isStar, "isStar");
  function isEOF(p = pos) {
    return tokens[p] instanceof EOFToken;
  }
  __name(isEOF, "isEOF");
  function isClauseCombinator(p = pos) {
    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);
  }
  __name(isClauseCombinator, "isClauseCombinator");
  function isSelectorClauseEnd(p = pos) {
    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;
  }
  __name(isSelectorClauseEnd, "isSelectorClauseEnd");
  function consumeFunctionArguments() {
    const result2 = [consumeArgument()];
    while (true) {
      skipWhitespace();
      if (!isComma())
        break;
      pos++;
      result2.push(consumeArgument());
    }
    return result2;
  }
  __name(consumeFunctionArguments, "consumeFunctionArguments");
  function consumeArgument() {
    skipWhitespace();
    if (isNumber())
      return tokens[pos++].value;
    if (isString2())
      return tokens[pos++].value;
    return consumeComplexSelector();
  }
  __name(consumeArgument, "consumeArgument");
  function consumeComplexSelector() {
    const result2 = { simples: [] };
    skipWhitespace();
    if (isClauseCombinator()) {
      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });
    } else {
      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });
    }
    while (true) {
      skipWhitespace();
      if (isClauseCombinator()) {
        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
        skipWhitespace();
      } else if (isSelectorClauseEnd()) {
        break;
      }
      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });
    }
    return result2;
  }
  __name(consumeComplexSelector, "consumeComplexSelector");
  function consumeSimpleSelector() {
    let rawCSSString = "";
    const functions = [];
    while (!isSelectorClauseEnd()) {
      if (isIdent() || isStar()) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof HashToken) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {
        pos++;
        if (isIdent())
          rawCSSString += "." + tokens[pos++].toSource();
        else
          throw unexpected();
      } else if (tokens[pos] instanceof ColonToken) {
        pos++;
        if (isIdent()) {
          if (!customNames.has(tokens[pos].value.toLowerCase())) {
            rawCSSString += ":" + tokens[pos++].toSource();
          } else {
            const name = tokens[pos++].value.toLowerCase();
            functions.push({ name, args: [] });
            names.add(name);
          }
        } else if (isFunction()) {
          const name = tokens[pos++].value.toLowerCase();
          if (!customNames.has(name)) {
            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
          } else {
            functions.push({ name, args: consumeFunctionArguments() });
            names.add(name);
          }
          skipWhitespace();
          if (!isCloseParen())
            throw unexpected();
          pos++;
        } else {
          throw unexpected();
        }
      } else if (tokens[pos] instanceof OpenSquareToken) {
        rawCSSString += "[";
        pos++;
        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())
          rawCSSString += tokens[pos++].toSource();
        if (!(tokens[pos] instanceof CloseSquareToken))
          throw unexpected();
        rawCSSString += "]";
        pos++;
      } else {
        throw unexpected();
      }
    }
    if (!rawCSSString && !functions.length)
      throw unexpected();
    return { css: rawCSSString || void 0, functions };
  }
  __name(consumeSimpleSelector, "consumeSimpleSelector");
  function consumeBuiltinFunctionArguments() {
    let s = "";
    let balance = 1;
    while (!isEOF()) {
      if (isOpenParen() || isFunction())
        balance++;
      if (isCloseParen())
        balance--;
      if (!balance)
        break;
      s += tokens[pos++].toSource();
    }
    return s;
  }
  __name(consumeBuiltinFunctionArguments, "consumeBuiltinFunctionArguments");
  const result = consumeFunctionArguments();
  if (!isEOF())
    throw unexpected();
  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
    throw new InvalidSelectorError(`Error while parsing css selector "${selector}". Did you mean to CSS.escape it?`);
  return { selector: result, names: Array.from(names) };
}
__name(parseCSS, "parseCSS");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/selectorParser.js
var kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "internal:chain", "left-of", "right-of", "above", "below", "near"]);
var kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);
var customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
function parseSelector(selector) {
  const parsedStrings = parseSelectorString(selector);
  const parts = [];
  for (const part of parsedStrings.parts) {
    if (part.name === "css" || part.name === "css:light") {
      if (part.name === "css:light")
        part.body = ":light(" + part.body + ")";
      const parsedCSS = parseCSS(part.body, customCSSNames);
      parts.push({
        name: "css",
        body: parsedCSS.selector,
        source: part.body
      });
      continue;
    }
    if (kNestedSelectorNames.has(part.name)) {
      let innerSelector;
      let distance;
      try {
        const unescaped = JSON.parse("[" + part.body + "]");
        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")
          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
        innerSelector = unescaped[0];
        if (unescaped.length === 2) {
          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))
            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
          distance = unescaped[1];
        }
      } catch (e) {
        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
      }
      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };
      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");
      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;
      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))
        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);
      parts.push(nested);
      continue;
    }
    parts.push({ ...part, source: part.body });
  }
  if (kNestedSelectorNames.has(parts[0].name))
    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);
  return {
    capture: parsedStrings.capture,
    parts
  };
}
__name(parseSelector, "parseSelector");
function splitSelectorByFrame(selectorText) {
  const selector = parseSelector(selectorText);
  const result = [];
  let chunk = {
    parts: []
  };
  let chunkStartIndex = 0;
  for (let i = 0; i < selector.parts.length; ++i) {
    const part = selector.parts[i];
    if (part.name === "internal:control" && part.body === "enter-frame") {
      if (!chunk.parts.length)
        throw new InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");
      result.push(chunk);
      chunk = { parts: [] };
      chunkStartIndex = i + 1;
      continue;
    }
    if (selector.capture === i)
      chunk.capture = i - chunkStartIndex;
    chunk.parts.push(part);
  }
  if (!chunk.parts.length)
    throw new InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
  result.push(chunk);
  if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
    throw new InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
  return result;
}
__name(splitSelectorByFrame, "splitSelectorByFrame");
function selectorPartsEqual(list1, list2) {
  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });
}
__name(selectorPartsEqual, "selectorPartsEqual");
function stringifySelector(selector, forceEngineName) {
  if (typeof selector === "string")
    return selector;
  return selector.parts.map((p, i) => {
    let includeEngine = true;
    if (!forceEngineName && i !== selector.capture) {
      if (p.name === "css")
        includeEngine = false;
      else if (p.name === "xpath" && p.source.startsWith("//") || p.source.startsWith(".."))
        includeEngine = false;
    }
    const prefix = includeEngine ? p.name + "=" : "";
    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
  }).join(" >> ");
}
__name(stringifySelector, "stringifySelector");
function visitAllSelectorParts(selector, visitor) {
  const visit2 = /* @__PURE__ */ __name((selector2, nested) => {
    for (const part of selector2.parts) {
      visitor(part, nested);
      if (kNestedSelectorNames.has(part.name))
        visit2(part.body.parsed, true);
    }
  }, "visit");
  visit2(selector, false);
}
__name(visitAllSelectorParts, "visitAllSelectorParts");
function parseSelectorString(selector) {
  let index2 = 0;
  let quote5;
  let start = 0;
  const result = { parts: [] };
  const append = /* @__PURE__ */ __name(() => {
    const part = selector.substring(start, index2).trim();
    const eqIndex = part.indexOf("=");
    let name;
    let body;
    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
      name = part.substring(0, eqIndex).trim();
      body = part.substring(eqIndex + 1);
    } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
      name = "text";
      body = part;
    } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
      name = "text";
      body = part;
    } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
      name = "xpath";
      body = part;
    } else {
      name = "css";
      body = part;
    }
    let capture = false;
    if (name[0] === "*") {
      capture = true;
      name = name.substring(1);
    }
    result.parts.push({ name, body });
    if (capture) {
      if (result.capture !== void 0)
        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
      result.capture = result.parts.length - 1;
    }
  }, "append");
  if (!selector.includes(">>")) {
    index2 = selector.length;
    append();
    return result;
  }
  const shouldIgnoreTextSelectorQuote = /* @__PURE__ */ __name(() => {
    const prefix = selector.substring(start, index2);
    const match = prefix.match(/^\s*text\s*=(.*)$/);
    return !!match && !!match[1];
  }, "shouldIgnoreTextSelectorQuote");
  while (index2 < selector.length) {
    const c = selector[index2];
    if (c === "\\" && index2 + 1 < selector.length) {
      index2 += 2;
    } else if (c === quote5) {
      quote5 = void 0;
      index2++;
    } else if (!quote5 && (c === '"' || c === "'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {
      quote5 = c;
      index2++;
    } else if (!quote5 && c === ">" && selector[index2 + 1] === ">") {
      append();
      index2 += 2;
      start = index2;
    } else {
      index2++;
    }
  }
  append();
  return result;
}
__name(parseSelectorString, "parseSelectorString");
function parseAttributeSelector(selector, allowUnquotedStrings) {
  let wp = 0;
  let EOL = selector.length === 0;
  const next = /* @__PURE__ */ __name(() => selector[wp] || "", "next");
  const eat1 = /* @__PURE__ */ __name(() => {
    const result2 = next();
    ++wp;
    EOL = wp >= selector.length;
    return result2;
  }, "eat1");
  const syntaxError = /* @__PURE__ */ __name((stage) => {
    if (EOL)
      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \`${selector}\``);
    throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));
  }, "syntaxError");
  function skipSpaces() {
    while (!EOL && /\s/.test(next()))
      eat1();
  }
  __name(skipSpaces, "skipSpaces");
  function isCSSNameChar(char) {
    return char >= "\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";
  }
  __name(isCSSNameChar, "isCSSNameChar");
  function readIdentifier() {
    let result2 = "";
    skipSpaces();
    while (!EOL && isCSSNameChar(next()))
      result2 += eat1();
    return result2;
  }
  __name(readIdentifier, "readIdentifier");
  function readQuotedString(quote5) {
    let result2 = eat1();
    if (result2 !== quote5)
      syntaxError("parsing quoted string");
    while (!EOL && next() !== quote5) {
      if (next() === "\\")
        eat1();
      result2 += eat1();
    }
    if (next() !== quote5)
      syntaxError("parsing quoted string");
    result2 += eat1();
    return result2;
  }
  __name(readQuotedString, "readQuotedString");
  function readRegularExpression() {
    if (eat1() !== "/")
      syntaxError("parsing regular expression");
    let source8 = "";
    let inClass = false;
    while (!EOL) {
      if (next() === "\\") {
        source8 += eat1();
        if (EOL)
          syntaxError("parsing regular expression");
      } else if (inClass && next() === "]") {
        inClass = false;
      } else if (!inClass && next() === "[") {
        inClass = true;
      } else if (!inClass && next() === "/") {
        break;
      }
      source8 += eat1();
    }
    if (eat1() !== "/")
      syntaxError("parsing regular expression");
    let flags = "";
    while (!EOL && next().match(/[dgimsuy]/))
      flags += eat1();
    try {
      return new RegExp(source8, flags);
    } catch (e) {
      throw new InvalidSelectorError(`Error while parsing selector \`${selector}\`: ${e.message}`);
    }
  }
  __name(readRegularExpression, "readRegularExpression");
  function readAttributeToken() {
    let token = "";
    skipSpaces();
    if (next() === `'` || next() === `"`)
      token = readQuotedString(next()).slice(1, -1);
    else
      token = readIdentifier();
    if (!token)
      syntaxError("parsing property path");
    return token;
  }
  __name(readAttributeToken, "readAttributeToken");
  function readOperator() {
    skipSpaces();
    let op = "";
    if (!EOL)
      op += eat1();
    if (!EOL && op !== "=")
      op += eat1();
    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))
      syntaxError("parsing operator");
    return op;
  }
  __name(readOperator, "readOperator");
  function readAttribute() {
    eat1();
    const jsonPath = [];
    jsonPath.push(readAttributeToken());
    skipSpaces();
    while (next() === ".") {
      eat1();
      jsonPath.push(readAttributeToken());
      skipSpaces();
    }
    if (next() === "]") {
      eat1();
      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };
    }
    const operator = readOperator();
    let value = void 0;
    let caseSensitive = true;
    skipSpaces();
    if (next() === "/") {
      if (operator !== "=")
        throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
      value = readRegularExpression();
    } else if (next() === `'` || next() === `"`) {
      value = readQuotedString(next()).slice(1, -1);
      skipSpaces();
      if (next() === "i" || next() === "I") {
        caseSensitive = false;
        eat1();
      } else if (next() === "s" || next() === "S") {
        caseSensitive = true;
        eat1();
      }
    } else {
      value = "";
      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))
        value += eat1();
      if (value === "true") {
        value = true;
      } else if (value === "false") {
        value = false;
      } else ;
    }
    skipSpaces();
    if (next() !== "]")
      syntaxError("parsing attribute value");
    eat1();
    if (operator !== "=" && typeof value !== "string")
      throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };
  }
  __name(readAttribute, "readAttribute");
  const result = {
    name: "",
    attributes: []
  };
  result.name = readIdentifier();
  skipSpaces();
  while (next() === "[") {
    result.attributes.push(readAttribute());
    skipSpaces();
  }
  if (!EOL)
    syntaxError(void 0);
  if (!result.name && !result.attributes.length)
    throw new InvalidSelectorError(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
  return result;
}
__name(parseAttributeSelector, "parseAttributeSelector");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/locatorGenerators.js
function asLocator(lang, selector, isFrameLocator = false) {
  return asLocators(lang, selector, isFrameLocator, 1)[0];
}
__name(asLocator, "asLocator");
function asLocators(lang, selector, isFrameLocator = false, maxOutputSize = 20, preferredQuote) {
  try {
    return innerAsLocators(new generators[lang](preferredQuote), parseSelector(selector), isFrameLocator, maxOutputSize);
  } catch (e) {
    return [selector];
  }
}
__name(asLocators, "asLocators");
function innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {
  const parts = [...parsed.parts];
  const tokens = [];
  let nextBase = isFrameLocator ? "frame-locator" : "page";
  for (let index2 = 0; index2 < parts.length; index2++) {
    const part = parts[index2];
    const base = nextBase;
    nextBase = "locator";
    if (part.name === "internal:describe")
      continue;
    if (part.name === "nth") {
      if (part.body === "0")
        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);
      else if (part.body === "-1")
        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);
      else
        tokens.push([factory.generateLocator(base, "nth", part.body)]);
      continue;
    }
    if (part.name === "visible") {
      tokens.push([factory.generateLocator(base, "visible", part.body), factory.generateLocator(base, "default", `visible=${part.body}`)]);
      continue;
    }
    if (part.name === "internal:text") {
      const { exact, text } = detectExact(part.body);
      tokens.push([factory.generateLocator(base, "text", text, { exact })]);
      continue;
    }
    if (part.name === "internal:has-text") {
      const { exact, text } = detectExact(part.body);
      if (!exact) {
        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:has-not-text") {
      const { exact, text } = detectExact(part.body);
      if (!exact) {
        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:has") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));
      continue;
    }
    if (part.name === "internal:has-not") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));
      continue;
    }
    if (part.name === "internal:and") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));
      continue;
    }
    if (part.name === "internal:or") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));
      continue;
    }
    if (part.name === "internal:chain") {
      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
      tokens.push(inners.map((inner) => factory.generateLocator(base, "chain", inner)));
      continue;
    }
    if (part.name === "internal:label") {
      const { exact, text } = detectExact(part.body);
      tokens.push([factory.generateLocator(base, "label", text, { exact })]);
      continue;
    }
    if (part.name === "internal:role") {
      const attrSelector = parseAttributeSelector(part.body);
      const options2 = { attrs: [] };
      for (const attr of attrSelector.attributes) {
        if (attr.name === "name") {
          options2.exact = attr.caseSensitive;
          options2.name = attr.value;
        } else {
          if (attr.name === "level" && typeof attr.value === "string")
            attr.value = +attr.value;
          options2.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });
        }
      }
      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options2)]);
      continue;
    }
    if (part.name === "internal:testid") {
      const attrSelector = parseAttributeSelector(part.body);
      const { value } = attrSelector.attributes[0];
      tokens.push([factory.generateLocator(base, "test-id", value)]);
      continue;
    }
    if (part.name === "internal:attr") {
      const attrSelector = parseAttributeSelector(part.body);
      const { name, value, caseSensitive } = attrSelector.attributes[0];
      const text = value;
      const exact = !!caseSensitive;
      if (name === "placeholder") {
        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);
        continue;
      }
      if (name === "alt") {
        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);
        continue;
      }
      if (name === "title") {
        tokens.push([factory.generateLocator(base, "title", text, { exact })]);
        continue;
      }
    }
    if (part.name === "internal:control" && part.body === "enter-frame") {
      const lastTokens = tokens[tokens.length - 1];
      const lastPart = parts[index2 - 1];
      const transformed = lastTokens.map((token) => factory.chainLocators([token, factory.generateLocator(base, "frame", "")]));
      if (["xpath", "css"].includes(lastPart.name)) {
        transformed.push(
          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] })),
          factory.generateLocator(base, "frame-locator", stringifySelector({ parts: [lastPart] }, true))
        );
      }
      lastTokens.splice(0, lastTokens.length, ...transformed);
      nextBase = "frame-locator";
      continue;
    }
    const nextPart = parts[index2 + 1];
    const selectorPart = stringifySelector({ parts: [part] });
    const locatorPart = factory.generateLocator(base, "default", selectorPart);
    if (nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {
      const { exact, text } = detectExact(nextPart.body);
      if (!exact) {
        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });
        const options2 = {};
        if (nextPart.name === "internal:has-text")
          options2.hasText = text;
        else
          options2.hasNotText = text;
        const combinedPart = factory.generateLocator(base, "default", selectorPart, options2);
        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);
        index2++;
        continue;
      }
    }
    let locatorPartWithEngine;
    if (["xpath", "css"].includes(part.name)) {
      const selectorPart2 = stringifySelector(
        { parts: [part] },
        /* forceEngineName */
        true
      );
      locatorPartWithEngine = factory.generateLocator(base, "default", selectorPart2);
    }
    tokens.push([locatorPart, locatorPartWithEngine].filter(Boolean));
  }
  return combineTokens(factory, tokens, maxOutputSize);
}
__name(innerAsLocators, "innerAsLocators");
function combineTokens(factory, tokens, maxOutputSize) {
  const currentTokens = tokens.map(() => "");
  const result = [];
  const visit2 = /* @__PURE__ */ __name((index2) => {
    if (index2 === tokens.length) {
      result.push(factory.chainLocators(currentTokens));
      return result.length < maxOutputSize;
    }
    for (const taken of tokens[index2]) {
      currentTokens[index2] = taken;
      if (!visit2(index2 + 1))
        return false;
    }
    return true;
  }, "visit");
  visit2(0);
  return result;
}
__name(combineTokens, "combineTokens");
function detectExact(text) {
  let exact = false;
  const match = text.match(/^\/(.*)\/([igm]*)$/);
  if (match)
    return { text: new RegExp(match[1], match[2]) };
  if (text.endsWith('"')) {
    text = JSON.parse(text);
    exact = true;
  } else if (text.endsWith('"s')) {
    text = JSON.parse(text.substring(0, text.length - 1));
    exact = true;
  } else if (text.endsWith('"i')) {
    text = JSON.parse(text.substring(0, text.length - 1));
    exact = false;
  }
  return { exact, text };
}
__name(detectExact, "detectExact");
var JavaScriptLocatorFactory = class {
  static {
    __name(this, "JavaScriptLocatorFactory");
  }
  constructor(preferredQuote) {
    this.preferredQuote = preferredQuote;
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options2.hasText)} })`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options2.hasNotText)} })`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frameLocator(${this.quote(body)})`;
      case "frame":
        return `contentFrame()`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first()`;
      case "last":
        return `last()`;
      case "visible":
        return `filter({ visible: ${body === "true" ? "true" : "false"} })`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`name: ${this.regexToSourceString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`name: ${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`exact: true`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);
        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";
        return `getByRole(${this.quote(body)}${attrString})`;
      case "has-text":
        return `filter({ hasText: ${this.toHasText(body)} })`;
      case "has-not-text":
        return `filter({ hasNotText: ${this.toHasText(body)} })`;
      case "has":
        return `filter({ has: ${body} })`;
      case "hasNot":
        return `filter({ hasNot: ${body} })`;
      case "and":
        return `and(${body})`;
      case "or":
        return `or(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `getByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("getByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("getByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("getByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("getByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("getByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToSourceString(re2) {
    return normalizeEscapedRegexQuotes(String(re2));
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToSourceString(body)})`;
    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToSourceString(body);
    return this.quote(body);
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToSourceString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, this.preferredQuote ?? "'");
  }
};
var PythonLocatorFactory = class {
  static {
    __name(this, "PythonLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, has_text=${this.toHasText(options2.hasText)})`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options2.hasNotText)})`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frame_locator(${this.quote(body)})`;
      case "frame":
        return `content_frame`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first`;
      case "last":
        return `last`;
      case "visible":
        return `filter(visible=${body === "true" ? "True" : "False"})`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`name=${this.regexToString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`name=${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`exact=True`);
        }
        for (const { name, value } of options2.attrs) {
          let valueString = typeof value === "string" ? this.quote(value) : value;
          if (typeof value === "boolean")
            valueString = value ? "True" : "False";
          attrs.push(`${toSnakeCase(name)}=${valueString}`);
        }
        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";
        return `get_by_role(${this.quote(body)}${attrString})`;
      case "has-text":
        return `filter(has_text=${this.toHasText(body)})`;
      case "has-not-text":
        return `filter(has_not_text=${this.toHasText(body)})`;
      case "has":
        return `filter(has=${body})`;
      case "hasNot":
        return `filter(has_not=${body})`;
      case "and":
        return `and_(${body})`;
      case "or":
        return `or_(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `get_by_test_id(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("get_by_text", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("get_by_alt_text", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("get_by_placeholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("get_by_label", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("get_by_title", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";
    return `re.compile(r"${normalizeEscapedRegexQuotes(body.source).replace(/\\\//, "/").replace(/"/g, '\\"')}"${suffix})`;
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, exact=True)`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToString(body);
    return `${this.quote(body)}`;
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var JavaLocatorFactory = class {
  static {
    __name(this, "JavaLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    let clazz;
    switch (base) {
      case "page":
        clazz = "Page";
        break;
      case "frame-locator":
        clazz = "FrameLocator";
        break;
      case "locator":
        clazz = "Locator";
        break;
    }
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options2.hasText)}))`;
        if (options2.hasNotText !== void 0)
          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options2.hasNotText)}))`;
        return `locator(${this.quote(body)})`;
      case "frame-locator":
        return `frameLocator(${this.quote(body)})`;
      case "frame":
        return `contentFrame()`;
      case "nth":
        return `nth(${body})`;
      case "first":
        return `first()`;
      case "last":
        return `last()`;
      case "visible":
        return `filter(new ${clazz}.FilterOptions().setVisible(${body === "true" ? "true" : "false"}))`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`.setName(${this.regexToString(options2.name)})`);
        } else if (typeof options2.name === "string") {
          attrs.push(`.setName(${this.quote(options2.name)})`);
          if (options2.exact)
            attrs.push(`.setExact(true)`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);
        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";
        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;
      case "has-text":
        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;
      case "has-not-text":
        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;
      case "has":
        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;
      case "hasNot":
        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;
      case "and":
        return `and(${body})`;
      case "or":
        return `or(${body})`;
      case "chain":
        return `locator(${body})`;
      case "test-id":
        return `getByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact(clazz, "getByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact(clazz, "getByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact(clazz, "getByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact(clazz, "getByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";
    return `Pattern.compile(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;
  }
  toCallWithExact(clazz, method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return this.regexToString(body);
    return this.quote(body);
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var CSharpLocatorFactory = class {
  static {
    __name(this, "CSharpLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    switch (kind) {
      case "default":
        if (options2.hasText !== void 0)
          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options2.hasText)} })`;
        if (options2.hasNotText !== void 0)
          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options2.hasNotText)} })`;
        return `Locator(${this.quote(body)})`;
      case "frame-locator":
        return `FrameLocator(${this.quote(body)})`;
      case "frame":
        return `ContentFrame`;
      case "nth":
        return `Nth(${body})`;
      case "first":
        return `First`;
      case "last":
        return `Last`;
      case "visible":
        return `Filter(new() { Visible = ${body === "true" ? "true" : "false"} })`;
      case "role":
        const attrs = [];
        if (isRegExp5(options2.name)) {
          attrs.push(`NameRegex = ${this.regexToString(options2.name)}`);
        } else if (typeof options2.name === "string") {
          attrs.push(`Name = ${this.quote(options2.name)}`);
          if (options2.exact)
            attrs.push(`Exact = true`);
        }
        for (const { name, value } of options2.attrs)
          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);
        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";
        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;
      case "has-text":
        return `Filter(new() { ${this.toHasText(body)} })`;
      case "has-not-text":
        return `Filter(new() { ${this.toHasNotText(body)} })`;
      case "has":
        return `Filter(new() { Has = ${body} })`;
      case "hasNot":
        return `Filter(new() { HasNot = ${body} })`;
      case "and":
        return `And(${body})`;
      case "or":
        return `Or(${body})`;
      case "chain":
        return `Locator(${body})`;
      case "test-id":
        return `GetByTestId(${this.toTestIdValue(body)})`;
      case "text":
        return this.toCallWithExact("GetByText", body, !!options2.exact);
      case "alt":
        return this.toCallWithExact("GetByAltText", body, !!options2.exact);
      case "placeholder":
        return this.toCallWithExact("GetByPlaceholder", body, !!options2.exact);
      case "label":
        return this.toCallWithExact("GetByLabel", body, !!options2.exact);
      case "title":
        return this.toCallWithExact("GetByTitle", body, !!options2.exact);
      default:
        throw new Error("Unknown selector kind " + kind);
    }
  }
  chainLocators(locators) {
    return locators.join(".");
  }
  regexToString(body) {
    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";
    return `new Regex(${this.quote(normalizeEscapedRegexQuotes(body.source))}${suffix})`;
  }
  toCallWithExact(method, body, exact) {
    if (isRegExp5(body))
      return `${method}(${this.regexToString(body)})`;
    if (exact)
      return `${method}(${this.quote(body)}, new() { Exact = true })`;
    return `${method}(${this.quote(body)})`;
  }
  toHasText(body) {
    if (isRegExp5(body))
      return `HasTextRegex = ${this.regexToString(body)}`;
    return `HasText = ${this.quote(body)}`;
  }
  toTestIdValue(value) {
    if (isRegExp5(value))
      return this.regexToString(value);
    return this.quote(value);
  }
  toHasNotText(body) {
    if (isRegExp5(body))
      return `HasNotTextRegex = ${this.regexToString(body)}`;
    return `HasNotText = ${this.quote(body)}`;
  }
  quote(text) {
    return escapeWithQuotes(text, '"');
  }
};
var JsonlLocatorFactory = class {
  static {
    __name(this, "JsonlLocatorFactory");
  }
  generateLocator(base, kind, body, options2 = {}) {
    return JSON.stringify({
      kind,
      body,
      options: options2
    });
  }
  chainLocators(locators) {
    const objects = locators.map((l) => JSON.parse(l));
    for (let i = 0; i < objects.length - 1; ++i)
      objects[i].next = objects[i + 1];
    return JSON.stringify(objects[0]);
  }
};
var generators = {
  javascript: JavaScriptLocatorFactory,
  python: PythonLocatorFactory,
  java: JavaLocatorFactory,
  csharp: CSharpLocatorFactory,
  jsonl: JsonlLocatorFactory
};
function isRegExp5(obj) {
  return obj instanceof RegExp;
}
__name(isRegExp5, "isRegExp");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/frameSelectors.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var FrameSelectors = class {
  static {
    __name(this, "FrameSelectors");
  }
  constructor(frame) {
    this.frame = frame;
  }
  _parseSelector(selector, options2) {
    const strict = typeof options2?.strict === "boolean" ? options2.strict : !!this.frame._page.browserContext._options.strictSelectors;
    return this.frame._page.browserContext.selectors().parseSelector(selector, strict);
  }
  async query(selector, options2, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, options2, scope);
    if (!resolved)
      return null;
    const handle = await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelector(info3.parsed, scope2 || document, info3.strict);
    }, { info: resolved.info, scope: resolved.scope });
    const elementHandle = handle.asElement();
    if (!elementHandle) {
      handle.dispose();
      return null;
    }
    return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
  }
  async queryArrayInMainWorld(selector, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
    if (!resolved)
      throw new Error(`Failed to find frame for selector "${selector}"`);
    return await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelectorAll(info3.parsed, scope2 || document);
    }, { info: resolved.info, scope: resolved.scope });
  }
  async queryCount(selector, options2) {
    const resolved = await this.resolveInjectedForSelector(selector);
    if (!resolved)
      throw new Error(`Failed to find frame for selector "${selector}"`);
    await options2.__testHookBeforeQuery?.();
    return await resolved.injected.evaluate((injected, { info: info3 }) => {
      return injected.querySelectorAll(info3.parsed, document).length;
    }, { info: resolved.info });
  }
  async queryAll(selector, scope) {
    const resolved = await this.resolveInjectedForSelector(selector, {}, scope);
    if (!resolved)
      return [];
    const arrayHandle = await resolved.injected.evaluateHandle((injected, { info: info3, scope: scope2 }) => {
      return injected.querySelectorAll(info3.parsed, scope2 || document);
    }, { info: resolved.info, scope: resolved.scope });
    const properties = await arrayHandle.getProperties();
    arrayHandle.dispose();
    const targetContext = await resolved.frame._mainContext();
    const result = [];
    for (const property of properties.values()) {
      const elementHandle = property.asElement();
      if (elementHandle)
        result.push(adoptIfNeeded(elementHandle, targetContext));
      else
        property.dispose();
    }
    return Promise.all(result);
  }
  _jumpToAriaRefFrameIfNeeded(selector, info3, frame) {
    if (info3.parsed.parts[0].name !== "aria-ref")
      return frame;
    const body = info3.parsed.parts[0].body;
    const match = body.match(/^f(\d+)e\d+$/);
    if (!match)
      return frame;
    const frameIndex = +match[1];
    const page = this.frame._page;
    const frameId = page.lastSnapshotFrameIds[frameIndex - 1];
    const jumptToFrame = frameId ? page.frameManager.frame(frameId) : null;
    if (!jumptToFrame)
      throw new InvalidSelectorError(`Invalid frame in aria-ref selector "${selector}"`);
    return jumptToFrame;
  }
  async resolveFrameForSelector(selector, options2 = {}, scope) {
    let frame = this.frame;
    const frameChunks = splitSelectorByFrame(selector);
    for (const chunk of frameChunks) {
      visitAllSelectorParts(chunk, (part, nested) => {
        if (nested && part.name === "internal:control" && part.body === "enter-frame") {
          const locator = asLocator(this.frame._page.browserContext._browser.sdkLanguage(), selector);
          throw new InvalidSelectorError(`Frame locators are not allowed inside composite locators, while querying "${locator}"`);
        }
      });
    }
    for (let i = 0; i < frameChunks.length - 1; ++i) {
      const info3 = this._parseSelector(frameChunks[i], options2);
      frame = this._jumpToAriaRefFrameIfNeeded(selector, info3, frame);
      const context2 = await frame._context(info3.world);
      const injectedScript = await context2.injectedScript();
      const handle = await injectedScript.evaluateHandle((injected, { info: info22, scope: scope2, selectorString }) => {
        const element2 = injected.querySelector(info22.parsed, scope2 || document, info22.strict);
        if (element2 && element2.nodeName !== "IFRAME" && element2.nodeName !== "FRAME")
          throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element2)}, <iframe> was expected`);
        return element2;
      }, { info: info3, scope: i === 0 ? scope : void 0, selectorString: stringifySelector(info3.parsed) });
      const element = handle.asElement();
      if (!element)
        return null;
      const maybeFrame = await frame._page.delegate.getContentFrame(element);
      element.dispose();
      if (!maybeFrame)
        return null;
      frame = maybeFrame;
    }
    if (frame !== this.frame)
      scope = void 0;
    const lastChunk = frame.selectors._parseSelector(frameChunks[frameChunks.length - 1], options2);
    frame = this._jumpToAriaRefFrameIfNeeded(selector, lastChunk, frame);
    return { frame, info: lastChunk, scope };
  }
  async resolveInjectedForSelector(selector, options2, scope) {
    const resolved = await this.resolveFrameForSelector(selector, options2, scope);
    if (!resolved)
      return;
    const context2 = await resolved.frame._context(options2?.mainWorld ? "main" : resolved.info.world);
    const injected = await context2.injectedScript();
    return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
  }
};
async function adoptIfNeeded(handle, context2) {
  if (handle._context === context2)
    return handle;
  const adopted = await handle._page.delegate.adoptElementHandle(handle, context2);
  handle.dispose();
  return adopted;
}
__name(adoptIfNeeded, "adoptIfNeeded");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/helper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAX_LOG_LENGTH = process.env.MAX_LOG_LENGTH ? +process.env.MAX_LOG_LENGTH : Infinity;
var Helper = class {
  static {
    __name(this, "Helper");
  }
  static completeUserURL(urlString) {
    if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
      urlString = "http://" + urlString;
    return urlString;
  }
  static enclosingIntRect(rect) {
    const x = Math.floor(rect.x + 1e-3);
    const y = Math.floor(rect.y + 1e-3);
    const x2 = Math.ceil(rect.x + rect.width - 1e-3);
    const y2 = Math.ceil(rect.y + rect.height - 1e-3);
    return { x, y, width: x2 - x, height: y2 - y };
  }
  static enclosingIntSize(size) {
    return { width: Math.floor(size.width + 1e-3), height: Math.floor(size.height + 1e-3) };
  }
  static getViewportSizeFromWindowFeatures(features2) {
    const widthString = features2.find((f) => f.startsWith("width="));
    const heightString = features2.find((f) => f.startsWith("height="));
    const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
    const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
    if (!Number.isNaN(width) && !Number.isNaN(height))
      return { width, height };
    return null;
  }
  static waitForEvent(progress3, emitter, event, predicate) {
    const listeners2 = [];
    const dispose = /* @__PURE__ */ __name(() => eventsHelper.removeEventListeners(listeners2), "dispose");
    const promise = progress3.race(new Promise((resolve, reject) => {
      listeners2.push(eventsHelper.addEventListener(emitter, event, (eventArg) => {
        try {
          if (predicate && !predicate(eventArg))
            return;
          resolve(eventArg);
        } catch (e) {
          reject(e);
        }
      }));
    })).finally(() => dispose());
    return { promise, dispose };
  }
  static secondsToRoundishMillis(value) {
    return (value * 1e6 | 0) / 1e3;
  }
  static millisToRoundishMillis(value) {
    return (value * 1e3 | 0) / 1e3;
  }
  static debugProtocolLogger(protocolLogger) {
    return (direction, message) => {
      if (protocolLogger)
        protocolLogger(direction, message);
      if (debugLogger.isEnabled("protocol")) {
        let text = JSON.stringify(message);
        if (text.length > MAX_LOG_LENGTH)
          text = text.substring(0, MAX_LOG_LENGTH / 2) + " <<<<<( LOG TRUNCATED )>>>>> " + text.substring(text.length - MAX_LOG_LENGTH / 2);
        debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + text);
      }
    };
  }
  static formatBrowserLogs(logs, disconnectReason) {
    if (!disconnectReason && !logs.length)
      return "";
    return "\n" + (disconnectReason ? disconnectReason + "\n" : "") + logs.join("\n");
  }
};
var helper = Helper;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/network.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
function filterCookies(cookies, urls) {
  const parsedURLs = urls.map((s) => new URL(s));
  return cookies.filter((c) => {
    if (!parsedURLs.length)
      return true;
    for (const parsedURL of parsedURLs) {
      let domain2 = c.domain;
      if (!domain2.startsWith("."))
        domain2 = "." + domain2;
      if (!("." + parsedURL.hostname).endsWith(domain2))
        continue;
      if (!parsedURL.pathname.startsWith(c.path))
        continue;
      if (parsedURL.protocol !== "https:" && !isLocalHostname(parsedURL.hostname) && c.secure)
        continue;
      return true;
    }
    return false;
  });
}
__name(filterCookies, "filterCookies");
function isLocalHostname(hostname) {
  return hostname === "localhost" || hostname.endsWith(".localhost");
}
__name(isLocalHostname, "isLocalHostname");
var kMaxCookieExpiresDateInSeconds = 253402300799;
function rewriteCookies(cookies) {
  return cookies.map((c) => {
    assert3(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
    assert3(!(c.url && c.domain), "Cookie should have either url or domain");
    assert3(!(c.url && c.path), "Cookie should have either url or path");
    assert3(!(c.expires && c.expires < 0 && c.expires !== -1), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
    assert3(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
    const copy = { ...c };
    if (copy.url) {
      assert3(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
      assert3(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
      const url4 = new URL(copy.url);
      copy.domain = url4.hostname;
      copy.path = url4.pathname.substring(0, url4.pathname.lastIndexOf("/") + 1);
      copy.secure = url4.protocol === "https:";
    }
    return copy;
  });
}
__name(rewriteCookies, "rewriteCookies");
function parseURL2(url4) {
  try {
    return new URL(url4);
  } catch (e) {
    return null;
  }
}
__name(parseURL2, "parseURL");
function stripFragmentFromUrl(url4) {
  if (!url4.includes("#"))
    return url4;
  return url4.substring(0, url4.indexOf("#"));
}
__name(stripFragmentFromUrl, "stripFragmentFromUrl");
var Request = class extends SdkObject {
  static {
    __name(this, "Request");
  }
  constructor(context2, frame, serviceWorker, redirectedFrom, documentId, url4, resourceType, method, postData, headers) {
    super(frame || context2, "request");
    this._response = null;
    this._redirectedTo = null;
    this._failureText = null;
    this._headersMap = /* @__PURE__ */ new Map();
    this._frame = null;
    this._serviceWorker = null;
    this._rawRequestHeadersPromise = new ManualPromise();
    this._waitForResponsePromise = new ManualPromise();
    this._responseEndTiming = -1;
    assert3(!url4.startsWith("data:"), "Data urls should not fire requests");
    this._context = context2;
    this._frame = frame;
    this._serviceWorker = serviceWorker;
    this._redirectedFrom = redirectedFrom;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    this._documentId = documentId;
    this._url = stripFragmentFromUrl(url4);
    this._resourceType = resourceType;
    this._method = method;
    this._postData = postData;
    this._headers = headers;
    this._updateHeadersMap();
    this._isFavicon = url4.endsWith("/favicon.ico") || !!redirectedFrom?._isFavicon;
  }
  _setFailureText(failureText) {
    this._failureText = failureText;
    this._waitForResponsePromise.resolve(null);
  }
  _applyOverrides(overrides) {
    this._overrides = { ...this._overrides, ...overrides };
    this._updateHeadersMap();
    return this._overrides;
  }
  _updateHeadersMap() {
    for (const { name, value } of this.headers())
      this._headersMap.set(name.toLowerCase(), value);
  }
  overrides() {
    return this._overrides;
  }
  url() {
    return this._overrides?.url || this._url;
  }
  resourceType() {
    return this._resourceType;
  }
  method() {
    return this._overrides?.method || this._method;
  }
  postDataBuffer() {
    return this._overrides?.postData || this._postData;
  }
  headers() {
    return this._overrides?.headers || this._headers;
  }
  headerValue(name) {
    return this._headersMap.get(name);
  }
  // "null" means no raw headers available - we'll use provisional headers as raw headers.
  setRawRequestHeaders(headers) {
    if (!this._rawRequestHeadersPromise.isDone())
      this._rawRequestHeadersPromise.resolve(headers || this._headers);
  }
  async rawRequestHeaders() {
    return this._overrides?.headers || this._rawRequestHeadersPromise;
  }
  response() {
    return this._waitForResponsePromise;
  }
  _existingResponse() {
    return this._response;
  }
  _setResponse(response) {
    this._response = response;
    this._waitForResponsePromise.resolve(response);
  }
  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }
  frame() {
    return this._frame;
  }
  serviceWorker() {
    return this._serviceWorker;
  }
  isNavigationRequest() {
    return !!this._documentId;
  }
  redirectedFrom() {
    return this._redirectedFrom;
  }
  failure() {
    if (this._failureText === null)
      return null;
    return {
      errorText: this._failureText
    };
  }
  // TODO(bidi): remove once post body is available.
  _setBodySize(size) {
    this._bodySize = size;
  }
  bodySize() {
    return this._bodySize || this.postDataBuffer()?.length || 0;
  }
  async requestHeadersSize() {
    let headersSize = 4;
    headersSize += this.method().length;
    headersSize += new URL(this.url()).pathname.length;
    headersSize += 8;
    const headers = await this.rawRequestHeaders();
    for (const header of headers)
      headersSize += header.name.length + header.value.length + 4;
    return headersSize;
  }
};
var Route = class extends SdkObject {
  static {
    __name(this, "Route");
  }
  constructor(request2, delegate) {
    super(request2._frame || request2._context, "route");
    this._handled = false;
    this._futureHandlers = [];
    this._request = request2;
    this._delegate = delegate;
    this._request._context.addRouteInFlight(this);
  }
  handle(handlers) {
    this._futureHandlers = [...handlers];
    this.continue({ isFallback: true }).catch(() => {
    });
  }
  async removeHandler(handler) {
    this._futureHandlers = this._futureHandlers.filter((h) => h !== handler);
    if (handler === this._currentHandler) {
      await this.continue({ isFallback: true }).catch(() => {
      });
      return;
    }
  }
  request() {
    return this._request;
  }
  async abort(errorCode = "failed") {
    this._startHandling();
    this._request._context.emit(BrowserContext.Events.RequestAborted, this._request);
    await this._delegate.abort(errorCode);
    this._endHandling();
  }
  redirectNavigationRequest(url4) {
    this._startHandling();
    assert3(this._request.isNavigationRequest());
    this._request.frame().redirectNavigation(url4, this._request._documentId, this._request.headerValue("referer"));
    this._endHandling();
  }
  async fulfill(overrides) {
    this._startHandling();
    let body = overrides.body;
    let isBase64 = overrides.isBase64 || false;
    if (body === void 0) {
      if (overrides.fetchResponseUid) {
        const buffer = this._request._context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || APIRequestContext.findResponseBody(overrides.fetchResponseUid);
        assert3(buffer, "Fetch response has been disposed");
        body = buffer.toString("base64");
        isBase64 = true;
      } else {
        body = "";
        isBase64 = false;
      }
    }
    const headers = [...overrides.headers || []];
    this._maybeAddCorsHeaders(headers);
    this._request._context.emit(BrowserContext.Events.RequestFulfilled, this._request);
    await this._delegate.fulfill({
      status: overrides.status || 200,
      headers,
      body,
      isBase64
    });
    this._endHandling();
  }
  // See https://github.com/microsoft/playwright/issues/12929
  _maybeAddCorsHeaders(headers) {
    const origin = this._request.headerValue("origin");
    if (!origin)
      return;
    const requestUrl = new URL(this._request.url());
    if (!requestUrl.protocol.startsWith("http"))
      return;
    if (requestUrl.origin === origin.trim())
      return;
    const corsHeader = headers.find(({ name }) => name === "access-control-allow-origin");
    if (corsHeader)
      return;
    headers.push({ name: "access-control-allow-origin", value: origin });
    headers.push({ name: "access-control-allow-credentials", value: "true" });
    headers.push({ name: "vary", value: "Origin" });
  }
  async continue(overrides) {
    if (overrides.url) {
      const newUrl = new URL(overrides.url);
      const oldUrl = new URL(this._request.url());
      if (oldUrl.protocol !== newUrl.protocol)
        throw new Error("New URL must have same protocol as overridden URL");
    }
    if (overrides.headers) {
      overrides.headers = overrides.headers?.filter((header) => {
        const headerName = header.name.toLowerCase();
        return headerName !== "cookie" && headerName !== "host";
      });
    }
    overrides = this._request._applyOverrides(overrides);
    const nextHandler = this._futureHandlers.shift();
    if (nextHandler) {
      this._currentHandler = nextHandler;
      nextHandler(this, this._request);
      return;
    }
    if (!overrides.isFallback)
      this._request._context.emit(BrowserContext.Events.RequestContinued, this._request);
    this._startHandling();
    await this._delegate.continue(overrides);
    this._endHandling();
  }
  _startHandling() {
    assert3(!this._handled, "Route is already handled!");
    this._handled = true;
    this._currentHandler = void 0;
  }
  _endHandling() {
    this._futureHandlers = [];
    this._currentHandler = void 0;
    this._request._context.removeRouteInFlight(this);
  }
};
var Response2 = class extends SdkObject {
  static {
    __name(this, "Response");
  }
  constructor(request2, status, statusText2, headers, timing, getResponseBodyCallback, fromServiceWorker, httpVersion) {
    super(request2.frame() || request2._context, "response");
    this._contentPromise = null;
    this._finishedPromise = new ManualPromise();
    this._headersMap = /* @__PURE__ */ new Map();
    this._serverAddrPromise = new ManualPromise();
    this._securityDetailsPromise = new ManualPromise();
    this._rawResponseHeadersPromise = new ManualPromise();
    this._encodedBodySizePromise = new ManualPromise();
    this._transferSizePromise = new ManualPromise();
    this._responseHeadersSizePromise = new ManualPromise();
    this._request = request2;
    this._timing = timing;
    this._status = status;
    this._statusText = statusText2;
    this._url = request2.url();
    this._headers = headers;
    for (const { name, value } of this._headers)
      this._headersMap.set(name.toLowerCase(), value);
    this._getResponseBodyCallback = getResponseBodyCallback;
    this._request._setResponse(this);
    this._httpVersion = httpVersion;
    this._fromServiceWorker = fromServiceWorker;
  }
  _serverAddrFinished(addr) {
    this._serverAddrPromise.resolve(addr);
  }
  _securityDetailsFinished(securityDetails) {
    this._securityDetailsPromise.resolve(securityDetails);
  }
  _requestFinished(responseEndTiming) {
    this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
    if (this._timing.requestStart === -1)
      this._timing.requestStart = this._request._responseEndTiming;
    this._finishedPromise.resolve();
  }
  _setHttpVersion(httpVersion) {
    this._httpVersion = httpVersion;
  }
  url() {
    return this._url;
  }
  status() {
    return this._status;
  }
  statusText() {
    return this._statusText;
  }
  headers() {
    return this._headers;
  }
  headerValue(name) {
    return this._headersMap.get(name);
  }
  async rawResponseHeaders() {
    return this._rawResponseHeadersPromise;
  }
  // "null" means no raw headers available - we'll use provisional headers as raw headers.
  setRawResponseHeaders(headers) {
    if (!this._rawResponseHeadersPromise.isDone())
      this._rawResponseHeadersPromise.resolve(headers || this._headers);
  }
  setTransferSize(size) {
    this._transferSizePromise.resolve(size);
  }
  setEncodedBodySize(size) {
    this._encodedBodySizePromise.resolve(size);
  }
  setResponseHeadersSize(size) {
    this._responseHeadersSizePromise.resolve(size);
  }
  timing() {
    return this._timing;
  }
  async serverAddr() {
    return await this._serverAddrPromise || null;
  }
  async securityDetails() {
    return await this._securityDetailsPromise || null;
  }
  body() {
    if (!this._contentPromise) {
      this._contentPromise = this._finishedPromise.then(async () => {
        if (this._status >= 300 && this._status <= 399)
          throw new Error("Response body is unavailable for redirect responses");
        return this._getResponseBodyCallback();
      });
    }
    return this._contentPromise;
  }
  request() {
    return this._request;
  }
  frame() {
    return this._request.frame();
  }
  httpVersion() {
    if (!this._httpVersion)
      return "HTTP/1.1";
    if (this._httpVersion === "http/1.1")
      return "HTTP/1.1";
    if (this._httpVersion === "h2")
      return "HTTP/2.0";
    return this._httpVersion;
  }
  fromServiceWorker() {
    return this._fromServiceWorker;
  }
  async responseHeadersSize() {
    const availableSize = await this._responseHeadersSizePromise;
    if (availableSize !== null)
      return availableSize;
    let headersSize = 4;
    headersSize += 8;
    headersSize += 3;
    headersSize += this.statusText().length;
    const headers = await this._rawResponseHeadersPromise;
    for (const header of headers)
      headersSize += header.name.length + header.value.length + 4;
    headersSize += 2;
    return headersSize;
  }
  async sizes() {
    const requestHeadersSize = await this._request.requestHeadersSize();
    const responseHeadersSize = await this.responseHeadersSize();
    let encodedBodySize = await this._encodedBodySizePromise;
    if (encodedBodySize === null) {
      const headers = await this._rawResponseHeadersPromise;
      const contentLength = headers.find((h) => h.name.toLowerCase() === "content-length")?.value;
      encodedBodySize = contentLength ? +contentLength : 0;
    }
    let transferSize = await this._transferSizePromise;
    if (transferSize === null) {
      transferSize = responseHeadersSize + encodedBodySize;
    }
    return {
      requestBodySize: this._request.bodySize(),
      requestHeadersSize,
      responseBodySize: encodedBodySize,
      responseHeadersSize,
      transferSize
    };
  }
};
var WebSocket2 = class _WebSocket extends SdkObject {
  static {
    __name(this, "WebSocket");
  }
  constructor(parent, url4) {
    super(parent, "ws");
    this._notified = false;
    this._url = url4;
  }
  static {
    this.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
  }
  markAsNotified() {
    if (this._notified)
      return false;
    this._notified = true;
    return true;
  }
  url() {
    return this._url;
  }
  frameSent(opcode, data) {
    this.emit(_WebSocket.Events.FrameSent, { opcode, data });
  }
  frameReceived(opcode, data) {
    this.emit(_WebSocket.Events.FrameReceived, { opcode, data });
  }
  error(errorMessage) {
    this.emit(_WebSocket.Events.SocketError, errorMessage);
  }
  closed() {
    this.emit(_WebSocket.Events.Close);
  }
};
var STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
function statusText(status) {
  return STATUS_TEXTS[String(status)] || "Unknown";
}
__name(statusText, "statusText");
function singleHeader(name, value) {
  return [{ name, value }];
}
__name(singleHeader, "singleHeader");
function mergeHeaders(headers) {
  const lowerCaseToValue = /* @__PURE__ */ new Map();
  const lowerCaseToOriginalCase = /* @__PURE__ */ new Map();
  for (const h of headers) {
    if (!h)
      continue;
    for (const { name, value } of h) {
      const lower = name.toLowerCase();
      lowerCaseToOriginalCase.set(lower, name);
      lowerCaseToValue.set(lower, value);
    }
  }
  const result = [];
  for (const [lower, value] of lowerCaseToValue)
    result.push({ name: lowerCaseToOriginalCase.get(lower), value });
  return result;
}
__name(mergeHeaders, "mergeHeaders");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/page.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/accessibility.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Accessibility = class {
  static {
    __name(this, "Accessibility");
  }
  constructor(getAXTree) {
    this._getAXTree = getAXTree;
  }
  async snapshot(options2 = {}) {
    const {
      interestingOnly = true,
      root = null
    } = options2;
    const { tree, needle } = await this._getAXTree(root || void 0);
    if (!interestingOnly) {
      if (root)
        return needle && serializeTree(needle)[0];
      return serializeTree(tree)[0];
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    collectInterestingNodes(interestingNodes, tree, false);
    if (root && (!needle || !interestingNodes.has(needle)))
      return null;
    return serializeTree(needle || tree, interestingNodes)[0];
  }
};
function collectInterestingNodes(collection, node, insideControl) {
  if (node.isInteresting(insideControl))
    collection.add(node);
  if (node.isLeafNode())
    return;
  insideControl = insideControl || node.isControl();
  for (const child of node.children())
    collectInterestingNodes(collection, child, insideControl);
}
__name(collectInterestingNodes, "collectInterestingNodes");
function serializeTree(node, whitelistedNodes) {
  const children = [];
  for (const child of node.children())
    children.push(...serializeTree(child, whitelistedNodes));
  if (whitelistedNodes && !whitelistedNodes.has(node))
    return children;
  const serializedNode = node.serialize();
  if (children.length)
    serializedNode.children = children;
  return [serializedNode];
}
__name(serializeTree, "serializeTree");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/console.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ConsoleMessage = class {
  static {
    __name(this, "ConsoleMessage");
  }
  constructor(page, type, text, args, location2) {
    this._page = page;
    this._type = type;
    this._text = text;
    this._args = args;
    this._location = location2 || { url: "", lineNumber: 0, columnNumber: 0 };
  }
  page() {
    return this._page;
  }
  type() {
    return this._type;
  }
  text() {
    if (this._text === void 0)
      this._text = this._args.map((arg) => arg.preview()).join(" ");
    return this._text;
  }
  args() {
    return this._args;
  }
  location() {
    return this._location;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/fileChooser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FileChooser = class {
  static {
    __name(this, "FileChooser");
  }
  constructor(page, elementHandle, isMultiple) {
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }
  element() {
    return this._elementHandle;
  }
  isMultiple() {
    return this._isMultiple;
  }
  page() {
    return this._page;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/input.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/usKeyboardLayout.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var keypadLocation = 3;
var USKeyboardLayout = {
  // Functions row
  "Escape": { "keyCode": 27, "key": "Escape" },
  "F1": { "keyCode": 112, "key": "F1" },
  "F2": { "keyCode": 113, "key": "F2" },
  "F3": { "keyCode": 114, "key": "F3" },
  "F4": { "keyCode": 115, "key": "F4" },
  "F5": { "keyCode": 116, "key": "F5" },
  "F6": { "keyCode": 117, "key": "F6" },
  "F7": { "keyCode": 118, "key": "F7" },
  "F8": { "keyCode": 119, "key": "F8" },
  "F9": { "keyCode": 120, "key": "F9" },
  "F10": { "keyCode": 121, "key": "F10" },
  "F11": { "keyCode": 122, "key": "F11" },
  "F12": { "keyCode": 123, "key": "F12" },
  // Numbers row
  "Backquote": { "keyCode": 192, "shiftKey": "~", "key": "`" },
  "Digit1": { "keyCode": 49, "shiftKey": "!", "key": "1" },
  "Digit2": { "keyCode": 50, "shiftKey": "@", "key": "2" },
  "Digit3": { "keyCode": 51, "shiftKey": "#", "key": "3" },
  "Digit4": { "keyCode": 52, "shiftKey": "$", "key": "4" },
  "Digit5": { "keyCode": 53, "shiftKey": "%", "key": "5" },
  "Digit6": { "keyCode": 54, "shiftKey": "^", "key": "6" },
  "Digit7": { "keyCode": 55, "shiftKey": "&", "key": "7" },
  "Digit8": { "keyCode": 56, "shiftKey": "*", "key": "8" },
  "Digit9": { "keyCode": 57, "shiftKey": "(", "key": "9" },
  "Digit0": { "keyCode": 48, "shiftKey": ")", "key": "0" },
  "Minus": { "keyCode": 189, "shiftKey": "_", "key": "-" },
  "Equal": { "keyCode": 187, "shiftKey": "+", "key": "=" },
  "Backslash": { "keyCode": 220, "shiftKey": "|", "key": "\\" },
  "Backspace": { "keyCode": 8, "key": "Backspace" },
  // First row
  "Tab": { "keyCode": 9, "key": "Tab" },
  "KeyQ": { "keyCode": 81, "shiftKey": "Q", "key": "q" },
  "KeyW": { "keyCode": 87, "shiftKey": "W", "key": "w" },
  "KeyE": { "keyCode": 69, "shiftKey": "E", "key": "e" },
  "KeyR": { "keyCode": 82, "shiftKey": "R", "key": "r" },
  "KeyT": { "keyCode": 84, "shiftKey": "T", "key": "t" },
  "KeyY": { "keyCode": 89, "shiftKey": "Y", "key": "y" },
  "KeyU": { "keyCode": 85, "shiftKey": "U", "key": "u" },
  "KeyI": { "keyCode": 73, "shiftKey": "I", "key": "i" },
  "KeyO": { "keyCode": 79, "shiftKey": "O", "key": "o" },
  "KeyP": { "keyCode": 80, "shiftKey": "P", "key": "p" },
  "BracketLeft": { "keyCode": 219, "shiftKey": "{", "key": "[" },
  "BracketRight": { "keyCode": 221, "shiftKey": "}", "key": "]" },
  // Second row
  "CapsLock": { "keyCode": 20, "key": "CapsLock" },
  "KeyA": { "keyCode": 65, "shiftKey": "A", "key": "a" },
  "KeyS": { "keyCode": 83, "shiftKey": "S", "key": "s" },
  "KeyD": { "keyCode": 68, "shiftKey": "D", "key": "d" },
  "KeyF": { "keyCode": 70, "shiftKey": "F", "key": "f" },
  "KeyG": { "keyCode": 71, "shiftKey": "G", "key": "g" },
  "KeyH": { "keyCode": 72, "shiftKey": "H", "key": "h" },
  "KeyJ": { "keyCode": 74, "shiftKey": "J", "key": "j" },
  "KeyK": { "keyCode": 75, "shiftKey": "K", "key": "k" },
  "KeyL": { "keyCode": 76, "shiftKey": "L", "key": "l" },
  "Semicolon": { "keyCode": 186, "shiftKey": ":", "key": ";" },
  "Quote": { "keyCode": 222, "shiftKey": '"', "key": "'" },
  "Enter": { "keyCode": 13, "key": "Enter", "text": "\r" },
  // Third row
  "ShiftLeft": { "keyCode": 160, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 1 },
  "KeyZ": { "keyCode": 90, "shiftKey": "Z", "key": "z" },
  "KeyX": { "keyCode": 88, "shiftKey": "X", "key": "x" },
  "KeyC": { "keyCode": 67, "shiftKey": "C", "key": "c" },
  "KeyV": { "keyCode": 86, "shiftKey": "V", "key": "v" },
  "KeyB": { "keyCode": 66, "shiftKey": "B", "key": "b" },
  "KeyN": { "keyCode": 78, "shiftKey": "N", "key": "n" },
  "KeyM": { "keyCode": 77, "shiftKey": "M", "key": "m" },
  "Comma": { "keyCode": 188, "shiftKey": "<", "key": "," },
  "Period": { "keyCode": 190, "shiftKey": ">", "key": "." },
  "Slash": { "keyCode": 191, "shiftKey": "?", "key": "/" },
  "ShiftRight": { "keyCode": 161, "keyCodeWithoutLocation": 16, "key": "Shift", "location": 2 },
  // Last row
  "ControlLeft": { "keyCode": 162, "keyCodeWithoutLocation": 17, "key": "Control", "location": 1 },
  "MetaLeft": { "keyCode": 91, "key": "Meta", "location": 1 },
  "AltLeft": { "keyCode": 164, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 1 },
  "Space": { "keyCode": 32, "key": " " },
  "AltRight": { "keyCode": 165, "keyCodeWithoutLocation": 18, "key": "Alt", "location": 2 },
  "AltGraph": { "keyCode": 225, "key": "AltGraph" },
  "MetaRight": { "keyCode": 92, "key": "Meta", "location": 2 },
  "ContextMenu": { "keyCode": 93, "key": "ContextMenu" },
  "ControlRight": { "keyCode": 163, "keyCodeWithoutLocation": 17, "key": "Control", "location": 2 },
  // Center block
  "PrintScreen": { "keyCode": 44, "key": "PrintScreen" },
  "ScrollLock": { "keyCode": 145, "key": "ScrollLock" },
  "Pause": { "keyCode": 19, "key": "Pause" },
  "PageUp": { "keyCode": 33, "key": "PageUp" },
  "PageDown": { "keyCode": 34, "key": "PageDown" },
  "Insert": { "keyCode": 45, "key": "Insert" },
  "Delete": { "keyCode": 46, "key": "Delete" },
  "Home": { "keyCode": 36, "key": "Home" },
  "End": { "keyCode": 35, "key": "End" },
  "ArrowLeft": { "keyCode": 37, "key": "ArrowLeft" },
  "ArrowUp": { "keyCode": 38, "key": "ArrowUp" },
  "ArrowRight": { "keyCode": 39, "key": "ArrowRight" },
  "ArrowDown": { "keyCode": 40, "key": "ArrowDown" },
  // Numpad
  "NumLock": { "keyCode": 144, "key": "NumLock" },
  "NumpadDivide": { "keyCode": 111, "key": "/", "location": 3 },
  "NumpadMultiply": { "keyCode": 106, "key": "*", "location": 3 },
  "NumpadSubtract": { "keyCode": 109, "key": "-", "location": 3 },
  "Numpad7": { "keyCode": 36, "shiftKeyCode": 103, "key": "Home", "shiftKey": "7", "location": 3 },
  "Numpad8": { "keyCode": 38, "shiftKeyCode": 104, "key": "ArrowUp", "shiftKey": "8", "location": 3 },
  "Numpad9": { "keyCode": 33, "shiftKeyCode": 105, "key": "PageUp", "shiftKey": "9", "location": 3 },
  "Numpad4": { "keyCode": 37, "shiftKeyCode": 100, "key": "ArrowLeft", "shiftKey": "4", "location": 3 },
  "Numpad5": { "keyCode": 12, "shiftKeyCode": 101, "key": "Clear", "shiftKey": "5", "location": 3 },
  "Numpad6": { "keyCode": 39, "shiftKeyCode": 102, "key": "ArrowRight", "shiftKey": "6", "location": 3 },
  "NumpadAdd": { "keyCode": 107, "key": "+", "location": 3 },
  "Numpad1": { "keyCode": 35, "shiftKeyCode": 97, "key": "End", "shiftKey": "1", "location": 3 },
  "Numpad2": { "keyCode": 40, "shiftKeyCode": 98, "key": "ArrowDown", "shiftKey": "2", "location": 3 },
  "Numpad3": { "keyCode": 34, "shiftKeyCode": 99, "key": "PageDown", "shiftKey": "3", "location": 3 },
  "Numpad0": { "keyCode": 45, "shiftKeyCode": 96, "key": "Insert", "shiftKey": "0", "location": 3 },
  "NumpadDecimal": { "keyCode": 46, "shiftKeyCode": 110, "key": "\0", "shiftKey": ".", "location": 3 },
  "NumpadEnter": { "keyCode": 13, "key": "Enter", "text": "\r", "location": 3 }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/input.js
var keypadLocation2 = keypadLocation;
var kModifiers = ["Alt", "Control", "Meta", "Shift"];
var Keyboard = class {
  static {
    __name(this, "Keyboard");
  }
  constructor(raw, page) {
    this._pressedModifiers = /* @__PURE__ */ new Set();
    this._pressedKeys = /* @__PURE__ */ new Set();
    this._raw = raw;
    this._page = page;
  }
  async down(progress3, key) {
    const description = this._keyDescriptionForString(key);
    const autoRepeat = this._pressedKeys.has(description.code);
    this._pressedKeys.add(description.code);
    if (kModifiers.includes(description.key))
      this._pressedModifiers.add(description.key);
    await this._raw.keydown(progress3, this._pressedModifiers, key, description, autoRepeat);
  }
  _keyDescriptionForString(str) {
    const keyString = resolveSmartModifierString(str);
    let description = usKeyboardLayout.get(keyString);
    if (!description)
      throw new NonRecoverableDOMError(`Unknown key: "${keyString}"`);
    const shift = this._pressedModifiers.has("Shift");
    description = shift && description.shifted ? description.shifted : description;
    if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
      return { ...description, text: "" };
    return description;
  }
  async up(progress3, key) {
    const description = this._keyDescriptionForString(key);
    if (kModifiers.includes(description.key))
      this._pressedModifiers.delete(description.key);
    this._pressedKeys.delete(description.code);
    await this._raw.keyup(progress3, this._pressedModifiers, key, description);
  }
  async insertText(progress3, text) {
    await this._raw.sendText(progress3, text);
  }
  async type(progress3, text, options2) {
    const delay = options2 && options2.delay || void 0;
    for (const char of text) {
      if (usKeyboardLayout.has(char)) {
        await this.press(progress3, char, { delay });
      } else {
        if (delay)
          await progress3.wait(delay);
        await this.insertText(progress3, char);
      }
    }
  }
  async press(progress3, key, options2 = {}) {
    function split(keyString) {
      const keys = [];
      let building = "";
      for (const char of keyString) {
        if (char === "+" && building) {
          keys.push(building);
          building = "";
        } else {
          building += char;
        }
      }
      keys.push(building);
      return keys;
    }
    __name(split, "split");
    const tokens = split(key);
    key = tokens[tokens.length - 1];
    for (let i = 0; i < tokens.length - 1; ++i)
      await this.down(progress3, tokens[i]);
    await this.down(progress3, key);
    if (options2.delay)
      await progress3.wait(options2.delay);
    await this.up(progress3, key);
    for (let i = tokens.length - 2; i >= 0; --i)
      await this.up(progress3, tokens[i]);
  }
  async ensureModifiers(progress3, mm) {
    const modifiers = mm.map(resolveSmartModifier);
    for (const modifier of modifiers) {
      if (!kModifiers.includes(modifier))
        throw new Error("Unknown modifier " + modifier);
    }
    const restore = Array.from(this._pressedModifiers);
    for (const key of kModifiers) {
      const needDown = modifiers.includes(key);
      const isDown = this._pressedModifiers.has(key);
      if (needDown && !isDown)
        await this.down(progress3, key);
      else if (!needDown && isDown)
        await this.up(progress3, key);
    }
    return restore;
  }
  _modifiers() {
    return this._pressedModifiers;
  }
};
function resolveSmartModifierString(key) {
  if (key === "ControlOrMeta")
    return process.platform === "darwin" ? "Meta" : "Control";
  return key;
}
__name(resolveSmartModifierString, "resolveSmartModifierString");
function resolveSmartModifier(m) {
  return resolveSmartModifierString(m);
}
__name(resolveSmartModifier, "resolveSmartModifier");
var Mouse = class {
  static {
    __name(this, "Mouse");
  }
  constructor(raw, page) {
    this._x = 0;
    this._y = 0;
    this._lastButton = "none";
    this._buttons = /* @__PURE__ */ new Set();
    this._raw = raw;
    this._page = page;
    this._keyboard = this._page.keyboard;
  }
  currentPoint() {
    return { x: this._x, y: this._y };
  }
  async move(progress3, x, y, options2 = {}) {
    const { steps = 1 } = options2;
    const fromX = this._x;
    const fromY = this._y;
    this._x = x;
    this._y = y;
    for (let i = 1; i <= steps; i++) {
      const middleX = fromX + (x - fromX) * (i / steps);
      const middleY = fromY + (y - fromY) * (i / steps);
      await this._raw.move(progress3, middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options2.forClick);
    }
  }
  async down(progress3, options2 = {}) {
    const { button = "left", clickCount = 1 } = options2;
    this._lastButton = button;
    this._buttons.add(button);
    await this._raw.down(progress3, this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
  }
  async up(progress3, options2 = {}) {
    const { button = "left", clickCount = 1 } = options2;
    this._lastButton = "none";
    this._buttons.delete(button);
    await this._raw.up(progress3, this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
  }
  async click(progress3, x, y, options2 = {}) {
    const { delay = null, clickCount = 1 } = options2;
    if (delay) {
      this.move(progress3, x, y, { forClick: true });
      for (let cc = 1; cc <= clickCount; ++cc) {
        await this.down(progress3, { ...options2, clickCount: cc });
        await progress3.wait(delay);
        await this.up(progress3, { ...options2, clickCount: cc });
        if (cc < clickCount)
          await progress3.wait(delay);
      }
    } else {
      const promises = [];
      promises.push(this.move(progress3, x, y, { forClick: true }));
      for (let cc = 1; cc <= clickCount; ++cc) {
        promises.push(this.down(progress3, { ...options2, clickCount: cc }));
        promises.push(this.up(progress3, { ...options2, clickCount: cc }));
      }
      await Promise.all(promises);
    }
  }
  async wheel(progress3, deltaX, deltaY) {
    await this._raw.wheel(progress3, this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
  }
};
var aliases = /* @__PURE__ */ new Map([
  ["ShiftLeft", ["Shift"]],
  ["ControlLeft", ["Control"]],
  ["AltLeft", ["Alt"]],
  ["MetaLeft", ["Meta"]],
  ["Enter", ["\n", "\r"]]
]);
var usKeyboardLayout = buildLayoutClosure(USKeyboardLayout);
function buildLayoutClosure(layout) {
  const result = /* @__PURE__ */ new Map();
  for (const code in layout) {
    const definition = layout[code];
    const description = {
      key: definition.key || "",
      keyCode: definition.keyCode || 0,
      keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
      code,
      text: definition.text || "",
      location: definition.location || 0
    };
    if (definition.key.length === 1)
      description.text = description.key;
    let shiftedDescription;
    if (definition.shiftKey) {
      assert3(definition.shiftKey.length === 1);
      shiftedDescription = { ...description };
      shiftedDescription.key = definition.shiftKey;
      shiftedDescription.text = definition.shiftKey;
      if (definition.shiftKeyCode)
        shiftedDescription.keyCode = definition.shiftKeyCode;
    }
    result.set(code, { ...description, shifted: shiftedDescription });
    if (aliases.has(code)) {
      for (const alias of aliases.get(code))
        result.set(alias, description);
    }
    if (definition.location)
      continue;
    if (description.key.length === 1)
      result.set(description.key, description);
    if (shiftedDescription)
      result.set(shiftedDescription.key, { ...shiftedDescription, shifted: void 0 });
  }
  return result;
}
__name(buildLayoutClosure, "buildLayoutClosure");
var Touchscreen = class {
  static {
    __name(this, "Touchscreen");
  }
  constructor(raw, page) {
    this._raw = raw;
    this._page = page;
  }
  async tap(progress3, x, y) {
    if (!this._page.browserContext._options.hasTouch)
      throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
    await this._raw.tap(progress3, x, y, this._page.keyboard._modifiers());
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/screenshotter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/multimap.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MultiMap = class {
  static {
    __name(this, "MultiMap");
  }
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    let values = this._map.get(key);
    if (!values) {
      values = [];
      this._map.set(key, values);
    }
    values.push(value);
  }
  get(key) {
    return this._map.get(key) || [];
  }
  has(key) {
    return this._map.has(key);
  }
  delete(key, value) {
    const values = this._map.get(key);
    if (!values)
      return;
    if (values.includes(value))
      this._map.set(key, values.filter((v) => value !== v));
  }
  deleteAll(key) {
    this._map.delete(key);
  }
  hasValue(key, value) {
    const values = this._map.get(key);
    if (!values)
      return false;
    return values.includes(value);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  }
  keys() {
    return this._map.keys();
  }
  values() {
    const result = [];
    for (const key of this.keys())
      result.push(...this.get(key));
    return result;
  }
  clear() {
    this._map.clear();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/screenshotter.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
function inPagePrepareForScreenshots(screenshotStyle, hideCaret, disableAnimations, syncAnimations) {
  if (syncAnimations) {
    const style = document.createElement("style");
    style.textContent = "body {}";
    document.head.appendChild(style);
    document.documentElement.getBoundingClientRect();
    style.remove();
  }
  if (!screenshotStyle && !hideCaret && !disableAnimations)
    return;
  const collectRoots = /* @__PURE__ */ __name((root, roots2 = []) => {
    roots2.push(root);
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
    do {
      const node = walker.currentNode;
      const shadowRoot = node instanceof Element ? node.shadowRoot : null;
      if (shadowRoot)
        collectRoots(shadowRoot, roots2);
    } while (walker.nextNode());
    return roots2;
  }, "collectRoots");
  const roots = collectRoots(document);
  const cleanupCallbacks = [];
  if (screenshotStyle) {
    for (const root of roots) {
      const styleTag = document.createElement("style");
      styleTag.textContent = screenshotStyle;
      if (root === document)
        document.documentElement.append(styleTag);
      else
        root.append(styleTag);
      cleanupCallbacks.push(() => {
        styleTag.remove();
      });
    }
  }
  if (hideCaret) {
    const elements = /* @__PURE__ */ new Map();
    for (const root of roots) {
      root.querySelectorAll("input,textarea,[contenteditable]").forEach((element) => {
        elements.set(element, {
          value: element.style.getPropertyValue("caret-color"),
          priority: element.style.getPropertyPriority("caret-color")
        });
        element.style.setProperty("caret-color", "transparent", "important");
      });
    }
    cleanupCallbacks.push(() => {
      for (const [element, value] of elements)
        element.style.setProperty("caret-color", value.value, value.priority);
    });
  }
  if (disableAnimations) {
    const infiniteAnimationsToResume = /* @__PURE__ */ new Set();
    const handleAnimations = /* @__PURE__ */ __name((root) => {
      for (const animation of root.getAnimations()) {
        if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))
          continue;
        const endTime = animation.effect.getComputedTiming().endTime;
        if (Number.isFinite(endTime)) {
          try {
            animation.finish();
          } catch (e) {
          }
        } else {
          try {
            animation.cancel();
            infiniteAnimationsToResume.add(animation);
          } catch (e) {
          }
        }
      }
    }, "handleAnimations");
    for (const root of roots) {
      const handleRootAnimations = handleAnimations.bind(null, root);
      handleRootAnimations();
      root.addEventListener("transitionrun", handleRootAnimations);
      root.addEventListener("animationstart", handleRootAnimations);
      cleanupCallbacks.push(() => {
        root.removeEventListener("transitionrun", handleRootAnimations);
        root.removeEventListener("animationstart", handleRootAnimations);
      });
    }
    cleanupCallbacks.push(() => {
      for (const animation of infiniteAnimationsToResume) {
        try {
          animation.play();
        } catch (e) {
        }
      }
    });
  }
  window.__pwCleanupScreenshot = () => {
    for (const cleanupCallback of cleanupCallbacks)
      cleanupCallback();
    delete window.__pwCleanupScreenshot;
  };
}
__name(inPagePrepareForScreenshots, "inPagePrepareForScreenshots");
var Screenshotter = class {
  static {
    __name(this, "Screenshotter");
  }
  constructor(page) {
    this._queue = new TaskQueue();
    this._page = page;
    this._queue = new TaskQueue();
  }
  async _originalViewportSize(progress3) {
    let viewportSize = this._page.emulatedSize()?.viewport;
    if (!viewportSize)
      viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ width: window.innerWidth, height: window.innerHeight }));
    return viewportSize;
  }
  async _fullPageSize(progress3) {
    const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => {
      if (!document.body || !document.documentElement)
        return null;
      return {
        width: Math.max(
          document.body.scrollWidth,
          document.documentElement.scrollWidth,
          document.body.offsetWidth,
          document.documentElement.offsetWidth,
          document.body.clientWidth,
          document.documentElement.clientWidth
        ),
        height: Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight,
          document.body.offsetHeight,
          document.documentElement.offsetHeight,
          document.body.clientHeight,
          document.documentElement.clientHeight
        )
      };
    });
    return fullPageSize;
  }
  async screenshotPage(progress3, options2) {
    const format2 = validateScreenshotOptions(options2);
    return this._queue.postTask(async () => {
      progress3.log("taking page screenshot");
      const viewportSize = await this._originalViewportSize(progress3);
      await this._preparePageForScreenshot(progress3, this._page.mainFrame(), options2.style, options2.caret !== "initial", options2.animations === "disabled");
      try {
        if (options2.fullPage) {
          const fullPageSize = await this._fullPageSize(progress3);
          let documentRect = { x: 0, y: 0, width: fullPageSize.width, height: fullPageSize.height };
          const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
          if (options2.clip)
            documentRect = trimClipToSize(options2.clip, documentRect);
          return await this._screenshot(progress3, format2, documentRect, void 0, fitsViewport, options2);
        }
        const viewportRect = options2.clip ? trimClipToSize(options2.clip, viewportSize) : { x: 0, y: 0, ...viewportSize };
        return await this._screenshot(progress3, format2, void 0, viewportRect, true, options2);
      } finally {
        await this._restorePageAfterScreenshot();
      }
    });
  }
  async screenshotElement(progress3, handle, options2) {
    const format2 = validateScreenshotOptions(options2);
    return this._queue.postTask(async () => {
      progress3.log("taking element screenshot");
      const viewportSize = await this._originalViewportSize(progress3);
      await this._preparePageForScreenshot(progress3, handle._frame, options2.style, options2.caret !== "initial", options2.animations === "disabled");
      try {
        await handle._waitAndScrollIntoViewIfNeeded(
          progress3,
          true
          /* waitForVisible */
        );
        const boundingBox = await progress3.race(handle.boundingBox());
        assert3(boundingBox, "Node is either not visible or not an HTMLElement");
        assert3(boundingBox.width !== 0, "Node has 0 width.");
        assert3(boundingBox.height !== 0, "Node has 0 height.");
        const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
        const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ x: window.scrollX, y: window.scrollY }));
        const documentRect = { ...boundingBox };
        documentRect.x += scrollOffset.x;
        documentRect.y += scrollOffset.y;
        return await this._screenshot(progress3, format2, helper.enclosingIntRect(documentRect), void 0, fitsViewport, options2);
      } finally {
        await this._restorePageAfterScreenshot();
      }
    });
  }
  async _preparePageForScreenshot(progress3, frame, screenshotStyle, hideCaret, disableAnimations) {
    if (disableAnimations)
      progress3.log("  disabled all CSS animations");
    const syncAnimations = this._page.delegate.shouldToggleStyleSheetToSyncAnimations();
    const script = `((__name => (${inPagePrepareForScreenshots.toString()}))(t => t))`;
    await progress3.race(this._page.safeNonStallingEvaluateInAllFrames("(" + script + `)(${JSON.stringify(screenshotStyle)}, ${hideCaret}, ${disableAnimations}, ${syncAnimations})`, "utility"));
    try {
      if (!process.env.PW_TEST_SCREENSHOT_NO_FONTS_READY) {
        progress3.log("waiting for fonts to load...");
        await progress3.race(frame.nonStallingEvaluateInExistingContext("document.fonts.ready", "utility").catch(() => {
        }));
        progress3.log("fonts loaded");
      }
    } catch (error3) {
      await this._restorePageAfterScreenshot();
      throw error3;
    }
  }
  async _restorePageAfterScreenshot() {
    await this._page.safeNonStallingEvaluateInAllFrames("window.__pwCleanupScreenshot && window.__pwCleanupScreenshot()", "utility");
  }
  async _maskElements(progress3, options2) {
    if (!options2.mask || !options2.mask.length)
      return () => Promise.resolve();
    const framesToParsedSelectors = new MultiMap();
    await progress3.race(Promise.all((options2.mask || []).map(async ({ frame, selector }) => {
      const pair = await frame.selectors.resolveFrameForSelector(selector);
      if (pair)
        framesToParsedSelectors.set(pair.frame, pair.info.parsed);
    })));
    const frames = [...framesToParsedSelectors.keys()];
    const cleanup = /* @__PURE__ */ __name(async () => {
      await Promise.all(frames.map((frame) => frame.hideHighlight()));
    }, "cleanup");
    try {
      const promises = frames.map((frame) => frame.maskSelectors(framesToParsedSelectors.get(frame), options2.maskColor || "#F0F"));
      await progress3.race(Promise.all(promises));
      return cleanup;
    } catch (error3) {
      cleanup().catch(() => {
      });
      throw error3;
    }
  }
  async _screenshot(progress3, format2, documentRect, viewportRect, fitsViewport, options2) {
    if (options2.__testHookBeforeScreenshot)
      await progress3.race(options2.__testHookBeforeScreenshot());
    const shouldSetDefaultBackground = options2.omitBackground && format2 === "png";
    if (shouldSetDefaultBackground)
      await progress3.race(this._page.delegate.setBackgroundColor({ r: 0, g: 0, b: 0, a: 0 }));
    const cleanupHighlight = await this._maskElements(progress3, options2);
    try {
      const quality = format2 === "jpeg" ? options2.quality ?? 80 : void 0;
      const buffer = await this._page.delegate.takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, options2.scale || "device");
      await cleanupHighlight();
      if (shouldSetDefaultBackground)
        await this._page.delegate.setBackgroundColor();
      if (options2.__testHookAfterScreenshot)
        await progress3.race(options2.__testHookAfterScreenshot());
      return buffer;
    } catch (error3) {
      cleanupHighlight().catch(() => {
      });
      if (shouldSetDefaultBackground)
        this._page.delegate.setBackgroundColor().catch(() => {
        });
      throw error3;
    }
  }
};
var TaskQueue = class {
  static {
    __name(this, "TaskQueue");
  }
  constructor() {
    this._chain = Promise.resolve();
  }
  postTask(task) {
    const result = this._chain.then(task);
    this._chain = result.catch(() => {
    });
    return result;
  }
};
function trimClipToSize(clip, size) {
  const p1 = {
    x: Math.max(0, Math.min(clip.x, size.width)),
    y: Math.max(0, Math.min(clip.y, size.height))
  };
  const p2 = {
    x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
    y: Math.max(0, Math.min(clip.y + clip.height, size.height))
  };
  const result = { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
  assert3(result.width && result.height, "Clipped area is either empty or outside the resulting image");
  return result;
}
__name(trimClipToSize, "trimClipToSize");
function validateScreenshotOptions(options2) {
  let format2 = null;
  if (options2.type) {
    assert3(options2.type === "png" || options2.type === "jpeg", "Unknown options.type value: " + options2.type);
    format2 = options2.type;
  }
  if (!format2)
    format2 = "png";
  if (options2.quality !== void 0) {
    assert3(format2 === "jpeg", "options.quality is unsupported for the " + format2 + " screenshots");
    assert3(typeof options2.quality === "number", "Expected options.quality to be a number but found " + typeof options2.quality);
    assert3(Number.isInteger(options2.quality), "Expected options.quality to be an integer");
    assert3(options2.quality >= 0 && options2.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options2.quality);
  }
  if (options2.clip) {
    assert3(typeof options2.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options2.clip.x);
    assert3(typeof options2.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options2.clip.y);
    assert3(typeof options2.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options2.clip.width);
    assert3(typeof options2.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options2.clip.height);
    assert3(options2.clip.width !== 0, "Expected options.clip.width not to be 0.");
    assert3(options2.clip.height !== 0, "Expected options.clip.height not to be 0.");
  }
  return format2;
}
__name(validateScreenshotOptions, "validateScreenshotOptions");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/protocolFormatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function formatProtocolParam(params, alternatives) {
  if (!params)
    return void 0;
  for (const name of alternatives.split("|")) {
    if (name === "url") {
      try {
        const urlObject = new URL(params[name]);
        if (urlObject.protocol === "data:")
          return urlObject.protocol;
        if (urlObject.protocol === "about:")
          return params[name];
        return urlObject.pathname + urlObject.search;
      } catch (error3) {
        if (params[name] !== void 0)
          return params[name];
      }
    }
    if (name === "timeNumber" && params[name] !== void 0) {
      return new Date(params[name]).toString();
    }
    const value = deepParam(params, name);
    if (value !== void 0)
      return value;
  }
}
__name(formatProtocolParam, "formatProtocolParam");
function deepParam(params, name) {
  const tokens = name.split(".");
  let current = params;
  for (const token of tokens) {
    if (typeof current !== "object" || current === null)
      return void 0;
    current = current[token];
  }
  if (current === void 0)
    return void 0;
  return String(current);
}
__name(deepParam, "deepParam");
function renderTitleForCall(metadata) {
  const titleFormat = metadata.title ?? methodMetainfo.get(metadata.type + "." + metadata.method)?.title ?? metadata.method;
  return titleFormat.replace(/\{([^}]+)\}/g, (fullMatch, p1) => {
    return formatProtocolParam(metadata.params, p1) ?? fullMatch;
  });
}
__name(renderTitleForCall, "renderTitleForCall");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/comparators.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/image_tools/compare.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/image_tools/colorUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function blendWithWhite(c, a) {
  return 255 + (c - 255) * a;
}
__name(blendWithWhite, "blendWithWhite");
function rgb2gray(r, g, b) {
  return 77 * r + 150 * g + 29 * b + 128 >> 8;
}
__name(rgb2gray, "rgb2gray");
function colorDeltaE94(rgb1, rgb2) {
  const [l1, a1, b1] = xyz2lab(srgb2xyz(rgb1));
  const [l2, a2, b2] = xyz2lab(srgb2xyz(rgb2));
  const deltaL = l1 - l2;
  const deltaA = a1 - a2;
  const deltaB = b1 - b2;
  const c1 = Math.sqrt(a1 ** 2 + b1 ** 2);
  const c2 = Math.sqrt(a2 ** 2 + b2 ** 2);
  const deltaC = c1 - c2;
  let deltaH = deltaA ** 2 + deltaB ** 2 - deltaC ** 2;
  deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
  const k1 = 0.045;
  const k2 = 0.015;
  const kL = 1;
  const kC = 1;
  const kH = 1;
  const sC = 1 + k1 * c1;
  const sH = 1 + k2 * c1;
  const sL = 1;
  return Math.sqrt((deltaL / sL / kL) ** 2 + (deltaC / sC / kC) ** 2 + (deltaH / sH / kH) ** 2);
}
__name(colorDeltaE94, "colorDeltaE94");
function srgb2xyz(rgb) {
  let r = rgb[0] / 255;
  let g = rgb[1] / 255;
  let b = rgb[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  return [
    r * 0.4124 + g * 0.3576 + b * 0.1805,
    r * 0.2126 + g * 0.7152 + b * 0.0722,
    r * 0.0193 + g * 0.1192 + b * 0.9505
  ];
}
__name(srgb2xyz, "srgb2xyz");
var sigma_pow2 = 6 * 6 / 29 / 29;
var sigma_pow3 = 6 * 6 * 6 / 29 / 29 / 29;
function xyz2lab(xyz) {
  const x = xyz[0] / 0.950489;
  const y = xyz[1];
  const z = xyz[2] / 1.08884;
  const fx = x > sigma_pow3 ? x ** (1 / 3) : x / 3 / sigma_pow2 + 4 / 29;
  const fy = y > sigma_pow3 ? y ** (1 / 3) : y / 3 / sigma_pow2 + 4 / 29;
  const fz = z > sigma_pow3 ? z ** (1 / 3) : z / 3 / sigma_pow2 + 4 / 29;
  const l = 116 * fy - 16;
  const a = 500 * (fx - fy);
  const b = 200 * (fy - fz);
  return [l, a, b];
}
__name(xyz2lab, "xyz2lab");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/image_tools/imageChannel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ImageChannel = class _ImageChannel {
  static {
    __name(this, "ImageChannel");
  }
  static intoRGB(width, height, data, options2 = {}) {
    const {
      paddingSize = 0,
      paddingColorOdd = [255, 0, 255],
      paddingColorEven = [0, 255, 0]
    } = options2;
    const newWidth = width + 2 * paddingSize;
    const newHeight = height + 2 * paddingSize;
    const r = new Uint8Array(newWidth * newHeight);
    const g = new Uint8Array(newWidth * newHeight);
    const b = new Uint8Array(newWidth * newHeight);
    for (let y = 0; y < newHeight; ++y) {
      for (let x = 0; x < newWidth; ++x) {
        const index2 = y * newWidth + x;
        if (y >= paddingSize && y < newHeight - paddingSize && x >= paddingSize && x < newWidth - paddingSize) {
          const offset = ((y - paddingSize) * width + (x - paddingSize)) * 4;
          const alpha = data[offset + 3] === 255 ? 1 : data[offset + 3] / 255;
          r[index2] = blendWithWhite(data[offset], alpha);
          g[index2] = blendWithWhite(data[offset + 1], alpha);
          b[index2] = blendWithWhite(data[offset + 2], alpha);
        } else {
          const color = (y + x) % 2 === 0 ? paddingColorEven : paddingColorOdd;
          r[index2] = color[0];
          g[index2] = color[1];
          b[index2] = color[2];
        }
      }
    }
    return [
      new _ImageChannel(newWidth, newHeight, r),
      new _ImageChannel(newWidth, newHeight, g),
      new _ImageChannel(newWidth, newHeight, b)
    ];
  }
  constructor(width, height, data) {
    this.data = data;
    this.width = width;
    this.height = height;
  }
  get(x, y) {
    return this.data[y * this.width + x];
  }
  boundXY(x, y) {
    return [
      Math.min(Math.max(x, 0), this.width - 1),
      Math.min(Math.max(y, 0), this.height - 1)
    ];
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/image_tools/stats.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DYNAMIC_RANGE = 2 ** 8 - 1;
function ssim(stats, x1, y1, x2, y2) {
  const mean1 = stats.meanC1(x1, y1, x2, y2);
  const mean2 = stats.meanC2(x1, y1, x2, y2);
  const var1 = stats.varianceC1(x1, y1, x2, y2);
  const var2 = stats.varianceC2(x1, y1, x2, y2);
  const cov = stats.covariance(x1, y1, x2, y2);
  const c1 = (0.01 * DYNAMIC_RANGE) ** 2;
  const c2 = (0.03 * DYNAMIC_RANGE) ** 2;
  return (2 * mean1 * mean2 + c1) * (2 * cov + c2) / (mean1 ** 2 + mean2 ** 2 + c1) / (var1 + var2 + c2);
}
__name(ssim, "ssim");
var FastStats = class {
  static {
    __name(this, "FastStats");
  }
  constructor(c1, c2) {
    this.c1 = c1;
    this.c2 = c2;
    const { width, height } = c1;
    this._partialSumC1 = new Array(width * height);
    this._partialSumC2 = new Array(width * height);
    this._partialSumSq1 = new Array(width * height);
    this._partialSumSq2 = new Array(width * height);
    this._partialSumMult = new Array(width * height);
    const recalc = /* @__PURE__ */ __name((mx, idx, initial, x, y) => {
      mx[idx] = initial;
      if (y > 0)
        mx[idx] += mx[(y - 1) * width + x];
      if (x > 0)
        mx[idx] += mx[y * width + x - 1];
      if (x > 0 && y > 0)
        mx[idx] -= mx[(y - 1) * width + x - 1];
    }, "recalc");
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const idx = y * width + x;
        recalc(this._partialSumC1, idx, this.c1.data[idx], x, y);
        recalc(this._partialSumC2, idx, this.c2.data[idx], x, y);
        recalc(this._partialSumSq1, idx, this.c1.data[idx] * this.c1.data[idx], x, y);
        recalc(this._partialSumSq2, idx, this.c2.data[idx] * this.c2.data[idx], x, y);
        recalc(this._partialSumMult, idx, this.c1.data[idx] * this.c2.data[idx], x, y);
      }
    }
  }
  _sum(partialSum, x1, y1, x2, y2) {
    const width = this.c1.width;
    let result = partialSum[y2 * width + x2];
    if (y1 > 0)
      result -= partialSum[(y1 - 1) * width + x2];
    if (x1 > 0)
      result -= partialSum[y2 * width + x1 - 1];
    if (x1 > 0 && y1 > 0)
      result += partialSum[(y1 - 1) * width + x1 - 1];
    return result;
  }
  meanC1(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return this._sum(this._partialSumC1, x1, y1, x2, y2) / N;
  }
  meanC2(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return this._sum(this._partialSumC2, x1, y1, x2, y2) / N;
  }
  varianceC1(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumSq1, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) ** 2 / N) / N;
  }
  varianceC2(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumSq2, x1, y1, x2, y2) - this._sum(this._partialSumC2, x1, y1, x2, y2) ** 2 / N) / N;
  }
  covariance(x1, y1, x2, y2) {
    const N = (y2 - y1 + 1) * (x2 - x1 + 1);
    return (this._sum(this._partialSumMult, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) * this._sum(this._partialSumC2, x1, y1, x2, y2) / N) / N;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/image_tools/compare.js
var SSIM_WINDOW_RADIUS = 15;
var VARIANCE_WINDOW_RADIUS = 1;
function drawPixel(width, data, x, y, r, g, b) {
  const idx = (y * width + x) * 4;
  data[idx + 0] = r;
  data[idx + 1] = g;
  data[idx + 2] = b;
  data[idx + 3] = 255;
}
__name(drawPixel, "drawPixel");
function compare(actual, expected, diff4, width, height, options2 = {}) {
  const {
    maxColorDeltaE94 = 1
  } = options2;
  const paddingSize = Math.max(VARIANCE_WINDOW_RADIUS, SSIM_WINDOW_RADIUS);
  const paddingColorEven = [255, 0, 255];
  const paddingColorOdd = [0, 255, 0];
  const [r1, g1, b1] = ImageChannel.intoRGB(width, height, expected, {
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
  const [r2, g2, b2] = ImageChannel.intoRGB(width, height, actual, {
    paddingSize,
    paddingColorEven,
    paddingColorOdd
  });
  const noop = /* @__PURE__ */ __name((x, y) => {
  }, "noop");
  const drawRedPixel = diff4 ? (x, y) => drawPixel(width, diff4, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;
  const drawYellowPixel = diff4 ? (x, y) => drawPixel(width, diff4, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;
  const drawGrayPixel = diff4 ? (x, y) => {
    const gray = rgb2gray(r1.get(x, y), g1.get(x, y), b1.get(x, y));
    const value = blendWithWhite(gray, 0.1);
    drawPixel(width, diff4, x - paddingSize, y - paddingSize, value, value, value);
  } : noop;
  let fastR, fastG, fastB;
  let diffCount = 0;
  for (let y = paddingSize; y < r1.height - paddingSize; ++y) {
    for (let x = paddingSize; x < r1.width - paddingSize; ++x) {
      if (r1.get(x, y) === r2.get(x, y) && g1.get(x, y) === g2.get(x, y) && b1.get(x, y) === b2.get(x, y)) {
        drawGrayPixel(x, y);
        continue;
      }
      const delta = colorDeltaE94(
        [r1.get(x, y), g1.get(x, y), b1.get(x, y)],
        [r2.get(x, y), g2.get(x, y), b2.get(x, y)]
      );
      if (delta <= maxColorDeltaE94) {
        drawGrayPixel(x, y);
        continue;
      }
      if (!fastR || !fastG || !fastB) {
        fastR = new FastStats(r1, r2);
        fastG = new FastStats(g1, g2);
        fastB = new FastStats(b1, b2);
      }
      const [varX1, varY1] = r1.boundXY(x - VARIANCE_WINDOW_RADIUS, y - VARIANCE_WINDOW_RADIUS);
      const [varX2, varY2] = r1.boundXY(x + VARIANCE_WINDOW_RADIUS, y + VARIANCE_WINDOW_RADIUS);
      const var1 = fastR.varianceC1(varX1, varY1, varX2, varY2) + fastG.varianceC1(varX1, varY1, varX2, varY2) + fastB.varianceC1(varX1, varY1, varX2, varY2);
      const var2 = fastR.varianceC2(varX1, varY1, varX2, varY2) + fastG.varianceC2(varX1, varY1, varX2, varY2) + fastB.varianceC2(varX1, varY1, varX2, varY2);
      if (var1 === 0 || var2 === 0) {
        drawRedPixel(x, y);
        ++diffCount;
        continue;
      }
      const [ssimX1, ssimY1] = r1.boundXY(x - SSIM_WINDOW_RADIUS, y - SSIM_WINDOW_RADIUS);
      const [ssimX2, ssimY2] = r1.boundXY(x + SSIM_WINDOW_RADIUS, y + SSIM_WINDOW_RADIUS);
      const ssimRGB = (ssim(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + ssim(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + ssim(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3;
      const isAntialiased = ssimRGB >= 0.99;
      if (isAntialiased) {
        drawYellowPixel(x, y);
      } else {
        drawRedPixel(x, y);
        ++diffCount;
      }
    }
  }
  return diffCount;
}
__name(compare, "compare");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/comparators.js
function getComparator(mimeType) {
  if (mimeType === "image/png")
    return compareImages.bind(null, "image/png");
  if (mimeType === "image/jpeg")
    return compareImages.bind(null, "image/jpeg");
  if (mimeType === "text/plain")
    return compareText;
  return compareBuffersOrStrings;
}
__name(getComparator, "getComparator");
var JPEG_JS_MAX_BUFFER_SIZE_IN_MB = 5 * 1024;
function compareBuffersOrStrings(actualBuffer, expectedBuffer) {
  if (typeof actualBuffer === "string")
    return compareText(actualBuffer, expectedBuffer);
  if (!actualBuffer || !(actualBuffer instanceof Buffer))
    return { errorMessage: "Actual result should be a Buffer or a string." };
  if (Buffer.compare(actualBuffer, expectedBuffer))
    return { errorMessage: "Buffers differ" };
  return null;
}
__name(compareBuffersOrStrings, "compareBuffersOrStrings");
function compareImages(mimeType, actualBuffer, expectedBuffer, options2 = {}) {
  if (!actualBuffer || !(actualBuffer instanceof Buffer))
    return { errorMessage: "Actual result should be a Buffer." };
  validateBuffer(expectedBuffer, mimeType);
  let actual = mimeType === "image/png" ? PNG2.sync.read(actualBuffer) : jpegjs2.decode(actualBuffer, { maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB });
  let expected = mimeType === "image/png" ? PNG2.sync.read(expectedBuffer) : jpegjs2.decode(expectedBuffer, { maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB });
  const size = { width: Math.max(expected.width, actual.width), height: Math.max(expected.height, actual.height) };
  let sizesMismatchError = "";
  if (expected.width !== actual.width || expected.height !== actual.height) {
    sizesMismatchError = `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `;
    actual = resizeImage(actual, size);
    expected = resizeImage(expected, size);
  }
  const diff22 = new PNG2({ width: size.width, height: size.height });
  let count3;
  if (options2.comparator === "ssim-cie94") {
    count3 = compare(expected.data, actual.data, diff22.data, size.width, size.height, {
      // All E* formulae are originally designed to have the difference of 1.0 stand for a "just noticeable difference" (JND).
      // See https://en.wikipedia.org/wiki/Color_difference#CIELAB_%CE%94E*
      maxColorDeltaE94: 1
    });
  } else if ((options2.comparator ?? "pixelmatch") === "pixelmatch") {
    count3 = pixelmatch(expected.data, actual.data, diff22.data, size.width, size.height, {
      threshold: options2.threshold ?? 0.2
    });
  } else {
    throw new Error(`Configuration specifies unknown comparator "${options2.comparator}"`);
  }
  const maxDiffPixels1 = options2.maxDiffPixels;
  const maxDiffPixels2 = options2.maxDiffPixelRatio !== void 0 ? expected.width * expected.height * options2.maxDiffPixelRatio : void 0;
  let maxDiffPixels;
  if (maxDiffPixels1 !== void 0 && maxDiffPixels2 !== void 0)
    maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);
  else
    maxDiffPixels = maxDiffPixels1 ?? maxDiffPixels2 ?? 0;
  const ratio = Math.ceil(count3 / (expected.width * expected.height) * 100) / 100;
  const pixelsMismatchError = count3 > maxDiffPixels ? `${count3} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different.` : "";
  if (pixelsMismatchError || sizesMismatchError)
    return { errorMessage: sizesMismatchError + pixelsMismatchError, diff: PNG2.sync.write(diff22) };
  return null;
}
__name(compareImages, "compareImages");
function validateBuffer(buffer, mimeType) {
  if (mimeType === "image/png") {
    const pngMagicNumber = [137, 80, 78, 71, 13, 10, 26, 10];
    if (buffer.length < pngMagicNumber.length || !pngMagicNumber.every((byte, index2) => buffer[index2] === byte))
      throw new Error("could not decode image as PNG.");
  } else if (mimeType === "image/jpeg") {
    const jpegMagicNumber = [255, 216];
    if (buffer.length < jpegMagicNumber.length || !jpegMagicNumber.every((byte, index2) => buffer[index2] === byte))
      throw new Error("could not decode image as JPEG.");
  }
}
__name(validateBuffer, "validateBuffer");
function compareText(actual, expectedBuffer) {
  if (typeof actual !== "string")
    return { errorMessage: "Actual result should be a string" };
  let expected = expectedBuffer.toString("utf-8");
  if (expected === actual)
    return null;
  if (!actual.endsWith("\n"))
    actual += "\n";
  if (!expected.endsWith("\n"))
    expected += "\n";
  const lines = diff3.createPatch("file", expected, actual, void 0, void 0, { context: 5 }).split("\n");
  const coloredLines = lines.slice(4).map((line) => {
    if (line.startsWith("-"))
      return colors2.green(line);
    if (line.startsWith("+"))
      return colors2.red(line);
    if (line.startsWith("@@"))
      return colors2.dim(line);
    return line;
  });
  const errorMessage = coloredLines.join("\n");
  return { errorMessage };
}
__name(compareText, "compareText");
function resizeImage(image, size) {
  if (image.width === size.width && image.height === size.height)
    return image;
  const buffer = new Uint8Array(size.width * size.height * 4);
  for (let y = 0; y < size.height; y++) {
    for (let x = 0; x < size.width; x++) {
      const to = (y * size.width + x) * 4;
      if (y < image.height && x < image.width) {
        const from = (y * image.width + x) * 4;
        buffer[to] = image.data[from];
        buffer[to + 1] = image.data[from + 1];
        buffer[to + 2] = image.data[from + 2];
        buffer[to + 3] = image.data[from + 3];
      } else {
        buffer[to] = 0;
        buffer[to + 1] = 0;
        buffer[to + 2] = 0;
        buffer[to + 3] = 0;
      }
    }
  }
  return { data: Buffer.from(buffer), width: size.width, height: size.height };
}
__name(resizeImage, "resizeImage");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/page.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/bindingsControllerSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source4 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/bindingsController.ts\nvar bindingsController_exports = {};\n__export(bindingsController_exports, {\n  BindingsController: () => BindingsController\n});\nmodule.exports = __toCommonJS(bindingsController_exports);\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a;\n  try {\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/bindingsController.ts\nvar BindingsController = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(global, globalBindingName) {\n    this._bindings = /* @__PURE__ */ new Map();\n    this._global = global;\n    this._globalBindingName = globalBindingName;\n  }\n  addBinding(bindingName, needsHandle) {\n    const data = {\n      callbacks: /* @__PURE__ */ new Map(),\n      lastSeq: 0,\n      handles: /* @__PURE__ */ new Map(),\n      removed: false\n    };\n    this._bindings.set(bindingName, data);\n    this._global[bindingName] = (...args) => {\n      if (data.removed)\n        throw new Error(`binding "${bindingName}" has been removed`);\n      if (needsHandle && args.slice(1).some((arg) => arg !== void 0))\n        throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);\n      const seq = ++data.lastSeq;\n      const promise = new Promise((resolve, reject) => data.callbacks.set(seq, { resolve, reject }));\n      let payload;\n      if (needsHandle) {\n        data.handles.set(seq, args[0]);\n        payload = { name: bindingName, seq };\n      } else {\n        const serializedArgs = [];\n        for (let i = 0; i < args.length; i++) {\n          serializedArgs[i] = serializeAsCallArgument(args[i], (v) => {\n            return { fallThrough: v };\n          });\n        }\n        payload = { name: bindingName, seq, serializedArgs };\n      }\n      this._global[this._globalBindingName](JSON.stringify(payload));\n      return promise;\n    };\n  }\n  removeBinding(bindingName) {\n    const data = this._bindings.get(bindingName);\n    if (data)\n      data.removed = true;\n    this._bindings.delete(bindingName);\n    delete this._global[bindingName];\n  }\n  takeBindingHandle(arg) {\n    const handles = this._bindings.get(arg.name).handles;\n    const handle = handles.get(arg.seq);\n    handles.delete(arg.seq);\n    return handle;\n  }\n  deliverBindingResult(arg) {\n    const callbacks = this._bindings.get(arg.name).callbacks;\n    if ("error" in arg)\n      callbacks.get(arg.seq).reject(arg.error);\n    else\n      callbacks.get(arg.seq).resolve(arg.result);\n    callbacks.delete(arg.seq);\n  }\n};\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/page.js
var Page = class _Page extends SdkObject {
  static {
    __name(this, "Page");
  }
  constructor(delegate, browserContext) {
    super(browserContext, "page");
    this._closedState = "open";
    this._closedPromise = new ManualPromise();
    this._initializedPromise = new ManualPromise();
    this._eventsToEmitAfterInitialized = [];
    this._crashed = false;
    this.openScope = new LongStandingScope();
    this._emulatedMedia = {};
    this._fileChooserInterceptedBy = /* @__PURE__ */ new Set();
    this._pageBindings = /* @__PURE__ */ new Map();
    this.initScripts = [];
    this._workers = /* @__PURE__ */ new Map();
    this.requestInterceptors = [];
    this.video = null;
    this._locatorHandlers = /* @__PURE__ */ new Map();
    this._lastLocatorHandlerUid = 0;
    this._locatorHandlerRunningCounter = 0;
    this._frameThrottler = new FrameThrottler(10, 35, 200);
    this.lastSnapshotFrameIds = [];
    this.attribution.page = this;
    this.delegate = delegate;
    this.browserContext = browserContext;
    this.accessibility = new Accessibility(delegate.getAccessibilityTree.bind(delegate));
    this.keyboard = new Keyboard(delegate.rawKeyboard, this);
    this.mouse = new Mouse(delegate.rawMouse, this);
    this.touchscreen = new Touchscreen(delegate.rawTouchscreen, this);
    this.screenshotter = new Screenshotter(this);
    this.frameManager = new FrameManager(this);
    if (delegate.pdf)
      this.pdf = delegate.pdf.bind(delegate);
    this.coverage = delegate.coverage ? delegate.coverage() : null;
    this.isStorageStatePage = browserContext.isCreatingStorageStatePage();
  }
  static {
    this.Events = {
      Close: "close",
      Crash: "crash",
      Download: "download",
      EmulatedSizeChanged: "emulatedsizechanged",
      FileChooser: "filechooser",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      LocatorHandlerTriggered: "locatorhandlertriggered",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
  }
  async reportAsNew(opener, error3 = void 0, contextEvent = BrowserContext.Events.Page) {
    if (opener) {
      const openerPageOrError = await opener.waitForInitializedOrError();
      if (openerPageOrError instanceof _Page && !openerPageOrError.isClosed())
        this._opener = openerPageOrError;
    }
    this._markInitialized(error3, contextEvent);
  }
  _markInitialized(error3 = void 0, contextEvent = BrowserContext.Events.Page) {
    if (error3) {
      if (this.browserContext.isClosingOrClosed())
        return;
      this.frameManager.createDummyMainFrameIfNeeded();
    }
    this._initialized = error3 || this;
    this.emitOnContext(contextEvent, this);
    for (const { event, args } of this._eventsToEmitAfterInitialized)
      this.browserContext.emit(event, ...args);
    this._eventsToEmitAfterInitialized = [];
    if (this.isClosed())
      this.emit(_Page.Events.Close);
    else
      this.instrumentation.onPageOpen(this);
    this._initializedPromise.resolve(this._initialized);
  }
  initializedOrUndefined() {
    return this._initialized ? this : void 0;
  }
  waitForInitializedOrError() {
    return this._initializedPromise;
  }
  emitOnContext(event, ...args) {
    if (this.isStorageStatePage)
      return;
    this.browserContext.emit(event, ...args);
  }
  emitOnContextOnceInitialized(event, ...args) {
    if (this.isStorageStatePage)
      return;
    if (this._initialized)
      this.browserContext.emit(event, ...args);
    else
      this._eventsToEmitAfterInitialized.push({ event, args });
  }
  async resetForReuse(progress3) {
    await this.mainFrame().gotoImpl(progress3, "about:blank", {});
    this._emulatedSize = void 0;
    this._emulatedMedia = {};
    this._extraHTTPHeaders = void 0;
    await Promise.all([
      this.delegate.updateEmulatedViewportSize(),
      this.delegate.updateEmulateMedia(),
      this.delegate.updateExtraHTTPHeaders()
    ]);
    await this.delegate.resetForReuse(progress3);
  }
  _didClose() {
    this.frameManager.dispose();
    this._frameThrottler.dispose();
    assert3(this._closedState !== "closed", "Page closed twice");
    this._closedState = "closed";
    this.emit(_Page.Events.Close);
    this._closedPromise.resolve();
    this.instrumentation.onPageClose(this);
    this.openScope.close(new TargetClosedError());
  }
  _didCrash() {
    this.frameManager.dispose();
    this._frameThrottler.dispose();
    this.emit(_Page.Events.Crash);
    this._crashed = true;
    this.instrumentation.onPageClose(this);
    this.openScope.close(new Error("Page crashed"));
  }
  async _onFileChooserOpened(handle) {
    let multiple;
    try {
      multiple = await handle.evaluate((element) => !!element.multiple);
    } catch (e) {
      return;
    }
    if (!this.listenerCount(_Page.Events.FileChooser)) {
      handle.dispose();
      return;
    }
    const fileChooser = new FileChooser(this, handle, multiple);
    this.emit(_Page.Events.FileChooser, fileChooser);
  }
  opener() {
    return this._opener;
  }
  mainFrame() {
    return this.frameManager.mainFrame();
  }
  frames() {
    return this.frameManager.frames();
  }
  async exposeBinding(progress3, name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered`);
    if (this.browserContext._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered in the browser context`);
    await progress3.race(this.browserContext.exposePlaywrightBindingIfNeeded());
    const binding3 = new PageBinding(name, playwrightBinding, needsHandle);
    this._pageBindings.set(name, binding3);
    try {
      await progress3.race(this.delegate.addInitScript(binding3.initScript));
      await progress3.race(this.safeNonStallingEvaluateInAllFrames(binding3.initScript.source, "main"));
      return binding3;
    } catch (error3) {
      this._pageBindings.delete(name);
      throw error3;
    }
  }
  async removeExposedBindings(bindings) {
    bindings = bindings.filter((binding3) => this._pageBindings.get(binding3.name) === binding3);
    for (const binding3 of bindings)
      this._pageBindings.delete(binding3.name);
    await this.delegate.removeInitScripts(bindings.map((binding3) => binding3.initScript));
    const cleanup = bindings.map((binding3) => `{ ${binding3.cleanupScript} };
`).join("");
    await this.safeNonStallingEvaluateInAllFrames(cleanup, "main");
  }
  async setExtraHTTPHeaders(progress3, headers) {
    const oldHeaders = this._extraHTTPHeaders;
    try {
      this._extraHTTPHeaders = headers;
      await progress3.race(this.delegate.updateExtraHTTPHeaders());
    } catch (error3) {
      this._extraHTTPHeaders = oldHeaders;
      this.delegate.updateExtraHTTPHeaders().catch(() => {
      });
      throw error3;
    }
  }
  extraHTTPHeaders() {
    return this._extraHTTPHeaders;
  }
  async onBindingCalled(payload, context2) {
    if (this._closedState === "closed")
      return;
    await PageBinding.dispatch(this, payload, context2);
  }
  addConsoleMessage(type, args, location2, text) {
    const message = new ConsoleMessage(this, type, text, args, location2);
    const intercepted = this.frameManager.interceptConsoleMessage(message);
    if (intercepted) {
      args.forEach((arg) => arg.dispose());
      return;
    }
    this.emitOnContextOnceInitialized(BrowserContext.Events.Console, message);
  }
  async reload(progress3, options2) {
    return this.mainFrame().raceNavigationAction(progress3, async () => {
      const [response] = await Promise.all([
        // Reload must be a new document, and should not be confused with a stray pushState.
        this.mainFrame()._waitForNavigation(progress3, true, options2),
        progress3.race(this.delegate.reload())
      ]);
      return response;
    });
  }
  async goBack(progress3, options2) {
    return this.mainFrame().raceNavigationAction(progress3, async () => {
      let error3;
      const waitPromise = this.mainFrame()._waitForNavigation(progress3, false, options2).catch((e) => {
        error3 = e;
        return null;
      });
      const result = await progress3.race(this.delegate.goBack());
      if (!result) {
        waitPromise.catch(() => {
        });
        return null;
      }
      const response = await waitPromise;
      if (error3)
        throw error3;
      return response;
    });
  }
  async goForward(progress3, options2) {
    return this.mainFrame().raceNavigationAction(progress3, async () => {
      let error3;
      const waitPromise = this.mainFrame()._waitForNavigation(progress3, false, options2).catch((e) => {
        error3 = e;
        return null;
      });
      const result = await progress3.race(this.delegate.goForward());
      if (!result) {
        waitPromise.catch(() => {
        });
        return null;
      }
      const response = await waitPromise;
      if (error3)
        throw error3;
      return response;
    });
  }
  requestGC() {
    return this.delegate.requestGC();
  }
  registerLocatorHandler(selector, noWaitAfter) {
    const uid = ++this._lastLocatorHandlerUid;
    this._locatorHandlers.set(uid, { selector, noWaitAfter });
    return uid;
  }
  resolveLocatorHandler(uid, remove) {
    const handler = this._locatorHandlers.get(uid);
    if (remove)
      this._locatorHandlers.delete(uid);
    if (handler) {
      handler.resolved?.resolve();
      handler.resolved = void 0;
    }
  }
  unregisterLocatorHandler(uid) {
    this._locatorHandlers.delete(uid);
  }
  async performActionPreChecks(progress3) {
    await this._performWaitForNavigationCheck(progress3);
    await this._performLocatorHandlersCheckpoint(progress3);
    await this._performWaitForNavigationCheck(progress3);
  }
  async _performWaitForNavigationCheck(progress3) {
    const mainFrame = this.frameManager.mainFrame();
    if (!mainFrame || !mainFrame.pendingDocument())
      return;
    const url4 = mainFrame.pendingDocument()?.request?.url();
    const toUrl = url4 ? `" ${trimStringWithEllipsis(url4, 200)}"` : "";
    progress3.log(`  waiting for${toUrl} navigation to finish...`);
    await helper.waitForEvent(progress3, mainFrame, Frame.Events.InternalNavigation, (e) => {
      if (!e.isPublic)
        return false;
      if (!e.error)
        progress3.log(`  navigated to "${trimStringWithEllipsis(mainFrame.url(), 200)}"`);
      return true;
    }).promise;
  }
  async _performLocatorHandlersCheckpoint(progress3) {
    if (this._locatorHandlerRunningCounter)
      return;
    for (const [uid, handler] of this._locatorHandlers) {
      if (!handler.resolved) {
        if (await this.mainFrame().isVisibleInternal(progress3, handler.selector, { strict: true })) {
          handler.resolved = new ManualPromise();
          this.emit(_Page.Events.LocatorHandlerTriggered, uid);
        }
      }
      if (handler.resolved) {
        ++this._locatorHandlerRunningCounter;
        progress3.log(`  found ${asLocator(this.browserContext._browser.sdkLanguage(), handler.selector)}, intercepting action to run the handler`);
        const promise = handler.resolved.then(async () => {
          if (!handler.noWaitAfter) {
            progress3.log(`  locator handler has finished, waiting for ${asLocator(this.browserContext._browser.sdkLanguage(), handler.selector)} to be hidden`);
            await this.mainFrame().waitForSelector(progress3, handler.selector, false, { state: "hidden" });
          } else {
            progress3.log(`  locator handler has finished`);
          }
        });
        await progress3.race(this.openScope.race(promise)).finally(() => --this._locatorHandlerRunningCounter);
        progress3.log(`  interception handler has finished, continuing`);
      }
    }
  }
  async emulateMedia(progress3, options2) {
    const oldEmulatedMedia = { ...this._emulatedMedia };
    if (options2.media !== void 0)
      this._emulatedMedia.media = options2.media;
    if (options2.colorScheme !== void 0)
      this._emulatedMedia.colorScheme = options2.colorScheme;
    if (options2.reducedMotion !== void 0)
      this._emulatedMedia.reducedMotion = options2.reducedMotion;
    if (options2.forcedColors !== void 0)
      this._emulatedMedia.forcedColors = options2.forcedColors;
    if (options2.contrast !== void 0)
      this._emulatedMedia.contrast = options2.contrast;
    try {
      await progress3.race(this.delegate.updateEmulateMedia());
    } catch (error3) {
      this._emulatedMedia = oldEmulatedMedia;
      this.delegate.updateEmulateMedia().catch(() => {
      });
      throw error3;
    }
  }
  emulatedMedia() {
    const contextOptions = this.browserContext._options;
    return {
      media: this._emulatedMedia.media || "no-override",
      colorScheme: this._emulatedMedia.colorScheme !== void 0 ? this._emulatedMedia.colorScheme : contextOptions.colorScheme ?? "light",
      reducedMotion: this._emulatedMedia.reducedMotion !== void 0 ? this._emulatedMedia.reducedMotion : contextOptions.reducedMotion ?? "no-preference",
      forcedColors: this._emulatedMedia.forcedColors !== void 0 ? this._emulatedMedia.forcedColors : contextOptions.forcedColors ?? "none",
      contrast: this._emulatedMedia.contrast !== void 0 ? this._emulatedMedia.contrast : contextOptions.contrast ?? "no-preference"
    };
  }
  async setViewportSize(progress3, viewportSize) {
    const oldEmulatedSize = this._emulatedSize;
    try {
      this._setEmulatedSize({ viewport: { ...viewportSize }, screen: { ...viewportSize } });
      await progress3.race(this.delegate.updateEmulatedViewportSize());
    } catch (error3) {
      this._emulatedSize = oldEmulatedSize;
      this.delegate.updateEmulatedViewportSize().catch(() => {
      });
      throw error3;
    }
  }
  setEmulatedSizeFromWindowOpen(emulatedSize) {
    this._setEmulatedSize(emulatedSize);
  }
  _setEmulatedSize(emulatedSize) {
    this._emulatedSize = emulatedSize;
    this.emit(_Page.Events.EmulatedSizeChanged);
  }
  emulatedSize() {
    if (this._emulatedSize)
      return this._emulatedSize;
    const contextOptions = this.browserContext._options;
    return contextOptions.viewport ? { viewport: contextOptions.viewport, screen: contextOptions.screen || contextOptions.viewport } : void 0;
  }
  async bringToFront() {
    await this.delegate.bringToFront();
  }
  async addInitScript(progress3, source8) {
    const initScript = new InitScript(source8);
    this.initScripts.push(initScript);
    try {
      await progress3.race(this.delegate.addInitScript(initScript));
    } catch (error3) {
      this.removeInitScripts([initScript]).catch(() => {
      });
      throw error3;
    }
    return initScript;
  }
  async removeInitScripts(initScripts) {
    const set2 = new Set(initScripts);
    this.initScripts = this.initScripts.filter((script) => !set2.has(script));
    await this.delegate.removeInitScripts(initScripts);
  }
  needsRequestInterception() {
    return this.requestInterceptors.length > 0 || this.browserContext.requestInterceptors.length > 0;
  }
  async addRequestInterceptor(progress3, handler, prepend) {
    if (prepend)
      this.requestInterceptors.unshift(handler);
    else
      this.requestInterceptors.push(handler);
    await this.delegate.updateRequestInterception();
  }
  async removeRequestInterceptor(handler) {
    const index2 = this.requestInterceptors.indexOf(handler);
    if (index2 === -1)
      return;
    this.requestInterceptors.splice(index2, 1);
    await this.browserContext.notifyRoutesInFlightAboutRemovedHandler(handler);
    await this.delegate.updateRequestInterception();
  }
  async expectScreenshot(progress3, options2) {
    const locator = options2.locator;
    const rafrafScreenshot = locator ? async (timeout) => {
      return await locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress3, locator.selector, timeout, options2 || {});
    } : async (timeout) => {
      await this.performActionPreChecks(progress3);
      await this.mainFrame().rafrafTimeout(progress3, timeout);
      return await this.screenshotter.screenshotPage(progress3, options2 || {});
    };
    const comparator = getComparator("image/png");
    if (!options2.expected && options2.isNot)
      return { errorMessage: '"not" matcher requires expected result' };
    try {
      const format2 = validateScreenshotOptions(options2 || {});
      if (format2 !== "png")
        throw new Error("Only PNG screenshots are supported");
    } catch (error3) {
      return { errorMessage: error3.message };
    }
    let intermediateResult;
    const areEqualScreenshots = /* @__PURE__ */ __name((actual, expected, previous) => {
      const comparatorResult = actual && expected ? comparator(actual, expected, options2) : void 0;
      if (comparatorResult !== void 0 && !!comparatorResult === !!options2.isNot)
        return true;
      if (comparatorResult)
        intermediateResult = { errorMessage: comparatorResult.errorMessage, diff: comparatorResult.diff, actual, previous };
      return false;
    }, "areEqualScreenshots");
    try {
      let actual;
      let previous;
      const pollIntervals = [0, 100, 250, 500];
      progress3.log(`${renderTitleForCall(progress3.metadata)}${options2.timeout ? ` with timeout ${options2.timeout}ms` : ""}`);
      if (options2.expected)
        progress3.log(`  verifying given screenshot expectation`);
      else
        progress3.log(`  generating new stable screenshot expectation`);
      let isFirstIteration = true;
      while (true) {
        if (this.isClosed())
          throw new Error("The page has closed");
        const screenshotTimeout = pollIntervals.shift() ?? 1e3;
        if (screenshotTimeout)
          progress3.log(`waiting ${screenshotTimeout}ms before taking screenshot`);
        previous = actual;
        actual = await rafrafScreenshot(screenshotTimeout).catch((e) => {
          if (this.mainFrame().isNonRetriableError(e))
            throw e;
          progress3.log(`failed to take screenshot - ` + e.message);
          return void 0;
        });
        if (!actual)
          continue;
        const expectation = options2.expected && isFirstIteration ? options2.expected : previous;
        if (areEqualScreenshots(actual, expectation, previous))
          break;
        if (intermediateResult)
          progress3.log(intermediateResult.errorMessage);
        isFirstIteration = false;
      }
      if (!isFirstIteration)
        progress3.log(`captured a stable screenshot`);
      if (!options2.expected)
        return { actual };
      if (isFirstIteration) {
        progress3.log(`screenshot matched expectation`);
        return {};
      }
      if (areEqualScreenshots(actual, options2.expected, void 0)) {
        progress3.log(`screenshot matched expectation`);
        return {};
      }
      throw new Error(intermediateResult.errorMessage);
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))
        throw e;
      let errorMessage = e.message;
      if (e instanceof TimeoutError && intermediateResult?.previous)
        errorMessage = `Failed to take two consecutive stable screenshots.`;
      return {
        log: compressCallLog(e.message ? [...progress3.metadata.log, e.message] : progress3.metadata.log),
        ...intermediateResult,
        errorMessage,
        timedOut: e instanceof TimeoutError
      };
    }
  }
  async screenshot(progress3, options2) {
    return await this.screenshotter.screenshotPage(progress3, options2);
  }
  async close(options2 = {}) {
    if (this._closedState === "closed")
      return;
    if (options2.reason)
      this.closeReason = options2.reason;
    const runBeforeUnload = !!options2.runBeforeUnload;
    if (this._closedState !== "closing") {
      this._closedState = "closing";
      await this.delegate.closePage(runBeforeUnload).catch((e) => debugLogger.log("error", e));
    }
    if (!runBeforeUnload)
      await this._closedPromise;
  }
  isClosed() {
    return this._closedState === "closed";
  }
  hasCrashed() {
    return this._crashed;
  }
  isClosedOrClosingOrCrashed() {
    return this._closedState !== "open" || this._crashed;
  }
  addWorker(workerId, worker) {
    this._workers.set(workerId, worker);
    this.emit(_Page.Events.Worker, worker);
  }
  removeWorker(workerId) {
    const worker = this._workers.get(workerId);
    if (!worker)
      return;
    worker.didClose();
    this._workers.delete(workerId);
  }
  clearWorkers() {
    for (const [workerId, worker] of this._workers) {
      worker.didClose();
      this._workers.delete(workerId);
    }
  }
  async setFileChooserInterceptedBy(enabled, by) {
    const wasIntercepted = this.fileChooserIntercepted();
    if (enabled)
      this._fileChooserInterceptedBy.add(by);
    else
      this._fileChooserInterceptedBy.delete(by);
    if (wasIntercepted !== this.fileChooserIntercepted())
      await this.delegate.updateFileChooserInterception();
  }
  fileChooserIntercepted() {
    return this._fileChooserInterceptedBy.size > 0;
  }
  frameNavigatedToNewDocument(frame) {
    this.emit(_Page.Events.InternalFrameNavigatedToNewDocument, frame);
    const origin = frame.origin();
    if (origin)
      this.browserContext.addVisitedOrigin(origin);
  }
  allInitScripts() {
    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map((binding3) => binding3.initScript);
    if (this.browserContext.bindingsInitScript)
      bindings.unshift(this.browserContext.bindingsInitScript);
    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];
  }
  getBinding(name) {
    return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);
  }
  setScreencastOptions(options2) {
    this.delegate.setScreencastOptions(options2).catch((e) => debugLogger.log("error", e));
    this._frameThrottler.setThrottlingEnabled(!!options2);
  }
  throttleScreencastFrameAck(ack) {
    this._frameThrottler.ack(ack);
  }
  temporarilyDisableTracingScreencastThrottling() {
    this._frameThrottler.recharge();
  }
  async safeNonStallingEvaluateInAllFrames(expression, world, options2 = {}) {
    await Promise.all(this.frames().map(async (frame) => {
      try {
        await frame.nonStallingEvaluateInExistingContext(expression, world);
      } catch (e) {
        if (options2.throwOnJSErrors && isJavaScriptErrorInEvaluate(e))
          throw e;
      }
    }));
  }
  async hideHighlight() {
    await Promise.all(this.frames().map((frame) => frame.hideHighlight().catch(() => {
    })));
  }
  async snapshotForAI(progress3) {
    this.lastSnapshotFrameIds = [];
    const snapshot = await snapshotFrameForAI(progress3, this.mainFrame(), 0, this.lastSnapshotFrameIds);
    return snapshot.join("\n");
  }
};
var Worker = class _Worker extends SdkObject {
  static {
    __name(this, "Worker");
  }
  constructor(parent, url4) {
    super(parent, "worker");
    this.existingExecutionContext = null;
    this.openScope = new LongStandingScope();
    this.url = url4;
    this._executionContextCallback = () => {
    };
    this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
  }
  static {
    this.Events = {
      Close: "close"
    };
  }
  createExecutionContext(delegate) {
    this.existingExecutionContext = new ExecutionContext(this, delegate, "worker");
    this._executionContextCallback(this.existingExecutionContext);
    return this.existingExecutionContext;
  }
  didClose() {
    if (this.existingExecutionContext)
      this.existingExecutionContext.contextDestroyed("Worker was closed");
    this.emit(_Worker.Events.Close, this);
    this.openScope.close(new Error("Worker closed"));
  }
  async evaluateExpression(expression, isFunction, arg) {
    return evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
  }
  async evaluateExpressionHandle(expression, isFunction, arg) {
    return evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
  }
};
var PageBinding = class _PageBinding {
  static {
    __name(this, "PageBinding");
  }
  static {
    this.kController = "__playwright__binding__controller__";
  }
  static {
    this.kBindingName = "__playwright__binding__";
  }
  static createInitScript() {
    return new InitScript(`
      (() => {
        const module = {};
        ${source4}
        const property = '${_PageBinding.kController}';
        if (!globalThis[property])
          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${_PageBinding.kBindingName}');
      })();
    `);
  }
  constructor(name, playwrightFunction, needsHandle) {
    this.name = name;
    this.playwrightFunction = playwrightFunction;
    this.initScript = new InitScript(`globalThis['${_PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);
    this.needsHandle = needsHandle;
    this.cleanupScript = `globalThis['${_PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;
  }
  static async dispatch(page, payload, context2) {
    const { name, seq: seq2, serializedArgs } = JSON.parse(payload);
    try {
      assert3(context2.world);
      const binding3 = page.getBinding(name);
      if (!binding3)
        throw new Error(`Function "${name}" is not exposed`);
      let result;
      if (binding3.needsHandle) {
        const handle = await context2.evaluateExpressionHandle(`arg => globalThis['${_PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq: seq2 }).catch((e) => null);
        result = await binding3.playwrightFunction({ frame: context2.frame, page, context: page.browserContext }, handle);
      } else {
        if (!Array.isArray(serializedArgs))
          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
        const args = serializedArgs.map((a) => parseEvaluationResultValue(a));
        result = await binding3.playwrightFunction({ frame: context2.frame, page, context: page.browserContext }, ...args);
      }
      context2.evaluateExpressionHandle(`arg => globalThis['${_PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq: seq2, result }).catch((e) => debugLogger.log("error", e));
    } catch (error3) {
      context2.evaluateExpressionHandle(`arg => globalThis['${_PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq: seq2, error: error3 }).catch((e) => debugLogger.log("error", e));
    }
  }
};
var InitScript = class {
  static {
    __name(this, "InitScript");
  }
  constructor(source8) {
    this.source = `(() => {
      ${source8}
    })();`;
  }
};
var FrameThrottler = class {
  static {
    __name(this, "FrameThrottler");
  }
  constructor(nonThrottledFrames, defaultInterval, throttlingInterval) {
    this._acks = [];
    this._throttlingEnabled = false;
    this._nonThrottledFrames = nonThrottledFrames;
    this._budget = nonThrottledFrames;
    this._defaultInterval = defaultInterval;
    this._throttlingInterval = throttlingInterval;
    this._tick();
  }
  dispose() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
      this._timeoutId = void 0;
    }
  }
  setThrottlingEnabled(enabled) {
    this._throttlingEnabled = enabled;
  }
  recharge() {
    for (const ack of this._acks)
      ack();
    this._acks = [];
    this._budget = this._nonThrottledFrames;
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
      this._tick();
    }
  }
  ack(ack) {
    if (!this._timeoutId) {
      ack();
      return;
    }
    this._acks.push(ack);
  }
  _tick() {
    const ack = this._acks.shift();
    if (ack) {
      --this._budget;
      ack();
    }
    if (this._throttlingEnabled && this._budget <= 0) {
      this._timeoutId = setTimeout(() => this._tick(), this._throttlingInterval);
    } else {
      this._timeoutId = setTimeout(() => this._tick(), this._defaultInterval);
    }
  }
};
async function snapshotFrameForAI(progress3, frame, frameOrdinal, frameIds) {
  const snapshot = await frame.retryWithProgressAndTimeouts(progress3, [1e3, 2e3, 4e3, 8e3], async (continuePolling) => {
    try {
      const context2 = await progress3.race(frame._utilityContext());
      const injectedScript = await progress3.race(context2.injectedScript());
      const snapshotOrRetry = await progress3.race(injectedScript.evaluate((injected, refPrefix) => {
        const node = injected.document.body;
        if (!node)
          return true;
        return injected.ariaSnapshot(node, { mode: "ai", refPrefix });
      }, frameOrdinal ? "f" + frameOrdinal : ""));
      if (snapshotOrRetry === true)
        return continuePolling;
      return snapshotOrRetry;
    } catch (e) {
      if (frame.isNonRetriableError(e))
        throw e;
      return continuePolling;
    }
  });
  const lines = snapshot.split("\n");
  const result = [];
  for (const line of lines) {
    const match = line.match(/^(\s*)- iframe (?:\[active\] )?\[ref=([^\]]*)\]/);
    if (!match) {
      result.push(line);
      continue;
    }
    const leadingSpace = match[1];
    const ref2 = match[2];
    const frameSelector = `aria-ref=${ref2} >> internal:control=enter-frame`;
    const frameBodySelector = `${frameSelector} >> body`;
    const child = await progress3.race(frame.selectors.resolveFrameForSelector(frameBodySelector, { strict: true }));
    if (!child) {
      result.push(line);
      continue;
    }
    const frameOrdinal2 = frameIds.length + 1;
    frameIds.push(child.frame._id);
    try {
      const childSnapshot = await snapshotFrameForAI(progress3, child.frame, frameOrdinal2, frameIds);
      result.push(line + ":", ...childSnapshot.map((l) => leadingSpace + "  " + l));
    } catch {
      result.push(line);
    }
  }
  return result;
}
__name(snapshotFrameForAI, "snapshotFrameForAI");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/frames.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/task.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function makeWaitForNextTask() {
  if (process.versions.electron)
    return (callback) => setTimeout(callback, 0);
  if (parseInt(process.versions.node, 10) >= 11)
    return setImmediate;
  let spinning = false;
  const callbacks = [];
  const loop = /* @__PURE__ */ __name(() => {
    const callback = callbacks.shift();
    if (!callback) {
      spinning = false;
      return;
    }
    setImmediate(loop);
    callback();
  }, "loop");
  return (callback) => {
    callbacks.push(callback);
    if (!spinning) {
      spinning = true;
      setImmediate(loop);
    }
  };
}
__name(makeWaitForNextTask, "makeWaitForNextTask");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/frames.js
import "node:os";
var NavigationAbortedError = class extends Error {
  static {
    __name(this, "NavigationAbortedError");
  }
  constructor(documentId, message) {
    super(message);
    this.documentId = documentId;
  }
};
var kDummyFrameId = "<dummy>";
var FrameManager = class {
  static {
    __name(this, "FrameManager");
  }
  constructor(page) {
    this._frames = /* @__PURE__ */ new Map();
    this._consoleMessageTags = /* @__PURE__ */ new Map();
    this._signalBarriers = /* @__PURE__ */ new Set();
    this._webSockets = /* @__PURE__ */ new Map();
    this._page = page;
    this._mainFrame = void 0;
  }
  createDummyMainFrameIfNeeded() {
    if (!this._mainFrame)
      this.frameAttached(kDummyFrameId, null);
  }
  dispose() {
    for (const frame of this._frames.values()) {
      frame._stopNetworkIdleTimer();
      frame._invalidateNonStallingEvaluations("Target crashed");
    }
  }
  mainFrame() {
    return this._mainFrame;
  }
  frames() {
    const frames = [];
    collect(this._mainFrame);
    return frames;
    function collect(frame) {
      frames.push(frame);
      for (const subframe of frame.childFrames())
        collect(subframe);
    }
    __name(collect, "collect");
  }
  frame(frameId) {
    return this._frames.get(frameId) || null;
  }
  frameAttached(frameId, parentFrameId) {
    const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
    if (!parentFrame) {
      if (this._mainFrame) {
        this._frames.delete(this._mainFrame._id);
        this._mainFrame._id = frameId;
      } else {
        assert3(!this._frames.has(frameId));
        this._mainFrame = new Frame(this._page, frameId, parentFrame);
      }
      this._frames.set(frameId, this._mainFrame);
      return this._mainFrame;
    } else {
      assert3(!this._frames.has(frameId));
      const frame = new Frame(this._page, frameId, parentFrame);
      this._frames.set(frameId, frame);
      this._page.emit(Page.Events.FrameAttached, frame);
      return frame;
    }
  }
  async waitForSignalsCreatedBy(progress3, waitAfter, action) {
    if (!waitAfter)
      return action();
    const barrier = new SignalBarrier(progress3);
    this._signalBarriers.add(barrier);
    try {
      const result = await action();
      await progress3.race(this._page.delegate.inputActionEpilogue());
      await barrier.waitFor();
      await new Promise(makeWaitForNextTask());
      return result;
    } finally {
      this._signalBarriers.delete(barrier);
    }
  }
  frameWillPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers)
      barrier.retain();
  }
  frameDidPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers)
      barrier.release();
  }
  frameRequestedNavigation(frameId, documentId) {
    const frame = this._frames.get(frameId);
    if (!frame)
      return;
    for (const barrier of this._signalBarriers)
      barrier.addFrameNavigation(frame);
    if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
      return;
    }
    const request2 = documentId ? Array.from(frame._inflightRequests).find((request22) => request22._documentId === documentId) : void 0;
    frame.setPendingDocument({ documentId, request: request2 });
  }
  frameCommittedNewDocumentNavigation(frameId, url4, name, documentId, initial) {
    const frame = this._frames.get(frameId);
    this.removeChildFramesRecursively(frame);
    this.clearWebSockets(frame);
    frame._url = url4;
    frame._name = name;
    let keepPending;
    const pendingDocument = frame.pendingDocument();
    if (pendingDocument) {
      if (pendingDocument.documentId === void 0) {
        pendingDocument.documentId = documentId;
      }
      if (pendingDocument.documentId === documentId) {
        frame._currentDocument = pendingDocument;
      } else {
        keepPending = pendingDocument;
        frame._currentDocument = { documentId, request: void 0 };
      }
      frame.setPendingDocument(void 0);
    } else {
      frame._currentDocument = { documentId, request: void 0 };
    }
    frame._onClearLifecycle();
    const navigationEvent = { url: url4, name, newDocument: frame._currentDocument, isPublic: true };
    this._fireInternalFrameNavigation(frame, navigationEvent);
    if (!initial) {
      debugLogger.log("api", `  navigated to "${url4}"`);
      this._page.frameNavigatedToNewDocument(frame);
    }
    frame.setPendingDocument(keepPending);
  }
  frameCommittedSameDocumentNavigation(frameId, url4) {
    const frame = this._frames.get(frameId);
    if (!frame)
      return;
    const pending = frame.pendingDocument();
    if (pending && pending.documentId === void 0 && pending.request === void 0) {
      frame.setPendingDocument(void 0);
    }
    frame._url = url4;
    const navigationEvent = { url: url4, name: frame._name, isPublic: true };
    this._fireInternalFrameNavigation(frame, navigationEvent);
    debugLogger.log("api", `  navigated to "${url4}"`);
  }
  frameAbortedNavigation(frameId, errorText, documentId) {
    const frame = this._frames.get(frameId);
    if (!frame || !frame.pendingDocument())
      return;
    if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
      return;
    const navigationEvent = {
      url: frame._url,
      name: frame._name,
      newDocument: frame.pendingDocument(),
      error: new NavigationAbortedError(documentId, errorText),
      isPublic: !(documentId && frame._redirectedNavigations.has(documentId))
    };
    frame.setPendingDocument(void 0);
    this._fireInternalFrameNavigation(frame, navigationEvent);
  }
  frameDetached(frameId) {
    const frame = this._frames.get(frameId);
    if (frame) {
      this._removeFramesRecursively(frame);
      this._page.mainFrame()._recalculateNetworkIdle();
    }
  }
  frameLifecycleEvent(frameId, event) {
    const frame = this._frames.get(frameId);
    if (frame)
      frame._onLifecycleEvent(event);
  }
  requestStarted(request2, route) {
    const frame = request2.frame();
    this._inflightRequestStarted(request2);
    if (request2._documentId)
      frame.setPendingDocument({ documentId: request2._documentId, request: request2 });
    if (request2._isFavicon) {
      route?.abort("aborted").catch(() => {
      });
      return;
    }
    this._page.emitOnContext(BrowserContext.Events.Request, request2);
    if (route)
      new Route(request2, route).handle([...this._page.requestInterceptors, ...this._page.browserContext.requestInterceptors]);
  }
  requestReceivedResponse(response) {
    if (response.request()._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.Response, response);
  }
  reportRequestFinished(request2, response) {
    this._inflightRequestFinished(request2);
    if (request2._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.RequestFinished, { request: request2, response });
  }
  requestFailed(request2, canceled) {
    const frame = request2.frame();
    this._inflightRequestFinished(request2);
    if (frame.pendingDocument() && frame.pendingDocument().request === request2) {
      let errorText = request2.failure().errorText;
      if (canceled)
        errorText += "; maybe frame was detached?";
      this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
    }
    if (request2._isFavicon)
      return;
    this._page.emitOnContext(BrowserContext.Events.RequestFailed, request2);
  }
  removeChildFramesRecursively(frame) {
    for (const child of frame.childFrames())
      this._removeFramesRecursively(child);
  }
  _removeFramesRecursively(frame) {
    this.removeChildFramesRecursively(frame);
    frame._onDetached();
    this._frames.delete(frame._id);
    if (!this._page.isClosed())
      this._page.emit(Page.Events.FrameDetached, frame);
  }
  _inflightRequestFinished(request2) {
    const frame = request2.frame();
    if (request2._isFavicon)
      return;
    if (!frame._inflightRequests.has(request2))
      return;
    frame._inflightRequests.delete(request2);
    if (frame._inflightRequests.size === 0)
      frame._startNetworkIdleTimer();
  }
  _inflightRequestStarted(request2) {
    const frame = request2.frame();
    if (request2._isFavicon)
      return;
    frame._inflightRequests.add(request2);
    if (frame._inflightRequests.size === 1)
      frame._stopNetworkIdleTimer();
  }
  interceptConsoleMessage(message) {
    if (message.type() !== "debug")
      return false;
    const tag = message.text();
    const handler = this._consoleMessageTags.get(tag);
    if (!handler)
      return false;
    this._consoleMessageTags.delete(tag);
    handler();
    return true;
  }
  clearWebSockets(frame) {
    if (frame.parentFrame())
      return;
    this._webSockets.clear();
  }
  onWebSocketCreated(requestId, url4) {
    const ws3 = new WebSocket2(this._page, url4);
    this._webSockets.set(requestId, ws3);
  }
  onWebSocketRequest(requestId) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3 && ws3.markAsNotified())
      this._page.emit(Page.Events.WebSocket, ws3);
  }
  onWebSocketResponse(requestId, status, statusText2) {
    const ws3 = this._webSockets.get(requestId);
    if (status < 400)
      return;
    if (ws3)
      ws3.error(`${statusText2}: ${status}`);
  }
  onWebSocketFrameSent(requestId, opcode, data) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.frameSent(opcode, data);
  }
  webSocketFrameReceived(requestId, opcode, data) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.frameReceived(opcode, data);
  }
  webSocketClosed(requestId) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.closed();
    this._webSockets.delete(requestId);
  }
  webSocketError(requestId, errorMessage) {
    const ws3 = this._webSockets.get(requestId);
    if (ws3)
      ws3.error(errorMessage);
  }
  _fireInternalFrameNavigation(frame, event) {
    frame.emit(Frame.Events.InternalNavigation, event);
  }
};
var Frame = class _Frame extends SdkObject {
  static {
    __name(this, "Frame");
  }
  constructor(page, id, parentFrame) {
    super(page, "frame");
    this._firedLifecycleEvents = /* @__PURE__ */ new Set();
    this._firedNetworkIdleSelf = false;
    this._url = "";
    this._contextData = /* @__PURE__ */ new Map();
    this._childFrames = /* @__PURE__ */ new Set();
    this._name = "";
    this._inflightRequests = /* @__PURE__ */ new Set();
    this._setContentCounter = 0;
    this._detachedScope = new LongStandingScope();
    this._raceAgainstEvaluationStallingEventsPromises = /* @__PURE__ */ new Set();
    this._redirectedNavigations = /* @__PURE__ */ new Map();
    this.attribution.frame = this;
    this._id = id;
    this._page = page;
    this._parentFrame = parentFrame;
    this._currentDocument = { documentId: void 0, request: void 0 };
    this.selectors = new FrameSelectors(this);
    this._contextData.set("main", { contextPromise: new ManualPromise(), context: null });
    this._contextData.set("utility", { contextPromise: new ManualPromise(), context: null });
    this._setContext("main", null);
    this._setContext("utility", null);
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
    this._firedLifecycleEvents.add("commit");
    if (id !== kDummyFrameId)
      this._startNetworkIdleTimer();
  }
  static {
    this.Events = {
      InternalNavigation: "internalnavigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
  }
  isDetached() {
    return this._detachedScope.isClosed();
  }
  _onLifecycleEvent(event) {
    if (this._firedLifecycleEvents.has(event))
      return;
    this._firedLifecycleEvents.add(event);
    this.emit(_Frame.Events.AddLifecycle, event);
    if (this === this._page.mainFrame() && this._url !== "about:blank")
      debugLogger.log("api", `  "${event}" event fired`);
    this._page.mainFrame()._recalculateNetworkIdle();
  }
  _onClearLifecycle() {
    for (const event of this._firedLifecycleEvents)
      this.emit(_Frame.Events.RemoveLifecycle, event);
    this._firedLifecycleEvents.clear();
    this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request2) => request2 === this._currentDocument.request));
    this._stopNetworkIdleTimer();
    if (this._inflightRequests.size === 0)
      this._startNetworkIdleTimer();
    this._page.mainFrame()._recalculateNetworkIdle(this);
    this._onLifecycleEvent("commit");
  }
  setPendingDocument(documentInfo) {
    this._pendingDocument = documentInfo;
    if (documentInfo)
      this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
  }
  pendingDocument() {
    return this._pendingDocument;
  }
  _invalidateNonStallingEvaluations(message) {
    if (!this._raceAgainstEvaluationStallingEventsPromises.size)
      return;
    const error3 = new Error(message);
    for (const promise of this._raceAgainstEvaluationStallingEventsPromises)
      promise.reject(error3);
  }
  async raceAgainstEvaluationStallingEvents(cb) {
    if (this._pendingDocument)
      throw new Error("Frame is currently attempting a navigation");
    if (this._page.browserContext.dialogManager.hasOpenDialogsForPage(this._page))
      throw new Error("Open JavaScript dialog prevents evaluation");
    const promise = new ManualPromise();
    this._raceAgainstEvaluationStallingEventsPromises.add(promise);
    try {
      return await Promise.race([
        cb(),
        promise
      ]);
    } finally {
      this._raceAgainstEvaluationStallingEventsPromises.delete(promise);
    }
  }
  nonStallingRawEvaluateInExistingMainContext(expression) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      const context2 = this._existingMainContext();
      if (!context2)
        throw new Error("Frame does not yet have a main execution context");
      return context2.rawEvaluateJSON(expression);
    });
  }
  nonStallingEvaluateInExistingContext(expression, world) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      const context2 = this._contextData.get(world)?.context;
      if (!context2)
        throw new Error("Frame does not yet have the execution context");
      return context2.evaluateExpression(expression, { isFunction: false });
    });
  }
  _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle) {
    let isNetworkIdle = this._firedNetworkIdleSelf;
    for (const child of this._childFrames) {
      child._recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle);
      if (!child._firedLifecycleEvents.has("networkidle"))
        isNetworkIdle = false;
    }
    if (isNetworkIdle && !this._firedLifecycleEvents.has("networkidle")) {
      this._firedLifecycleEvents.add("networkidle");
      this.emit(_Frame.Events.AddLifecycle, "networkidle");
      if (this === this._page.mainFrame() && this._url !== "about:blank")
        debugLogger.log("api", `  "networkidle" event fired`);
    }
    if (frameThatAllowsRemovingNetworkIdle !== this && this._firedLifecycleEvents.has("networkidle") && !isNetworkIdle) {
      this._firedLifecycleEvents.delete("networkidle");
      this.emit(_Frame.Events.RemoveLifecycle, "networkidle");
    }
  }
  async raceNavigationAction(progress3, action) {
    return LongStandingScope.raceMultiple([
      this._detachedScope,
      this._page.openScope
    ], action().catch((e) => {
      if (e instanceof NavigationAbortedError && e.documentId) {
        const data = this._redirectedNavigations.get(e.documentId);
        if (data) {
          progress3.log(`waiting for redirected navigation to "${data.url}"`);
          return progress3.race(data.gotoPromise);
        }
      }
      throw e;
    }));
  }
  redirectNavigation(url4, documentId, referer) {
    const controller = new ProgressController();
    const data = {
      url: url4,
      gotoPromise: controller.run((progress3) => this.gotoImpl(progress3, url4, { referer }), 0)
    };
    this._redirectedNavigations.set(documentId, data);
    data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));
  }
  async goto(progress3, url4, options2 = {}) {
    const constructedNavigationURL = constructURLBasedOnBaseURL(this._page.browserContext._options.baseURL, url4);
    return this.raceNavigationAction(progress3, async () => this.gotoImpl(progress3, constructedNavigationURL, options2));
  }
  async gotoImpl(progress3, url4, options2) {
    const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    progress3.log(`navigating to "${url4}", waiting until "${waitUntil}"`);
    const headers = this._page.extraHTTPHeaders() || [];
    const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
    let referer = refererHeader ? refererHeader.value : void 0;
    if (options2.referer !== void 0) {
      if (referer !== void 0 && referer !== options2.referer)
        throw new Error('"referer" is already specified as extra HTTP header');
      referer = options2.referer;
    }
    url4 = helper.completeUserURL(url4);
    const navigationEvents = [];
    const collectNavigations = /* @__PURE__ */ __name((arg) => navigationEvents.push(arg), "collectNavigations");
    this.on(_Frame.Events.InternalNavigation, collectNavigations);
    const navigateResult = await progress3.race(this._page.delegate.navigateFrame(this, url4, referer)).finally(
      () => this.off(_Frame.Events.InternalNavigation, collectNavigations)
    );
    let event;
    if (navigateResult.newDocumentId) {
      const predicate = /* @__PURE__ */ __name((event2) => {
        return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
      }, "predicate");
      const events = navigationEvents.filter(predicate);
      if (events.length)
        event = events[0];
      else
        event = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, predicate).promise;
      if (event.newDocument.documentId !== navigateResult.newDocumentId) {
        throw new NavigationAbortedError(navigateResult.newDocumentId, `Navigation to "${url4}" is interrupted by another navigation to "${event.url}"`);
      }
      if (event.error)
        throw event.error;
    } else {
      const predicate = /* @__PURE__ */ __name((e) => !e.newDocument, "predicate");
      const events = navigationEvents.filter(predicate);
      if (events.length)
        event = events[0];
      else
        event = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, predicate).promise;
    }
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
    const request2 = event.newDocument ? event.newDocument.request : void 0;
    const response = request2 ? progress3.race(request2._finalRequest().response()) : null;
    return response;
  }
  async _waitForNavigation(progress3, requiresNewDocument, options2) {
    const waitUntil = verifyLifecycle("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    progress3.log(`waiting for navigation until "${waitUntil}"`);
    const navigationEvent = await helper.waitForEvent(progress3, this, _Frame.Events.InternalNavigation, (event) => {
      if (event.error)
        return true;
      if (requiresNewDocument && !event.newDocument)
        return false;
      progress3.log(`  navigated to "${this._url}"`);
      return true;
    }).promise;
    if (navigationEvent.error)
      throw navigationEvent.error;
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
    const request2 = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
    return request2 ? progress3.race(request2._finalRequest().response()) : null;
  }
  async _waitForLoadState(progress3, state) {
    const waitUntil = verifyLifecycle("state", state);
    if (!this._firedLifecycleEvents.has(waitUntil))
      await helper.waitForEvent(progress3, this, _Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
  }
  async frameElement() {
    return this._page.delegate.getFrameElement(this);
  }
  _context(world) {
    return this._contextData.get(world).contextPromise.then((contextOrDestroyedReason) => {
      if (contextOrDestroyedReason instanceof ExecutionContext)
        return contextOrDestroyedReason;
      throw new Error(contextOrDestroyedReason.destroyedReason);
    });
  }
  _mainContext() {
    return this._context("main");
  }
  _existingMainContext() {
    return this._contextData.get("main")?.context || null;
  }
  _utilityContext() {
    return this._context("utility");
  }
  async evaluateExpression(expression, options2 = {}, arg) {
    const context2 = await this._context(options2.world ?? "main");
    const value = await context2.evaluateExpression(expression, options2, arg);
    return value;
  }
  async evaluateExpressionHandle(expression, options2 = {}, arg) {
    const context2 = await this._context(options2.world ?? "main");
    const value = await context2.evaluateExpressionHandle(expression, options2, arg);
    return value;
  }
  async querySelector(selector, options2) {
    debugLogger.log("api", `    finding element using the selector "${selector}"`);
    return this.selectors.query(selector, options2);
  }
  async waitForSelector(progress3, selector, performActionPreChecksAndLog, options2, scope) {
    if (options2.visibility)
      throw new Error("options.visibility is not supported, did you mean options.state?");
    if (options2.waitFor && options2.waitFor !== "visible")
      throw new Error("options.waitFor is not supported, did you mean options.state?");
    const { state = "visible" } = options2;
    if (!["attached", "detached", "visible", "hidden"].includes(state))
      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
    if (performActionPreChecksAndLog)
      progress3.log(`waiting for ${this._asLocator(selector)}${state === "attached" ? "" : " to be " + state}`);
    const promise = this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
      if (performActionPreChecksAndLog)
        await this._page.performActionPreChecks(progress3);
      const resolved = await progress3.race(this.selectors.resolveInjectedForSelector(selector, options2, scope));
      if (!resolved) {
        if (state === "hidden" || state === "detached")
          return null;
        return continuePolling;
      }
      const result = await progress3.race(resolved.injected.evaluateHandle((injected, { info: info3, root }) => {
        if (root && !root.isConnected)
          throw injected.createStacklessError("Element is not attached to the DOM");
        const elements = injected.querySelectorAll(info3.parsed, root || document);
        const element2 = elements[0];
        const visible2 = element2 ? injected.utils.isElementVisible(element2) : false;
        let log22 = "";
        if (elements.length > 1) {
          if (info3.strict)
            throw injected.strictModeViolationError(info3.parsed, elements);
          log22 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
        } else if (element2) {
          log22 = `  locator resolved to ${visible2 ? "visible" : "hidden"} ${injected.previewNode(element2)}`;
        }
        return { log: log22, element: element2, visible: visible2, attached: !!element2 };
      }, { info: resolved.info, root: resolved.frame === this ? scope : void 0 }));
      const { log: log3, visible, attached } = await progress3.race(result.evaluate((r) => ({ log: r.log, visible: r.visible, attached: r.attached })));
      if (log3)
        progress3.log(log3);
      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
      if (!success) {
        result.dispose();
        return continuePolling;
      }
      if (options2.omitReturnValue) {
        result.dispose();
        return null;
      }
      const element = state === "attached" || state === "visible" ? await progress3.race(result.evaluateHandle((r) => r.element)) : null;
      result.dispose();
      if (!element)
        return null;
      if (options2.__testHookBeforeAdoptNode)
        await progress3.race(options2.__testHookBeforeAdoptNode());
      try {
        const mainContext = await progress3.race(resolved.frame._mainContext());
        return await progress3.race(element._adoptTo(mainContext));
      } catch (e) {
        return continuePolling;
      }
    });
    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
  }
  async dispatchEvent(progress3, selector, type, eventInit = {}, options2, scope) {
    await this._callOnElementOnceMatches(progress3, selector, (injectedScript, element, data) => {
      injectedScript.dispatchEvent(element, data.type, data.eventInit);
    }, { type, eventInit }, { mainWorld: true, ...options2 }, scope);
  }
  async evalOnSelector(selector, strict, expression, isFunction, arg, scope) {
    const handle = await this.selectors.query(selector, { strict }, scope);
    if (!handle)
      throw new Error(`Failed to find element matching selector "${selector}"`);
    const result = await handle.evaluateExpression(expression, { isFunction }, arg);
    handle.dispose();
    return result;
  }
  async evalOnSelectorAll(selector, expression, isFunction, arg, scope) {
    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);
    arrayHandle.dispose();
    return result;
  }
  async maskSelectors(selectors2, color) {
    const context2 = await this._utilityContext();
    const injectedScript = await context2.injectedScript();
    await injectedScript.evaluate((injected, { parsed, color: color2 }) => {
      injected.maskSelectors(parsed, color2);
    }, { parsed: selectors2, color });
  }
  async querySelectorAll(selector) {
    return this.selectors.queryAll(selector);
  }
  async queryCount(selector, options2) {
    try {
      return await this.selectors.queryCount(selector, options2);
    } catch (e) {
      if (this.isNonRetriableError(e))
        throw e;
      return 0;
    }
  }
  async content() {
    try {
      const context2 = await this._utilityContext();
      return await context2.evaluate(() => {
        let retVal = "";
        if (document.doctype)
          retVal = new XMLSerializer().serializeToString(document.doctype);
        if (document.documentElement)
          retVal += document.documentElement.outerHTML;
        return retVal;
      });
    } catch (e) {
      if (this.isNonRetriableError(e))
        throw e;
      throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
    }
  }
  async setContent(progress3, html, options2) {
    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
    await this.raceNavigationAction(progress3, async () => {
      const waitUntil = options2.waitUntil === void 0 ? "load" : options2.waitUntil;
      progress3.log(`setting frame content, waiting until "${waitUntil}"`);
      const context2 = await progress3.race(this._utilityContext());
      const tagPromise = new ManualPromise();
      this._page.frameManager._consoleMessageTags.set(tag, () => {
        this._onClearLifecycle();
        tagPromise.resolve();
      });
      const lifecyclePromise = progress3.race(tagPromise).then(() => this._waitForLoadState(progress3, waitUntil));
      const contentPromise = progress3.race(context2.evaluate(({ html: html2, tag: tag2 }) => {
        document.open();
        console.debug(tag2);
        document.write(html2);
        document.close();
      }, { html, tag }));
      await Promise.all([contentPromise, lifecyclePromise]);
      return null;
    }).finally(() => {
      this._page.frameManager._consoleMessageTags.delete(tag);
    });
  }
  name() {
    return this._name || "";
  }
  url() {
    return this._url;
  }
  origin() {
    if (!this._url.startsWith("http"))
      return;
    return parseURL2(this._url)?.origin;
  }
  parentFrame() {
    return this._parentFrame;
  }
  childFrames() {
    return Array.from(this._childFrames);
  }
  async addScriptTag(params) {
    const {
      url: url4 = null,
      content = null,
      type = ""
    } = params;
    if (!url4 && !content)
      throw new Error("Provide an object with a `url`, `path` or `content` property");
    const context2 = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url4 !== null)
        return (await context2.evaluateHandle(addScriptUrl, { url: url4, type })).asElement();
      const result = (await context2.evaluateHandle(addScriptContent, { content, type })).asElement();
      if (this._page.delegate.cspErrorsAsynchronousForInlineScripts)
        await context2.evaluate(() => true);
      return result;
    });
    async function addScriptUrl(params2) {
      const script = document.createElement("script");
      script.src = params2.url;
      if (params2.type)
        script.type = params2.type;
      const promise = new Promise((res, rej) => {
        script.onload = res;
        script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
      });
      document.head.appendChild(script);
      await promise;
      return script;
    }
    __name(addScriptUrl, "addScriptUrl");
    function addScriptContent(params2) {
      const script = document.createElement("script");
      script.type = params2.type || "text/javascript";
      script.text = params2.content;
      let error3 = null;
      script.onerror = (e) => error3 = e;
      document.head.appendChild(script);
      if (error3)
        throw error3;
      return script;
    }
    __name(addScriptContent, "addScriptContent");
  }
  async addStyleTag(params) {
    const {
      url: url4 = null,
      content = null
    } = params;
    if (!url4 && !content)
      throw new Error("Provide an object with a `url`, `path` or `content` property");
    const context2 = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url4 !== null)
        return (await context2.evaluateHandle(addStyleUrl, url4)).asElement();
      return (await context2.evaluateHandle(addStyleContent, content)).asElement();
    });
    async function addStyleUrl(url22) {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = url22;
      const promise = new Promise((res, rej) => {
        link.onload = res;
        link.onerror = rej;
      });
      document.head.appendChild(link);
      await promise;
      return link;
    }
    __name(addStyleUrl, "addStyleUrl");
    async function addStyleContent(content2) {
      const style = document.createElement("style");
      style.type = "text/css";
      style.appendChild(document.createTextNode(content2));
      const promise = new Promise((res, rej) => {
        style.onload = res;
        style.onerror = rej;
      });
      document.head.appendChild(style);
      await promise;
      return style;
    }
    __name(addStyleContent, "addStyleContent");
  }
  async _raceWithCSPError(func) {
    const listeners2 = [];
    let result;
    let error3;
    let cspMessage;
    const actionPromise = func().then((r) => result = r).catch((e) => error3 = e);
    const errorPromise = new Promise((resolve) => {
      listeners2.push(eventsHelper.addEventListener(this._page.browserContext, BrowserContext.Events.Console, (message) => {
        if (message.page() !== this._page || message.type() !== "error")
          return;
        if (message.text().includes("Content-Security-Policy") || message.text().includes("Content Security Policy")) {
          cspMessage = message;
          resolve();
        }
      }));
    });
    await Promise.race([actionPromise, errorPromise]);
    eventsHelper.removeEventListeners(listeners2);
    if (cspMessage)
      throw new Error(cspMessage.text());
    if (error3)
      throw error3;
    return result;
  }
  async retryWithProgressAndTimeouts(progress3, timeouts, action) {
    const continuePolling = Symbol("continuePolling");
    timeouts = [0, ...timeouts];
    let timeoutIndex = 0;
    while (true) {
      const timeout = timeouts[Math.min(timeoutIndex++, timeouts.length - 1)];
      if (timeout) {
        const actionPromise = new Promise((f) => setTimeout(f, timeout));
        await progress3.race(LongStandingScope.raceMultiple([
          this._page.openScope,
          this._detachedScope
        ], actionPromise));
      }
      try {
        const result = await action(continuePolling);
        if (result === continuePolling)
          continue;
        return result;
      } catch (e) {
        if (this.isNonRetriableError(e))
          throw e;
        continue;
      }
    }
  }
  isNonRetriableError(e) {
    if (isAbortError(e))
      return true;
    if (isJavaScriptErrorInEvaluate(e) || isSessionClosedError(e))
      return true;
    if (isNonRecoverableDOMError(e) || isInvalidSelectorError(e))
      return true;
    if (this.isDetached())
      return true;
    return false;
  }
  async _retryWithProgressIfNotConnected(progress3, selector, strict, performActionPreChecks, action) {
    progress3.log(`waiting for ${this._asLocator(selector)}`);
    return this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
      if (performActionPreChecks)
        await this._page.performActionPreChecks(progress3);
      const resolved = await progress3.race(this.selectors.resolveInjectedForSelector(selector, { strict }));
      if (!resolved)
        return continuePolling;
      const result = await progress3.race(resolved.injected.evaluateHandle((injected, { info: info3, callId }) => {
        const elements = injected.querySelectorAll(info3.parsed, document);
        if (callId)
          injected.markTargetElements(new Set(elements), callId);
        const element2 = elements[0];
        let log22 = "";
        if (elements.length > 1) {
          if (info3.strict)
            throw injected.strictModeViolationError(info3.parsed, elements);
          log22 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
        } else if (element2) {
          log22 = `  locator resolved to ${injected.previewNode(element2)}`;
        }
        return { log: log22, success: !!element2, element: element2 };
      }, { info: resolved.info, callId: progress3.metadata.id }));
      const { log: log3, success } = await progress3.race(result.evaluate((r) => ({ log: r.log, success: r.success })));
      if (log3)
        progress3.log(log3);
      if (!success) {
        result.dispose();
        return continuePolling;
      }
      const element = await progress3.race(result.evaluateHandle((r) => r.element));
      result.dispose();
      try {
        const result2 = await action(element);
        if (result2 === "error:notconnected") {
          progress3.log("element was detached from the DOM, retrying");
          return continuePolling;
        }
        return result2;
      } finally {
        element?.dispose();
      }
    });
  }
  async rafrafTimeoutScreenshotElementWithProgress(progress3, selector, timeout, options2) {
    return await this._retryWithProgressIfNotConnected(progress3, selector, true, true, async (handle) => {
      await handle._frame.rafrafTimeout(progress3, timeout);
      return await this._page.screenshotter.screenshotElement(progress3, handle, options2);
    });
  }
  async click(progress3, selector, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._click(progress3, { ...options2, waitAfter: !options2.noWaitAfter })));
  }
  async dblclick(progress3, selector, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._dblclick(progress3, options2)));
  }
  async dragAndDrop(progress3, source8, target, options2) {
    assertDone(await this._retryWithProgressIfNotConnected(progress3, source8, options2.strict, !options2.force, async (handle) => {
      return handle._retryPointerAction(progress3, "move and down", false, async (point) => {
        await this._page.mouse.move(progress3, point.x, point.y);
        await this._page.mouse.down(progress3);
      }, {
        ...options2,
        waitAfter: "disabled",
        position: options2.sourcePosition
      });
    }));
    assertDone(await this._retryWithProgressIfNotConnected(progress3, target, options2.strict, false, async (handle) => {
      return handle._retryPointerAction(progress3, "move and up", false, async (point) => {
        await this._page.mouse.move(progress3, point.x, point.y);
        await this._page.mouse.up(progress3);
      }, {
        ...options2,
        waitAfter: "disabled",
        position: options2.targetPosition
      });
    }));
  }
  async tap(progress3, selector, options2) {
    if (!this._page.browserContext._options.hasTouch)
      throw new Error("The page does not support tap. Use hasTouch context option to enable touch support.");
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._tap(progress3, options2)));
  }
  async fill(progress3, selector, value, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._fill(progress3, value, options2)));
  }
  async focus(progress3, selector, options2) {
    assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._focus(progress3)));
  }
  async blur(progress3, selector, options2) {
    assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._blur(progress3)));
  }
  async resolveSelector(progress3, selector, options2 = {}) {
    const element = await progress3.race(this.selectors.query(selector, options2));
    if (!element)
      throw new Error(`No element matching ${selector}`);
    const generated = await progress3.race(element.evaluateInUtility(async ([injected, node]) => {
      return injected.generateSelectorSimple(node);
    }, {}));
    if (!generated)
      throw new Error(`Unable to generate locator for ${selector}`);
    let frame = element._frame;
    const result = [generated];
    while (frame?.parentFrame()) {
      const frameElement = await progress3.race(frame.frameElement());
      if (frameElement) {
        const generated2 = await progress3.race(frameElement.evaluateInUtility(async ([injected, node]) => {
          return injected.generateSelectorSimple(node);
        }, {}));
        frameElement.dispose();
        if (generated2 === "error:notconnected" || !generated2)
          throw new Error(`Unable to generate locator for ${selector}`);
        result.push(generated2);
      }
      frame = frame.parentFrame();
    }
    const resolvedSelector = result.reverse().join(" >> internal:control=enter-frame >> ");
    return { resolvedSelector };
  }
  async textContent(progress3, selector, options2, scope) {
    return this._callOnElementOnceMatches(progress3, selector, (injected, element) => element.textContent, void 0, options2, scope);
  }
  async innerText(progress3, selector, options2, scope) {
    return this._callOnElementOnceMatches(progress3, selector, (injectedScript, element) => {
      if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
        throw injectedScript.createStacklessError("Node is not an HTMLElement");
      return element.innerText;
    }, void 0, options2, scope);
  }
  async innerHTML(progress3, selector, options2, scope) {
    return this._callOnElementOnceMatches(progress3, selector, (injected, element) => element.innerHTML, void 0, options2, scope);
  }
  async getAttribute(progress3, selector, name, options2, scope) {
    return this._callOnElementOnceMatches(progress3, selector, (injected, element, data) => element.getAttribute(data.name), { name }, options2, scope);
  }
  async inputValue(progress3, selector, options2, scope) {
    return this._callOnElementOnceMatches(progress3, selector, (injectedScript, node) => {
      const element = injectedScript.retarget(node, "follow-label");
      if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
        throw injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
      return element.value;
    }, void 0, options2, scope);
  }
  async highlight(progress3, selector) {
    const resolved = await progress3.race(this.selectors.resolveInjectedForSelector(selector));
    if (!resolved)
      return;
    return await progress3.race(resolved.injected.evaluate((injected, { info: info3 }) => {
      return injected.highlight(info3.parsed);
    }, { info: resolved.info }));
  }
  async hideHighlight() {
    return this.raceAgainstEvaluationStallingEvents(async () => {
      const context2 = await this._utilityContext();
      const injectedScript = await context2.injectedScript();
      return await injectedScript.evaluate((injected) => {
        return injected.hideHighlight();
      });
    });
  }
  async _elementState(progress3, selector, state, options2, scope) {
    const result = await this._callOnElementOnceMatches(progress3, selector, (injected, element, data) => {
      return injected.elementState(element, data.state);
    }, { state }, options2, scope);
    if (result.received === "error:notconnected")
      throwElementIsNotAttached();
    return result.matches;
  }
  async isVisible(progress3, selector, options2 = {}, scope) {
    progress3.log(`  checking visibility of ${this._asLocator(selector)}`);
    return await this.isVisibleInternal(progress3, selector, options2, scope);
  }
  async isVisibleInternal(progress3, selector, options2 = {}, scope) {
    try {
      const resolved = await progress3.race(this.selectors.resolveInjectedForSelector(selector, options2, scope));
      if (!resolved)
        return false;
      return await progress3.race(resolved.injected.evaluate((injected, { info: info3, root }) => {
        const element = injected.querySelector(info3.parsed, root || document, info3.strict);
        const state = element ? injected.elementState(element, "visible") : { matches: false, received: "error:notconnected" };
        return state.matches;
      }, { info: resolved.info, root: resolved.frame === this ? scope : void 0 }));
    } catch (e) {
      if (this.isNonRetriableError(e))
        throw e;
      return false;
    }
  }
  async isHidden(progress3, selector, options2 = {}, scope) {
    return !await this.isVisible(progress3, selector, options2, scope);
  }
  async isDisabled(progress3, selector, options2, scope) {
    return this._elementState(progress3, selector, "disabled", options2, scope);
  }
  async isEnabled(progress3, selector, options2, scope) {
    return this._elementState(progress3, selector, "enabled", options2, scope);
  }
  async isEditable(progress3, selector, options2, scope) {
    return this._elementState(progress3, selector, "editable", options2, scope);
  }
  async isChecked(progress3, selector, options2, scope) {
    return this._elementState(progress3, selector, "checked", options2, scope);
  }
  async hover(progress3, selector, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._hover(progress3, options2)));
  }
  async selectOption(progress3, selector, elements, values, options2) {
    return await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._selectOption(progress3, elements, values, options2));
  }
  async setInputFiles(progress3, selector, params) {
    const inputFileItems = await prepareFilesForUpload(this, params);
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, params.strict, true, (handle) => handle._setInputFiles(progress3, inputFileItems)));
  }
  async type(progress3, selector, text, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._type(progress3, text, options2)));
  }
  async press(progress3, selector, key, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, true, (handle) => handle._press(progress3, key, options2)));
  }
  async check(progress3, selector, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._setChecked(progress3, true, options2)));
  }
  async uncheck(progress3, selector, options2) {
    return assertDone(await this._retryWithProgressIfNotConnected(progress3, selector, options2.strict, !options2.force, (handle) => handle._setChecked(progress3, false, options2)));
  }
  async waitForTimeout(progress3, timeout) {
    return progress3.wait(timeout);
  }
  async ariaSnapshot(progress3, selector) {
    return await this._retryWithProgressIfNotConnected(progress3, selector, true, true, (handle) => progress3.race(handle.ariaSnapshot()));
  }
  async expect(progress3, selector, options2, timeout) {
    progress3.log(`${renderTitleForCall(progress3.metadata)}${timeout ? ` with timeout ${timeout}ms` : ""}`);
    const lastIntermediateResult = { isSet: false };
    const fixupMetadataError = /* @__PURE__ */ __name((result) => {
      if (result.matches === options2.isNot)
        progress3.metadata.error = { error: { name: "Expect", message: "Expect failed" } };
    }, "fixupMetadataError");
    try {
      if (selector)
        progress3.log(`waiting for ${this._asLocator(selector)}`);
      await this._page.performActionPreChecks(progress3);
      try {
        const resultOneShot = await this._expectInternal(progress3, selector, options2, lastIntermediateResult, true);
        if (resultOneShot.matches !== options2.isNot)
          return resultOneShot;
      } catch (e) {
        if (this.isNonRetriableError(e))
          throw e;
      }
      const result = await this.retryWithProgressAndTimeouts(progress3, [100, 250, 500, 1e3], async (continuePolling) => {
        await this._page.performActionPreChecks(progress3);
        const { matches, received } = await this._expectInternal(progress3, selector, options2, lastIntermediateResult, false);
        if (matches === options2.isNot) {
          return continuePolling;
        }
        return { matches, received };
      });
      fixupMetadataError(result);
      return result;
    } catch (e) {
      if (isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e))
        throw e;
      const result = { matches: options2.isNot, log: compressCallLog(progress3.metadata.log) };
      if (lastIntermediateResult.isSet)
        result.received = lastIntermediateResult.received;
      if (e instanceof TimeoutError)
        result.timedOut = true;
      fixupMetadataError(result);
      return result;
    }
  }
  async _expectInternal(progress3, selector, options2, lastIntermediateResult, noAbort) {
    const race = /* @__PURE__ */ __name((p) => noAbort ? p : progress3.race(p), "race");
    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : void 0;
    const { frame, info: info3 } = selectorInFrame || { frame: this, info: void 0 };
    const world = options2.expression === "to.have.property" ? "main" : info3?.world ?? "utility";
    const context2 = await race(frame._context(world));
    const injected = await race(context2.injectedScript());
    const { log: log3, matches, received, missingReceived } = await race(injected.evaluate(async (injected2, { info: info22, options: options22, callId }) => {
      const elements = info22 ? injected2.querySelectorAll(info22.parsed, document) : [];
      if (callId)
        injected2.markTargetElements(new Set(elements), callId);
      const isArray = options22.expression === "to.have.count" || options22.expression.endsWith(".array");
      let log22 = "";
      if (isArray)
        log22 = `  locator resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`;
      else if (elements.length > 1)
        throw injected2.strictModeViolationError(info22.parsed, elements);
      else if (elements.length)
        log22 = `  locator resolved to ${injected2.previewNode(elements[0])}`;
      return { log: log22, ...await injected2.expect(elements[0], options22, elements) };
    }, { info: info3, options: options2, callId: progress3.metadata.id }));
    if (log3)
      progress3.log(log3);
    if (matches === options2.isNot) {
      lastIntermediateResult.received = missingReceived ? "<element(s) not found>" : received;
      lastIntermediateResult.isSet = true;
      if (!missingReceived && !Array.isArray(received))
        progress3.log(`  unexpected value "${renderUnexpectedValue(options2.expression, received)}"`);
    }
    return { matches, received };
  }
  async waitForFunctionExpression(progress3, expression, isFunction, arg, options2, world = "main") {
    if (typeof options2.pollingInterval === "number")
      assert3(options2.pollingInterval > 0, "Cannot poll with non-positive interval: " + options2.pollingInterval);
    expression = normalizeEvaluationExpression(expression, isFunction);
    return this.retryWithProgressAndTimeouts(progress3, [100], async () => {
      const context2 = world === "main" ? await progress3.race(this._mainContext()) : await progress3.race(this._utilityContext());
      const injectedScript = await progress3.race(context2.injectedScript());
      const handle = await progress3.race(injectedScript.evaluateHandle((injected, { expression: expression2, isFunction: isFunction2, polling, arg: arg2 }) => {
        let evaledExpression;
        const predicate = /* @__PURE__ */ __name(() => {
          let result2 = evaledExpression ?? globalThis.eval(expression2);
          if (isFunction2 === true) {
            evaledExpression = result2;
            result2 = result2(arg2);
          } else if (isFunction2 === false) {
            result2 = result2;
          } else {
            if (typeof result2 === "function") {
              evaledExpression = result2;
              result2 = result2(arg2);
            }
          }
          return result2;
        }, "predicate");
        let fulfill;
        let reject;
        let aborted = false;
        const result = new Promise((f, r) => {
          fulfill = f;
          reject = r;
        });
        const next = /* @__PURE__ */ __name(() => {
          if (aborted)
            return;
          try {
            const success = predicate();
            if (success) {
              fulfill(success);
              return;
            }
            if (typeof polling !== "number")
              injected.utils.builtins.requestAnimationFrame(next);
            else
              injected.utils.builtins.setTimeout(next, polling);
          } catch (e) {
            reject(e);
          }
        }, "next");
        next();
        return { result, abort: /* @__PURE__ */ __name(() => aborted = true, "abort") };
      }, { expression, isFunction, polling: options2.pollingInterval, arg }));
      try {
        return await progress3.race(handle.evaluateHandle((h) => h.result));
      } catch (error3) {
        await handle.evaluate((h) => h.abort()).catch(() => {
        });
        throw error3;
      } finally {
        handle.dispose();
      }
    });
  }
  async waitForFunctionValueInUtility(progress3, pageFunction) {
    const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
    const handle = await this.waitForFunctionExpression(progress3, expression, true, void 0, {}, "utility");
    return JSON.parse(handle.rawValue());
  }
  async title() {
    const context2 = await this._utilityContext();
    return context2.evaluate(() => document.title);
  }
  async rafrafTimeout(progress3, timeout) {
    if (timeout === 0)
      return;
    const context2 = await progress3.race(this._utilityContext());
    await Promise.all([
      // wait for double raf
      progress3.race(context2.evaluate(() => new Promise((x) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(x);
        });
      }))),
      progress3.wait(timeout)
    ]);
  }
  _onDetached() {
    this._stopNetworkIdleTimer();
    this._detachedScope.close(new Error("Frame was detached"));
    for (const data of this._contextData.values()) {
      if (data.context)
        data.context.contextDestroyed("Frame was detached");
      data.contextPromise.resolve({ destroyedReason: "Frame was detached" });
    }
    if (this._parentFrame)
      this._parentFrame._childFrames.delete(this);
    this._parentFrame = null;
  }
  async _callOnElementOnceMatches(progress3, selector, body, taskData, options2, scope) {
    const callbackText = body.toString();
    progress3.log(`waiting for ${this._asLocator(selector)}`);
    const promise = this.retryWithProgressAndTimeouts(progress3, [0, 20, 50, 100, 100, 500], async (continuePolling) => {
      const resolved = await progress3.race(this.selectors.resolveInjectedForSelector(selector, options2, scope));
      if (!resolved)
        return continuePolling;
      const { log: log3, success, value } = await progress3.race(resolved.injected.evaluate((injected, { info: info3, callbackText: callbackText2, taskData: taskData2, callId, root }) => {
        const callback = injected.eval(callbackText2);
        const element = injected.querySelector(info3.parsed, root || document, info3.strict);
        if (!element)
          return { success: false };
        const log22 = `  locator resolved to ${injected.previewNode(element)}`;
        if (callId)
          injected.markTargetElements(/* @__PURE__ */ new Set([element]), callId);
        return { log: log22, success: true, value: callback(injected, element, taskData2) };
      }, { info: resolved.info, callbackText, taskData, callId: progress3.metadata.id, root: resolved.frame === this ? scope : void 0 }));
      if (log3)
        progress3.log(log3);
      if (!success)
        return continuePolling;
      return value;
    });
    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
  }
  _setContext(world, context2) {
    const data = this._contextData.get(world);
    data.context = context2;
    if (context2)
      data.contextPromise.resolve(context2);
    else
      data.contextPromise = new ManualPromise();
  }
  _contextCreated(world, context2) {
    const data = this._contextData.get(world);
    if (data.context) {
      data.context.contextDestroyed("Execution context was destroyed, most likely because of a navigation");
      this._setContext(world, null);
    }
    this._setContext(world, context2);
  }
  _contextDestroyed(context2) {
    if (this._detachedScope.isClosed())
      return;
    context2.contextDestroyed("Execution context was destroyed, most likely because of a navigation");
    for (const [world, data] of this._contextData) {
      if (data.context === context2)
        this._setContext(world, null);
    }
  }
  _startNetworkIdleTimer() {
    assert3(!this._networkIdleTimer);
    if (this._firedLifecycleEvents.has("networkidle") || this._detachedScope.isClosed())
      return;
    this._networkIdleTimer = setTimeout(() => {
      this._firedNetworkIdleSelf = true;
      this._page.mainFrame()._recalculateNetworkIdle();
    }, 500);
  }
  _stopNetworkIdleTimer() {
    if (this._networkIdleTimer)
      clearTimeout(this._networkIdleTimer);
    this._networkIdleTimer = void 0;
    this._firedNetworkIdleSelf = false;
  }
  async extendInjectedScript(source8, arg) {
    const context2 = await this._context("main");
    const injectedScriptHandle = await context2.injectedScript();
    await injectedScriptHandle.evaluate((injectedScript, { source: source22, arg: arg2 }) => {
      injectedScript.extend(source22, arg2);
    }, { source: source8, arg });
  }
  _asLocator(selector) {
    return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);
  }
};
var SignalBarrier = class {
  static {
    __name(this, "SignalBarrier");
  }
  constructor(progress3) {
    this._protectCount = 0;
    this._promise = new ManualPromise();
    this._progress = progress3;
    this.retain();
  }
  waitFor() {
    this.release();
    return this._progress.race(this._promise);
  }
  addFrameNavigation(frame) {
    if (frame.parentFrame())
      return;
    this.retain();
    const waiter = helper.waitForEvent(this._progress, frame, Frame.Events.InternalNavigation, (e) => {
      if (!e.isPublic)
        return false;
      if (!e.error && this._progress)
        this._progress.log(`  navigated to "${frame._url}"`);
      return true;
    });
    LongStandingScope.raceMultiple([
      frame._page.openScope,
      frame._detachedScope
    ], waiter.promise).catch(() => {
    }).finally(() => {
      waiter.dispose();
      this.release();
    });
  }
  retain() {
    ++this._protectCount;
  }
  release() {
    --this._protectCount;
    if (!this._protectCount)
      this._promise.resolve();
  }
};
function verifyLifecycle(name, waitUntil) {
  if (waitUntil === "networkidle0")
    waitUntil = "networkidle";
  if (!kLifecycleEvents.has(waitUntil))
    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}
__name(verifyLifecycle, "verifyLifecycle");
function renderUnexpectedValue(expression, received) {
  if (expression === "to.match.aria")
    return received ? received.raw : received;
  return received;
}
__name(renderUnexpectedValue, "renderUnexpectedValue");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/har/harTracer.js
var FALLBACK_HTTP_VERSION = "HTTP/1.1";
var HarTracer = class {
  static {
    __name(this, "HarTracer");
  }
  constructor(context2, page, delegate, options2) {
    this._barrierPromises = /* @__PURE__ */ new Set();
    this._pageEntries = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._started = false;
    this._context = context2;
    this._page = page;
    this._delegate = delegate;
    this._options = options2;
    if (options2.slimMode) {
      options2.omitSecurityDetails = true;
      options2.omitCookies = true;
      options2.omitTiming = true;
      options2.omitServerIP = true;
      options2.omitSizes = true;
      options2.omitPages = true;
    }
    this._entrySymbol = Symbol("requestHarEntry");
    this._baseURL = context2 instanceof APIRequestContext ? context2._defaultOptions().baseURL : context2._options.baseURL;
  }
  start(options2) {
    if (this._started)
      return;
    this._options.omitScripts = options2.omitScripts;
    this._started = true;
    const apiRequest = this._context instanceof APIRequestContext ? this._context : this._context.fetchRequest;
    this._eventListeners = [
      eventsHelper.addEventListener(apiRequest, APIRequestContext.Events.Request, (event) => this._onAPIRequest(event)),
      eventsHelper.addEventListener(apiRequest, APIRequestContext.Events.RequestFinished, (event) => this._onAPIRequestFinished(event))
    ];
    if (this._context instanceof BrowserContext) {
      this._eventListeners.push(
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, (page) => this._createPageEntryIfNeeded(page)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Request, (request2) => this._onRequest(request2)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFinished, ({ request: request2, response }) => this._onRequestFinished(request2, response).catch(() => {
        })),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFailed, (request2) => this._onRequestFailed(request2)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.Response, (response) => this._onResponse(response)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestAborted, (request2) => this._onRequestAborted(request2)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestFulfilled, (request2) => this._onRequestFulfilled(request2)),
        eventsHelper.addEventListener(this._context, BrowserContext.Events.RequestContinued, (request2) => this._onRequestContinued(request2))
      );
      for (const page of this._context.pages())
        this._createPageEntryIfNeeded(page);
    }
  }
  _shouldIncludeEntryWithUrl(urlString) {
    return !this._options.urlFilter || urlMatches(this._baseURL, urlString, this._options.urlFilter);
  }
  _entryForRequest(request2) {
    return request2[this._entrySymbol];
  }
  _createPageEntryIfNeeded(page) {
    if (!page)
      return;
    if (this._options.omitPages)
      return;
    if (this._page && page !== this._page)
      return;
    let pageEntry = this._pageEntries.get(page);
    if (!pageEntry) {
      const date = /* @__PURE__ */ new Date();
      pageEntry = {
        startedDateTime: date.toISOString(),
        id: page.guid,
        title: "",
        pageTimings: this._options.omitTiming ? {} : {
          onContentLoad: -1,
          onLoad: -1
        }
      };
      pageEntry[startedDateSymbol] = date;
      page.mainFrame().on(Frame.Events.AddLifecycle, (event) => {
        if (event === "load")
          this._onLoad(page, pageEntry);
        if (event === "domcontentloaded")
          this._onDOMContentLoaded(page, pageEntry);
      });
      this._pageEntries.set(page, pageEntry);
    }
    return pageEntry;
  }
  _onDOMContentLoaded(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        domContentLoaded: performance.timing.domContentLoadedEventStart
      };
    }), { isFunction: true, world: "utility" }).then((result) => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming)
        pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
    }).catch(() => {
    });
    this._addBarrier(page, promise);
  }
  _onLoad(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        loaded: performance.timing.loadEventStart
      };
    }), { isFunction: true, world: "utility" }).then((result) => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming)
        pageEntry.pageTimings.onLoad = result.loaded;
    }).catch(() => {
    });
    this._addBarrier(page, promise);
  }
  _addBarrier(target, promise) {
    if (!target)
      return null;
    if (!this._options.waitForContentOnStop)
      return;
    const race = target.openScope.safeRace(promise);
    this._barrierPromises.add(race);
    race.then(() => this._barrierPromises.delete(race));
  }
  _onAPIRequest(event) {
    if (!this._shouldIncludeEntryWithUrl(event.url.toString()))
      return;
    const harEntry = createHarEntry(event.method, event.url, void 0, this._options);
    harEntry._apiRequest = true;
    if (!this._options.omitCookies)
      harEntry.request.cookies = event.cookies;
    harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({ name, value }));
    harEntry.request.postData = this._postDataForBuffer(event.postData || null, event.headers["content-type"], this._options.content);
    if (!this._options.omitSizes)
      harEntry.request.bodySize = event.postData?.length || 0;
    event[this._entrySymbol] = harEntry;
    if (this._started)
      this._delegate.onEntryStarted(harEntry);
  }
  _onAPIRequestFinished(event) {
    const harEntry = this._entryForRequest(event.requestEvent);
    if (!harEntry)
      return;
    harEntry.response.status = event.statusCode;
    harEntry.response.statusText = event.statusMessage;
    harEntry.response.httpVersion = event.httpVersion;
    harEntry.response.redirectURL = event.headers.location || "";
    if (!this._options.omitServerIP) {
      harEntry.serverIPAddress = event.serverIPAddress;
      harEntry._serverPort = event.serverPort;
    }
    if (!this._options.omitTiming) {
      harEntry.timings = event.timings;
      this._computeHarEntryTotalTime(harEntry);
    }
    if (!this._options.omitSecurityDetails)
      harEntry._securityDetails = event.securityDetails;
    for (let i = 0; i < event.rawHeaders.length; i += 2) {
      harEntry.response.headers.push({
        name: event.rawHeaders[i],
        value: event.rawHeaders[i + 1]
      });
    }
    harEntry.response.cookies = this._options.omitCookies ? [] : event.cookies.map((c) => {
      return {
        ...c,
        expires: c.expires === -1 ? void 0 : safeDateToISOString(c.expires)
      };
    });
    const content = harEntry.response.content;
    const contentType = event.headers["content-type"];
    if (contentType)
      content.mimeType = contentType;
    this._storeResponseContent(event.body, content, "other");
    if (!this._options.omitSizes)
      harEntry.response.bodySize = event.body?.length ?? 0;
    if (this._started)
      this._delegate.onEntryFinished(harEntry);
  }
  _onRequest(request2) {
    if (!this._shouldIncludeEntryWithUrl(request2.url()))
      return;
    const page = request2.frame()?._page;
    if (this._page && page !== this._page)
      return;
    const url4 = parseURL2(request2.url());
    if (!url4)
      return;
    const pageEntry = this._createPageEntryIfNeeded(page);
    const harEntry = createHarEntry(request2.method(), url4, request2.frame()?.guid, this._options);
    if (pageEntry)
      harEntry.pageref = pageEntry.id;
    this._recordRequestHeadersAndCookies(harEntry, request2.headers());
    harEntry.request.postData = this._postDataForRequest(request2, this._options.content);
    if (!this._options.omitSizes)
      harEntry.request.bodySize = request2.bodySize();
    if (request2.redirectedFrom()) {
      const fromEntry = this._entryForRequest(request2.redirectedFrom());
      if (fromEntry)
        fromEntry.response.redirectURL = request2.url();
    }
    request2[this._entrySymbol] = harEntry;
    assert3(this._started);
    this._delegate.onEntryStarted(harEntry);
  }
  _recordRequestHeadersAndCookies(harEntry, headers) {
    if (!this._options.omitCookies) {
      harEntry.request.cookies = [];
      for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
        harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
    }
    harEntry.request.headers = headers;
  }
  _recordRequestOverrides(harEntry, request2) {
    if (!request2.overrides() || !this._options.recordRequestOverrides)
      return;
    harEntry.request.method = request2.method();
    harEntry.request.url = request2.url();
    harEntry.request.postData = this._postDataForRequest(request2, this._options.content);
    this._recordRequestHeadersAndCookies(harEntry, request2.headers());
  }
  async _onRequestFinished(request2, response) {
    if (!response)
      return;
    const harEntry = this._entryForRequest(request2);
    if (!harEntry)
      return;
    const page = request2.frame()?._page;
    if (!this._options.omitServerIP) {
      this._addBarrier(page || request2.serviceWorker(), response.serverAddr().then((server) => {
        if (server?.ipAddress)
          harEntry.serverIPAddress = server.ipAddress;
        if (server?.port)
          harEntry._serverPort = server.port;
      }));
    }
    if (!this._options.omitSecurityDetails) {
      this._addBarrier(page || request2.serviceWorker(), response.securityDetails().then((details) => {
        if (details)
          harEntry._securityDetails = details;
      }));
    }
    const httpVersion = response.httpVersion();
    harEntry.request.httpVersion = httpVersion;
    harEntry.response.httpVersion = httpVersion;
    const compressionCalculationBarrier = this._options.omitSizes ? void 0 : {
      _encodedBodySize: -1,
      _decodedBodySize: -1,
      barrier: new ManualPromise(),
      _check: /* @__PURE__ */ __name(function() {
        if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
          harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
          this.barrier.resolve();
        }
      }, "_check"),
      setEncodedBodySize: /* @__PURE__ */ __name(function(encodedBodySize) {
        this._encodedBodySize = encodedBodySize;
        this._check();
      }, "setEncodedBodySize"),
      setDecodedBodySize: /* @__PURE__ */ __name(function(decodedBodySize) {
        this._decodedBodySize = decodedBodySize;
        this._check();
      }, "setDecodedBodySize")
    };
    if (compressionCalculationBarrier)
      this._addBarrier(page || request2.serviceWorker(), compressionCalculationBarrier.barrier);
    const promise = response.body().then((buffer) => {
      if (this._options.omitScripts && request2.resourceType() === "script") {
        compressionCalculationBarrier?.setDecodedBodySize(0);
        return;
      }
      const content = harEntry.response.content;
      compressionCalculationBarrier?.setDecodedBodySize(buffer.length);
      this._storeResponseContent(buffer, content, request2.resourceType());
    }).catch(() => {
      compressionCalculationBarrier?.setDecodedBodySize(0);
    }).then(() => {
      if (this._started)
        this._delegate.onEntryFinished(harEntry);
    });
    this._addBarrier(page || request2.serviceWorker(), promise);
    const timing = response.timing();
    harEntry.timings.receive = response.request()._responseEndTiming !== -1 ? helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
    this._computeHarEntryTotalTime(harEntry);
    if (!this._options.omitSizes) {
      this._addBarrier(page || request2.serviceWorker(), response.sizes().then((sizes) => {
        harEntry.response.bodySize = sizes.responseBodySize;
        harEntry.response.headersSize = sizes.responseHeadersSize;
        harEntry.response._transferSize = sizes.transferSize;
        harEntry.request.headersSize = sizes.requestHeadersSize;
        compressionCalculationBarrier?.setEncodedBodySize(sizes.responseBodySize);
      }));
    }
  }
  async _onRequestFailed(request2) {
    const harEntry = this._entryForRequest(request2);
    if (!harEntry)
      return;
    if (request2._failureText !== null)
      harEntry.response._failureText = request2._failureText;
    this._recordRequestOverrides(harEntry, request2);
    if (this._started)
      this._delegate.onEntryFinished(harEntry);
  }
  _onRequestAborted(request2) {
    const harEntry = this._entryForRequest(request2);
    if (harEntry)
      harEntry._wasAborted = true;
  }
  _onRequestFulfilled(request2) {
    const harEntry = this._entryForRequest(request2);
    if (harEntry)
      harEntry._wasFulfilled = true;
  }
  _onRequestContinued(request2) {
    const harEntry = this._entryForRequest(request2);
    if (harEntry)
      harEntry._wasContinued = true;
  }
  _storeResponseContent(buffer, content, resourceType) {
    if (!buffer) {
      content.size = 0;
      return;
    }
    if (!this._options.omitSizes)
      content.size = buffer.length;
    if (this._options.content === "embed") {
      if (isTextualMimeType(content.mimeType) && resourceType !== "font") {
        content.text = buffer.toString();
      } else {
        content.text = buffer.toString("base64");
        content.encoding = "base64";
      }
    } else if (this._options.content === "attach") {
      const sha1 = calculateSha1(buffer) + "." + (mime2.getExtension(content.mimeType) || "dat");
      if (this._options.includeTraceInfo)
        content._sha1 = sha1;
      else
        content._file = sha1;
      if (this._started)
        this._delegate.onContentBlob(sha1, buffer);
    }
  }
  _onResponse(response) {
    const harEntry = this._entryForRequest(response.request());
    if (!harEntry)
      return;
    const page = response.frame()?._page;
    const pageEntry = this._createPageEntryIfNeeded(page);
    const request2 = response.request();
    harEntry.response = {
      status: response.status(),
      statusText: response.statusText(),
      httpVersion: response.httpVersion(),
      // These are bad values that will be overwritten below.
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: "x-unknown"
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: "",
      _transferSize: this._options.omitSizes ? void 0 : -1
    };
    if (!this._options.omitTiming) {
      const startDateTime = pageEntry ? pageEntry[startedDateSymbol].valueOf() : 0;
      const timing = response.timing();
      if (pageEntry && startDateTime > timing.startTime)
        pageEntry.startedDateTime = new Date(timing.startTime).toISOString();
      const dns2 = timing.domainLookupEnd !== -1 ? helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
      const connect2 = timing.connectEnd !== -1 ? helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
      const ssl = timing.connectEnd !== -1 ? helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
      const wait = timing.responseStart !== -1 ? helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
      const receive = -1;
      harEntry.timings = {
        dns: dns2,
        connect: connect2,
        ssl,
        send: 0,
        wait,
        receive
      };
      this._computeHarEntryTotalTime(harEntry);
    }
    this._recordRequestOverrides(harEntry, request2);
    this._addBarrier(page || request2.serviceWorker(), request2.rawRequestHeaders().then((headers) => {
      this._recordRequestHeadersAndCookies(harEntry, headers);
    }));
    this._recordResponseHeaders(harEntry, response.headers());
    this._addBarrier(page || request2.serviceWorker(), response.rawResponseHeaders().then((headers) => {
      this._recordResponseHeaders(harEntry, headers);
    }));
  }
  _recordResponseHeaders(harEntry, headers) {
    if (!this._options.omitCookies) {
      harEntry.response.cookies = headers.filter((header) => header.name.toLowerCase() === "set-cookie").map((header) => parseCookie(header.value));
    }
    harEntry.response.headers = headers;
    const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
    if (contentType)
      harEntry.response.content.mimeType = contentType.value;
  }
  _computeHarEntryTotalTime(harEntry) {
    harEntry.time = [
      harEntry.timings.dns,
      harEntry.timings.connect,
      harEntry.timings.ssl,
      harEntry.timings.wait,
      harEntry.timings.receive
    ].reduce((pre, cur) => (cur || -1) > 0 ? cur + pre : pre, 0);
  }
  async flush() {
    await Promise.all(this._barrierPromises);
  }
  stop() {
    this._started = false;
    eventsHelper.removeEventListeners(this._eventListeners);
    this._barrierPromises.clear();
    const context2 = this._context instanceof BrowserContext ? this._context : void 0;
    const log3 = {
      version: "1.2",
      creator: {
        name: "Playwright",
        version: getPlaywrightVersion()
      },
      browser: {
        name: context2?._browser.options.name || "",
        version: context2?._browser.version() || ""
      },
      pages: this._pageEntries.size ? Array.from(this._pageEntries.values()) : void 0,
      entries: []
    };
    if (!this._options.omitTiming) {
      for (const pageEntry of log3.pages || []) {
        const startDateTime = pageEntry[startedDateSymbol].valueOf();
        if (typeof pageEntry.pageTimings.onContentLoad === "number" && pageEntry.pageTimings.onContentLoad >= 0)
          pageEntry.pageTimings.onContentLoad -= startDateTime;
        else
          pageEntry.pageTimings.onContentLoad = -1;
        if (typeof pageEntry.pageTimings.onLoad === "number" && pageEntry.pageTimings.onLoad >= 0)
          pageEntry.pageTimings.onLoad -= startDateTime;
        else
          pageEntry.pageTimings.onLoad = -1;
      }
    }
    this._pageEntries.clear();
    return log3;
  }
  _postDataForRequest(request2, content) {
    const postData = request2.postDataBuffer();
    if (!postData)
      return;
    const contentType = request2.headerValue("content-type");
    return this._postDataForBuffer(postData, contentType, content);
  }
  _postDataForBuffer(postData, contentType, content) {
    if (!postData)
      return;
    contentType ??= "application/octet-stream";
    const result = {
      mimeType: contentType,
      text: "",
      params: []
    };
    if (content === "embed" && contentType !== "application/octet-stream")
      result.text = postData.toString();
    if (content === "attach") {
      const sha1 = calculateSha1(postData) + "." + (mime2.getExtension(contentType) || "dat");
      if (this._options.includeTraceInfo)
        result._sha1 = sha1;
      else
        result._file = sha1;
      this._delegate.onContentBlob(sha1, postData);
    }
    if (contentType === "application/x-www-form-urlencoded") {
      const parsed = new URLSearchParams(postData.toString());
      for (const [name, value] of parsed.entries())
        result.params.push({ name, value });
    }
    return result;
  }
};
function createHarEntry(method, url4, frameref, options2) {
  const harEntry = {
    _frameref: options2.includeTraceInfo ? frameref : void 0,
    _monotonicTime: options2.includeTraceInfo ? monotonicTime() : void 0,
    startedDateTime: (/* @__PURE__ */ new Date()).toISOString(),
    time: -1,
    request: {
      method,
      url: url4.toString(),
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      queryString: [...url4.searchParams].map((e) => ({ name: e[0], value: e[1] })),
      headersSize: -1,
      bodySize: -1
    },
    response: {
      status: -1,
      statusText: "",
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: "x-unknown"
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: "",
      _transferSize: options2.omitSizes ? void 0 : -1
    },
    cache: {},
    timings: {
      send: -1,
      wait: -1,
      receive: -1
    }
  };
  return harEntry;
}
__name(createHarEntry, "createHarEntry");
function parseCookie(c) {
  const cookie = {
    name: "",
    value: ""
  };
  let first = true;
  for (const pair of c.split(/; */)) {
    const indexOfEquals = pair.indexOf("=");
    const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
    const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
    if (first) {
      first = false;
      cookie.name = name;
      cookie.value = value;
      continue;
    }
    if (name === "Domain")
      cookie.domain = value;
    if (name === "Expires")
      cookie.expires = safeDateToISOString(value);
    if (name === "HttpOnly")
      cookie.httpOnly = true;
    if (name === "Max-Age")
      cookie.expires = safeDateToISOString(Date.now() + +value * 1e3);
    if (name === "Path")
      cookie.path = value;
    if (name === "SameSite")
      cookie.sameSite = value;
    if (name === "Secure")
      cookie.secure = true;
  }
  return cookie;
}
__name(parseCookie, "parseCookie");
function safeDateToISOString(value) {
  try {
    return new Date(value).toISOString();
  } catch (e) {
  }
}
__name(safeDateToISOString, "safeDateToISOString");
var startedDateSymbol = Symbol("startedDate");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/har/harRecorder.js
var HarRecorder = class {
  static {
    __name(this, "HarRecorder");
  }
  constructor(context2, page, options2) {
    this._isFlushed = false;
    this._entries = [];
    this._zipFile = null;
    this._writtenZipEntries = /* @__PURE__ */ new Set();
    this._artifact = new Artifact(context2, path10.join(context2._browser.options.artifactsDir, `${createGuid()}.har`));
    const urlFilterRe = options2.urlRegexSource !== void 0 && options2.urlRegexFlags !== void 0 ? new RegExp(options2.urlRegexSource, options2.urlRegexFlags) : void 0;
    const expectsZip = !!options2.zip;
    const content = options2.content || (expectsZip ? "attach" : "embed");
    this._tracer = new HarTracer(context2, page, this, {
      content,
      slimMode: options2.mode === "minimal",
      includeTraceInfo: false,
      recordRequestOverrides: true,
      waitForContentOnStop: true,
      urlFilter: urlFilterRe ?? options2.urlGlob
    });
    this._zipFile = content === "attach" || expectsZip ? new yazl2.ZipFile() : null;
    this._tracer.start({ omitScripts: false });
  }
  onEntryStarted(entry) {
    this._entries.push(entry);
  }
  onEntryFinished(entry) {
  }
  onContentBlob(sha1, buffer) {
    if (!this._zipFile || this._writtenZipEntries.has(sha1))
      return;
    this._writtenZipEntries.add(sha1);
    this._zipFile.addBuffer(buffer, sha1);
  }
  async flush() {
    if (this._isFlushed)
      return;
    this._isFlushed = true;
    await this._tracer.flush();
    const log3 = this._tracer.stop();
    log3.entries = this._entries;
    const harFileContent = jsonStringify({ log: log3 });
    if (this._zipFile) {
      const result = new ManualPromise();
      this._zipFile.on("error", (error3) => result.reject(error3));
      this._zipFile.addBuffer(Buffer.from(harFileContent, "utf-8"), "har.har");
      this._zipFile.end();
      const chunks = [];
      this._zipFile.outputStream.on("data", (data) => chunks.push(data)).on("close", () => {
        fs14.writeFileSync(this._artifact.localPath(), Buffer.concat(chunks));
        result.resolve();
      });
      await result;
    } else {
      await fs14.promises.writeFile(this._artifact.localPath(), harFileContent);
    }
  }
  async export() {
    await this.flush();
    this._artifact.reportFinished();
    return this._artifact;
  }
};
function jsonStringify(object) {
  const tokens = [];
  innerJsonStringify(object, tokens, "", false, void 0);
  return tokens.join("");
}
__name(jsonStringify, "jsonStringify");
function innerJsonStringify(object, tokens, indent, flat, parentKey) {
  if (typeof object !== "object" || object === null) {
    tokens.push(JSON.stringify(object));
    return;
  }
  const isArray = Array.isArray(object);
  if (!isArray && object.constructor.name !== "Object") {
    tokens.push(JSON.stringify(object));
    return;
  }
  const entries = isArray ? object : Object.entries(object).filter((e) => e[1] !== void 0);
  if (!entries.length) {
    tokens.push(isArray ? `[]` : `{}`);
    return;
  }
  const childIndent = `${indent}  `;
  let brackets;
  if (isArray)
    brackets = flat ? { open: "[", close: "]" } : { open: `[
${childIndent}`, close: `
${indent}]` };
  else
    brackets = flat ? { open: "{ ", close: " }" } : { open: `{
${childIndent}`, close: `
${indent}}` };
  tokens.push(brackets.open);
  for (let i = 0; i < entries.length; ++i) {
    const entry = entries[i];
    if (i)
      tokens.push(flat ? `, ` : `,
${childIndent}`);
    if (!isArray)
      tokens.push(`${JSON.stringify(entry[0])}: `);
    const key = isArray ? void 0 : entry[0];
    const flatten = flat || key === "timings" || parentKey === "headers";
    innerJsonStringify(isArray ? entry : entry[1], tokens, childIndent, flatten, key);
  }
  tokens.push(brackets.close);
}
__name(innerJsonStringify, "innerJsonStringify");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderApp.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/_virtual/empty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/mocks/empty.js
var empty_exports = {};
__export(empty_exports, {
  default: () => empty
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var empty = {};

// node_modules/@cloudflare/playwright/lib/_virtual/empty.js
var require$$06 = /* @__PURE__ */ getAugmentedNamespace(empty_exports);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderApp.js
import fs18 from "node:fs";
import path12 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/launchApp.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs15 from "node:fs";
import path11 from "node:path";
import "node:crypto";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
async function launchApp(browserType, options2) {
  const args = [...options2.persistentContextOptions?.args ?? []];
  let channel2 = options2.persistentContextOptions?.channel;
  if (browserType.name() === "chromium") {
    args.push(
      "--app=data:text/html,",
      `--window-size=${options2.windowSize.width},${options2.windowSize.height}`,
      ...options2.windowPosition ? [`--window-position=${options2.windowPosition.x},${options2.windowPosition.y}`] : [],
      "--test-type="
    );
    if (!channel2 && !options2.persistentContextOptions?.executablePath)
      channel2 = findChromiumChannelBestEffort(options2.sdkLanguage);
  }
  const controller = new ProgressController();
  let context2;
  try {
    context2 = await controller.run((progress3) => browserType.launchPersistentContext(progress3, "", {
      ignoreDefaultArgs: ["--enable-automation"],
      ...options2?.persistentContextOptions,
      channel: channel2,
      noDefaultViewport: options2.persistentContextOptions?.noDefaultViewport ?? true,
      acceptDownloads: options2?.persistentContextOptions?.acceptDownloads ?? (isUnderTest() ? "accept" : "internal-browser-default"),
      colorScheme: options2?.persistentContextOptions?.colorScheme ?? "no-override",
      args
    }), 0);
  } catch (error3) {
    if (channel2) {
      error3 = rewriteErrorMessage(error3, [
        `Failed to launch "${channel2}" channel.`,
        "Using custom channels could lead to unexpected behavior due to Enterprise policies (chrome://policy).",
        "Install the default browser instead:",
        wrapInASCIIBox(`${buildPlaywrightCLICommand(options2.sdkLanguage, "install")}`, 2)
      ].join("\n"));
    }
    throw error3;
  }
  const [page] = context2.pages();
  if (browserType.name() === "chromium" && process.platform === "darwin") {
    context2.on("page", async (newPage) => {
      if (newPage.mainFrame().url() === "chrome://new-tab-page/") {
        await page.bringToFront();
        await newPage.close();
      }
    });
  }
  if (browserType.name() === "chromium")
    await installAppIcon(page);
  return { context: context2, page };
}
__name(launchApp, "launchApp");
async function installAppIcon(page) {
  const icon = await fs15.promises.readFile(__require.resolve("./chromium/appIcon.png"));
  const crPage = page.delegate;
  await crPage._mainFrameSession._client.send("Browser.setDockTile", {
    image: icon.toString("base64")
  });
}
__name(installAppIcon, "installAppIcon");
async function syncLocalStorageWithSettings(page, appName) {
  if (isUnderTest())
    return;
  const settingsFile = path11.join(registryDirectory, ".settings", `${appName}.json`);
  const controller = new ProgressController();
  await controller.run(async (progress3) => {
    await page.exposeBinding(progress3, "_saveSerializedSettings", false, (_, settings2) => {
      fs15.mkdirSync(path11.dirname(settingsFile), { recursive: true });
      fs15.writeFileSync(settingsFile, settings2);
    });
    const settings = await fs15.promises.readFile(settingsFile, "utf-8").catch(() => "{}");
    await page.addInitScript(
      progress3,
      `(${String((settings2) => {
        if (location && location.protocol === "data:")
          return;
        if (window.top !== window)
          return;
        Object.entries(settings2).map(([k, v]) => localStorage[k] = v);
        window.saveSettings = () => {
          window._saveSerializedSettings(JSON.stringify({ ...localStorage }));
        };
      })})(${settings});
    `
    );
  });
}
__name(syncLocalStorageWithSettings, "syncLocalStorageWithSettings");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/throttledFile.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs16 from "node:fs";
var ThrottledFile = class {
  static {
    __name(this, "ThrottledFile");
  }
  constructor(file) {
    this._file = file;
  }
  setContent(text) {
    this._text = text;
    if (!this._timer)
      this._timer = setTimeout(() => this.flush(), 250);
  }
  flush() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = void 0;
    }
    if (this._text)
      fs16.writeFileSync(this._file, this._text);
    this._text = void 0;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/languages.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/csharp.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/language.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function generateCode(actions, languageGenerator, options2) {
  const header = languageGenerator.generateHeader(options2);
  const footer = languageGenerator.generateFooter(options2.saveStorage);
  const actionTexts = actions.map((a) => generateActionText(languageGenerator, a, !!options2.generateAutoExpect)).filter(Boolean);
  const text = [header, ...actionTexts, footer].join("\n");
  return { header, footer, actionTexts, text };
}
__name(generateCode, "generateCode");
function generateActionText(generator, action, generateAutoExpect) {
  let text = generator.generateAction(action);
  if (!text)
    return;
  if (generateAutoExpect && action.action.preconditionSelector) {
    const expectAction = {
      frame: action.frame,
      startTime: action.startTime,
      endTime: action.startTime,
      action: {
        name: "assertVisible",
        selector: action.action.preconditionSelector,
        signals: []
      }
    };
    const expectText = generator.generateAction(expectAction);
    if (expectText)
      text = expectText + "\n\n" + text;
  }
  return text;
}
__name(generateActionText, "generateActionText");
function sanitizeDeviceOptions(device, options2) {
  const cleanedOptions = {};
  for (const property in options2) {
    if (JSON.stringify(device[property]) !== JSON.stringify(options2[property]))
      cleanedOptions[property] = options2[property];
  }
  return cleanedOptions;
}
__name(sanitizeDeviceOptions, "sanitizeDeviceOptions");
function toSignalMap(action) {
  let popup;
  let download;
  let dialog;
  for (const signal of action.signals) {
    if (signal.name === "popup")
      popup = signal;
    else if (signal.name === "download")
      download = signal;
    else if (signal.name === "dialog")
      dialog = signal;
  }
  return {
    popup,
    download,
    dialog
  };
}
__name(toSignalMap, "toSignalMap");
function toKeyboardModifiers(modifiers) {
  const result = [];
  if (modifiers & 1)
    result.push("Alt");
  if (modifiers & 2)
    result.push("ControlOrMeta");
  if (modifiers & 4)
    result.push("ControlOrMeta");
  if (modifiers & 8)
    result.push("Shift");
  return result;
}
__name(toKeyboardModifiers, "toKeyboardModifiers");
function toClickOptionsForSourceCode(action) {
  const modifiers = toKeyboardModifiers(action.modifiers);
  const options2 = {};
  if (action.button !== "left")
    options2.button = action.button;
  if (modifiers.length)
    options2.modifiers = modifiers;
  if (action.clickCount > 2)
    options2.clickCount = action.clickCount;
  if (action.position)
    options2.position = action.position;
  return options2;
}
__name(toClickOptionsForSourceCode, "toClickOptionsForSourceCode");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/csharp.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/deviceDescriptors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/deviceDescriptorsSource.json.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var deviceDescriptorsSource = {
  "Blackberry PlayBook": { "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/26.0 Safari/536.2+", "viewport": { "width": 600, "height": 1024 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Blackberry PlayBook landscape": { "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/26.0 Safari/536.2+", "viewport": { "width": 1024, "height": 600 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "BlackBerry Z30": { "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/26.0 Mobile Safari/537.10+", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "BlackBerry Z30 landscape": { "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/26.0 Mobile Safari/537.10+", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note 3": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note 3 landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note II": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy Note II landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S III": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S III landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/26.0 Mobile Safari/534.30", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Galaxy S5": { "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S8": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 360, "height": 740 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S8 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 740, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S9+": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 320, "height": 658 }, "deviceScaleFactor": 4.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S9+ landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 658, "height": 320 }, "deviceScaleFactor": 4.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S24": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-S921U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 480, "height": 1040 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy S24 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-S921U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 1040, "height": 480 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy A55": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-A556B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 480, "height": 1040 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy A55 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-A556B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 1040, "height": 480 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S4": { "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 712, "height": 1138 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 1138, "height": 712 }, "deviceScaleFactor": 2.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S9": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-X710) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 640, "height": 1024 }, "deviceScaleFactor": 2.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Galaxy Tab S9 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 14; SM-X710) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 1024, "height": 640 }, "deviceScaleFactor": 2.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "iPad (gen 5)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 5) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 6)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 6) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 7)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 810, "height": 1080 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 7) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 1080, "height": 810 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 11)": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/19E241 Safari/604.1", "viewport": { "width": 656, "height": 944 }, "deviceScaleFactor": 2.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad (gen 11) landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 18_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/19E241 Safari/604.1", "viewport": { "width": 944, "height": 656 }, "deviceScaleFactor": 2.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Mini": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 768, "height": 1024 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Mini landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 1024, "height": 768 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Pro 11": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 834, "height": 1194 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPad Pro 11 landscape": { "userAgent": "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 1194, "height": 834 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 6 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 7 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 414, "height": 736 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 8 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 736, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/26.0 Mobile/14E304 Safari/602.1", "viewport": { "width": 320, "height": 568 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/26.0 Mobile/14E304 Safari/602.1", "viewport": { "width": 568, "height": 320 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE (3rd gen)": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/26.0 Mobile/19E241 Safari/602.1", "viewport": { "width": 375, "height": 667 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone SE (3rd gen) landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 18_5 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/26.0 Mobile/19E241 Safari/602.1", "viewport": { "width": 667, "height": 375 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone X": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 375, "height": 812 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone X landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/26.0 Mobile/15A372 Safari/604.1", "viewport": { "width": 812, "height": 375 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone XR": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 414, "height": 896 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone XR landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "viewport": { "width": 896, "height": 414 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 414, "height": 715 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 800, "height": 364 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 635 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 724, "height": 325 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 414, "height": 715 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 11 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 414, "height": 896 }, "viewport": { "width": 808, "height": 364 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 378 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Mini": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 629 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 12 Mini landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 712, "height": 325 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 342 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 342 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Mini": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 375, "height": 629 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 13 Mini landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 375, "height": 812 }, "viewport": { "width": 712, "height": 327 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 390, "height": 664 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 390, "height": 844 }, "viewport": { "width": 750, "height": 340 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 428, "height": 746 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 428, "height": 926 }, "viewport": { "width": 832, "height": 378 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 660 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 740 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 14 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 659 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Plus": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 739 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Plus landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 393, "height": 659 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 393, "height": 852 }, "viewport": { "width": 734, "height": 343 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro Max": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 430, "height": 739 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "iPhone 15 Pro Max landscape": { "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Mobile/15E148 Safari/604.1", "screen": { "width": 430, "height": 932 }, "viewport": { "width": 814, "height": 380 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Kindle Fire HDX": { "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true", "viewport": { "width": 800, "height": 1280 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Kindle Fire HDX landscape": { "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true", "viewport": { "width": 1280, "height": 800 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "LG Optimus L70": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 384, "height": 640 }, "deviceScaleFactor": 1.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "LG Optimus L70 landscape": { "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 640, "height": 384 }, "deviceScaleFactor": 1.25, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 550": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 550 landscape": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 950": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 4, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Microsoft Lumia 950 landscape": { "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36 Edge/14.14263", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 4, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 10": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 800, "height": 1280 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 10 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 1280, "height": 800 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 4": { "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 384, "height": 640 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 640, "height": 384 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5X": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 5X landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6": { "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6P": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 412, "height": 732 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 6P landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 732, "height": 412 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 7": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 600, "height": 960 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nexus 7 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "viewport": { "width": 960, "height": 600 }, "deviceScaleFactor": 2, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia Lumia 520": { "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)", "viewport": { "width": 320, "height": 533 }, "deviceScaleFactor": 1.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia Lumia 520 landscape": { "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)", "viewport": { "width": 533, "height": 320 }, "deviceScaleFactor": 1.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Nokia N9": { "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13", "viewport": { "width": 480, "height": 854 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Nokia N9 landscape": { "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13", "viewport": { "width": 854, "height": 480 }, "deviceScaleFactor": 1, "isMobile": true, "hasTouch": true, "defaultBrowserType": "webkit" },
  "Pixel 2": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 411, "height": 731 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 731, "height": 411 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 XL": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 411, "height": 823 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 2 XL landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 823, "height": 411 }, "deviceScaleFactor": 3.5, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 3": { "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 393, "height": 786 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 3 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 786, "height": 393 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4": { "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 353, "height": 745 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 745, "height": 353 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4a (5G)": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "width": 412, "height": 892 }, "viewport": { "width": 412, "height": 765 }, "deviceScaleFactor": 2.63, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 4a (5G) landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "height": 892, "width": 412 }, "viewport": { "width": 840, "height": 312 }, "deviceScaleFactor": 2.63, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 5": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "width": 393, "height": 851 }, "viewport": { "width": 393, "height": 727 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 5 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "width": 851, "height": 393 }, "viewport": { "width": 802, "height": 293 }, "deviceScaleFactor": 2.75, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 7": { "userAgent": "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "width": 412, "height": 915 }, "viewport": { "width": 412, "height": 839 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Pixel 7 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "screen": { "width": 915, "height": 412 }, "viewport": { "width": 863, "height": 360 }, "deviceScaleFactor": 2.625, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Moto G4": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 360, "height": 640 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Moto G4 landscape": { "userAgent": "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Mobile Safari/537.36", "viewport": { "width": 640, "height": 360 }, "deviceScaleFactor": 3, "isMobile": true, "hasTouch": true, "defaultBrowserType": "chromium" },
  "Desktop Chrome HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Edge HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36 Edg/140.0.7339.16", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Firefox HiDPI": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "firefox" },
  "Desktop Safari": { "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/26.0 Safari/605.1.15", "screen": { "width": 1792, "height": 1120 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 2, "isMobile": false, "hasTouch": false, "defaultBrowserType": "webkit" },
  "Desktop Chrome": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Edge": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.7339.16 Safari/537.36 Edg/140.0.7339.16", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "chromium" },
  "Desktop Firefox": { "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:141.0) Gecko/20100101 Firefox/141.0", "screen": { "width": 1920, "height": 1080 }, "viewport": { "width": 1280, "height": 720 }, "deviceScaleFactor": 1, "isMobile": false, "hasTouch": false, "defaultBrowserType": "firefox" }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/deviceDescriptors.js
var deviceDescriptors = deviceDescriptorsSource;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/csharp.js
var CSharpLanguageGenerator = class {
  static {
    __name(this, "CSharpLanguageGenerator");
  }
  constructor(mode) {
    this.groupName = ".NET C#";
    this.highlighter = "csharp";
    if (mode === "library") {
      this.name = "Library";
      this.id = "csharp";
    } else if (mode === "mstest") {
      this.name = "MSTest";
      this.id = "csharp-mstest";
    } else if (mode === "nunit") {
      this.name = "NUnit";
      this.id = "csharp-nunit";
    } else {
      throw new Error(`Unknown C# language mode: ${mode}`);
    }
    this._mode = mode;
  }
  generateAction(actionInContext) {
    const action = this._generateActionInner(actionInContext);
    if (action)
      return action;
    return "";
  }
  _generateActionInner(actionInContext) {
    const action = actionInContext.action;
    if (this._mode !== "library" && (action.name === "openPage" || action.name === "closePage"))
      return "";
    const pageAlias = this._formatPageAlias(actionInContext.frame.pageAlias);
    const formatter = new CSharpFormatter(this._mode === "library" ? 0 : 8);
    if (action.name === "openPage") {
      formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.ContentFrame`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals2 = toSignalMap(action);
    if (signals2.dialog) {
      formatter.add(`    void ${pageAlias}_Dialog${signals2.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals2.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals2.dialog.dialogAlias}_EventHandler;`);
    }
    const lines = [];
    lines.push(this._generateActionCall(subject, actionInContext));
    if (signals2.download) {
      lines.unshift(`var download${signals2.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
      lines.push(`});`);
    }
    if (signals2.popup) {
      lines.unshift(`var ${this._formatPageAlias(signals2.popup.popupAlias)} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
      lines.push(`});`);
    }
    for (const line of lines)
      formatter.add(line);
    return formatter.format();
  }
  _formatPageAlias(pageAlias) {
    if (this._mode === "library")
      return pageAlias;
    if (pageAlias === "page")
      return "Page";
    return pageAlias;
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `await ${subject}.CloseAsync();`;
      case "click": {
        let method = "Click";
        if (action.clickCount === 2)
          method = "DblClick";
        const options2 = toClickOptionsForSourceCode(action);
        if (!Object.entries(options2).length)
          return `await ${subject}.${this._asLocator(action.selector)}.${method}Async();`;
        const optionsString = formatObject(options2, "    ", "Locator" + method + "Options");
        return `await ${subject}.${this._asLocator(action.selector)}.${method}Async(${optionsString});`;
      }
      case "check":
        return `await ${subject}.${this._asLocator(action.selector)}.CheckAsync();`;
      case "uncheck":
        return `await ${subject}.${this._asLocator(action.selector)}.UncheckAsync();`;
      case "fill":
        return `await ${subject}.${this._asLocator(action.selector)}.FillAsync(${quote(action.text)});`;
      case "setInputFiles":
        return `await ${subject}.${this._asLocator(action.selector)}.SetInputFilesAsync(${formatObject(action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `await ${subject}.${this._asLocator(action.selector)}.PressAsync(${quote(shortcut)});`;
      }
      case "navigate":
        return `await ${subject}.GotoAsync(${quote(action.url)});`;
      case "select":
        return `await ${subject}.${this._asLocator(action.selector)}.SelectOptionAsync(${formatObject(action.options)});`;
      case "assertText":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "ToContainTextAsync" : "ToHaveTextAsync"}(${quote(action.text)});`;
      case "assertChecked":
        return `await Expect(${subject}.${this._asLocator(action.selector)})${action.checked ? "" : ".Not"}.ToBeCheckedAsync();`;
      case "assertVisible":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).ToBeVisibleAsync();`;
      case "assertValue": {
        const assertion = action.value ? `ToHaveValueAsync(${quote(action.value)})` : `ToBeEmptyAsync()`;
        return `await Expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot":
        return `await Expect(${subject}.${this._asLocator(action.selector)}).ToMatchAriaSnapshotAsync(${quote(action.ariaSnapshot)});`;
    }
  }
  _asLocator(selector) {
    return asLocator("csharp", selector);
  }
  generateHeader(options2) {
    if (this._mode === "library")
      return this.generateStandaloneHeader(options2);
    return this.generateTestRunnerHeader(options2);
  }
  generateStandaloneHeader(options2) {
    const formatter = new CSharpFormatter(0);
    formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      using var playwright = await Playwright.CreateAsync();
      await using var browser = await playwright.${toPascal(options2.browserName)}.LaunchAsync(${formatObject(options2.launchOptions, "    ", "BrowserTypeLaunchOptions")});
      var context = await browser.NewContextAsync(${formatContextOptions(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`      await context.RouteFromHARAsync(${quote(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatObject({ url: url4 }, "    ", "BrowserContextRouteFromHAROptions")}` : ""});`);
    }
    formatter.newLine();
    return formatter.format();
  }
  generateTestRunnerHeader(options2) {
    const formatter = new CSharpFormatter(0);
    formatter.add(`
      using Microsoft.Playwright.${this._mode === "nunit" ? "NUnit" : "MSTest"};
      using Microsoft.Playwright;

      ${this._mode === "nunit" ? `[Parallelizable(ParallelScope.Self)]
      [TestFixture]` : "[TestClass]"}
      public class Tests : PageTest
      {`);
    const formattedContextOptions = formatContextOptions(options2.contextOptions, options2.deviceName);
    if (formattedContextOptions) {
      formatter.add(`public override BrowserNewContextOptions ContextOptions()
      {
          return ${formattedContextOptions};
      }`);
      formatter.newLine();
    }
    formatter.add(`    [${this._mode === "nunit" ? "Test" : "TestMethod"}]
    public async Task MyTest()
    {`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`    await Context.RouteFromHARAsync(${quote(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatObject({ url: url4 }, "    ", "BrowserContextRouteFromHAROptions")}` : ""});`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    const offset = this._mode === "library" ? "" : "        ";
    let storageStateLine = saveStorage ? `
${offset}await context.StorageStateAsync(new BrowserContextStorageStateOptions
${offset}{
${offset}    Path = ${quote(saveStorage)}
${offset}});
` : "";
    if (this._mode !== "library")
      storageStateLine += `    }
}
`;
    return storageStateLine;
  }
};
function formatObject(value, indent = "    ", name = "") {
  if (typeof value === "string") {
    if (["permissions", "colorScheme", "modifiers", "button", "recordHarContent", "recordHarMode", "serviceWorkers"].includes(name))
      return `${getClassName(name)}.${toPascal(value)}`;
    return quote(value);
  }
  if (Array.isArray(value))
    return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
  if (typeof value === "object") {
    const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
    if (!keys.length)
      return name ? `new ${getClassName(name)}` : "";
    const tokens = [];
    for (const key of keys) {
      const property = getPropertyName(key);
      tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
    }
    if (name)
      return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
    return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
  }
  if (name === "latitude" || name === "longitude")
    return String(value) + "m";
  return String(value);
}
__name(formatObject, "formatObject");
function getClassName(value) {
  switch (value) {
    case "viewport":
      return "ViewportSize";
    case "proxy":
      return "ProxySettings";
    case "permissions":
      return "ContextPermission";
    case "modifiers":
      return "KeyboardModifier";
    case "button":
      return "MouseButton";
    case "recordHarMode":
      return "HarMode";
    case "recordHarContent":
      return "HarContentPolicy";
    case "serviceWorkers":
      return "ServiceWorkerPolicy";
    default:
      return toPascal(value);
  }
}
__name(getClassName, "getClassName");
function getPropertyName(key) {
  switch (key) {
    case "storageState":
      return "StorageStatePath";
    case "viewport":
      return "ViewportSize";
    default:
      return toPascal(key);
  }
}
__name(getPropertyName, "getPropertyName");
function toPascal(value) {
  return value[0].toUpperCase() + value.slice(1);
}
__name(toPascal, "toPascal");
function formatContextOptions(contextOptions, deviceName) {
  let options2 = { ...contextOptions };
  delete options2.recordHar;
  const device = deviceName && deviceDescriptors[deviceName];
  if (!device) {
    if (!Object.entries(options2).length)
      return "";
    return formatObject(options2, "    ", "BrowserNewContextOptions");
  }
  options2 = sanitizeDeviceOptions(device, options2);
  if (!Object.entries(options2).length)
    return `playwright.Devices[${quote(deviceName)}]`;
  return formatObject(options2, "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
}
__name(formatContextOptions, "formatContextOptions");
var CSharpFormatter = class {
  static {
    __name(this, "CSharpFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(4);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
  }
  add(text) {
    this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    let previousLine = "";
    return this._lines.map((line) => {
      if (line === "")
        return line;
      if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
        spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
      previousLine = line;
      line = spaces + extraSpaces + line;
      if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
        spaces += this._baseIndent;
      if (line.endsWith("));"))
        spaces = spaces.substring(this._baseIndent.length);
      return this._baseOffset + line;
    }).join("\n");
  }
};
function quote(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote, "quote");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/java.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/javascript.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var JavaScriptLanguageGenerator = class {
  static {
    __name(this, "JavaScriptLanguageGenerator");
  }
  constructor(isTest) {
    this.groupName = "Node.js";
    this.highlighter = "javascript";
    this.id = isTest ? "playwright-test" : "javascript";
    this.name = isTest ? "Test Runner" : "Library";
    this._isTest = isTest;
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isTest && (action.name === "openPage" || action.name === "closePage"))
      return "";
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new JavaScriptFormatter(2);
    if (action.name === "openPage") {
      formatter.add(`const ${pageAlias} = await context.newPage();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`await ${pageAlias}.goto(${quote2(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.contentFrame()`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals2 = toSignalMap(action);
    if (signals2.dialog) {
      formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
    }
    if (signals2.popup)
      formatter.add(`const ${signals2.popup.popupAlias}Promise = ${pageAlias}.waitForEvent('popup');`);
    if (signals2.download)
      formatter.add(`const download${signals2.download.downloadAlias}Promise = ${pageAlias}.waitForEvent('download');`);
    formatter.add(wrapWithStep(actionInContext.description, this._generateActionCall(subject, actionInContext)));
    if (signals2.popup)
      formatter.add(`const ${signals2.popup.popupAlias} = await ${signals2.popup.popupAlias}Promise;`);
    if (signals2.download)
      formatter.add(`const download${signals2.download.downloadAlias} = await download${signals2.download.downloadAlias}Promise;`);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `await ${subject}.close();`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsString = formatOptions(options2);
        return `await ${subject}.${this._asLocator(action.selector)}.${method}(${optionsString});`;
      }
      case "check":
        return `await ${subject}.${this._asLocator(action.selector)}.check();`;
      case "uncheck":
        return `await ${subject}.${this._asLocator(action.selector)}.uncheck();`;
      case "fill":
        return `await ${subject}.${this._asLocator(action.selector)}.fill(${quote2(action.text)});`;
      case "setInputFiles":
        return `await ${subject}.${this._asLocator(action.selector)}.setInputFiles(${formatObject2(action.files.length === 1 ? action.files[0] : action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `await ${subject}.${this._asLocator(action.selector)}.press(${quote2(shortcut)});`;
      }
      case "navigate":
        return `await ${subject}.goto(${quote2(action.url)});`;
      case "select":
        return `await ${subject}.${this._asLocator(action.selector)}.selectOption(${formatObject2(action.options.length === 1 ? action.options[0] : action.options)});`;
      case "assertText":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "toContainText" : "toHaveText"}(${quote2(action.text)});`;
      case "assertChecked":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)})${action.checked ? "" : ".not"}.toBeChecked();`;
      case "assertVisible":
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).toBeVisible();`;
      case "assertValue": {
        const assertion = action.value ? `toHaveValue(${quote2(action.value)})` : `toBeEmpty()`;
        return `${this._isTest ? "" : "// "}await expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot": {
        const commentIfNeeded = this._isTest ? "" : "// ";
        return `${commentIfNeeded}await expect(${subject}.${this._asLocator(action.selector)}).toMatchAriaSnapshot(${quoteMultiline(action.ariaSnapshot, `${commentIfNeeded}  `)});`;
      }
    }
  }
  _asLocator(selector) {
    return asLocator("javascript", selector);
  }
  generateHeader(options2) {
    if (this._isTest)
      return this.generateTestHeader(options2);
    return this.generateStandaloneHeader(options2);
  }
  generateFooter(saveStorage) {
    if (this._isTest)
      return this.generateTestFooter(saveStorage);
    return this.generateStandaloneFooter(saveStorage);
  }
  generateTestHeader(options2) {
    const formatter = new JavaScriptFormatter();
    const useText = formatContextOptions2(options2.contextOptions, options2.deviceName, this._isTest);
    formatter.add(`
      import { test, expect${options2.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      formatter.add(`  await page.routeFromHAR(${quote2(options2.contextOptions.recordHar.path)}${url4 ? `, ${formatOptions({ url: url4 })}` : ""});`);
    }
    return formatter.format();
  }
  generateTestFooter(saveStorage) {
    return `});`;
  }
  generateStandaloneHeader(options2) {
    const formatter = new JavaScriptFormatter();
    formatter.add(`
      const { ${options2.browserName}${options2.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options2.browserName}.launch(${formatObjectOrVoid(options2.launchOptions)});
        const context = await browser.newContext(${formatContextOptions2(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar)
      formatter.add(`        await context.routeFromHAR(${quote2(options2.contextOptions.recordHar.path)});`);
    return formatter.format();
  }
  generateStandaloneFooter(saveStorage) {
    const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote2(saveStorage)} });` : "";
    return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
  }
};
function formatOptions(value, hasArguments) {
  const keys = Object.keys(value);
  if (!keys.length)
    return "";
  return "" + formatObject2(value);
}
__name(formatOptions, "formatOptions");
function formatObject2(value, indent = "  ") {
  if (typeof value === "string")
    return quote2(value);
  if (Array.isArray(value))
    return `[${value.map((o) => formatObject2(o)).join(", ")}]`;
  if (typeof value === "object") {
    const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
    if (!keys.length)
      return "{}";
    const tokens = [];
    for (const key of keys)
      tokens.push(`${key}: ${formatObject2(value[key])}`);
    return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
  }
  return String(value);
}
__name(formatObject2, "formatObject");
function formatObjectOrVoid(value, indent = "  ") {
  const result = formatObject2(value, indent);
  return result === "{}" ? "" : result;
}
__name(formatObjectOrVoid, "formatObjectOrVoid");
function formatContextOptions2(options2, deviceName, isTest) {
  const device = deviceName && deviceDescriptors[deviceName];
  options2 = { ...options2, recordHar: void 0 };
  if (!device)
    return formatObjectOrVoid(options2);
  let serializedObject = formatObjectOrVoid(sanitizeDeviceOptions(device, options2));
  if (!serializedObject)
    serializedObject = "{\n}";
  const lines = serializedObject.split("\n");
  lines.splice(1, 0, `...devices[${quote2(deviceName)}],`);
  return lines.join("\n");
}
__name(formatContextOptions2, "formatContextOptions");
var JavaScriptFormatter = class {
  static {
    __name(this, "JavaScriptFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(2);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    const trim = isMultilineString(text) ? (line) => line : (line) => line.trim();
    this._lines = text.trim().split("\n").map(trim).concat(this._lines);
  }
  add(text) {
    const trim = isMultilineString(text) ? (line) => line : (line) => line.trim();
    this._lines.push(...text.trim().split("\n").map(trim));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    let previousLine = "";
    return this._lines.map((line) => {
      if (line === "")
        return line;
      if (line.startsWith("}") || line.startsWith("]"))
        spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
      previousLine = line;
      const callCarryOver = line.startsWith(".set");
      line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
      if (line.endsWith("{") || line.endsWith("["))
        spaces += this._baseIndent;
      return this._baseOffset + line;
    }).join("\n");
  }
};
function quote2(text) {
  return escapeWithQuotes(text, "'");
}
__name(quote2, "quote");
function wrapWithStep(description, body) {
  return description ? `await test.step(\`${description}\`, async () => {
${body}
});` : body;
}
__name(wrapWithStep, "wrapWithStep");
function quoteMultiline(text, indent = "  ") {
  const escape = /* @__PURE__ */ __name((text2) => text2.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$\{/g, "\\${"), "escape");
  const lines = text.split("\n");
  if (lines.length === 1)
    return "`" + escape(text) + "`";
  return "`\n" + lines.map((line) => indent + escape(line).replace(/\${/g, "\\${")).join("\n") + `
${indent}\``;
}
__name(quoteMultiline, "quoteMultiline");
function isMultilineString(text) {
  return text.match(/`[\S\s]*`/)?.[0].includes("\n");
}
__name(isMultilineString, "isMultilineString");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/java.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var JavaLanguageGenerator = class {
  static {
    __name(this, "JavaLanguageGenerator");
  }
  constructor(mode) {
    this.groupName = "Java";
    this.highlighter = "java";
    if (mode === "library") {
      this.name = "Library";
      this.id = "java";
    } else if (mode === "junit") {
      this.name = "JUnit";
      this.id = "java-junit";
    } else {
      throw new Error(`Unknown Java language mode: ${mode}`);
    }
    this._mode = mode;
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    const pageAlias = actionInContext.frame.pageAlias;
    const offset = this._mode === "junit" ? 4 : 6;
    const formatter = new JavaScriptFormatter(offset);
    if (this._mode !== "library" && (action.name === "openPage" || action.name === "closePage"))
      return "";
    if (action.name === "openPage") {
      formatter.add(`Page ${pageAlias} = context.newPage();`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`${pageAlias}.navigate(${quote3(action.url)});`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector, false)}.contentFrame()`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals2 = toSignalMap(action);
    if (signals2.dialog) {
      formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
    }
    let code = this._generateActionCall(subject, actionInContext, !!actionInContext.frame.framePath.length);
    if (signals2.popup) {
      code = `Page ${signals2.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
    }
    if (signals2.download) {
      code = `Download download${signals2.download.downloadAlias} = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
    }
    formatter.add(code);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext, inFrameLocator) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `${subject}.close();`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsText = formatClickOptions(options2);
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.${method}(${optionsText});`;
      }
      case "check":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.check();`;
      case "uncheck":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.uncheck();`;
      case "fill":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.fill(${quote3(action.text)});`;
      case "setInputFiles":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)});`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.press(${quote3(shortcut)});`;
      }
      case "navigate":
        return `${subject}.navigate(${quote3(action.url)});`;
      case "select":
        return `${subject}.${this._asLocator(action.selector, inFrameLocator)}.selectOption(${formatSelectOption(action.options.length === 1 ? action.options[0] : action.options)});`;
      case "assertText":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).${action.substring ? "containsText" : "hasText"}(${quote3(action.text)});`;
      case "assertChecked":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)})${action.checked ? "" : ".not()"}.isChecked();`;
      case "assertVisible":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).isVisible();`;
      case "assertValue": {
        const assertion = action.value ? `hasValue(${quote3(action.value)})` : `isEmpty()`;
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).${assertion};`;
      }
      case "assertSnapshot":
        return `assertThat(${subject}.${this._asLocator(action.selector, inFrameLocator)}).matchesAriaSnapshot(${quote3(action.ariaSnapshot)});`;
    }
  }
  _asLocator(selector, inFrameLocator) {
    return asLocator("java", selector, inFrameLocator);
  }
  generateHeader(options2) {
    const formatter = new JavaScriptFormatter();
    if (this._mode === "junit") {
      formatter.add(`
      import com.microsoft.playwright.junit.UsePlaywright;
      import com.microsoft.playwright.Page;
      import com.microsoft.playwright.options.*;

      ${options2.contextOptions.recordHar ? `import java.nio.file.Paths;
` : ""}import org.junit.jupiter.api.*;
      import static com.microsoft.playwright.assertions.PlaywrightAssertions.*;

      @UsePlaywright
      public class TestExample {
        @Test
        void test(Page page) {`);
      if (options2.contextOptions.recordHar) {
        const url4 = options2.contextOptions.recordHar.urlFilter;
        const recordHarOptions = typeof url4 === "string" ? `, new Page.RouteFromHAROptions()
            .setUrl(${quote3(url4)})` : "";
        formatter.add(`          page.routeFromHAR(Paths.get(${quote3(options2.contextOptions.recordHar.path)})${recordHarOptions});`);
      }
      return formatter.format();
    }
    formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
    ${options2.contextOptions.recordHar ? `import java.nio.file.Paths;
` : ""}import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options2.browserName}().launch(${formatLaunchOptions(options2.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions3(options2.contextOptions, options2.deviceName)});`);
    if (options2.contextOptions.recordHar) {
      const url4 = options2.contextOptions.recordHar.urlFilter;
      const recordHarOptions = typeof url4 === "string" ? `, new BrowserContext.RouteFromHAROptions()
          .setUrl(${quote3(url4)})` : "";
      formatter.add(`          context.routeFromHAR(Paths.get(${quote3(options2.contextOptions.recordHar.path)})${recordHarOptions});`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote3(saveStorage)}));
` : "";
    if (this._mode === "junit") {
      return `${storageStateLine}  }
}`;
    }
    return `${storageStateLine}    }
  }
}`;
  }
};
function formatPath(files) {
  if (Array.isArray(files)) {
    if (files.length === 0)
      return "new Path[0]";
    return `new Path[] {${files.map((s) => "Paths.get(" + quote3(s) + ")").join(", ")}}`;
  }
  return `Paths.get(${quote3(files)})`;
}
__name(formatPath, "formatPath");
function formatSelectOption(options2) {
  if (Array.isArray(options2)) {
    if (options2.length === 0)
      return "new String[0]";
    return `new String[] {${options2.map((s) => quote3(s)).join(", ")}}`;
  }
  return quote3(options2);
}
__name(formatSelectOption, "formatSelectOption");
function formatLaunchOptions(options2) {
  const lines = [];
  if (!Object.keys(options2).filter((key) => options2[key] !== void 0).length)
    return "";
  lines.push("new BrowserType.LaunchOptions()");
  if (options2.channel)
    lines.push(`  .setChannel(${quote3(options2.channel)})`);
  if (typeof options2.headless === "boolean")
    lines.push(`  .setHeadless(false)`);
  return lines.join("\n");
}
__name(formatLaunchOptions, "formatLaunchOptions");
function formatContextOptions3(contextOptions, deviceName) {
  const lines = [];
  if (!Object.keys(contextOptions).length && !deviceName)
    return "";
  const device = deviceName ? deviceDescriptors[deviceName] : {};
  const options2 = { ...device, ...contextOptions };
  lines.push("new Browser.NewContextOptions()");
  if (options2.acceptDownloads)
    lines.push(`  .setAcceptDownloads(true)`);
  if (options2.bypassCSP)
    lines.push(`  .setBypassCSP(true)`);
  if (options2.colorScheme)
    lines.push(`  .setColorScheme(ColorScheme.${options2.colorScheme.toUpperCase()})`);
  if (options2.deviceScaleFactor)
    lines.push(`  .setDeviceScaleFactor(${options2.deviceScaleFactor})`);
  if (options2.geolocation)
    lines.push(`  .setGeolocation(${options2.geolocation.latitude}, ${options2.geolocation.longitude})`);
  if (options2.hasTouch)
    lines.push(`  .setHasTouch(${options2.hasTouch})`);
  if (options2.isMobile)
    lines.push(`  .setIsMobile(${options2.isMobile})`);
  if (options2.locale)
    lines.push(`  .setLocale(${quote3(options2.locale)})`);
  if (options2.proxy)
    lines.push(`  .setProxy(new Proxy(${quote3(options2.proxy.server)}))`);
  if (options2.serviceWorkers)
    lines.push(`  .setServiceWorkers(ServiceWorkerPolicy.${options2.serviceWorkers.toUpperCase()})`);
  if (options2.storageState)
    lines.push(`  .setStorageStatePath(Paths.get(${quote3(options2.storageState)}))`);
  if (options2.timezoneId)
    lines.push(`  .setTimezoneId(${quote3(options2.timezoneId)})`);
  if (options2.userAgent)
    lines.push(`  .setUserAgent(${quote3(options2.userAgent)})`);
  if (options2.viewport)
    lines.push(`  .setViewportSize(${options2.viewport.width}, ${options2.viewport.height})`);
  return lines.join("\n");
}
__name(formatContextOptions3, "formatContextOptions");
function formatClickOptions(options2) {
  const lines = [];
  if (options2.button)
    lines.push(`  .setButton(MouseButton.${options2.button.toUpperCase()})`);
  if (options2.modifiers)
    lines.push(`  .setModifiers(Arrays.asList(${options2.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
  if (options2.clickCount)
    lines.push(`  .setClickCount(${options2.clickCount})`);
  if (options2.position)
    lines.push(`  .setPosition(${options2.position.x}, ${options2.position.y})`);
  if (!lines.length)
    return "";
  lines.unshift(`new Locator.ClickOptions()`);
  return lines.join("\n");
}
__name(formatClickOptions, "formatClickOptions");
function quote3(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote3, "quote");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/jsonl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var JsonlLanguageGenerator = class {
  static {
    __name(this, "JsonlLanguageGenerator");
  }
  constructor() {
    this.id = "jsonl";
    this.groupName = "";
    this.name = "JSONL";
    this.highlighter = "javascript";
  }
  generateAction(actionInContext) {
    const locator = actionInContext.action.selector ? JSON.parse(asLocator("jsonl", actionInContext.action.selector)) : void 0;
    const entry = {
      ...actionInContext.action,
      ...actionInContext.frame,
      locator,
      ariaSnapshot: void 0
    };
    return JSON.stringify(entry);
  }
  generateHeader(options2) {
    return JSON.stringify(options2);
  }
  generateFooter(saveStorage) {
    return "";
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/python.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var PythonLanguageGenerator = class {
  static {
    __name(this, "PythonLanguageGenerator");
  }
  constructor(isAsync2, isPyTest) {
    this.groupName = "Python";
    this.highlighter = "python";
    this.id = isPyTest ? "python-pytest" : isAsync2 ? "python-async" : "python";
    this.name = isPyTest ? "Pytest" : isAsync2 ? "Library Async" : "Library";
    this._isAsync = isAsync2;
    this._isPyTest = isPyTest;
    this._awaitPrefix = isAsync2 ? "await " : "";
    this._asyncPrefix = isAsync2 ? "async " : "";
  }
  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isPyTest && (action.name === "openPage" || action.name === "closePage"))
      return "";
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new PythonFormatter(4);
    if (action.name === "openPage") {
      formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
      if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
        formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote4(action.url)})`);
      return formatter.format();
    }
    const locators = actionInContext.frame.framePath.map((selector) => `.${this._asLocator(selector)}.content_frame`);
    const subject = `${pageAlias}${locators.join("")}`;
    const signals2 = toSignalMap(action);
    if (signals2.dialog)
      formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
    let code = `${this._awaitPrefix}${this._generateActionCall(subject, actionInContext)}`;
    if (signals2.popup) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as ${signals2.popup.popupAlias}_info {
        ${code}
      }
      ${signals2.popup.popupAlias} = ${this._awaitPrefix}${signals2.popup.popupAlias}_info.value`;
    }
    if (signals2.download) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download${signals2.download.downloadAlias}_info {
        ${code}
      }
      download${signals2.download.downloadAlias} = ${this._awaitPrefix}download${signals2.download.downloadAlias}_info.value`;
    }
    formatter.add(code);
    return formatter.format();
  }
  _generateActionCall(subject, actionInContext) {
    const action = actionInContext.action;
    switch (action.name) {
      case "openPage":
        throw Error("Not reached");
      case "closePage":
        return `${subject}.close()`;
      case "click": {
        let method = "click";
        if (action.clickCount === 2)
          method = "dblclick";
        const options2 = toClickOptionsForSourceCode(action);
        const optionsString = formatOptions2(options2, false);
        return `${subject}.${this._asLocator(action.selector)}.${method}(${optionsString})`;
      }
      case "check":
        return `${subject}.${this._asLocator(action.selector)}.check()`;
      case "uncheck":
        return `${subject}.${this._asLocator(action.selector)}.uncheck()`;
      case "fill":
        return `${subject}.${this._asLocator(action.selector)}.fill(${quote4(action.text)})`;
      case "setInputFiles":
        return `${subject}.${this._asLocator(action.selector)}.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
      case "press": {
        const modifiers = toKeyboardModifiers(action.modifiers);
        const shortcut = [...modifiers, action.key].join("+");
        return `${subject}.${this._asLocator(action.selector)}.press(${quote4(shortcut)})`;
      }
      case "navigate":
        return `${subject}.goto(${quote4(action.url)})`;
      case "select":
        return `${subject}.${this._asLocator(action.selector)}.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
      case "assertText":
        return `expect(${subject}.${this._asLocator(action.selector)}).${action.substring ? "to_contain_text" : "to_have_text"}(${quote4(action.text)})`;
      case "assertChecked":
        return `expect(${subject}.${this._asLocator(action.selector)}).${action.checked ? "to_be_checked()" : "not_to_be_checked()"}`;
      case "assertVisible":
        return `expect(${subject}.${this._asLocator(action.selector)}).to_be_visible()`;
      case "assertValue": {
        const assertion = action.value ? `to_have_value(${quote4(action.value)})` : `to_be_empty()`;
        return `expect(${subject}.${this._asLocator(action.selector)}).${assertion};`;
      }
      case "assertSnapshot":
        return `expect(${subject}.${this._asLocator(action.selector)}).to_match_aria_snapshot(${quote4(action.ariaSnapshot)})`;
    }
  }
  _asLocator(selector) {
    return asLocator("python", selector);
  }
  generateHeader(options2) {
    const formatter = new PythonFormatter();
    const recordHar = options2.contextOptions.recordHar;
    if (this._isPyTest) {
      const contextOptions = formatContextOptions4(
        options2.contextOptions,
        options2.deviceName,
        true
        /* asDict */
      );
      const fixture = contextOptions ? `

@pytest.fixture(scope="session")
def browser_context_args(browser_context_args, playwright) {
    return {${contextOptions}}
}
` : "";
      formatter.add(`${options2.deviceName || contextOptions ? "import pytest\n" : ""}import re
from playwright.sync_api import Page, expect
${fixture}

def test_example(page: Page) -> None {`);
      if (recordHar)
        formatter.add(`    page.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    } else if (this._isAsync) {
      formatter.add(`
import asyncio
import re
from playwright.async_api import Playwright, async_playwright, expect


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options2.browserName}.launch(${formatOptions2(options2.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions4(options2.contextOptions, options2.deviceName)})`);
      if (recordHar)
        formatter.add(`    await context.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    } else {
      formatter.add(`
import re
from playwright.sync_api import Playwright, sync_playwright, expect


def run(playwright: Playwright) -> None {
    browser = playwright.${options2.browserName}.launch(${formatOptions2(options2.launchOptions, false)})
    context = browser.new_context(${formatContextOptions4(options2.contextOptions, options2.deviceName)})`);
      if (recordHar)
        formatter.add(`    context.route_from_har(${quote4(recordHar.path)}${typeof recordHar.urlFilter === "string" ? `, url=${quote4(recordHar.urlFilter)}` : ""})`);
    }
    return formatter.format();
  }
  generateFooter(saveStorage) {
    if (this._isPyTest) {
      return "";
    } else if (this._isAsync) {
      const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote4(saveStorage)})` : "";
      return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
    } else {
      const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote4(saveStorage)})` : "";
      return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
    }
  }
};
function formatValue(value) {
  if (value === false)
    return "False";
  if (value === true)
    return "True";
  if (value === void 0)
    return "None";
  if (Array.isArray(value))
    return `[${value.map(formatValue).join(", ")}]`;
  if (typeof value === "string")
    return quote4(value);
  if (typeof value === "object")
    return JSON.stringify(value);
  return String(value);
}
__name(formatValue, "formatValue");
function formatOptions2(value, hasArguments, asDict) {
  const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
  if (!keys.length)
    return "";
  return (hasArguments ? ", " : "") + keys.map((key) => {
    if (asDict)
      return `"${toSnakeCase(key)}": ${formatValue(value[key])}`;
    return `${toSnakeCase(key)}=${formatValue(value[key])}`;
  }).join(", ");
}
__name(formatOptions2, "formatOptions");
function formatContextOptions4(options2, deviceName, asDict) {
  options2 = { ...options2, recordHar: void 0 };
  const device = deviceName && deviceDescriptors[deviceName];
  if (!device)
    return formatOptions2(options2, false, asDict);
  return `**playwright.devices[${quote4(deviceName)}]` + formatOptions2(sanitizeDeviceOptions(device, options2), true, asDict);
}
__name(formatContextOptions4, "formatContextOptions");
var PythonFormatter = class {
  static {
    __name(this, "PythonFormatter");
  }
  constructor(offset = 0) {
    this._lines = [];
    this._baseIndent = " ".repeat(4);
    this._baseOffset = " ".repeat(offset);
  }
  prepend(text) {
    this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
  }
  add(text) {
    this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
  }
  newLine() {
    this._lines.push("");
  }
  format() {
    let spaces = "";
    const lines = [];
    this._lines.forEach((line) => {
      if (line === "")
        return lines.push(line);
      if (line === "}") {
        spaces = spaces.substring(this._baseIndent.length);
        return;
      }
      line = spaces + line;
      if (line.endsWith("{")) {
        spaces += this._baseIndent;
        line = line.substring(0, line.length - 1).trimEnd() + ":";
      }
      return lines.push(this._baseOffset + line);
    });
    return lines.join("\n");
  }
};
function quote4(text) {
  return escapeWithQuotes(text, '"');
}
__name(quote4, "quote");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/codegen/languages.js
function languageSet() {
  return /* @__PURE__ */ new Set([
    new JavaScriptLanguageGenerator(
      /* isPlaywrightTest */
      true
    ),
    new JavaScriptLanguageGenerator(
      /* isPlaywrightTest */
      false
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      false,
      /* isPytest */
      true
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      false,
      /* isPytest */
      false
    ),
    new PythonLanguageGenerator(
      /* isAsync */
      true,
      /* isPytest */
      false
    ),
    new CSharpLanguageGenerator("mstest"),
    new CSharpLanguageGenerator("nunit"),
    new CSharpLanguageGenerator("library"),
    new JavaLanguageGenerator("junit"),
    new JavaLanguageGenerator("library"),
    new JsonlLanguageGenerator()
  ]);
}
__name(languageSet, "languageSet");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/timeoutRunner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function raceAgainstDeadline(cb, deadline) {
  let timer;
  return Promise.race([
    cb().then((result) => {
      return { result, timedOut: false };
    }),
    new Promise((resolve) => {
      const kMaxDeadline = 2147483647;
      const timeout = (deadline || kMaxDeadline) - monotonicTime();
      timer = setTimeout(() => resolve({ timedOut: true }), timeout);
    })
  ]).finally(() => {
    clearTimeout(timer);
  });
}
__name(raceAgainstDeadline, "raceAgainstDeadline");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderUtils.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
function buildFullSelector(framePath, selector) {
  return [...framePath, selector].join(" >> internal:control=enter-frame >> ");
}
__name(buildFullSelector, "buildFullSelector");
function metadataToCallLog(metadata, status) {
  const title2 = renderTitleForCall(metadata);
  if (metadata.error)
    status = "error";
  const params = {
    url: metadata.params?.url,
    selector: metadata.params?.selector
  };
  let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
  if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
    duration -= metadata.pauseEndTime - metadata.pauseStartTime;
    duration = Math.max(duration, 0);
  }
  const callLog = {
    id: metadata.id,
    messages: metadata.log,
    title: title2 ?? "",
    status,
    error: metadata.error?.error?.message,
    params,
    duration
  };
  return callLog;
}
__name(metadataToCallLog, "metadataToCallLog");
function mainFrameForAction(pageAliases, actionInContext) {
  const pageAlias = actionInContext.frame.pageAlias;
  const page = [...pageAliases.entries()].find(([, alias]) => pageAlias === alias)?.[0];
  if (!page)
    throw new Error(`Internal error: page ${pageAlias} not found in [${[...pageAliases.values()]}]`);
  return page.mainFrame();
}
__name(mainFrameForAction, "mainFrameForAction");
function isSameAction(a, b) {
  return a.action.name === b.action.name && a.frame.pageAlias === b.frame.pageAlias && a.frame.framePath.join("|") === b.frame.framePath.join("|");
}
__name(isSameAction, "isSameAction");
function isSameSelector(action, lastAction) {
  return "selector" in action.action && "selector" in lastAction.action && action.action.selector === lastAction.action.selector;
}
__name(isSameSelector, "isSameSelector");
function isShortlyAfter(action, lastAction) {
  return action.startTime - lastAction.startTime < 500;
}
__name(isShortlyAfter, "isShortlyAfter");
function shouldMergeAction(action, lastAction) {
  if (!lastAction)
    return false;
  switch (action.action.name) {
    case "fill":
      return isSameAction(action, lastAction) && isSameSelector(action, lastAction);
    case "navigate":
      return isSameAction(action, lastAction);
    case "click":
      return isSameAction(action, lastAction) && isSameSelector(action, lastAction) && isShortlyAfter(action, lastAction) && action.action.clickCount > lastAction.action.clickCount;
  }
  return false;
}
__name(shouldMergeAction, "shouldMergeAction");
function collapseActions(actions) {
  const result = [];
  for (const action of actions) {
    const lastAction = result[result.length - 1];
    const shouldMerge = shouldMergeAction(action, lastAction);
    if (!shouldMerge) {
      result.push(action);
      continue;
    }
    const startTime = result[result.length - 1].startTime;
    result[result.length - 1] = action;
    result[result.length - 1].startTime = startTime;
  }
  return result;
}
__name(collapseActions, "collapseActions");
async function generateFrameSelector(frame) {
  const selectorPromises = [];
  while (frame) {
    const parent = frame.parentFrame();
    if (!parent)
      break;
    selectorPromises.push(generateFrameSelectorInParent(parent, frame));
    frame = parent;
  }
  const result = await Promise.all(selectorPromises);
  return result.reverse();
}
__name(generateFrameSelector, "generateFrameSelector");
async function generateFrameSelectorInParent(parent, frame) {
  const result = await raceAgainstDeadline(async () => {
    try {
      const frameElement = await frame.frameElement();
      if (!frameElement || !parent)
        return;
      const utility = await parent._utilityContext();
      const injected = await utility.injectedScript();
      const selector = await injected.evaluate((injected2, element) => {
        return injected2.generateSelectorSimple(element);
      }, frameElement);
      return selector;
    } catch (e) {
    }
  }, monotonicTime() + 2e3);
  if (!result.timedOut && result.result)
    return result.result;
  if (frame.name())
    return `iframe[name=${quoteCSSAttributeValue(frame.name())}]`;
  return `iframe[src=${quoteCSSAttributeValue(frame.url())}]`;
}
__name(generateFrameSelectorInParent, "generateFrameSelectorInParent");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import EventEmitter10 from "node:events";
import fs17 from "node:fs";
import "node:crypto";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/locatorParser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseLocator(locator, testIdAttributeName2) {
  locator = locator.replace(/AriaRole\s*\.\s*([\w]+)/g, (_, group3) => group3.toLowerCase()).replace(/(get_by_role|getByRole)\s*\(\s*(?:["'`])([^'"`]+)['"`]/g, (_, group1, group22) => `${group1}(${group22.toLowerCase()}`);
  const params = [];
  let template = "";
  for (let i = 0; i < locator.length; ++i) {
    const quote5 = locator[i];
    if (quote5 !== '"' && quote5 !== "'" && quote5 !== "`" && quote5 !== "/") {
      template += quote5;
      continue;
    }
    const isRegexEscaping = locator[i - 1] === "r" || locator[i] === "/";
    ++i;
    let text = "";
    while (i < locator.length) {
      if (locator[i] === "\\") {
        if (isRegexEscaping) {
          if (locator[i + 1] !== quote5)
            text += locator[i];
          ++i;
          text += locator[i];
        } else {
          ++i;
          if (locator[i] === "n")
            text += "\n";
          else if (locator[i] === "r")
            text += "\r";
          else if (locator[i] === "t")
            text += "	";
          else
            text += locator[i];
        }
        ++i;
        continue;
      }
      if (locator[i] !== quote5) {
        text += locator[i++];
        continue;
      }
      break;
    }
    params.push({ quote: quote5, text });
    template += (quote5 === "/" ? "r" : "") + "$" + params.length;
  }
  template = template.toLowerCase().replace(/get_by_alt_text/g, "getbyalttext").replace(/get_by_test_id/g, "getbytestid").replace(/get_by_([\w]+)/g, "getby$1").replace(/has_not_text/g, "hasnottext").replace(/has_text/g, "hastext").replace(/has_not/g, "hasnot").replace(/frame_locator/g, "framelocator").replace(/content_frame/g, "contentframe").replace(/[{}\s]/g, "").replace(/new\(\)/g, "").replace(/new[\w]+\.[\w]+options\(\)/g, "").replace(/\.set/g, ",set").replace(/\.or_\(/g, "or(").replace(/\.and_\(/g, "and(").replace(/:/g, "=").replace(/,re\.ignorecase/g, "i").replace(/,pattern.case_insensitive/g, "i").replace(/,regexoptions.ignorecase/g, "i").replace(/re.compile\(([^)]+)\)/g, "$1").replace(/pattern.compile\(([^)]+)\)/g, "r$1").replace(/newregex\(([^)]+)\)/g, "r$1").replace(/string=/g, "=").replace(/regex=/g, "=").replace(/,,/g, ",").replace(/,\)/g, ")");
  const preferredQuote = params.map((p) => p.quote).filter((quote5) => "'\"`".includes(quote5))[0];
  return { selector: transform(template, params, testIdAttributeName2), preferredQuote };
}
__name(parseLocator, "parseLocator");
function countParams(template) {
  return [...template.matchAll(/\$\d+/g)].length;
}
__name(countParams, "countParams");
function shiftParams(template, sub) {
  return template.replace(/\$(\d+)/g, (_, ordinal) => `$${ordinal - sub}`);
}
__name(shiftParams, "shiftParams");
function transform(template, params, testIdAttributeName2) {
  while (true) {
    const hasMatch = template.match(/filter\(,?(has=|hasnot=|sethas\(|sethasnot\()/);
    if (!hasMatch)
      break;
    const start = hasMatch.index + hasMatch[0].length;
    let balance = 0;
    let end = start;
    for (; end < template.length; end++) {
      if (template[end] === "(")
        balance++;
      else if (template[end] === ")")
        balance--;
      if (balance < 0)
        break;
    }
    let prefix = template.substring(0, start);
    let extraSymbol = 0;
    if (["sethas(", "sethasnot("].includes(hasMatch[1])) {
      extraSymbol = 1;
      prefix = prefix.replace(/sethas\($/, "has=").replace(/sethasnot\($/, "hasnot=");
    }
    const paramsCountBeforeHas = countParams(template.substring(0, start));
    const hasTemplate = shiftParams(template.substring(start, end), paramsCountBeforeHas);
    const paramsCountInHas = countParams(hasTemplate);
    const hasParams = params.slice(paramsCountBeforeHas, paramsCountBeforeHas + paramsCountInHas);
    const hasSelector = JSON.stringify(transform(hasTemplate, hasParams, testIdAttributeName2));
    template = prefix.replace(/=$/, "2=") + `$${paramsCountBeforeHas + 1}` + shiftParams(template.substring(end + extraSymbol), paramsCountInHas - 1);
    const paramsBeforeHas = params.slice(0, paramsCountBeforeHas);
    const paramsAfterHas = params.slice(paramsCountBeforeHas + paramsCountInHas);
    params = paramsBeforeHas.concat([{ quote: '"', text: hasSelector }]).concat(paramsAfterHas);
  }
  template = template.replace(/\,set([\w]+)\(([^)]+)\)/g, (_, group1, group22) => "," + group1.toLowerCase() + "=" + group22.toLowerCase()).replace(/framelocator\(([^)]+)\)/g, "$1.internal:control=enter-frame").replace(/contentframe(\(\))?/g, "internal:control=enter-frame").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+),hasnottext=([^),]+)\)/g, "locator($1).internal:has-not-text=$2").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+)\)/g, "$1").replace(/getbyrole\(([^)]+)\)/g, "internal:role=$1").replace(/getbytext\(([^)]+)\)/g, "internal:text=$1").replace(/getbylabel\(([^)]+)\)/g, "internal:label=$1").replace(/getbytestid\(([^)]+)\)/g, `internal:testid=[${testIdAttributeName2}=$1]`).replace(/getby(placeholder|alt|title)(?:text)?\(([^)]+)\)/g, "internal:attr=[$1=$2]").replace(/first(\(\))?/g, "nth=0").replace(/last(\(\))?/g, "nth=-1").replace(/nth\(([^)]+)\)/g, "nth=$1").replace(/filter\(,?visible=true\)/g, "visible=true").replace(/filter\(,?visible=false\)/g, "visible=false").replace(/filter\(,?hastext=([^)]+)\)/g, "internal:has-text=$1").replace(/filter\(,?hasnottext=([^)]+)\)/g, "internal:has-not-text=$1").replace(/filter\(,?has2=([^)]+)\)/g, "internal:has=$1").replace(/filter\(,?hasnot2=([^)]+)\)/g, "internal:has-not=$1").replace(/,exact=false/g, "").replace(/,exact=true/g, "s").replace(/,includehidden=/g, ",include-hidden=").replace(/\,/g, "][");
  const parts = template.split(".");
  for (let index2 = 0; index2 < parts.length - 1; index2++) {
    if (parts[index2] === "internal:control=enter-frame" && parts[index2 + 1].startsWith("nth=")) {
      const [nth] = parts.splice(index2, 1);
      parts.splice(index2 + 1, 0, nth);
    }
  }
  return parts.map((t) => {
    if (!t.startsWith("internal:") || t === "internal:control")
      return t.replace(/\$(\d+)/g, (_, ordinal) => {
        const param = params[+ordinal - 1];
        return param.text;
      });
    t = t.includes("[") ? t.replace(/\]/, "") + "]" : t;
    t = t.replace(/(?:r)\$(\d+)(i)?/g, (_, ordinal, suffix) => {
      const param = params[+ordinal - 1];
      if (t.startsWith("internal:attr") || t.startsWith("internal:testid") || t.startsWith("internal:role"))
        return escapeForAttributeSelector(new RegExp(param.text), false) + (suffix || "");
      return escapeForTextSelector(new RegExp(param.text, suffix), false);
    }).replace(/\$(\d+)(i|s)?/g, (_, ordinal, suffix) => {
      const param = params[+ordinal - 1];
      if (t.startsWith("internal:has=") || t.startsWith("internal:has-not="))
        return param.text;
      if (t.startsWith("internal:testid"))
        return escapeForAttributeSelector(param.text, true);
      if (t.startsWith("internal:attr") || t.startsWith("internal:role"))
        return escapeForAttributeSelector(param.text, suffix === "s");
      return escapeForTextSelector(param.text, suffix === "s");
    });
    return t;
  }).join(" >> ");
}
__name(transform, "transform");
function locatorOrSelectorAsSelector(language, locator, testIdAttributeName2) {
  try {
    return unsafeLocatorOrSelectorAsSelector(language, locator, testIdAttributeName2);
  } catch (e) {
    return "";
  }
}
__name(locatorOrSelectorAsSelector, "locatorOrSelectorAsSelector");
function unsafeLocatorOrSelectorAsSelector(language, locator, testIdAttributeName2) {
  try {
    parseSelector(locator);
    return locator;
  } catch (e) {
  }
  const { selector, preferredQuote } = parseLocator(locator, testIdAttributeName2);
  const locators = asLocators(language, selector, void 0, void 0, preferredQuote);
  const digest = digestForComparison(language, locator);
  if (locators.some((candidate) => digestForComparison(language, candidate) === digest))
    return selector;
  return "";
}
__name(unsafeLocatorOrSelectorAsSelector, "unsafeLocatorOrSelectorAsSelector");
function digestForComparison(language, locator) {
  locator = locator.replace(/\s/g, "");
  if (language === "javascript")
    locator = locator.replace(/\\?["`]/g, "'").replace(/,{}/g, "");
  return locator;
}
__name(digestForComparison, "digestForComparison");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderSignalProcessor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RecorderSignalProcessor = class {
  static {
    __name(this, "RecorderSignalProcessor");
  }
  constructor(actionSink) {
    this._lastAction = null;
    this._delegate = actionSink;
  }
  addAction(actionInContext) {
    this._lastAction = actionInContext;
    this._delegate.addAction(actionInContext);
  }
  signal(pageAlias, frame, signal) {
    const timestamp2 = monotonicTime();
    if (signal.name === "navigation" && frame._page.mainFrame() === frame) {
      const lastAction = this._lastAction;
      const signalThreshold = isUnderTest() ? 500 : 5e3;
      let generateGoto = false;
      if (!lastAction)
        generateGoto = true;
      else if (lastAction.action.name !== "click" && lastAction.action.name !== "press" && lastAction.action.name !== "fill")
        generateGoto = true;
      else if (timestamp2 - lastAction.startTime > signalThreshold)
        generateGoto = true;
      if (generateGoto) {
        this.addAction({
          frame: {
            pageGuid: frame._page.guid,
            pageAlias,
            framePath: []
          },
          action: {
            name: "navigate",
            url: frame.url(),
            signals: []
          },
          startTime: timestamp2,
          endTime: timestamp2
        });
      }
      return;
    }
    generateFrameSelector(frame).then((framePath) => {
      const signalInContext = {
        frame: {
          pageGuid: frame._page.guid,
          pageAlias,
          framePath
        },
        signal,
        timestamp: timestamp2
      };
      this._delegate.addSignal(signalInContext);
    });
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/pollingRecorderSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source5 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/recorder/pollingRecorder.ts\nvar pollingRecorder_exports = {};\n__export(pollingRecorder_exports, {\n  PollingRecorder: () => PollingRecorder,\n  default: () => pollingRecorder_default\n});\nmodule.exports = __toCommonJS(pollingRecorder_exports);\n\n// packages/injected/src/recorder/clipPaths.ts\nvar svgJson = { "tagName": "svg", "children": [{ "tagName": "defs", "children": [{ "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-gripper" }, "children": [{ "tagName": "path", "attrs": { "d": "M5 3h2v2H5zm0 4h2v2H5zm0 4h2v2H5zm4-8h2v2H9zm0 4h2v2H9zm0 4h2v2H9z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-circle-large-filled" }, "children": [{ "tagName": "path", "attrs": { "d": "M8 1a6.8 6.8 0 0 1 1.86.253 6.899 6.899 0 0 1 3.083 1.805 6.903 6.903 0 0 1 1.804 3.083C14.916 6.738 15 7.357 15 8s-.084 1.262-.253 1.86a6.9 6.9 0 0 1-.704 1.674 7.157 7.157 0 0 1-2.516 2.509 6.966 6.966 0 0 1-1.668.71A6.984 6.984 0 0 1 8 15a6.984 6.984 0 0 1-1.86-.246 7.098 7.098 0 0 1-1.674-.711 7.3 7.3 0 0 1-1.415-1.094 7.295 7.295 0 0 1-1.094-1.415 7.098 7.098 0 0 1-.71-1.675A6.985 6.985 0 0 1 1 8c0-.643.082-1.262.246-1.86a6.968 6.968 0 0 1 .711-1.667 7.156 7.156 0 0 1 2.509-2.516 6.895 6.895 0 0 1 1.675-.704A6.808 6.808 0 0 1 8 1z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-inspect" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M1 3l1-1h12l1 1v6h-1V3H2v8h5v1H2l-1-1V3zm14.707 9.707L9 6v9.414l2.707-2.707h4zM10 13V8.414l3.293 3.293h-2L10 13z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-whole-word" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M0 11H1V13H15V11H16V14H15H1H0V11Z" } }, { "tagName": "path", "attrs": { "d": "M6.84048 11H5.95963V10.1406H5.93814C5.555 10.7995 4.99104 11.1289 4.24625 11.1289C3.69839 11.1289 3.26871 10.9839 2.95718 10.6938C2.64924 10.4038 2.49527 10.0189 2.49527 9.53906C2.49527 8.51139 3.10041 7.91341 4.3107 7.74512L5.95963 7.51416C5.95963 6.57959 5.58186 6.1123 4.82632 6.1123C4.16389 6.1123 3.56591 6.33789 3.03238 6.78906V5.88672C3.57307 5.54297 4.19612 5.37109 4.90152 5.37109C6.19416 5.37109 6.84048 6.05501 6.84048 7.42285V11ZM5.95963 8.21777L4.63297 8.40039C4.22476 8.45768 3.91682 8.55973 3.70914 8.70654C3.50145 8.84977 3.39761 9.10579 3.39761 9.47461C3.39761 9.74316 3.4925 9.96338 3.68228 10.1353C3.87564 10.3035 4.13166 10.3877 4.45035 10.3877C4.8872 10.3877 5.24706 10.2355 5.52994 9.93115C5.8164 9.62321 5.95963 9.2347 5.95963 8.76562V8.21777Z" } }, { "tagName": "path", "attrs": { "d": "M9.3475 10.2051H9.32601V11H8.44515V2.85742H9.32601V6.4668H9.3475C9.78076 5.73633 10.4146 5.37109 11.2489 5.37109C11.9543 5.37109 12.5057 5.61816 12.9032 6.1123C13.3042 6.60286 13.5047 7.26172 13.5047 8.08887C13.5047 9.00911 13.2809 9.74674 12.8333 10.3018C12.3857 10.8532 11.7734 11.1289 10.9964 11.1289C10.2695 11.1289 9.71989 10.821 9.3475 10.2051ZM9.32601 7.98682V8.75488C9.32601 9.20964 9.47282 9.59635 9.76644 9.91504C10.0636 10.2301 10.4396 10.3877 10.8944 10.3877C11.4279 10.3877 11.8451 10.1836 12.1458 9.77539C12.4502 9.36719 12.6024 8.79964 12.6024 8.07275C12.6024 7.46045 12.4609 6.98063 12.1781 6.6333C11.8952 6.28597 11.512 6.1123 11.0286 6.1123C10.5166 6.1123 10.1048 6.29134 9.7933 6.64941C9.48177 7.00391 9.32601 7.44971 9.32601 7.98682Z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-eye" }, "children": [{ "tagName": "path", "attrs": { "d": "M7.99993 6.00316C9.47266 6.00316 10.6666 7.19708 10.6666 8.66981C10.6666 10.1426 9.47266 11.3365 7.99993 11.3365C6.52715 11.3365 5.33324 10.1426 5.33324 8.66981C5.33324 7.19708 6.52715 6.00316 7.99993 6.00316ZM7.99993 7.00315C7.07946 7.00315 6.33324 7.74935 6.33324 8.66981C6.33324 9.59028 7.07946 10.3365 7.99993 10.3365C8.9204 10.3365 9.6666 9.59028 9.6666 8.66981C9.6666 7.74935 8.9204 7.00315 7.99993 7.00315ZM7.99993 3.66675C11.0756 3.66675 13.7307 5.76675 14.4673 8.70968C14.5344 8.97755 14.3716 9.24908 14.1037 9.31615C13.8358 9.38315 13.5643 9.22041 13.4973 8.95248C12.8713 6.45205 10.6141 4.66675 7.99993 4.66675C5.38454 4.66675 3.12664 6.45359 2.50182 8.95555C2.43491 9.22341 2.16348 9.38635 1.89557 9.31948C1.62766 9.25255 1.46471 8.98115 1.53162 8.71321C2.26701 5.76856 4.9229 3.66675 7.99993 3.66675Z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-symbol-constant" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M4 6h8v1H4V6zm8 3H4v1h8V9z" } }, { "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M1 4l1-1h12l1 1v8l-1 1H2l-1-1V4zm1 0v8h12V4H2z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-check" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M14.431 3.323l-8.47 10-.79-.036-3.35-4.77.818-.574 2.978 4.24 8.051-9.506.764.646z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-close" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M8 8.707l3.646 3.647.708-.707L8.707 8l3.647-3.646-.707-.708L8 7.293 4.354 3.646l-.707.708L7.293 8l-3.646 3.646.707.708L8 8.707z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-pass" }, "children": [{ "tagName": "path", "attrs": { "d": "M6.27 10.87h.71l4.56-4.56-.71-.71-4.2 4.21-1.92-1.92L4 8.6l2.27 2.27z" } }, { "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M8.6 1c1.6.1 3.1.9 4.2 2 1.3 1.4 2 3.1 2 5.1 0 1.6-.6 3.1-1.6 4.4-1 1.2-2.4 2.1-4 2.4-1.6.3-3.2.1-4.6-.7-1.4-.8-2.5-2-3.1-3.5C.9 9.2.8 7.5 1.3 6c.5-1.6 1.4-2.9 2.8-3.8C5.4 1.3 7 .9 8.6 1zm.5 12.9c1.3-.3 2.5-1 3.4-2.1.8-1.1 1.3-2.4 1.2-3.8 0-1.6-.6-3.2-1.7-4.3-1-1-2.2-1.6-3.6-1.7-1.3-.1-2.7.2-3.8 1-1.1.8-1.9 1.9-2.3 3.3-.4 1.3-.4 2.7.2 4 .6 1.3 1.5 2.3 2.7 3 1.2.7 2.6.9 3.9.6z" } }] }, { "tagName": "clipPath", "attrs": { "width": "16", "height": "16", "viewBox": "0 0 16 16", "fill": "currentColor", "id": "icon-gist" }, "children": [{ "tagName": "path", "attrs": { "fill-rule": "evenodd", "clip-rule": "evenodd", "d": "M10.57 1.14l3.28 3.3.15.36v9.7l-.5.5h-11l-.5-.5v-13l.5-.5h7.72l.35.14zM10 5h3l-3-3v3zM3 2v12h10V6H9.5L9 5.5V2H3zm2.062 7.533l1.817-1.828L6.17 7 4 9.179v.707l2.171 2.174.707-.707-1.816-1.82zM8.8 7.714l.7-.709 2.189 2.175v.709L9.5 12.062l-.705-.709 1.831-1.82L8.8 7.714z" } }] }] }] };\nvar clipPaths_default = svgJson;\n\n// packages/injected/src/recorder/recorder.ts\nvar HighlightColors = {\n  multiple: "#f6b26b7f",\n  single: "#6fa8dc7f",\n  assert: "#8acae480",\n  action: "#dc6f6f7f"\n};\nvar NoneTool = class {\n};\nvar InspectTool = class {\n  constructor(recorder, assertVisibility) {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._recorder = recorder;\n    this._assertVisibility = assertVisibility;\n  }\n  cursor() {\n    return "pointer";\n  }\n  uninstall() {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n  }\n  onClick(event) {\n    var _a;\n    consumeEvent(event);\n    if (event.button !== 0)\n      return;\n    if ((_a = this._hoveredModel) == null ? void 0 : _a.selector)\n      this._commit(this._hoveredModel.selector, this._hoveredModel);\n  }\n  onPointerDown(event) {\n    consumeEvent(event);\n  }\n  onPointerUp(event) {\n    consumeEvent(event);\n  }\n  onMouseDown(event) {\n    consumeEvent(event);\n  }\n  onMouseUp(event) {\n    consumeEvent(event);\n  }\n  onMouseMove(event) {\n    var _a;\n    consumeEvent(event);\n    let target = this._recorder.deepEventTarget(event);\n    if (!target.isConnected)\n      target = null;\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    let model = null;\n    if (this._hoveredElement) {\n      const generated = this._recorder.injectedScript.generateSelector(this._hoveredElement, { testIdAttributeName: this._recorder.state.testIdAttributeName, multiple: false });\n      model = {\n        selector: generated.selector,\n        elements: generated.elements,\n        tooltipText: this._recorder.injectedScript.utils.asLocator(this._recorder.state.language, generated.selector),\n        color: this._assertVisibility ? HighlightColors.assert : HighlightColors.single\n      };\n    }\n    if (((_a = this._hoveredModel) == null ? void 0 : _a.selector) === (model == null ? void 0 : model.selector))\n      return;\n    this._hoveredModel = model;\n    this._recorder.updateHighlight(model, true);\n  }\n  onMouseEnter(event) {\n    consumeEvent(event);\n  }\n  onMouseLeave(event) {\n    consumeEvent(event);\n    const window = this._recorder.injectedScript.window;\n    if (window.top !== window && this._recorder.deepEventTarget(event).nodeType === Node.DOCUMENT_NODE)\n      this._reset(true);\n  }\n  onKeyDown(event) {\n    consumeEvent(event);\n    if (event.key === "Escape") {\n      if (this._assertVisibility)\n        this._recorder.setMode("recording");\n    }\n  }\n  onKeyUp(event) {\n    consumeEvent(event);\n  }\n  onScroll(event) {\n    this._reset(false);\n  }\n  _commit(selector, model) {\n    var _a;\n    if (this._assertVisibility) {\n      this._recorder.recordAction({\n        name: "assertVisible",\n        selector,\n        signals: []\n      });\n      this._recorder.setMode("recording");\n      (_a = this._recorder.overlay) == null ? void 0 : _a.flashToolSucceeded("assertingVisibility");\n    } else {\n      this._recorder.elementPicked(selector, model);\n    }\n  }\n  _reset(userGesture) {\n    this._hoveredElement = null;\n    this._hoveredModel = null;\n    this._recorder.updateHighlight(null, userGesture);\n  }\n};\nvar RecordActionTool = class {\n  constructor(recorder) {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._observer = null;\n    this._recorder = recorder;\n    this._performingActions = /* @__PURE__ */ new Set();\n  }\n  cursor() {\n    return "pointer";\n  }\n  _installObserverIfNeeded() {\n    var _a;\n    if (this._observer)\n      return;\n    if (!((_a = this._recorder.injectedScript.document) == null ? void 0 : _a.body))\n      return;\n    this._observer = new MutationObserver((mutations) => {\n      if (!this._hoveredElement)\n        return;\n      for (const mutation of mutations) {\n        for (const node of mutation.removedNodes) {\n          if (node === this._hoveredElement || node.contains(this._hoveredElement))\n            this._resetHoveredModel();\n        }\n      }\n    });\n    this._observer.observe(this._recorder.injectedScript.document.body, { childList: true, subtree: true });\n  }\n  uninstall() {\n    var _a;\n    (_a = this._observer) == null ? void 0 : _a.disconnect();\n    this._observer = null;\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n  }\n  onClick(event) {\n    if (isRangeInput(this._hoveredElement))\n      return;\n    if (event.button === 2 && event.type === "auxclick")\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    const checkbox = asCheckbox(this._recorder.deepEventTarget(event));\n    if (checkbox && event.detail === 1) {\n      this._performAction({\n        name: checkbox.checked ? "check" : "uncheck",\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n      return;\n    }\n    this._cancelPendingClickAction();\n    if (event.detail === 1) {\n      this._pendingClickAction = {\n        action: {\n          name: "click",\n          selector: this._hoveredModel.selector,\n          position: positionForEvent(event),\n          signals: [],\n          button: buttonForEvent(event),\n          modifiers: modifiersForEvent(event),\n          clickCount: event.detail\n        },\n        timeout: this._recorder.injectedScript.utils.builtins.setTimeout(() => this._commitPendingClickAction(), 200)\n      };\n    }\n  }\n  onDblClick(event) {\n    if (isRangeInput(this._hoveredElement))\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    this._cancelPendingClickAction();\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  _commitPendingClickAction() {\n    if (this._pendingClickAction)\n      this._performAction(this._pendingClickAction.action);\n    this._cancelPendingClickAction();\n  }\n  _cancelPendingClickAction() {\n    if (this._pendingClickAction)\n      this._recorder.injectedScript.utils.builtins.clearTimeout(this._pendingClickAction.timeout);\n    this._pendingClickAction = void 0;\n  }\n  onContextMenu(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: "right",\n      modifiers: 0,\n      clickCount: 0\n    });\n  }\n  onPointerDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    this._consumeWhenAboutToPerform(event);\n  }\n  onPointerUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    this._consumeWhenAboutToPerform(event);\n  }\n  onMouseDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    this._consumeWhenAboutToPerform(event);\n    this._activeModel = this._hoveredModel;\n  }\n  onMouseUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    this._consumeWhenAboutToPerform(event);\n  }\n  onMouseMove(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    this._updateModelForHoveredElement();\n  }\n  onMouseLeave(event) {\n    const window = this._recorder.injectedScript.window;\n    if (window.top !== window && this._recorder.deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n      this._updateModelForHoveredElement();\n    }\n  }\n  onFocus(event) {\n    this._onFocus(true);\n  }\n  onInput(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (target.nodeName === "INPUT" && target.type.toLowerCase() === "file") {\n      this._recordAction({\n        name: "setInputFiles",\n        selector: this._activeModel.selector,\n        signals: [],\n        files: [...target.files || []].map((file) => file.name)\n      });\n      return;\n    }\n    if (isRangeInput(target)) {\n      this._recordAction({\n        name: "fill",\n        // must use hoveredModel instead of activeModel for it to work in webkit\n        selector: this._hoveredModel.selector,\n        signals: [],\n        text: target.value\n      });\n      return;\n    }\n    if (["INPUT", "TEXTAREA"].includes(target.nodeName) || target.isContentEditable) {\n      if (target.nodeName === "INPUT" && ["checkbox", "radio"].includes(target.type.toLowerCase())) {\n        return;\n      }\n      if (this._consumedDueWrongTarget(event))\n        return;\n      this._recordAction({\n        name: "fill",\n        selector: this._activeModel.selector,\n        signals: [],\n        text: target.isContentEditable ? target.innerText : target.value\n      });\n    }\n    if (target.nodeName === "SELECT") {\n      const selectElement = target;\n      this._recordAction({\n        name: "select",\n        selector: this._activeModel.selector,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n    }\n  }\n  onKeyDown(event) {\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n    if (this._consumedDueWrongTarget(event))\n      return;\n    if (event.key === " ") {\n      const checkbox = asCheckbox(this._recorder.deepEventTarget(event));\n      if (checkbox && event.detail === 0) {\n        this._performAction({\n          name: checkbox.checked ? "uncheck" : "check",\n          selector: this._activeModel.selector,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._performAction({\n      name: "press",\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  onKeyUp(event) {\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n    this._expectProgrammaticKeyUp = false;\n  }\n  onScroll(event) {\n    this._resetHoveredModel();\n  }\n  _resetHoveredModel() {\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._updateHighlight(false);\n  }\n  _onFocus(userGesture) {\n    const activeElement = deepActiveElement(this._recorder.document);\n    if (userGesture && activeElement === this._recorder.document.body)\n      return;\n    const result = activeElement ? this._recorder.injectedScript.generateSelector(activeElement, { testIdAttributeName: this._recorder.state.testIdAttributeName }) : null;\n    this._activeModel = result && result.selector ? { ...result, color: HighlightColors.action } : null;\n    if (userGesture) {\n      this._hoveredElement = activeElement;\n      this._updateModelForHoveredElement();\n    }\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._recorder.deepEventTarget(event);\n    const nodeName = target.nodeName;\n    if (nodeName === "SELECT" || nodeName === "OPTION")\n      return true;\n    if (nodeName === "INPUT" && ["date", "range"].includes(target.type))\n      return true;\n    return false;\n  }\n  _actionInProgress(event) {\n    const isKeyEvent = event instanceof KeyboardEvent;\n    const isMouseOrPointerEvent = event instanceof MouseEvent || event instanceof PointerEvent;\n    for (const action of this._performingActions) {\n      if (isKeyEvent && action.name === "press" && event.key === action.key)\n        return true;\n      if (isMouseOrPointerEvent && (action.name === "click" || action.name === "check" || action.name === "uncheck"))\n        return true;\n    }\n    consumeEvent(event);\n    return false;\n  }\n  _consumedDueToNoModel(event, model) {\n    if (model)\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._recorder.deepEventTarget(event))\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumeWhenAboutToPerform(event) {\n    if (!this._performingActions.size)\n      consumeEvent(event);\n  }\n  _recordAction(action) {\n    this._recorder.recordAction(action);\n  }\n  _performAction(action) {\n    this._recorder.updateHighlight(null, false);\n    this._performingActions.add(action);\n    const promise = this._recorder.performAction(action).then(() => {\n      this._performingActions.delete(action);\n      this._onFocus(false);\n    });\n    if (!this._recorder.injectedScript.isUnderTest)\n      return;\n    void promise.then(() => {\n      console.error("Action performed for test: " + JSON.stringify({\n        // eslint-disable-line no-console\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n        active: this._activeModel ? this._activeModel.selector : null\n      }));\n    });\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if (typeof event.key !== "string")\n      return false;\n    if (event.key === "Enter" && (this._recorder.deepEventTarget(event).nodeName === "TEXTAREA" || this._recorder.deepEventTarget(event).isContentEditable))\n      return false;\n    if (["Backspace", "Delete", "AltGraph"].includes(event.key))\n      return false;\n    if (event.key === "@" && event.code === "KeyL")\n      return false;\n    if (navigator.platform.includes("Mac")) {\n      if (event.key === "v" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === "v" && event.ctrlKey)\n        return false;\n      if (event.key === "Insert" && event.shiftKey)\n        return false;\n    }\n    if (["Shift", "Control", "Meta", "Alt", "Process"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !!asCheckbox(this._recorder.deepEventTarget(event));\n    return true;\n  }\n  _updateModelForHoveredElement() {\n    this._installObserverIfNeeded();\n    if (this._performingActions.size)\n      return;\n    if (!this._hoveredElement || !this._hoveredElement.isConnected) {\n      this._hoveredModel = null;\n      this._hoveredElement = null;\n      this._updateHighlight(true);\n      return;\n    }\n    const { selector, elements } = this._recorder.injectedScript.generateSelector(this._hoveredElement, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n    if (this._hoveredModel && this._hoveredModel.selector === selector)\n      return;\n    this._hoveredModel = selector ? { selector, elements, color: HighlightColors.action } : null;\n    this._updateHighlight(true);\n  }\n  _updateHighlight(userGesture) {\n    this._recorder.updateHighlight(this._hoveredModel, userGesture);\n  }\n};\nvar JsonRecordActionTool = class {\n  constructor(recorder) {\n    this._recorder = recorder;\n  }\n  install() {\n    this._recorder.highlight.uninstall();\n  }\n  uninstall() {\n    this._recorder.highlight.install();\n  }\n  onClick(event) {\n    const element = this._recorder.deepEventTarget(event);\n    if (isRangeInput(element))\n      return;\n    if (event.button === 2 && event.type === "auxclick")\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    const checkbox = asCheckbox(element);\n    const { ariaSnapshot, selector, ref } = this._ariaSnapshot(element);\n    if (checkbox && event.detail === 1) {\n      this._recorder.recordAction({\n        name: checkbox.checked ? "check" : "uncheck",\n        selector,\n        ref,\n        signals: [],\n        ariaSnapshot\n      });\n      return;\n    }\n    this._recorder.recordAction({\n      name: "click",\n      selector,\n      ref,\n      ariaSnapshot,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  onContextMenu(event) {\n    const element = this._recorder.deepEventTarget(event);\n    const { ariaSnapshot, selector, ref } = this._ariaSnapshot(element);\n    this._recorder.recordAction({\n      name: "click",\n      selector,\n      ref,\n      ariaSnapshot,\n      position: positionForEvent(event),\n      signals: [],\n      button: "right",\n      modifiers: modifiersForEvent(event),\n      clickCount: 1\n    });\n  }\n  onInput(event) {\n    const element = this._recorder.deepEventTarget(event);\n    const { ariaSnapshot, selector, ref } = this._ariaSnapshot(element);\n    if (isRangeInput(element)) {\n      this._recorder.recordAction({\n        name: "fill",\n        selector,\n        ref,\n        ariaSnapshot,\n        signals: [],\n        text: element.value\n      });\n      return;\n    }\n    if (["INPUT", "TEXTAREA"].includes(element.nodeName) || element.isContentEditable) {\n      if (element.nodeName === "INPUT" && ["checkbox", "radio"].includes(element.type.toLowerCase())) {\n        return;\n      }\n      this._recorder.recordAction({\n        name: "fill",\n        ref,\n        selector,\n        ariaSnapshot,\n        signals: [],\n        text: element.isContentEditable ? element.innerText : element.value\n      });\n      return;\n    }\n    if (element.nodeName === "SELECT") {\n      const selectElement = element;\n      this._recorder.recordAction({\n        name: "select",\n        selector,\n        ref,\n        ariaSnapshot,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n      return;\n    }\n  }\n  onKeyDown(event) {\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    const element = this._recorder.deepEventTarget(event);\n    const { ariaSnapshot, selector, ref } = this._ariaSnapshot(element);\n    if (event.key === " ") {\n      const checkbox = asCheckbox(element);\n      if (checkbox && event.detail === 0) {\n        this._recorder.recordAction({\n          name: checkbox.checked ? "uncheck" : "check",\n          selector,\n          ref,\n          ariaSnapshot,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._recorder.recordAction({\n      name: "press",\n      selector,\n      ref,\n      ariaSnapshot,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._recorder.deepEventTarget(event);\n    const nodeName = target.nodeName;\n    if (nodeName === "SELECT" || nodeName === "OPTION")\n      return true;\n    if (nodeName === "INPUT" && ["date", "range"].includes(target.type))\n      return true;\n    return false;\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if (typeof event.key !== "string")\n      return false;\n    if (event.key === "Enter" && (this._recorder.deepEventTarget(event).nodeName === "TEXTAREA" || this._recorder.deepEventTarget(event).isContentEditable))\n      return false;\n    if (["Backspace", "Delete", "AltGraph"].includes(event.key))\n      return false;\n    if (event.key === "@" && event.code === "KeyL")\n      return false;\n    if (navigator.platform.includes("Mac")) {\n      if (event.key === "v" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === "v" && event.ctrlKey)\n        return false;\n      if (event.key === "Insert" && event.shiftKey)\n        return false;\n    }\n    if (["Shift", "Control", "Meta", "Alt", "Process"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !this._isEditable(this._recorder.deepEventTarget(event));\n    return true;\n  }\n  _isEditable(element) {\n    if (element.nodeName === "TEXTAREA" || element.nodeName === "INPUT")\n      return true;\n    if (element.isContentEditable)\n      return true;\n    return false;\n  }\n  _ariaSnapshot(element) {\n    const { ariaSnapshot, refs } = this._recorder.injectedScript.ariaSnapshotForRecorder();\n    const ref = element ? refs.get(element) : void 0;\n    const elementInfo = element ? this._recorder.injectedScript.generateSelector(element, { testIdAttributeName: this._recorder.state.testIdAttributeName }) : void 0;\n    return { ariaSnapshot, selector: elementInfo == null ? void 0 : elementInfo.selector, ref };\n  }\n};\nvar TextAssertionTool = class {\n  constructor(recorder, kind) {\n    this._hoverHighlight = null;\n    this._action = null;\n    this._recorder = recorder;\n    this._textCache = /* @__PURE__ */ new Map();\n    this._kind = kind;\n    this._dialog = new Dialog(recorder);\n  }\n  cursor() {\n    return "pointer";\n  }\n  uninstall() {\n    this._dialog.close();\n    this._hoverHighlight = null;\n  }\n  onClick(event) {\n    consumeEvent(event);\n    if (this._kind === "value") {\n      this._commitAssertValue();\n    } else {\n      if (!this._dialog.isShowing())\n        this._showDialog();\n    }\n  }\n  onMouseDown(event) {\n    const target = this._recorder.deepEventTarget(event);\n    if (this._elementHasValue(target))\n      event.preventDefault();\n  }\n  onPointerUp(event) {\n    var _a;\n    const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n    if (this._kind === "value" && target && (target.nodeName === "INPUT" || target.nodeName === "SELECT") && target.disabled) {\n      this._commitAssertValue();\n    }\n  }\n  onMouseMove(event) {\n    var _a;\n    if (this._dialog.isShowing())\n      return;\n    const target = this._recorder.deepEventTarget(event);\n    if (((_a = this._hoverHighlight) == null ? void 0 : _a.elements[0]) === target)\n      return;\n    if (this._kind === "text" || this._kind === "snapshot") {\n      this._hoverHighlight = this._recorder.injectedScript.utils.elementText(this._textCache, target).full ? { elements: [target], selector: "", color: HighlightColors.assert } : null;\n    } else if (this._elementHasValue(target)) {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n    } else {\n      this._hoverHighlight = null;\n    }\n    this._recorder.updateHighlight(this._hoverHighlight, true);\n  }\n  onKeyDown(event) {\n    if (event.key === "Escape")\n      this._recorder.setMode("recording");\n    consumeEvent(event);\n  }\n  onScroll(event) {\n    this._recorder.updateHighlight(this._hoverHighlight, false);\n  }\n  _elementHasValue(element) {\n    return element.nodeName === "TEXTAREA" || element.nodeName === "SELECT" || element.nodeName === "INPUT" && !["button", "image", "reset", "submit"].includes(element.type);\n  }\n  _generateAction() {\n    var _a;\n    this._textCache.clear();\n    const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n    if (!target)\n      return null;\n    if (this._kind === "value") {\n      if (!this._elementHasValue(target))\n        return null;\n      const { selector } = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName });\n      if (target.nodeName === "INPUT" && ["checkbox", "radio"].includes(target.type.toLowerCase())) {\n        return {\n          name: "assertChecked",\n          selector,\n          signals: [],\n          // Interestingly, inputElement.checked is reversed inside this event handler.\n          checked: !target.checked\n        };\n      } else {\n        return {\n          name: "assertValue",\n          selector,\n          signals: [],\n          value: target.value\n        };\n      }\n    } else if (this._kind === "snapshot") {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName, forTextExpect: true });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n      this._recorder.updateHighlight(this._hoverHighlight, true);\n      return {\n        name: "assertSnapshot",\n        selector: this._hoverHighlight.selector,\n        signals: [],\n        ariaSnapshot: this._recorder.injectedScript.ariaSnapshot(target, { mode: "codegen" })\n      };\n    } else {\n      const generated = this._recorder.injectedScript.generateSelector(target, { testIdAttributeName: this._recorder.state.testIdAttributeName, forTextExpect: true });\n      this._hoverHighlight = { selector: generated.selector, elements: generated.elements, color: HighlightColors.assert };\n      this._recorder.updateHighlight(this._hoverHighlight, true);\n      return {\n        name: "assertText",\n        selector: this._hoverHighlight.selector,\n        signals: [],\n        text: this._recorder.injectedScript.utils.elementText(this._textCache, target).normalized,\n        substring: true\n      };\n    }\n  }\n  _renderValue(action) {\n    if ((action == null ? void 0 : action.name) === "assertText")\n      return this._recorder.injectedScript.utils.normalizeWhiteSpace(action.text);\n    if ((action == null ? void 0 : action.name) === "assertChecked")\n      return String(action.checked);\n    if ((action == null ? void 0 : action.name) === "assertValue")\n      return action.value;\n    if ((action == null ? void 0 : action.name) === "assertSnapshot")\n      return action.ariaSnapshot;\n    return "";\n  }\n  _commit() {\n    if (!this._action || !this._dialog.isShowing())\n      return;\n    this._dialog.close();\n    this._recorder.recordAction(this._action);\n    this._recorder.setMode("recording");\n  }\n  _showDialog() {\n    var _a, _b, _c, _d;\n    if (!((_a = this._hoverHighlight) == null ? void 0 : _a.elements[0]))\n      return;\n    this._action = this._generateAction();\n    if (((_b = this._action) == null ? void 0 : _b.name) === "assertText") {\n      this._showTextDialog(this._action);\n    } else if (((_c = this._action) == null ? void 0 : _c.name) === "assertSnapshot") {\n      this._recorder.recordAction(this._action);\n      this._recorder.setMode("recording");\n      (_d = this._recorder.overlay) == null ? void 0 : _d.flashToolSucceeded("assertingSnapshot");\n    }\n  }\n  _showTextDialog(action) {\n    const textElement = this._recorder.document.createElement("textarea");\n    textElement.setAttribute("spellcheck", "false");\n    textElement.value = this._renderValue(action);\n    textElement.classList.add("text-editor");\n    const updateAndValidate = () => {\n      var _a;\n      const newValue = this._recorder.injectedScript.utils.normalizeWhiteSpace(textElement.value);\n      const target = (_a = this._hoverHighlight) == null ? void 0 : _a.elements[0];\n      if (!target)\n        return;\n      action.text = newValue;\n      const targetText = this._recorder.injectedScript.utils.elementText(this._textCache, target).normalized;\n      const matches = newValue && targetText.includes(newValue);\n      textElement.classList.toggle("does-not-match", !matches);\n    };\n    textElement.addEventListener("input", updateAndValidate);\n    const label = "Assert that element contains text";\n    const dialogElement = this._dialog.show({\n      label,\n      body: textElement,\n      onCommit: () => this._commit()\n    });\n    const position = this._recorder.highlight.tooltipPosition(this._recorder.highlight.firstBox(), dialogElement);\n    this._dialog.moveTo(position.anchorTop, position.anchorLeft);\n    textElement.focus();\n  }\n  _commitAssertValue() {\n    var _a;\n    if (this._kind !== "value")\n      return;\n    const action = this._generateAction();\n    if (!action)\n      return;\n    this._recorder.recordAction(action);\n    this._recorder.setMode("recording");\n    (_a = this._recorder.overlay) == null ? void 0 : _a.flashToolSucceeded("assertingValue");\n  }\n};\nvar Overlay = class {\n  constructor(recorder) {\n    this._listeners = [];\n    this._offsetX = 0;\n    this._measure = { width: 0, height: 0 };\n    this._recorder = recorder;\n    const document = this._recorder.document;\n    this._overlayElement = document.createElement("x-pw-overlay");\n    const toolsListElement = document.createElement("x-pw-tools-list");\n    this._overlayElement.appendChild(toolsListElement);\n    this._dragHandle = document.createElement("x-pw-tool-gripper");\n    this._dragHandle.appendChild(document.createElement("x-div"));\n    toolsListElement.appendChild(this._dragHandle);\n    this._recordToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._recordToggle.title = "Record";\n    this._recordToggle.classList.add("record");\n    this._recordToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._recordToggle);\n    this._pickLocatorToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._pickLocatorToggle.title = "Pick locator";\n    this._pickLocatorToggle.classList.add("pick-locator");\n    this._pickLocatorToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._pickLocatorToggle);\n    this._assertVisibilityToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertVisibilityToggle.title = "Assert visibility";\n    this._assertVisibilityToggle.classList.add("visibility");\n    this._assertVisibilityToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertVisibilityToggle);\n    this._assertTextToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertTextToggle.title = "Assert text";\n    this._assertTextToggle.classList.add("text");\n    this._assertTextToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertTextToggle);\n    this._assertValuesToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertValuesToggle.title = "Assert value";\n    this._assertValuesToggle.classList.add("value");\n    this._assertValuesToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertValuesToggle);\n    this._assertSnapshotToggle = this._recorder.document.createElement("x-pw-tool-item");\n    this._assertSnapshotToggle.title = "Assert snapshot";\n    this._assertSnapshotToggle.classList.add("snapshot");\n    this._assertSnapshotToggle.appendChild(this._recorder.document.createElement("x-div"));\n    toolsListElement.appendChild(this._assertSnapshotToggle);\n    this._updateVisualPosition();\n    this._refreshListeners();\n  }\n  _refreshListeners() {\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(this._dragHandle, "mousedown", (event) => {\n        this._dragState = { offsetX: this._offsetX, dragStart: { x: event.clientX, y: 0 } };\n      }),\n      addEventListener(this._recordToggle, "click", () => {\n        if (this._recordToggle.classList.contains("disabled"))\n          return;\n        this._recorder.setMode(this._recorder.state.mode === "none" || this._recorder.state.mode === "standby" || this._recorder.state.mode === "inspecting" ? "recording" : "standby");\n      }),\n      addEventListener(this._pickLocatorToggle, "click", () => {\n        if (this._pickLocatorToggle.classList.contains("disabled"))\n          return;\n        const newMode = {\n          "inspecting": "standby",\n          "none": "inspecting",\n          "standby": "inspecting",\n          "recording": "recording-inspecting",\n          "recording-inspecting": "recording",\n          "assertingText": "recording-inspecting",\n          "assertingVisibility": "recording-inspecting",\n          "assertingValue": "recording-inspecting",\n          "assertingSnapshot": "recording-inspecting"\n        };\n        this._recorder.setMode(newMode[this._recorder.state.mode]);\n      }),\n      addEventListener(this._assertVisibilityToggle, "click", () => {\n        if (!this._assertVisibilityToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingVisibility" ? "recording" : "assertingVisibility");\n      }),\n      addEventListener(this._assertTextToggle, "click", () => {\n        if (!this._assertTextToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingText" ? "recording" : "assertingText");\n      }),\n      addEventListener(this._assertValuesToggle, "click", () => {\n        if (!this._assertValuesToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingValue" ? "recording" : "assertingValue");\n      }),\n      addEventListener(this._assertSnapshotToggle, "click", () => {\n        if (!this._assertSnapshotToggle.classList.contains("disabled"))\n          this._recorder.setMode(this._recorder.state.mode === "assertingSnapshot" ? "recording" : "assertingSnapshot");\n      })\n    ];\n  }\n  install() {\n    this._recorder.highlight.appendChild(this._overlayElement);\n    this._refreshListeners();\n    this._updateVisualPosition();\n  }\n  contains(element) {\n    return this._recorder.injectedScript.utils.isInsideScope(this._overlayElement, element);\n  }\n  setUIState(state) {\n    this._recordToggle.classList.toggle("toggled", state.mode === "recording" || state.mode === "assertingText" || state.mode === "assertingVisibility" || state.mode === "assertingValue" || state.mode === "assertingSnapshot" || state.mode === "recording-inspecting");\n    this._pickLocatorToggle.classList.toggle("toggled", state.mode === "inspecting" || state.mode === "recording-inspecting");\n    this._assertVisibilityToggle.classList.toggle("toggled", state.mode === "assertingVisibility");\n    this._assertVisibilityToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertTextToggle.classList.toggle("toggled", state.mode === "assertingText");\n    this._assertTextToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertValuesToggle.classList.toggle("toggled", state.mode === "assertingValue");\n    this._assertValuesToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    this._assertSnapshotToggle.classList.toggle("toggled", state.mode === "assertingSnapshot");\n    this._assertSnapshotToggle.classList.toggle("disabled", state.mode === "none" || state.mode === "standby" || state.mode === "inspecting");\n    if (this._offsetX !== state.overlay.offsetX) {\n      this._offsetX = state.overlay.offsetX;\n      this._updateVisualPosition();\n    }\n    if (state.mode === "none")\n      this._hideOverlay();\n    else\n      this._showOverlay();\n  }\n  flashToolSucceeded(tool) {\n    let element;\n    if (tool === "assertingVisibility")\n      element = this._assertVisibilityToggle;\n    else if (tool === "assertingSnapshot")\n      element = this._assertSnapshotToggle;\n    else\n      element = this._assertValuesToggle;\n    element.classList.add("succeeded");\n    this._recorder.injectedScript.utils.builtins.setTimeout(() => element.classList.remove("succeeded"), 2e3);\n  }\n  _hideOverlay() {\n    this._overlayElement.setAttribute("hidden", "true");\n  }\n  _showOverlay() {\n    if (!this._overlayElement.hasAttribute("hidden"))\n      return;\n    this._overlayElement.removeAttribute("hidden");\n    this._updateVisualPosition();\n  }\n  _updateVisualPosition() {\n    this._measure = this._overlayElement.getBoundingClientRect();\n    this._overlayElement.style.left = (this._recorder.injectedScript.window.innerWidth - this._measure.width) / 2 + this._offsetX + "px";\n  }\n  onMouseMove(event) {\n    if (!event.buttons) {\n      this._dragState = void 0;\n      return false;\n    }\n    if (this._dragState) {\n      this._offsetX = this._dragState.offsetX + event.clientX - this._dragState.dragStart.x;\n      const halfGapSize = (this._recorder.injectedScript.window.innerWidth - this._measure.width) / 2 - 10;\n      this._offsetX = Math.max(-halfGapSize, Math.min(halfGapSize, this._offsetX));\n      this._updateVisualPosition();\n      this._recorder.setOverlayState({ offsetX: this._offsetX });\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onMouseUp(event) {\n    if (this._dragState) {\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onClick(event) {\n    if (this._dragState) {\n      this._dragState = void 0;\n      consumeEvent(event);\n      return true;\n    }\n    return false;\n  }\n  onDblClick(event) {\n    return false;\n  }\n};\nvar Recorder = class {\n  constructor(injectedScript, options) {\n    this._listeners = [];\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this.state = {\n      mode: "none",\n      testIdAttributeName: "data-testid",\n      language: "javascript",\n      overlay: { offsetX: 0 }\n    };\n    this._delegate = {};\n    var _a, _b;\n    this.document = injectedScript.document;\n    this.injectedScript = injectedScript;\n    this.highlight = injectedScript.createHighlight();\n    this._tools = {\n      "none": new NoneTool(),\n      "standby": new NoneTool(),\n      "inspecting": new InspectTool(this, false),\n      "recording": (options == null ? void 0 : options.recorderMode) === "api" ? new JsonRecordActionTool(this) : new RecordActionTool(this),\n      "recording-inspecting": new InspectTool(this, false),\n      "assertingText": new TextAssertionTool(this, "text"),\n      "assertingVisibility": new InspectTool(this, true),\n      "assertingValue": new TextAssertionTool(this, "value"),\n      "assertingSnapshot": new TextAssertionTool(this, "snapshot")\n    };\n    this._currentTool = this._tools.none;\n    (_b = (_a = this._currentTool).install) == null ? void 0 : _b.call(_a);\n    if (injectedScript.window.top === injectedScript.window) {\n      this.overlay = new Overlay(this);\n      this.overlay.setUIState(this.state);\n    }\n    this._stylesheet = new injectedScript.window.CSSStyleSheet();\n    this._stylesheet.replaceSync(`\n      body[data-pw-cursor=pointer] *, body[data-pw-cursor=pointer] *::after { cursor: pointer !important; }\n      body[data-pw-cursor=text] *, body[data-pw-cursor=text] *::after { cursor: text !important; }\n    `);\n    this.installListeners();\n    injectedScript.utils.cacheNormalizedWhitespaces();\n    if (injectedScript.isUnderTest)\n      console.error("Recorder script ready for test");\n    injectedScript.consoleApi.install();\n  }\n  installListeners() {\n    var _a, _b, _c;\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(this.document, "click", (event) => this._onClick(event), true),\n      addEventListener(this.document, "auxclick", (event) => this._onClick(event), true),\n      addEventListener(this.document, "dblclick", (event) => this._onDblClick(event), true),\n      addEventListener(this.document, "contextmenu", (event) => this._onContextMenu(event), true),\n      addEventListener(this.document, "dragstart", (event) => this._onDragStart(event), true),\n      addEventListener(this.document, "input", (event) => this._onInput(event), true),\n      addEventListener(this.document, "keydown", (event) => this._onKeyDown(event), true),\n      addEventListener(this.document, "keyup", (event) => this._onKeyUp(event), true),\n      addEventListener(this.document, "pointerdown", (event) => this._onPointerDown(event), true),\n      addEventListener(this.document, "pointerup", (event) => this._onPointerUp(event), true),\n      addEventListener(this.document, "mousedown", (event) => this._onMouseDown(event), true),\n      addEventListener(this.document, "mouseup", (event) => this._onMouseUp(event), true),\n      addEventListener(this.document, "mousemove", (event) => this._onMouseMove(event), true),\n      addEventListener(this.document, "mouseleave", (event) => this._onMouseLeave(event), true),\n      addEventListener(this.document, "mouseenter", (event) => this._onMouseEnter(event), true),\n      addEventListener(this.document, "focus", (event) => this._onFocus(event), true),\n      addEventListener(this.document, "scroll", (event) => this._onScroll(event), true)\n    ];\n    this.highlight.install();\n    let recreationInterval;\n    const recreate = () => {\n      this.highlight.install();\n      recreationInterval = this.injectedScript.utils.builtins.setTimeout(recreate, 500);\n    };\n    recreationInterval = this.injectedScript.utils.builtins.setTimeout(recreate, 500);\n    this._listeners.push(() => this.injectedScript.utils.builtins.clearTimeout(recreationInterval));\n    this.highlight.appendChild(createSvgElement(this.document, clipPaths_default));\n    (_a = this.overlay) == null ? void 0 : _a.install();\n    (_c = (_b = this._currentTool) == null ? void 0 : _b.install) == null ? void 0 : _c.call(_b);\n    this.document.adoptedStyleSheets.push(this._stylesheet);\n  }\n  _switchCurrentTool() {\n    var _a, _b, _c, _d, _e, _f;\n    const newTool = this._tools[this.state.mode];\n    if (newTool === this._currentTool)\n      return;\n    (_b = (_a = this._currentTool).uninstall) == null ? void 0 : _b.call(_a);\n    this.clearHighlight();\n    this._currentTool = newTool;\n    (_d = (_c = this._currentTool).install) == null ? void 0 : _d.call(_c);\n    const cursor = (_e = newTool.cursor) == null ? void 0 : _e.call(newTool);\n    if (cursor)\n      (_f = this.injectedScript.document.body) == null ? void 0 : _f.setAttribute("data-pw-cursor", cursor);\n  }\n  setUIState(state, delegate) {\n    var _a;\n    this._delegate = delegate;\n    if (state.actionPoint && this.state.actionPoint && state.actionPoint.x === this.state.actionPoint.x && state.actionPoint.y === this.state.actionPoint.y) {\n    } else if (!state.actionPoint && !this.state.actionPoint) {\n    } else {\n      if (state.actionPoint)\n        this.highlight.showActionPoint(state.actionPoint.x, state.actionPoint.y);\n      else\n        this.highlight.hideActionPoint();\n    }\n    this.state = state;\n    this.highlight.setLanguage(state.language);\n    this._switchCurrentTool();\n    (_a = this.overlay) == null ? void 0 : _a.setUIState(state);\n    let highlight = "noop";\n    if (state.actionSelector !== this._lastHighlightedSelector) {\n      const entries = state.actionSelector ? entriesForSelectorHighlight(this.injectedScript, state.language, state.actionSelector, this.document) : null;\n      highlight = (entries == null ? void 0 : entries.length) ? entries : "clear";\n      this._lastHighlightedSelector = (entries == null ? void 0 : entries.length) ? state.actionSelector : void 0;\n    }\n    const ariaTemplateJSON = JSON.stringify(state.ariaTemplate);\n    if (this._lastHighlightedAriaTemplateJSON !== ariaTemplateJSON) {\n      const elements = state.ariaTemplate ? this.injectedScript.getAllElementsMatchingExpectAriaTemplate(this.document, state.ariaTemplate) : [];\n      if (elements.length) {\n        const color = elements.length > 1 ? HighlightColors.multiple : HighlightColors.single;\n        highlight = elements.map((element) => ({ element, color }));\n        this._lastHighlightedAriaTemplateJSON = ariaTemplateJSON;\n      } else {\n        if (!this._lastHighlightedSelector)\n          highlight = "clear";\n        this._lastHighlightedAriaTemplateJSON = "undefined";\n      }\n    }\n    if (highlight === "clear")\n      this.highlight.clearHighlight();\n    else if (highlight !== "noop")\n      this.highlight.updateHighlight(highlight);\n  }\n  clearHighlight() {\n    this.updateHighlight(null, false);\n  }\n  _onClick(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onClick(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onClick) == null ? void 0 : _c.call(_b, event);\n  }\n  _onDblClick(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onDblClick(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onDblClick) == null ? void 0 : _c.call(_b, event);\n  }\n  _onContextMenu(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onContextMenu) == null ? void 0 : _b.call(_a, event);\n  }\n  _onDragStart(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onDragStart) == null ? void 0 : _b.call(_a, event);\n  }\n  _onPointerDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onPointerDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onPointerUp(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onPointerUp) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseUp(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onMouseUp(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onMouseUp) == null ? void 0 : _c.call(_b, event);\n  }\n  _onMouseMove(event) {\n    var _a, _b, _c;\n    if (!event.isTrusted)\n      return;\n    if ((_a = this.overlay) == null ? void 0 : _a.onMouseMove(event))\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_c = (_b = this._currentTool).onMouseMove) == null ? void 0 : _c.call(_b, event);\n  }\n  _onMouseEnter(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseEnter) == null ? void 0 : _b.call(_a, event);\n  }\n  _onMouseLeave(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onMouseLeave) == null ? void 0 : _b.call(_a, event);\n  }\n  _onFocus(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onFocus) == null ? void 0 : _b.call(_a, event);\n  }\n  _onScroll(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this.highlight.hideActionPoint();\n    (_b = (_a = this._currentTool).onScroll) == null ? void 0 : _b.call(_a, event);\n  }\n  _onInput(event) {\n    var _a, _b;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onInput) == null ? void 0 : _b.call(_a, event);\n  }\n  _onKeyDown(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onKeyDown) == null ? void 0 : _b.call(_a, event);\n  }\n  _onKeyUp(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._ignoreOverlayEvent(event))\n      return;\n    (_b = (_a = this._currentTool).onKeyUp) == null ? void 0 : _b.call(_a, event);\n  }\n  updateHighlight(model, userGesture) {\n    this._lastHighlightedSelector = void 0;\n    this._lastHighlightedAriaTemplateJSON = "undefined";\n    this._updateHighlight(model, userGesture);\n  }\n  _updateHighlight(model, userGesture) {\n    var _a, _b;\n    let tooltipText = model == null ? void 0 : model.tooltipText;\n    if (tooltipText === void 0 && (model == null ? void 0 : model.selector))\n      tooltipText = this.injectedScript.utils.asLocator(this.state.language, model.selector);\n    if (model)\n      this.highlight.updateHighlight(model.elements.map((element) => ({ element, color: model.color, tooltipText })));\n    else\n      this.highlight.clearHighlight();\n    if (userGesture)\n      (_b = (_a = this._delegate).highlightUpdated) == null ? void 0 : _b.call(_a);\n  }\n  _ignoreOverlayEvent(event) {\n    return event.composedPath().some((e) => {\n      const nodeName = e.nodeName || "";\n      return nodeName.toLowerCase() === "x-pw-glass";\n    });\n  }\n  deepEventTarget(event) {\n    var _a;\n    for (const element of event.composedPath()) {\n      if (!((_a = this.overlay) == null ? void 0 : _a.contains(element)))\n        return element;\n    }\n    return event.composedPath()[0];\n  }\n  setMode(mode) {\n    var _a, _b;\n    void ((_b = (_a = this._delegate).setMode) == null ? void 0 : _b.call(_a, mode));\n  }\n  _captureAutoExpectSnapshot() {\n    const documentElement = this.injectedScript.document.documentElement;\n    return documentElement ? this.injectedScript.utils.generateAriaTree(documentElement, { mode: "autoexpect" }) : void 0;\n  }\n  async performAction(action) {\n    var _a, _b;\n    const previousSnapshot = this._lastActionAutoexpectSnapshot;\n    this._lastActionAutoexpectSnapshot = this._captureAutoExpectSnapshot();\n    if (!isAssertAction(action) && this._lastActionAutoexpectSnapshot) {\n      const element = findNewElement(previousSnapshot, this._lastActionAutoexpectSnapshot);\n      action.preconditionSelector = element ? this.injectedScript.generateSelector(element, { testIdAttributeName: this.state.testIdAttributeName }).selector : void 0;\n      if (action.preconditionSelector === action.selector)\n        action.preconditionSelector = void 0;\n    }\n    await ((_b = (_a = this._delegate).performAction) == null ? void 0 : _b.call(_a, action).catch(() => {\n    }));\n  }\n  recordAction(action) {\n    var _a, _b;\n    this._lastActionAutoexpectSnapshot = this._captureAutoExpectSnapshot();\n    void ((_b = (_a = this._delegate).recordAction) == null ? void 0 : _b.call(_a, action));\n  }\n  setOverlayState(state) {\n    var _a, _b;\n    void ((_b = (_a = this._delegate).setOverlayState) == null ? void 0 : _b.call(_a, state));\n  }\n  elementPicked(selector, model) {\n    var _a, _b;\n    const ariaSnapshot = this.injectedScript.ariaSnapshot(model.elements[0], { mode: "expect" });\n    void ((_b = (_a = this._delegate).elementPicked) == null ? void 0 : _b.call(_a, { selector, ariaSnapshot }));\n  }\n};\nvar Dialog = class {\n  constructor(recorder) {\n    this._dialogElement = null;\n    this._recorder = recorder;\n  }\n  isShowing() {\n    return !!this._dialogElement;\n  }\n  show(options) {\n    const acceptButton = this._recorder.document.createElement("x-pw-tool-item");\n    acceptButton.title = "Accept";\n    acceptButton.classList.add("accept");\n    acceptButton.appendChild(this._recorder.document.createElement("x-div"));\n    acceptButton.addEventListener("click", () => options.onCommit());\n    const cancelButton = this._recorder.document.createElement("x-pw-tool-item");\n    cancelButton.title = "Close";\n    cancelButton.classList.add("cancel");\n    cancelButton.appendChild(this._recorder.document.createElement("x-div"));\n    cancelButton.addEventListener("click", () => {\n      var _a;\n      this.close();\n      (_a = options.onCancel) == null ? void 0 : _a.call(options);\n    });\n    this._dialogElement = this._recorder.document.createElement("x-pw-dialog");\n    this._keyboardListener = (event) => {\n      var _a;\n      if (event.key === "Escape") {\n        this.close();\n        (_a = options.onCancel) == null ? void 0 : _a.call(options);\n        return;\n      }\n      if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) {\n        if (this._dialogElement)\n          options.onCommit();\n        return;\n      }\n    };\n    this._recorder.document.addEventListener("keydown", this._keyboardListener, true);\n    const toolbarElement = this._recorder.document.createElement("x-pw-tools-list");\n    const labelElement = this._recorder.document.createElement("label");\n    labelElement.textContent = options.label;\n    toolbarElement.appendChild(labelElement);\n    toolbarElement.appendChild(this._recorder.document.createElement("x-spacer"));\n    toolbarElement.appendChild(acceptButton);\n    toolbarElement.appendChild(cancelButton);\n    this._dialogElement.appendChild(toolbarElement);\n    const bodyElement = this._recorder.document.createElement("x-pw-dialog-body");\n    bodyElement.appendChild(options.body);\n    this._dialogElement.appendChild(bodyElement);\n    this._recorder.highlight.appendChild(this._dialogElement);\n    return this._dialogElement;\n  }\n  moveTo(top, left) {\n    if (!this._dialogElement)\n      return;\n    this._dialogElement.style.top = top + "px";\n    this._dialogElement.style.left = left + "px";\n  }\n  close() {\n    if (!this._dialogElement)\n      return;\n    this._dialogElement.remove();\n    this._recorder.document.removeEventListener("keydown", this._keyboardListener);\n    this._dialogElement = null;\n  }\n};\nfunction deepActiveElement(document) {\n  let activeElement = document.activeElement;\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    activeElement = activeElement.shadowRoot.activeElement;\n  return activeElement;\n}\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return "left";\n    case 2:\n      return "middle";\n    case 3:\n      return "right";\n  }\n  return "left";\n}\nfunction positionForEvent(event) {\n  const targetElement = event.target;\n  if (targetElement.nodeName !== "CANVAS")\n    return;\n  return {\n    x: event.offsetX,\n    y: event.offsetY\n  };\n}\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return null;\n  const inputElement = node;\n  return ["checkbox", "radio"].includes(inputElement.type) ? inputElement : null;\n}\nfunction isRangeInput(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return false;\n  const inputElement = node;\n  return inputElement.type.toLowerCase() === "range";\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n  return remove;\n}\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners)\n    listener();\n  listeners.splice(0, listeners.length);\n}\nfunction entriesForSelectorHighlight(injectedScript, language, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, ownerDocument);\n    const color = elements.length > 1 ? HighlightColors.multiple : HighlightColors.single;\n    const locator = injectedScript.utils.asLocator(language, selector);\n    return elements.map((element, index) => {\n      const suffix = elements.length > 1 ? ` [${index + 1} of ${elements.length}]` : "";\n      return { element, color, tooltipText: locator + suffix };\n    });\n  } catch (e) {\n    return [];\n  }\n}\nfunction createSvgElement(doc, { tagName, attrs, children }) {\n  const elem = doc.createElementNS("http://www.w3.org/2000/svg", tagName);\n  if (attrs) {\n    for (const [k, v] of Object.entries(attrs))\n      elem.setAttribute(k, v);\n  }\n  if (children) {\n    for (const c of children)\n      elem.appendChild(createSvgElement(doc, c));\n  }\n  return elem;\n}\nfunction isAssertAction(action) {\n  return action.name.startsWith("assert");\n}\nfunction findNewElement(from, to) {\n  var _a, _b;\n  function fillMap(root, map, position) {\n    let size = 1;\n    let childPosition = position + size;\n    for (const child of root.children || []) {\n      if (typeof child === "string") {\n        size++;\n        childPosition++;\n      } else {\n        size += fillMap(child, map, childPosition);\n        childPosition += size;\n      }\n    }\n    if (!["none", "presentation", "fragment", "iframe", "generic"].includes(root.role) && root.name) {\n      let byRole = map.get(root.role);\n      if (!byRole) {\n        byRole = /* @__PURE__ */ new Map();\n        map.set(root.role, byRole);\n      }\n      const existing = byRole.get(root.name);\n      const sizeAndPosition = size * 100 - position;\n      if (!existing || existing.sizeAndPosition < sizeAndPosition)\n        byRole.set(root.name, { node: root, sizeAndPosition });\n    }\n    return size;\n  }\n  const fromMap = /* @__PURE__ */ new Map();\n  if (from)\n    fillMap(from.root, fromMap, 0);\n  const toMap = /* @__PURE__ */ new Map();\n  fillMap(to.root, toMap, 0);\n  const result = [];\n  for (const [role, byRole] of toMap) {\n    for (const [name, byName] of byRole) {\n      const inFrom = (_a = fromMap.get(role)) == null ? void 0 : _a.get(name);\n      if (!inFrom)\n        result.push(byName);\n    }\n  }\n  result.sort((a, b) => b.sizeAndPosition - a.sizeAndPosition);\n  return (_b = result[0]) == null ? void 0 : _b.node.element;\n}\n\n// packages/injected/src/recorder/pollingRecorder.ts\nvar PollingRecorder = class {\n  constructor(injectedScript, options) {\n    this._recorder = new Recorder(injectedScript, options);\n    this._embedder = injectedScript.window;\n    injectedScript.onGlobalListenersRemoved.add(() => this._recorder.installListeners());\n    const refreshOverlay = () => {\n      this._lastStateJSON = void 0;\n      this._pollRecorderMode().catch((e) => console.log(e));\n    };\n    this._embedder.__pw_refreshOverlay = refreshOverlay;\n    refreshOverlay();\n  }\n  async _pollRecorderMode() {\n    const pollPeriod = 1e3;\n    if (this._pollRecorderModeTimer)\n      this._recorder.injectedScript.utils.builtins.clearTimeout(this._pollRecorderModeTimer);\n    const state = await this._embedder.__pw_recorderState().catch(() => null);\n    if (!state) {\n      this._pollRecorderModeTimer = this._recorder.injectedScript.utils.builtins.setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n    const stringifiedState = JSON.stringify(state);\n    if (this._lastStateJSON !== stringifiedState) {\n      this._lastStateJSON = stringifiedState;\n      const win = this._recorder.document.defaultView;\n      if (win.top !== win) {\n        state.actionPoint = void 0;\n      }\n      this._recorder.setUIState(state, this);\n    }\n    this._pollRecorderModeTimer = this._recorder.injectedScript.utils.builtins.setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n  async performAction(action) {\n    await this._embedder.__pw_recorderPerformAction(action);\n  }\n  async recordAction(action) {\n    await this._embedder.__pw_recorderRecordAction(action);\n  }\n  async elementPicked(elementInfo) {\n    await this._embedder.__pw_recorderElementPicked(elementInfo);\n  }\n  async setMode(mode) {\n    await this._embedder.__pw_recorderSetMode(mode);\n  }\n  async setOverlayState(state) {\n    await this._embedder.__pw_recorderSetOverlayState(state);\n  }\n};\nvar pollingRecorder_default = PollingRecorder;\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderRunner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/expectUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function serializeExpectedTextValues(items, options2 = {}) {
  return items.map((i) => ({
    string: isString(i) ? i : void 0,
    regexSource: isRegExp2(i) ? i.source : void 0,
    regexFlags: isRegExp2(i) ? i.flags : void 0,
    matchSubstring: options2.matchSubstring,
    ignoreCase: options2.ignoreCase,
    normalizeWhiteSpace: options2.normalizeWhiteSpace
  }));
}
__name(serializeExpectedTextValues, "serializeExpectedTextValues");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderRunner.js
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
async function performAction(pageAliases, actionInContext) {
  const mainFrame = mainFrameForAction(pageAliases, actionInContext);
  const controller = new ProgressController();
  const kActionTimeout = 5e3;
  return await controller.run((progress3) => performActionImpl(progress3, mainFrame, actionInContext), kActionTimeout);
}
__name(performAction, "performAction");
async function performActionImpl(progress3, mainFrame, actionInContext) {
  const { action } = actionInContext;
  if (action.name === "navigate") {
    await mainFrame.goto(progress3, action.url);
    return;
  }
  if (action.name === "openPage")
    throw Error("Not reached");
  if (action.name === "closePage") {
    await mainFrame._page.close();
    return;
  }
  const selector = buildFullSelector(actionInContext.frame.framePath, action.selector);
  if (action.name === "click") {
    const options2 = toClickOptions(action);
    await mainFrame.click(progress3, selector, { ...options2, strict: true });
    return;
  }
  if (action.name === "press") {
    const modifiers = toKeyboardModifiers(action.modifiers);
    const shortcut = [...modifiers, action.key].join("+");
    await mainFrame.press(progress3, selector, shortcut, { strict: true });
    return;
  }
  if (action.name === "fill") {
    await mainFrame.fill(progress3, selector, action.text, { strict: true });
    return;
  }
  if (action.name === "setInputFiles") {
    await mainFrame.setInputFiles(progress3, selector, { selector, payloads: [], strict: true });
    return;
  }
  if (action.name === "check") {
    await mainFrame.check(progress3, selector, { strict: true });
    return;
  }
  if (action.name === "uncheck") {
    await mainFrame.uncheck(progress3, selector, { strict: true });
    return;
  }
  if (action.name === "select") {
    const values = action.options.map((value) => ({ value }));
    await mainFrame.selectOption(progress3, selector, [], values, { strict: true });
    return;
  }
  if (action.name === "assertChecked") {
    await mainFrame.expect(progress3, selector, {
      selector,
      expression: "to.be.checked",
      expectedValue: { checked: action.checked },
      isNot: !action.checked
    });
    return;
  }
  if (action.name === "assertText") {
    await mainFrame.expect(progress3, selector, {
      selector,
      expression: "to.have.text",
      expectedText: serializeExpectedTextValues([action.text], { matchSubstring: true, normalizeWhiteSpace: true }),
      isNot: false
    });
    return;
  }
  if (action.name === "assertValue") {
    await mainFrame.expect(progress3, selector, {
      selector,
      expression: "to.have.value",
      expectedValue: action.value,
      isNot: false
    });
    return;
  }
  if (action.name === "assertVisible") {
    await mainFrame.expect(progress3, selector, {
      selector,
      expression: "to.be.visible",
      isNot: false
    });
    return;
  }
  throw new Error("Internal error: unexpected action " + action.name);
}
__name(performActionImpl, "performActionImpl");
function toClickOptions(action) {
  const modifiers = toKeyboardModifiers(action.modifiers);
  const options2 = {};
  if (action.button !== "left")
    options2.button = action.button;
  if (modifiers.length)
    options2.modifiers = modifiers;
  if (action.clickCount > 1)
    options2.clickCount = action.clickCount;
  if (action.position)
    options2.position = action.position;
  return options2;
}
__name(toClickOptions, "toClickOptions");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder.js
var recorderSymbol = Symbol("recorderSymbol");
var RecorderEvent = {
  PausedStateChanged: "pausedStateChanged",
  ModeChanged: "modeChanged",
  ElementPicked: "elementPicked",
  CallLogsUpdated: "callLogsUpdated",
  UserSourcesChanged: "userSourcesChanged",
  ActionAdded: "actionAdded",
  SignalAdded: "signalAdded",
  PageNavigated: "pageNavigated",
  ContextClosed: "contextClosed"
};
var Recorder = class _Recorder extends EventEmitter10 {
  static {
    __name(this, "Recorder");
  }
  constructor(context2, params) {
    super();
    this._highlightedElement = {};
    this._overlayState = { offsetX: 0 };
    this._currentCallsMetadata = /* @__PURE__ */ new Map();
    this._userSources = /* @__PURE__ */ new Map();
    this._omitCallTracking = false;
    this._currentLanguage = "javascript";
    this._pageAliases = /* @__PURE__ */ new Map();
    this._lastPopupOrdinal = 0;
    this._lastDialogOrdinal = -1;
    this._lastDownloadOrdinal = -1;
    this._listeners = [];
    this._enabled = false;
    this._callLogs = [];
    this._context = context2;
    this._params = params;
    this._mode = params.mode || "none";
    this._recorderMode = params.recorderMode ?? "default";
    this.handleSIGINT = params.handleSIGINT;
    this._signalProcessor = new RecorderSignalProcessor({
      addAction: /* @__PURE__ */ __name((actionInContext) => {
        if (this._enabled)
          this.emit(RecorderEvent.ActionAdded, actionInContext);
      }, "addAction"),
      addSignal: /* @__PURE__ */ __name((signal) => {
        if (this._enabled)
          this.emit(RecorderEvent.SignalAdded, signal);
      }, "addSignal")
    });
    context2.on(BrowserContext.Events.BeforeClose, () => {
      this.emit(RecorderEvent.ContextClosed);
    });
    this._listeners.push(eventsHelper.addEventListener(process, "exit", () => {
      this.emit(RecorderEvent.ContextClosed);
    }));
    this._setEnabled(params.mode === "recording");
    this._omitCallTracking = !!params.omitCallTracking;
    this._debugger = context2.debugger();
    context2.instrumentation.addListener(this, context2);
    if (isUnderTest()) {
      this._overlayState.offsetX = 200;
    }
  }
  static forContext(context2, params) {
    let recorderPromise = context2[recorderSymbol];
    if (!recorderPromise) {
      recorderPromise = _Recorder._create(context2, params);
      context2[recorderSymbol] = recorderPromise;
    }
    return recorderPromise;
  }
  static existingForContext(context2) {
    return context2[recorderSymbol];
  }
  static async _create(context2, params = {}) {
    const recorder = new _Recorder(context2, params);
    await recorder._install();
    return recorder;
  }
  async _install() {
    this.emit(RecorderEvent.ModeChanged, this._mode);
    this.emit(RecorderEvent.PausedStateChanged, this._debugger.isPaused());
    this._context.once(BrowserContext.Events.Close, () => {
      eventsHelper.removeEventListeners(this._listeners);
      this._context.instrumentation.removeListener(this);
      this.emit(RecorderEvent.ContextClosed);
    });
    const controller = new ProgressController();
    await controller.run(async (progress3) => {
      await this._context.exposeBinding(progress3, "__pw_recorderState", false, async (source8) => {
        let actionSelector;
        let actionPoint;
        const hasActiveScreenshotCommand = [...this._currentCallsMetadata.keys()].some(isScreenshotCommand);
        if (!hasActiveScreenshotCommand) {
          actionSelector = await this._scopeHighlightedSelectorToFrame(source8.frame);
          for (const [metadata, sdkObject] of this._currentCallsMetadata) {
            if (source8.page === sdkObject.attribution.page) {
              actionPoint = metadata.point || actionPoint;
              actionSelector = actionSelector || metadata.params.selector;
            }
          }
        }
        const uiState = {
          mode: this._mode,
          actionPoint,
          actionSelector,
          ariaTemplate: this._highlightedElement.ariaTemplate,
          language: this._currentLanguage,
          testIdAttributeName: this._testIdAttributeName(),
          overlay: this._overlayState
        };
        return uiState;
      });
      await this._context.exposeBinding(progress3, "__pw_recorderElementPicked", false, async ({ frame }, elementInfo) => {
        const selectorChain = await generateFrameSelector(frame);
        this.emit(RecorderEvent.ElementPicked, { selector: buildFullSelector(selectorChain, elementInfo.selector), ariaSnapshot: elementInfo.ariaSnapshot }, true);
      });
      await this._context.exposeBinding(progress3, "__pw_recorderSetMode", false, async ({ frame }, mode) => {
        if (frame.parentFrame())
          return;
        this.setMode(mode);
      });
      await this._context.exposeBinding(progress3, "__pw_recorderSetOverlayState", false, async ({ frame }, state) => {
        if (frame.parentFrame())
          return;
        this._overlayState = state;
      });
      await this._context.exposeBinding(progress3, "__pw_resume", false, () => {
        this._debugger.resume(false);
      });
      this._context.on(BrowserContext.Events.Page, (page) => this._onPage(page));
      for (const page of this._context.pages())
        this._onPage(page);
      this._context.dialogManager.addDialogHandler((dialog) => {
        this._onDialog(dialog.page());
        return false;
      });
      await this._context.exposeBinding(
        progress3,
        "__pw_recorderPerformAction",
        false,
        (source8, action) => this._performAction(source8.frame, action)
      );
      await this._context.exposeBinding(
        progress3,
        "__pw_recorderRecordAction",
        false,
        (source8, action) => this._recordAction(source8.frame, action)
      );
      await this._context.extendInjectedScript(source5, { recorderMode: this._recorderMode });
    });
    if (this._debugger.isPaused())
      this._pausedStateChanged();
    this._debugger.on(Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
  }
  _pausedStateChanged() {
    for (const { metadata, sdkObject } of this._debugger.pausedDetails()) {
      if (!this._currentCallsMetadata.has(metadata))
        this.onBeforeCall(sdkObject, metadata);
    }
    this.emit(RecorderEvent.PausedStateChanged, this._debugger.isPaused());
    this._updateUserSources();
    this.updateCallLog([...this._currentCallsMetadata.keys()]);
  }
  mode() {
    return this._mode;
  }
  setMode(mode) {
    if (this._mode === mode)
      return;
    this._highlightedElement = {};
    this._mode = mode;
    this.emit(RecorderEvent.ModeChanged, this._mode);
    this._setEnabled(this._isRecording());
    this._debugger.setMuted(this._isRecording());
    if (this._mode !== "none" && this._mode !== "standby" && this._context.pages().length === 1)
      this._context.pages()[0].bringToFront().catch(() => {
      });
    this._refreshOverlay();
  }
  url() {
    const page = this._context.pages()[0];
    return page?.mainFrame().url();
  }
  setHighlightedSelector(selector) {
    this._highlightedElement = { selector: locatorOrSelectorAsSelector(this._currentLanguage, selector, this._context.selectors().testIdAttributeName()) };
    this._refreshOverlay();
  }
  setHighlightedAriaTemplate(ariaTemplate) {
    this._highlightedElement = { ariaTemplate };
    this._refreshOverlay();
  }
  step() {
    this._debugger.resume(true);
  }
  setLanguage(language) {
    this._currentLanguage = language;
    this._refreshOverlay();
  }
  resume() {
    this._debugger.resume(false);
  }
  pause() {
    this._debugger.pauseOnNextStatement();
  }
  paused() {
    return this._debugger.isPaused();
  }
  close() {
    this._debugger.resume(false);
  }
  hideHighlightedSelector() {
    this._highlightedElement = {};
    this._refreshOverlay();
  }
  pausedSourceId() {
    for (const { metadata } of this._debugger.pausedDetails()) {
      if (!metadata.location)
        continue;
      const source8 = this._userSources.get(metadata.location.file);
      if (!source8)
        continue;
      return source8.id;
    }
  }
  userSources() {
    return [...this._userSources.values()];
  }
  callLog() {
    return this._callLogs;
  }
  async _scopeHighlightedSelectorToFrame(frame) {
    if (!this._highlightedElement.selector)
      return;
    try {
      const mainFrame = frame._page.mainFrame();
      const resolved = await mainFrame.selectors.resolveFrameForSelector(this._highlightedElement.selector);
      if (!resolved)
        return "";
      if (resolved?.frame === mainFrame)
        return stringifySelector(resolved.info.parsed);
      if (resolved?.frame === frame)
        return stringifySelector(resolved.info.parsed);
      return "";
    } catch {
      return "";
    }
  }
  _refreshOverlay() {
    for (const page of this._context.pages()) {
      for (const frame of page.frames())
        frame.evaluateExpression("window.__pw_refreshOverlay()").catch(() => {
        });
    }
  }
  async onBeforeCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._isRecording())
      return;
    this._currentCallsMetadata.set(metadata, sdkObject);
    this._updateUserSources();
    this.updateCallLog([metadata]);
    if (isScreenshotCommand(metadata))
      this.hideHighlightedSelector();
    else if (metadata.params && metadata.params.selector)
      this._highlightedElement = { selector: metadata.params.selector };
  }
  async onAfterCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._isRecording())
      return;
    if (!metadata.error)
      this._currentCallsMetadata.delete(metadata);
    this._updateUserSources();
    this.updateCallLog([metadata]);
  }
  _updateUserSources() {
    for (const source8 of this._userSources.values()) {
      source8.highlight = [];
      source8.revealLine = void 0;
    }
    for (const metadata of this._currentCallsMetadata.keys()) {
      if (!metadata.location)
        continue;
      const { file, line } = metadata.location;
      let source8 = this._userSources.get(file);
      if (!source8) {
        source8 = { isRecorded: false, label: file, id: file, text: this._readSource(file), highlight: [], language: languageForFile(file) };
        this._userSources.set(file, source8);
      }
      if (line) {
        const paused = this._debugger.isPaused(metadata);
        source8.highlight.push({ line, type: metadata.error ? "error" : paused ? "paused" : "running" });
        source8.revealLine = line;
      }
    }
    this.emit(RecorderEvent.UserSourcesChanged, this.userSources(), this.pausedSourceId());
  }
  async onBeforeInputAction(sdkObject, metadata) {
  }
  async onCallLog(sdkObject, metadata, logName, message) {
    this.updateCallLog([metadata]);
  }
  updateCallLog(metadatas) {
    if (this._isRecording())
      return;
    const logs = [];
    for (const metadata of metadatas) {
      if (!metadata.method || metadata.internal)
        continue;
      let status = "done";
      if (this._currentCallsMetadata.has(metadata))
        status = "in-progress";
      if (this._debugger.isPaused(metadata))
        status = "paused";
      logs.push(metadataToCallLog(metadata, status));
    }
    this._callLogs = logs;
    this.emit(RecorderEvent.CallLogsUpdated, logs);
  }
  _isRecording() {
    return ["recording", "assertingText", "assertingVisibility", "assertingValue", "assertingSnapshot"].includes(this._mode);
  }
  _readSource(fileName) {
    try {
      return fs17.readFileSync(fileName, "utf-8");
    } catch (e) {
      return "// No source available";
    }
  }
  _setEnabled(enabled) {
    this._enabled = enabled;
  }
  async _onPage(page) {
    const frame = page.mainFrame();
    page.on(Page.Events.Close, () => {
      this._signalProcessor.addAction({
        frame: this._describeMainFrame(page),
        action: {
          name: "closePage",
          signals: []
        },
        startTime: monotonicTime()
      });
      this._pageAliases.delete(page);
      this._filePrimaryURLChanged();
    });
    frame.on(Frame.Events.InternalNavigation, (event) => {
      if (event.isPublic) {
        this._onFrameNavigated(frame, page);
        this._filePrimaryURLChanged();
      }
    });
    page.on(Page.Events.Download, () => this._onDownload(page));
    const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
    const pageAlias = "page" + suffix;
    this._pageAliases.set(page, pageAlias);
    if (page.opener()) {
      this._onPopup(page.opener(), page);
    } else {
      this._signalProcessor.addAction({
        frame: this._describeMainFrame(page),
        action: {
          name: "openPage",
          url: page.mainFrame().url(),
          signals: []
        },
        startTime: monotonicTime()
      });
    }
    this._filePrimaryURLChanged();
  }
  _filePrimaryURLChanged() {
    const page = this._context.pages()[0];
    this.emit(RecorderEvent.PageNavigated, page?.mainFrame().url());
  }
  clear() {
    if (this._params.mode === "recording") {
      for (const page of this._context.pages())
        this._onFrameNavigated(page.mainFrame(), page);
    }
  }
  _describeMainFrame(page) {
    return {
      pageGuid: page.guid,
      pageAlias: this._pageAliases.get(page),
      framePath: []
    };
  }
  async _describeFrame(frame) {
    return {
      pageGuid: frame._page.guid,
      pageAlias: this._pageAliases.get(frame._page),
      framePath: await generateFrameSelector(frame)
    };
  }
  _testIdAttributeName() {
    return this._params.testIdAttributeName || this._context.selectors().testIdAttributeName() || "data-testid";
  }
  async _createActionInContext(frame, action) {
    const frameDescription = await this._describeFrame(frame);
    const actionInContext = {
      frame: frameDescription,
      action,
      description: void 0,
      startTime: monotonicTime()
    };
    return actionInContext;
  }
  async _performAction(frame, action) {
    const actionInContext = await this._createActionInContext(frame, action);
    this._signalProcessor.addAction(actionInContext);
    if (actionInContext.action.name !== "openPage" && actionInContext.action.name !== "closePage")
      await performAction(this._pageAliases, actionInContext);
    actionInContext.endTime = monotonicTime();
  }
  async _recordAction(frame, action) {
    const actionInContext = await this._createActionInContext(frame, action);
    this._signalProcessor.addAction(actionInContext);
  }
  _onFrameNavigated(frame, page) {
    const pageAlias = this._pageAliases.get(page);
    this._signalProcessor.signal(pageAlias, frame, { name: "navigation", url: frame.url() });
  }
  _onPopup(page, popup) {
    const pageAlias = this._pageAliases.get(page);
    const popupAlias = this._pageAliases.get(popup);
    this._signalProcessor.signal(pageAlias, page.mainFrame(), { name: "popup", popupAlias });
  }
  _onDownload(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDownloadOrdinal;
    this._signalProcessor.signal(pageAlias, page.mainFrame(), { name: "download", downloadAlias: this._lastDownloadOrdinal ? String(this._lastDownloadOrdinal) : "" });
  }
  _onDialog(page) {
    const pageAlias = this._pageAliases.get(page);
    ++this._lastDialogOrdinal;
    this._signalProcessor.signal(pageAlias, page.mainFrame(), { name: "dialog", dialogAlias: this._lastDialogOrdinal ? String(this._lastDialogOrdinal) : "" });
  }
};
function isScreenshotCommand(metadata) {
  return metadata.method.toLowerCase().includes("screenshot");
}
__name(isScreenshotCommand, "isScreenshotCommand");
function languageForFile(file) {
  if (file.endsWith(".py"))
    return "python";
  if (file.endsWith(".java"))
    return "java";
  if (file.endsWith(".cs"))
    return "csharp";
  return "javascript";
}
__name(languageForFile, "languageForFile");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/recorder/recorderApp.js
var RecorderApp = class _RecorderApp {
  static {
    __name(this, "RecorderApp");
  }
  constructor(recorder, params, page, wsEndpointForTest) {
    this._throttledOutputFile = null;
    this._actions = [];
    this._userSources = [];
    this._recorderSources = [];
    this._page = page;
    this._recorder = recorder;
    this.wsEndpointForTest = wsEndpointForTest;
    this._languageGeneratorOptions = {
      browserName: params.browserName,
      launchOptions: { headless: false, ...params.launchOptions, tracesDir: void 0 },
      contextOptions: { ...params.contextOptions },
      deviceName: params.device,
      saveStorage: params.saveStorage
    };
    this._throttledOutputFile = params.outputFile ? new ThrottledFile(params.outputFile) : null;
    this._primaryGeneratorId = process.env.TEST_INSPECTOR_LANGUAGE || params.language || determinePrimaryGeneratorId(params.sdkLanguage);
    this._selectedGeneratorId = this._primaryGeneratorId;
  }
  async _init(inspectedContext) {
    await syncLocalStorageWithSettings(this._page, "recorder");
    const controller = new ProgressController();
    await controller.run(async (progress3) => {
      await this._page.addRequestInterceptor(progress3, (route) => {
        if (!route.request().url().startsWith("https://playwright/")) {
          route.continue({ isFallback: true }).catch(() => {
          });
          return;
        }
        const uri = route.request().url().substring("https://playwright/".length);
        const file = __require.resolve("../../vite/recorder/" + uri);
        fs18.promises.readFile(file).then((buffer) => {
          route.fulfill({
            status: 200,
            headers: [
              { name: "Content-Type", value: mime2.getType(path12.extname(file)) || "application/octet-stream" }
            ],
            body: buffer.toString("base64"),
            isBase64: true
          }).catch(() => {
          });
        });
      });
      await this._page.exposeBinding(progress3, "dispatch", false, (_, data) => this._handleUIEvent(data));
      this._page.once("close", () => {
        this._recorder.close();
        this._page.browserContext.close({ reason: "Recorder window closed" }).catch(() => {
        });
        delete inspectedContext[recorderAppSymbol];
      });
      await this._page.mainFrame().goto(progress3, process.env.PW_HMR ? "http://localhost:44225" : "https://playwright/index.html");
    });
    const url4 = this._recorder.url();
    if (url4)
      this._onPageNavigated(url4);
    this._onModeChanged(this._recorder.mode());
    this._onPausedStateChanged(this._recorder.paused());
    this._updateActions("reveal");
    this._onUserSourcesChanged(this._recorder.userSources(), this._recorder.pausedSourceId());
    this._onCallLogsUpdated(this._recorder.callLog());
    this._wireListeners(this._recorder);
  }
  _handleUIEvent(data) {
    if (data.event === "clear") {
      this._actions = [];
      this._updateActions("reveal");
      this._recorder.clear();
      return;
    }
    if (data.event === "fileChanged") {
      const source8 = [...this._recorderSources, ...this._userSources].find((s) => s.id === data.params.fileId);
      if (source8) {
        if (source8.isRecorded)
          this._selectedGeneratorId = source8.id;
        this._recorder.setLanguage(source8.language);
      }
      return;
    }
    if (data.event === "setAutoExpect") {
      this._languageGeneratorOptions.generateAutoExpect = data.params.autoExpect;
      this._updateActions();
      return;
    }
    if (data.event === "setMode") {
      this._recorder.setMode(data.params.mode);
      return;
    }
    if (data.event === "resume") {
      this._recorder.resume();
      return;
    }
    if (data.event === "pause") {
      this._recorder.pause();
      return;
    }
    if (data.event === "step") {
      this._recorder.step();
      return;
    }
    if (data.event === "highlightRequested") {
      if (data.params.selector)
        this._recorder.setHighlightedSelector(data.params.selector);
      if (data.params.ariaTemplate)
        this._recorder.setHighlightedAriaTemplate(data.params.ariaTemplate);
      return;
    }
    throw new Error(`Unknown event: ${data.event}`);
  }
  static async show(context2, params) {
    if (process.env.PW_CODEGEN_NO_INSPECTOR)
      return;
    const recorder = await Recorder.forContext(context2, params);
    if (params.recorderMode === "api") {
      const browserName = context2._browser.options.name;
      await ProgrammaticRecorderApp.run(context2, recorder, browserName, params);
      return;
    }
    await _RecorderApp._show(recorder, context2, params);
  }
  async close() {
    await this._page.close();
  }
  static showInspectorNoReply(context2) {
    if (process.env.PW_CODEGEN_NO_INSPECTOR)
      return;
    void Recorder.forContext(context2, {}).then((recorder) => _RecorderApp._show(recorder, context2, {})).catch(() => {
    });
  }
  static async _show(recorder, inspectedContext, params) {
    if (inspectedContext[recorderAppSymbol])
      return;
    inspectedContext[recorderAppSymbol] = true;
    const sdkLanguage = inspectedContext._browser.sdkLanguage();
    const headed = !!inspectedContext._browser.options.headful;
    const recorderPlaywright = require$$06.createPlaywright({ sdkLanguage: "javascript", isInternalPlaywright: true });
    const { context: appContext, page } = await launchApp(recorderPlaywright.chromium, {
      sdkLanguage,
      windowSize: { width: 600, height: 600 },
      windowPosition: { x: 1020, y: 10 },
      persistentContextOptions: {
        noDefaultViewport: true,
        headless: !!process.env.PWTEST_CLI_HEADLESS || isUnderTest() && !headed,
        cdpPort: isUnderTest() ? 0 : void 0,
        handleSIGINT: params.handleSIGINT,
        executablePath: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.customExecutablePath : void 0,
        // Use the same channel as the inspected context to guarantee that the browser is installed.
        channel: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.channel : void 0
      }
    });
    const controller = new ProgressController();
    await controller.run(async (progress3) => {
      await appContext._browser._defaultContext._loadDefaultContextAsIs(progress3);
    });
    const appParams = {
      browserName: inspectedContext._browser.options.name,
      sdkLanguage: inspectedContext._browser.sdkLanguage(),
      wsEndpointForTest: inspectedContext._browser.options.wsEndpoint,
      headed: !!inspectedContext._browser.options.headful,
      executablePath: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.customExecutablePath : void 0,
      channel: inspectedContext._browser.options.isChromium ? inspectedContext._browser.options.channel : void 0,
      ...params
    };
    const recorderApp = new _RecorderApp(recorder, appParams, page, appContext._browser.options.wsEndpoint);
    await recorderApp._init(inspectedContext);
    inspectedContext.recorderAppForTest = recorderApp;
  }
  _wireListeners(recorder) {
    recorder.on(RecorderEvent.ActionAdded, (action) => {
      this._onActionAdded(action);
    });
    recorder.on(RecorderEvent.SignalAdded, (signal) => {
      this._onSignalAdded(signal);
    });
    recorder.on(RecorderEvent.PageNavigated, (url4) => {
      this._onPageNavigated(url4);
    });
    recorder.on(RecorderEvent.ContextClosed, () => {
      this._onContextClosed();
    });
    recorder.on(RecorderEvent.ModeChanged, (mode) => {
      this._onModeChanged(mode);
    });
    recorder.on(RecorderEvent.PausedStateChanged, (paused) => {
      this._onPausedStateChanged(paused);
    });
    recorder.on(RecorderEvent.UserSourcesChanged, (sources, pausedSourceId) => {
      this._onUserSourcesChanged(sources, pausedSourceId);
    });
    recorder.on(RecorderEvent.ElementPicked, (elementInfo, userGesture) => {
      this._onElementPicked(elementInfo, userGesture);
    });
    recorder.on(RecorderEvent.CallLogsUpdated, (callLogs) => {
      this._onCallLogsUpdated(callLogs);
    });
  }
  _onActionAdded(action) {
    this._actions.push(action);
    this._updateActions("reveal");
  }
  _onSignalAdded(signal) {
    const lastAction = this._actions.findLast((a) => a.frame.pageGuid === signal.frame.pageGuid);
    if (lastAction)
      lastAction.action.signals.push(signal.signal);
    this._updateActions();
  }
  _onPageNavigated(url4) {
    this._page.mainFrame().evaluateExpression((({ url: url22 }) => {
      window.playwrightSetPageURL(url22);
    }).toString(), { isFunction: true }, { url: url4 }).catch(() => {
    });
  }
  _onContextClosed() {
    this._throttledOutputFile?.flush();
    this._page.browserContext.close({ reason: "Recorder window closed" }).catch(() => {
    });
  }
  _onModeChanged(mode) {
    this._page.mainFrame().evaluateExpression(((mode2) => {
      window.playwrightSetMode(mode2);
    }).toString(), { isFunction: true }, mode).catch(() => {
    });
  }
  _onPausedStateChanged(paused) {
    this._page.mainFrame().evaluateExpression(((paused2) => {
      window.playwrightSetPaused(paused2);
    }).toString(), { isFunction: true }, paused).catch(() => {
    });
  }
  _onUserSourcesChanged(sources, pausedSourceId) {
    if (!sources.length && !this._userSources.length)
      return;
    this._userSources = sources;
    this._pushAllSources();
    this._revealSource(pausedSourceId);
  }
  _onElementPicked(elementInfo, userGesture) {
    if (userGesture)
      this._page.bringToFront();
    this._page.mainFrame().evaluateExpression(((param) => {
      window.playwrightElementPicked(param.elementInfo, param.userGesture);
    }).toString(), { isFunction: true }, { elementInfo, userGesture }).catch(() => {
    });
  }
  _onCallLogsUpdated(callLogs) {
    this._page.mainFrame().evaluateExpression(((callLogs2) => {
      window.playwrightUpdateLogs(callLogs2);
    }).toString(), { isFunction: true }, callLogs).catch(() => {
    });
  }
  _pushAllSources() {
    const sources = [...this._userSources, ...this._recorderSources];
    this._page.mainFrame().evaluateExpression((({ sources: sources2 }) => {
      window.playwrightSetSources(sources2);
    }).toString(), { isFunction: true }, { sources }).catch(() => {
    });
  }
  _revealSource(sourceId) {
    if (!sourceId)
      return;
    this._page.mainFrame().evaluateExpression((({ sourceId: sourceId2 }) => {
      window.playwrightSelectSource(sourceId2);
    }).toString(), { isFunction: true }, { sourceId }).catch(() => {
    });
  }
  _updateActions(reveal) {
    const recorderSources = [];
    const actions = collapseActions(this._actions);
    let revealSourceId;
    for (const languageGenerator of languageSet()) {
      const { header, footer, actionTexts, text } = generateCode(actions, languageGenerator, this._languageGeneratorOptions);
      const source8 = {
        isRecorded: true,
        label: languageGenerator.name,
        group: languageGenerator.groupName,
        id: languageGenerator.id,
        text,
        header,
        footer,
        actions: actionTexts,
        language: languageGenerator.highlighter,
        highlight: []
      };
      source8.revealLine = text.split("\n").length - 1;
      recorderSources.push(source8);
      if (languageGenerator.id === this._primaryGeneratorId)
        this._throttledOutputFile?.setContent(source8.text);
      if (reveal === "reveal" && source8.id === this._selectedGeneratorId)
        revealSourceId = source8.id;
    }
    this._recorderSources = recorderSources;
    this._pushAllSources();
    this._revealSource(revealSourceId);
  }
};
function determinePrimaryGeneratorId(sdkLanguage) {
  for (const language of languageSet()) {
    if (language.highlighter === sdkLanguage)
      return language.id;
  }
  return sdkLanguage;
}
__name(determinePrimaryGeneratorId, "determinePrimaryGeneratorId");
var ProgrammaticRecorderApp = class {
  static {
    __name(this, "ProgrammaticRecorderApp");
  }
  static async run(inspectedContext, recorder, browserName, params) {
    let lastAction = null;
    const languages = [...languageSet()];
    const languageGeneratorOptions = {
      browserName,
      launchOptions: { headless: false, ...params.launchOptions, tracesDir: void 0 },
      contextOptions: { ...params.contextOptions },
      deviceName: params.device,
      saveStorage: params.saveStorage
    };
    const languageGenerator = languages.find((l) => l.id === params.language) ?? languages.find((l) => l.id === "playwright-test");
    recorder.on(RecorderEvent.ActionAdded, (action) => {
      const page = findPageByGuid(inspectedContext, action.frame.pageGuid);
      if (!page)
        return;
      const { actionTexts } = generateCode([action], languageGenerator, languageGeneratorOptions);
      if (!lastAction || !shouldMergeAction(action, lastAction))
        inspectedContext.emit(BrowserContext.Events.RecorderEvent, { event: "actionAdded", data: action, page, code: actionTexts.join("\n") });
      else
        inspectedContext.emit(BrowserContext.Events.RecorderEvent, { event: "actionUpdated", data: action, page, code: actionTexts.join("\n") });
      lastAction = action;
    });
    recorder.on(RecorderEvent.SignalAdded, (signal) => {
      const page = findPageByGuid(inspectedContext, signal.frame.pageGuid);
      inspectedContext.emit(BrowserContext.Events.RecorderEvent, { event: "signalAdded", data: signal, page, code: "" });
    });
  }
};
function findPageByGuid(context2, guid) {
  return context2.pages().find((p) => p.guid === guid);
}
__name(findPageByGuid, "findPageByGuid");
var recorderAppSymbol = Symbol("recorderApp");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/selectors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Selectors = class {
  static {
    __name(this, "Selectors");
  }
  constructor(engines, testIdAttributeName2) {
    this.guid = `selectors@${createGuid()}`;
    this._builtinEngines = /* @__PURE__ */ new Set([
      "css",
      "css:light",
      "xpath",
      "xpath:light",
      "_react",
      "_vue",
      "text",
      "text:light",
      "id",
      "id:light",
      "data-testid",
      "data-testid:light",
      "data-test-id",
      "data-test-id:light",
      "data-test",
      "data-test:light",
      "nth",
      "visible",
      "internal:control",
      "internal:has",
      "internal:has-not",
      "internal:has-text",
      "internal:has-not-text",
      "internal:and",
      "internal:or",
      "internal:chain",
      "role",
      "internal:attr",
      "internal:label",
      "internal:text",
      "internal:role",
      "internal:testid",
      "internal:describe",
      "aria-ref"
    ]);
    this._builtinEnginesInMainWorld = /* @__PURE__ */ new Set([
      "_react",
      "_vue"
    ]);
    this._engines = /* @__PURE__ */ new Map();
    this._testIdAttributeName = testIdAttributeName2 ?? "data-testid";
    for (const engine of engines)
      this.register(engine);
  }
  register(engine) {
    if (!engine.name.match(/^[a-zA-Z_0-9-]+$/))
      throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
    if (this._builtinEngines.has(engine.name) || engine.name === "zs" || engine.name === "zs:light")
      throw new Error(`"${engine.name}" is a predefined selector engine`);
    if (this._engines.has(engine.name))
      throw new Error(`"${engine.name}" selector engine has been already registered`);
    this._engines.set(engine.name, engine);
  }
  testIdAttributeName() {
    return this._testIdAttributeName;
  }
  setTestIdAttributeName(testIdAttributeName2) {
    this._testIdAttributeName = testIdAttributeName2;
  }
  parseSelector(selector, strict) {
    const parsed = typeof selector === "string" ? parseSelector(selector) : selector;
    let needsMainWorld = false;
    visitAllSelectorParts(parsed, (part) => {
      const name = part.name;
      const custom2 = this._engines.get(name);
      if (!custom2 && !this._builtinEngines.has(name))
        throw new InvalidSelectorError(`Unknown engine "${name}" while parsing selector ${stringifySelector(parsed)}`);
      if (custom2 && !custom2.contentScript)
        needsMainWorld = true;
      if (this._builtinEnginesInMainWorld.has(name))
        needsMainWorld = true;
    });
    return {
      parsed,
      world: needsMainWorld ? "main" : "utility",
      strict
    };
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/trace/recorder/tracing.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs19 from "node:fs";
import os7 from "node:os";
import path13 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/trace/recorder/snapshotter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/trace/recorder/snapshotterInjected.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function frameSnapshotStreamer(snapshotStreamer, removeNoScript) {
  if (window[snapshotStreamer])
    return;
  const kShadowAttribute = "__playwright_shadow_root_";
  const kValueAttribute = "__playwright_value_";
  const kCheckedAttribute = "__playwright_checked_";
  const kSelectedAttribute = "__playwright_selected_";
  const kScrollTopAttribute = "__playwright_scroll_top_";
  const kScrollLeftAttribute = "__playwright_scroll_left_";
  const kStyleSheetAttribute = "__playwright_style_sheet_";
  const kTargetAttribute = "__playwright_target__";
  const kCustomElementsAttribute = "__playwright_custom_elements__";
  const kCurrentSrcAttribute = "__playwright_current_src__";
  const kBoundingRectAttribute = "__playwright_bounding_rect__";
  const kPopoverOpenAttribute = "__playwright_popover_open_";
  const kDialogOpenAttribute = "__playwright_dialog_open_";
  const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
  const kCachedData = Symbol("__playwright_snapshot_cache_");
  const kEndOfList = Symbol("__playwright_end_of_list_");
  function resetCachedData(obj) {
    delete obj[kCachedData];
  }
  __name(resetCachedData, "resetCachedData");
  function ensureCachedData(obj) {
    if (!obj[kCachedData])
      obj[kCachedData] = {};
    return obj[kCachedData];
  }
  __name(ensureCachedData, "ensureCachedData");
  function removeHash(url4) {
    try {
      const u = new URL(url4);
      u.hash = "";
      return u.toString();
    } catch (e) {
      return url4;
    }
  }
  __name(removeHash, "removeHash");
  class Streamer {
    static {
      __name(this, "Streamer");
    }
    constructor() {
      this._lastSnapshotNumber = 0;
      this._staleStyleSheets = /* @__PURE__ */ new Set();
      this._readingStyleSheet = false;
      const invalidateCSSGroupingRule = /* @__PURE__ */ __name((rule) => {
        if (rule.parentStyleSheet)
          this._invalidateStyleSheet(rule.parentStyleSheet);
      }, "invalidateCSSGroupingRule");
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
      this._interceptNativeMethod(window.CSSGroupingRule.prototype, "insertRule", invalidateCSSGroupingRule);
      this._interceptNativeMethod(window.CSSGroupingRule.prototype, "deleteRule", invalidateCSSGroupingRule);
      this._interceptNativeGetter(window.CSSGroupingRule.prototype, "cssRules", invalidateCSSGroupingRule);
      this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
      this._fakeBase = document.createElement("base");
      this._observer = new MutationObserver((list) => this._handleMutations(list));
      const observerConfig = { attributes: true, subtree: true };
      this._observer.observe(document, observerConfig);
      this._refreshListenersWhenNeeded();
    }
    _refreshListenersWhenNeeded() {
      this._refreshListeners();
      const customEventName = "__playwright_snapshotter_global_listeners_check__";
      let seenEvent = false;
      const handleCustomEvent = /* @__PURE__ */ __name(() => seenEvent = true, "handleCustomEvent");
      window.addEventListener(customEventName, handleCustomEvent);
      const observer = new MutationObserver((entries) => {
        const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));
        if (newDocumentElement) {
          seenEvent = false;
          window.dispatchEvent(new CustomEvent(customEventName));
          if (!seenEvent) {
            window.addEventListener(customEventName, handleCustomEvent);
            this._refreshListeners();
          }
        }
      });
      observer.observe(document, { childList: true });
    }
    _refreshListeners() {
      document.addEventListener("__playwright_mark_target__", (event) => {
        if (!event.detail)
          return;
        const callId = event.detail;
        event.composedPath()[0].__playwright_target__ = callId;
      });
      document.addEventListener("__playwright_unmark_target__", (event) => {
        if (!event.detail)
          return;
        const callId = event.detail;
        if (event.composedPath()[0].__playwright_target__ === callId)
          delete event.composedPath()[0].__playwright_target__;
      });
    }
    _interceptNativeMethod(obj, method, cb) {
      const native = obj[method];
      if (!native)
        return;
      obj[method] = function(...args) {
        const result = native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }
    _interceptNativeAsyncMethod(obj, method, cb) {
      const native = obj[method];
      if (!native)
        return;
      obj[method] = async function(...args) {
        const result = await native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }
    _interceptNativeGetter(obj, prop, cb) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      Object.defineProperty(obj, prop, {
        ...descriptor,
        get: /* @__PURE__ */ __name(function() {
          const result = descriptor.get.call(this);
          cb(this, result);
          return result;
        }, "get")
      });
    }
    _handleMutations(list) {
      for (const mutation of list)
        ensureCachedData(mutation.target).attributesCached = void 0;
    }
    _invalidateStyleSheet(sheet) {
      if (this._readingStyleSheet)
        return;
      this._staleStyleSheets.add(sheet);
    }
    _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
      const data = ensureCachedData(sheet);
      if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
        this._staleStyleSheets.delete(sheet);
        try {
          data.cssText = this._getSheetText(sheet);
        } catch (e) {
          data.cssText = "";
        }
      }
      return data.cssText;
    }
    // Returns either content, ref, or no override.
    _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
      const data = ensureCachedData(sheet);
      if (this._staleStyleSheets.has(sheet)) {
        this._staleStyleSheets.delete(sheet);
        try {
          data.cssText = this._getSheetText(sheet);
          data.cssRef = snapshotNumber;
          return data.cssText;
        } catch (e) {
        }
      }
      return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
    }
    markIframe(iframeElement, frameId) {
      iframeElement[kSnapshotFrameId] = frameId;
    }
    reset() {
      this._staleStyleSheets.clear();
      const visitNode = /* @__PURE__ */ __name((node) => {
        resetCachedData(node);
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node;
          if (element.shadowRoot)
            visitNode(element.shadowRoot);
        }
        for (let child = node.firstChild; child; child = child.nextSibling)
          visitNode(child);
      }, "visitNode");
      visitNode(document.documentElement);
      visitNode(this._fakeBase);
    }
    __sanitizeMetaAttribute(name, value, httpEquiv) {
      if (name === "charset")
        return "utf-8";
      if (httpEquiv.toLowerCase() !== "content-type" || name !== "content")
        return value;
      const [type, ...params] = value.split(";");
      if (type !== "text/html" || params.length <= 0)
        return value;
      const charsetParamIdx = params.findIndex((param) => param.trim().startsWith("charset="));
      if (charsetParamIdx > -1)
        params[charsetParamIdx] = "charset=utf-8";
      return `${type}; ${params.join("; ")}`;
    }
    _sanitizeUrl(url4) {
      if (url4.startsWith("javascript:") || url4.startsWith("vbscript:"))
        return "";
      return url4;
    }
    _sanitizeSrcSet(srcset) {
      return srcset.split(",").map((src2) => {
        src2 = src2.trim();
        const spaceIndex = src2.lastIndexOf(" ");
        if (spaceIndex === -1)
          return this._sanitizeUrl(src2);
        return this._sanitizeUrl(src2.substring(0, spaceIndex).trim()) + src2.substring(spaceIndex);
      }).join(", ");
    }
    _resolveUrl(base, url4) {
      if (url4 === "")
        return "";
      try {
        return new URL(url4, base).href;
      } catch (e) {
        return url4;
      }
    }
    _getSheetBase(sheet) {
      let rootSheet = sheet;
      while (rootSheet.parentStyleSheet)
        rootSheet = rootSheet.parentStyleSheet;
      if (rootSheet.ownerNode)
        return rootSheet.ownerNode.baseURI;
      return document.baseURI;
    }
    _getSheetText(sheet) {
      this._readingStyleSheet = true;
      try {
        const rules = [];
        for (const rule of sheet.cssRules)
          rules.push(rule.cssText);
        return rules.join("\n");
      } finally {
        this._readingStyleSheet = false;
      }
    }
    captureSnapshot() {
      const timestamp2 = performance.now();
      const snapshotNumber = ++this._lastSnapshotNumber;
      let nodeCounter = 0;
      let shadowDomNesting = 0;
      let headNesting = 0;
      this._handleMutations(this._observer.takeRecords());
      const definedCustomElements = /* @__PURE__ */ new Set();
      const visitNode = /* @__PURE__ */ __name((node) => {
        const nodeType = node.nodeType;
        const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
        if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
          return;
        if (nodeName === "SCRIPT")
          return;
        if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
          const rel = node.getAttribute("rel")?.toLowerCase();
          if (rel === "preload" || rel === "prefetch")
            return;
        }
        if (removeNoScript && nodeName === "NOSCRIPT")
          return;
        if (nodeName === "META" && node.httpEquiv.toLowerCase() === "content-security-policy")
          return;
        if ((nodeName === "IFRAME" || nodeName === "FRAME") && headNesting)
          return;
        const data = ensureCachedData(node);
        const values = [];
        let equals2 = !!data.cached;
        let extraNodes = 0;
        const expectValue = /* @__PURE__ */ __name((value) => {
          equals2 = equals2 && data.cached[values.length] === value;
          values.push(value);
        }, "expectValue");
        const checkAndReturn = /* @__PURE__ */ __name((n) => {
          data.attributesCached = true;
          if (equals2)
            return { equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]] };
          nodeCounter += extraNodes;
          data.ref = [snapshotNumber, nodeCounter++];
          data.cached = values;
          return { equals: false, n };
        }, "checkAndReturn");
        if (nodeType === Node.TEXT_NODE) {
          const value = node.nodeValue || "";
          expectValue(value);
          return checkAndReturn(value);
        }
        if (nodeName === "STYLE") {
          const sheet = node.sheet;
          let cssText;
          if (sheet)
            cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
          cssText = cssText || node.textContent || "";
          expectValue(cssText);
          extraNodes++;
          return checkAndReturn([nodeName, {}, cssText]);
        }
        const attrs = {};
        const result2 = [nodeName, attrs];
        const visitChild = /* @__PURE__ */ __name((child) => {
          const snapshot = visitNode(child);
          if (snapshot) {
            result2.push(snapshot.n);
            expectValue(child);
            equals2 = equals2 && snapshot.equals;
          }
        }, "visitChild");
        const visitChildStyleSheet = /* @__PURE__ */ __name((child) => {
          const snapshot = visitStyleSheet(child);
          if (snapshot) {
            result2.push(snapshot.n);
            expectValue(child);
            equals2 = equals2 && snapshot.equals;
          }
        }, "visitChildStyleSheet");
        if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
          attrs[kShadowAttribute] = "open";
        if (nodeType === Node.ELEMENT_NODE) {
          const element = node;
          if (element.localName.includes("-") && window.customElements?.get(element.localName))
            definedCustomElements.add(element.localName);
          if (nodeName === "INPUT" || nodeName === "TEXTAREA") {
            const value = element.value;
            expectValue(kValueAttribute);
            expectValue(value);
            attrs[kValueAttribute] = value;
          }
          if (nodeName === "INPUT" && ["checkbox", "radio"].includes(element.type)) {
            const value = element.checked ? "true" : "false";
            expectValue(kCheckedAttribute);
            expectValue(value);
            attrs[kCheckedAttribute] = value;
          }
          if (nodeName === "OPTION") {
            const value = element.selected ? "true" : "false";
            expectValue(kSelectedAttribute);
            expectValue(value);
            attrs[kSelectedAttribute] = value;
          }
          if (nodeName === "CANVAS" || nodeName === "IFRAME" || nodeName === "FRAME") {
            const boundingRect = element.getBoundingClientRect();
            const value = JSON.stringify({
              left: boundingRect.left,
              top: boundingRect.top,
              right: boundingRect.right,
              bottom: boundingRect.bottom
            });
            expectValue(kBoundingRectAttribute);
            expectValue(value);
            attrs[kBoundingRectAttribute] = value;
          }
          if (element.popover && element.matches && element.matches(":popover-open")) {
            const value = "true";
            expectValue(kPopoverOpenAttribute);
            expectValue(value);
            attrs[kPopoverOpenAttribute] = value;
          }
          if (nodeName === "DIALOG" && element.open) {
            const value = element.matches(":modal") ? "modal" : "true";
            expectValue(kDialogOpenAttribute);
            expectValue(value);
            attrs[kDialogOpenAttribute] = value;
          }
          if (element.scrollTop) {
            expectValue(kScrollTopAttribute);
            expectValue(element.scrollTop);
            attrs[kScrollTopAttribute] = "" + element.scrollTop;
          }
          if (element.scrollLeft) {
            expectValue(kScrollLeftAttribute);
            expectValue(element.scrollLeft);
            attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
          }
          if (element.shadowRoot) {
            ++shadowDomNesting;
            visitChild(element.shadowRoot);
            --shadowDomNesting;
          }
          if ("__playwright_target__" in element) {
            expectValue(kTargetAttribute);
            expectValue(element["__playwright_target__"]);
            attrs[kTargetAttribute] = element["__playwright_target__"];
          }
        }
        if (nodeName === "HEAD") {
          ++headNesting;
          this._fakeBase.setAttribute("href", document.baseURI);
          visitChild(this._fakeBase);
        }
        for (let child = node.firstChild; child; child = child.nextSibling)
          visitChild(child);
        if (nodeName === "HEAD")
          --headNesting;
        expectValue(kEndOfList);
        let documentOrShadowRoot = null;
        if (node.ownerDocument.documentElement === node)
          documentOrShadowRoot = node.ownerDocument;
        else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
          documentOrShadowRoot = node;
        if (documentOrShadowRoot) {
          for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
            visitChildStyleSheet(sheet);
          expectValue(kEndOfList);
        }
        if (nodeName === "IFRAME" || nodeName === "FRAME") {
          const element = node;
          const frameId = element[kSnapshotFrameId];
          const name = "src";
          const value = frameId ? `/snapshot/${frameId}` : "";
          expectValue(name);
          expectValue(value);
          attrs[name] = value;
        }
        if (nodeName === "BODY" && definedCustomElements.size) {
          const value = [...definedCustomElements].join(",");
          expectValue(kCustomElementsAttribute);
          expectValue(value);
          attrs[kCustomElementsAttribute] = value;
        }
        if (nodeName === "IMG" || nodeName === "PICTURE") {
          const value = nodeName === "PICTURE" ? "" : this._sanitizeUrl(node.currentSrc);
          expectValue(kCurrentSrcAttribute);
          expectValue(value);
          attrs[kCurrentSrcAttribute] = value;
        }
        if (equals2 && data.attributesCached && !shadowDomNesting)
          return checkAndReturn(result2);
        if (nodeType === Node.ELEMENT_NODE) {
          const element = node;
          for (let i = 0; i < element.attributes.length; i++) {
            const name = element.attributes[i].name;
            if (nodeName === "LINK" && name === "integrity")
              continue;
            if (nodeName === "IFRAME" && (name === "src" || name === "srcdoc" || name === "sandbox"))
              continue;
            if (nodeName === "FRAME" && name === "src")
              continue;
            if (nodeName === "DIALOG" && name === "open")
              continue;
            let value = element.attributes[i].value;
            if (nodeName === "META")
              value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);
            else if (name === "src" && nodeName === "IMG")
              value = this._sanitizeUrl(value);
            else if (name === "srcset" && nodeName === "IMG")
              value = this._sanitizeSrcSet(value);
            else if (name === "srcset" && nodeName === "SOURCE")
              value = this._sanitizeSrcSet(value);
            else if (name === "href" && nodeName === "LINK")
              value = this._sanitizeUrl(value);
            else if (name.startsWith("on"))
              value = "";
            expectValue(name);
            expectValue(value);
            attrs[name] = value;
          }
          expectValue(kEndOfList);
        }
        if (result2.length === 2 && !Object.keys(attrs).length)
          result2.pop();
        return checkAndReturn(result2);
      }, "visitNode");
      const visitStyleSheet = /* @__PURE__ */ __name((sheet) => {
        const data = ensureCachedData(sheet);
        const oldCSSText = data.cssText;
        const cssText = this._updateStyleElementStyleSheetTextIfNeeded(
          sheet,
          true
          /* forceText */
        );
        if (cssText === oldCSSText)
          return { equals: true, n: [[snapshotNumber - data.ref[0], data.ref[1]]] };
        data.ref = [snapshotNumber, nodeCounter++];
        return {
          equals: false,
          n: ["template", {
            [kStyleSheetAttribute]: cssText
          }]
        };
      }, "visitStyleSheet");
      let html;
      if (document.documentElement) {
        const { n } = visitNode(document.documentElement);
        html = n;
      } else {
        html = ["html"];
      }
      const result = {
        html,
        doctype: document.doctype ? document.doctype.name : void 0,
        resourceOverrides: [],
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        url: location.href,
        wallTime: Date.now(),
        collectionTime: 0
      };
      for (const sheet of this._staleStyleSheets) {
        if (sheet.href === null)
          continue;
        const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
        if (content === void 0) {
          continue;
        }
        const base = this._getSheetBase(sheet);
        const url4 = removeHash(this._resolveUrl(base, sheet.href));
        result.resourceOverrides.push({ url: url4, content, contentType: "text/css" });
      }
      result.collectionTime = performance.now() - timestamp2;
      return result;
    }
  }
  window[snapshotStreamer] = new Streamer();
}
__name(frameSnapshotStreamer, "frameSnapshotStreamer");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/trace/recorder/snapshotter.js
var Snapshotter = class {
  static {
    __name(this, "Snapshotter");
  }
  constructor(context2, delegate) {
    this._eventListeners = [];
    this._started = false;
    this._context = context2;
    this._delegate = delegate;
    const guid = createGuid();
    this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
  }
  started() {
    return this._started;
  }
  async start() {
    this._started = true;
    if (!this._initScript)
      await this._initialize();
    await this.reset();
  }
  async reset() {
    if (this._started)
      await this._context.safeNonStallingEvaluateInAllFrames(`window["${this._snapshotStreamer}"].reset()`, "main");
  }
  stop() {
    this._started = false;
  }
  async resetForReuse() {
    if (this._initScript) {
      eventsHelper.removeEventListeners(this._eventListeners);
      await this._context.removeInitScripts([this._initScript]);
      this._initScript = void 0;
    }
  }
  async _initialize() {
    for (const page of this._context.pages())
      this._onPage(page);
    this._eventListeners = [
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, this._onPage.bind(this))
    ];
    const { javaScriptEnabled } = this._context._options;
    const initScript = `((__name => (${frameSnapshotStreamer}))(t => t))`;
    const initScriptSource = `(${initScript})("${this._snapshotStreamer}", ${javaScriptEnabled || javaScriptEnabled === void 0})`;
    this._initScript = await this._context.addInitScript(void 0, initScriptSource);
    await this._context.safeNonStallingEvaluateInAllFrames(initScriptSource, "main");
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  async captureSnapshot(page, callId, snapshotName) {
    const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
    const snapshots = page.frames().map(async (frame) => {
      const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => debugLogger.log("error", e));
      if (!data || !this._started)
        return;
      const snapshot = {
        callId,
        snapshotName,
        pageId: page.guid,
        frameId: frame.guid,
        frameUrl: data.url,
        doctype: data.doctype,
        html: data.html,
        viewport: data.viewport,
        timestamp: monotonicTime(),
        wallTime: data.wallTime,
        collectionTime: data.collectionTime,
        resourceOverrides: [],
        isMainFrame: page.mainFrame() === frame
      };
      for (const { url: url4, content, contentType } of data.resourceOverrides) {
        if (typeof content === "string") {
          const buffer = Buffer.from(content);
          const sha1 = calculateSha1(buffer) + "." + (mime2.getExtension(contentType) || "dat");
          this._delegate.onSnapshotterBlob({ sha1, buffer });
          snapshot.resourceOverrides.push({ url: url4, sha1 });
        } else {
          snapshot.resourceOverrides.push({ url: url4, ref: content });
        }
      }
      this._delegate.onFrameSnapshot(snapshot);
    });
    await Promise.all(snapshots);
  }
  _onPage(page) {
    for (const frame of page.frames())
      this._annotateFrameHierarchy(frame);
    this._eventListeners.push(eventsHelper.addEventListener(page, Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
  }
  async _annotateFrameHierarchy(frame) {
    try {
      const frameElement = await frame.frameElement();
      const parent = frame.parentFrame();
      if (!parent)
        return;
      const context2 = await parent._mainContext();
      await context2?.evaluate(({ snapshotStreamer, frameElement: frameElement2, frameId }) => {
        window[snapshotStreamer].markIframe(frameElement2, frameId);
      }, { snapshotStreamer: this._snapshotStreamer, frameElement, frameId: frame.guid });
      frameElement.dispose();
    } catch (e) {
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/trace/recorder/tracing.js
var version4 = 8;
var kScreencastOptions = { width: 800, height: 600, quality: 90 };
var Tracing = class extends SdkObject {
  static {
    __name(this, "Tracing");
  }
  constructor(context2, tracesDir) {
    super(context2, "tracing");
    this._fs = new SerializedFS();
    this._screencastListeners = [];
    this._eventListeners = [];
    this._isStopping = false;
    this._allResources = /* @__PURE__ */ new Set();
    this._pendingHarEntries = /* @__PURE__ */ new Set();
    this._context = context2;
    this._precreatedTracesDir = tracesDir;
    this._harTracer = new HarTracer(context2, null, this, {
      content: "attach",
      includeTraceInfo: true,
      recordRequestOverrides: false,
      waitForContentOnStop: false
    });
    const testIdAttributeName2 = "selectors" in context2 ? context2.selectors().testIdAttributeName() : void 0;
    this._contextCreatedEvent = {
      version: version4,
      type: "context-options",
      origin: "library",
      browserName: "",
      options: {},
      platform: process.platform,
      wallTime: 0,
      monotonicTime: 0,
      sdkLanguage: this._sdkLanguage(),
      testIdAttributeName: testIdAttributeName2,
      contextId: context2.guid
    };
    if (context2 instanceof BrowserContext) {
      this._snapshotter = new Snapshotter(context2, this);
      assert3(tracesDir, "tracesDir must be specified for BrowserContext");
      this._contextCreatedEvent.browserName = context2._browser.options.name;
      this._contextCreatedEvent.channel = context2._browser.options.channel;
      this._contextCreatedEvent.options = context2._options;
    }
  }
  _sdkLanguage() {
    return this._context instanceof BrowserContext ? this._context._browser.sdkLanguage() : this._context.attribution.playwright.options.sdkLanguage;
  }
  async resetForReuse(progress3) {
    await this.stopChunk(progress3, { mode: "discard" }).catch(() => {
    });
    await this.stop(progress3);
    if (this._snapshotter)
      await progress3.race(this._snapshotter.resetForReuse());
  }
  start(options2) {
    if (this._isStopping)
      throw new Error("Cannot start tracing while stopping");
    if (this._state)
      throw new Error("Tracing has been already started");
    this._contextCreatedEvent.sdkLanguage = this._sdkLanguage();
    const traceName = options2.name || createGuid();
    const tracesDir = this._createTracesDirIfNeeded();
    this._state = {
      options: options2,
      traceName,
      tracesDir,
      traceFile: path13.join(tracesDir, traceName + ".trace"),
      networkFile: path13.join(tracesDir, traceName + ".network"),
      resourcesDir: path13.join(tracesDir, "resources"),
      chunkOrdinal: 0,
      traceSha1s: /* @__PURE__ */ new Set(),
      networkSha1s: /* @__PURE__ */ new Set(),
      recording: false,
      callIds: /* @__PURE__ */ new Set(),
      groupStack: []
    };
    this._fs.mkdir(this._state.resourcesDir);
    this._fs.writeFile(this._state.networkFile, "");
    if (options2.snapshots)
      this._harTracer.start({ omitScripts: !options2.live });
  }
  async startChunk(progress3, options2 = {}) {
    if (this._state && this._state.recording)
      await this.stopChunk(progress3, { mode: "discard" });
    if (!this._state)
      throw new Error("Must start tracing before starting a new chunk");
    if (this._isStopping)
      throw new Error("Cannot start a trace chunk while stopping");
    this._state.recording = true;
    this._state.callIds.clear();
    const preserveNetworkResources = this._context instanceof BrowserContext;
    if (options2.name && options2.name !== this._state.traceName)
      this._changeTraceName(this._state, options2.name, preserveNetworkResources);
    else
      this._allocateNewTraceFile(this._state);
    if (!preserveNetworkResources)
      this._fs.writeFile(this._state.networkFile, "");
    this._fs.mkdir(path13.dirname(this._state.traceFile));
    const event = {
      ...this._contextCreatedEvent,
      title: options2.title,
      wallTime: Date.now(),
      monotonicTime: monotonicTime()
    };
    this._appendTraceEvent(event);
    this._context.instrumentation.addListener(this, this._context);
    this._eventListeners.push(
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Console, this._onConsoleMessage.bind(this)),
      eventsHelper.addEventListener(this._context, BrowserContext.Events.PageError, this._onPageError.bind(this))
    );
    if (this._state.options.screenshots)
      this._startScreencast();
    if (this._state.options.snapshots)
      await this._snapshotter?.start();
    return { traceName: this._state.traceName };
  }
  _currentGroupId() {
    return this._state?.groupStack.length ? this._state.groupStack[this._state.groupStack.length - 1] : void 0;
  }
  group(name, location2, metadata) {
    if (!this._state)
      return;
    const stackFrames = [];
    const { file, line, column } = location2 ?? metadata.location ?? {};
    if (file) {
      stackFrames.push({
        file,
        line: line ?? 0,
        column: column ?? 0
      });
    }
    const event = {
      type: "before",
      callId: metadata.id,
      startTime: metadata.startTime,
      title: name,
      class: "Tracing",
      method: "tracingGroup",
      params: {},
      stepId: metadata.stepId,
      stack: stackFrames
    };
    if (this._currentGroupId())
      event.parentId = this._currentGroupId();
    this._state.groupStack.push(event.callId);
    this._appendTraceEvent(event);
  }
  groupEnd() {
    if (!this._state)
      return;
    const callId = this._state.groupStack.pop();
    if (!callId)
      return;
    const event = {
      type: "after",
      callId,
      endTime: monotonicTime()
    };
    this._appendTraceEvent(event);
  }
  _startScreencast() {
    if (!(this._context instanceof BrowserContext))
      return;
    for (const page of this._context.pages())
      this._startScreencastInPage(page);
    this._screencastListeners.push(
      eventsHelper.addEventListener(this._context, BrowserContext.Events.Page, this._startScreencastInPage.bind(this))
    );
  }
  _stopScreencast() {
    eventsHelper.removeEventListeners(this._screencastListeners);
    if (!(this._context instanceof BrowserContext))
      return;
    for (const page of this._context.pages())
      page.setScreencastOptions(null);
  }
  _allocateNewTraceFile(state) {
    const suffix = state.chunkOrdinal ? `-chunk${state.chunkOrdinal}` : ``;
    state.chunkOrdinal++;
    state.traceFile = path13.join(state.tracesDir, `${state.traceName}${suffix}.trace`);
  }
  _changeTraceName(state, name, preserveNetworkResources) {
    state.traceName = name;
    state.chunkOrdinal = 0;
    this._allocateNewTraceFile(state);
    const newNetworkFile = path13.join(state.tracesDir, name + ".network");
    if (preserveNetworkResources)
      this._fs.copyFile(state.networkFile, newNetworkFile);
    state.networkFile = newNetworkFile;
  }
  async stop(progress3) {
    if (!this._state)
      return;
    if (this._isStopping)
      throw new Error(`Tracing is already stopping`);
    if (this._state.recording)
      throw new Error(`Must stop trace file before stopping tracing`);
    this._closeAllGroups();
    this._harTracer.stop();
    this.flushHarEntries();
    const promise = progress3 ? progress3.race(this._fs.syncAndGetError()) : this._fs.syncAndGetError();
    await promise.finally(() => {
      this._state = void 0;
    });
  }
  async deleteTmpTracesDir() {
    if (this._tracesTmpDir)
      await removeFolders([this._tracesTmpDir]);
  }
  _createTracesDirIfNeeded() {
    if (this._precreatedTracesDir)
      return this._precreatedTracesDir;
    this._tracesTmpDir = fs19.mkdtempSync(path13.join(os7.tmpdir(), "playwright-tracing-"));
    return this._tracesTmpDir;
  }
  abort() {
    this._snapshotter?.dispose();
    this._harTracer.stop();
  }
  async flush() {
    this.abort();
    await this._fs.syncAndGetError();
  }
  _closeAllGroups() {
    while (this._currentGroupId())
      this.groupEnd();
  }
  async stopChunk(progress3, params) {
    if (this._isStopping)
      throw new Error(`Tracing is already stopping`);
    this._isStopping = true;
    if (!this._state || !this._state.recording) {
      this._isStopping = false;
      if (params.mode !== "discard")
        throw new Error(`Must start tracing before stopping`);
      return {};
    }
    this._closeAllGroups();
    this._context.instrumentation.removeListener(this);
    eventsHelper.removeEventListeners(this._eventListeners);
    if (this._state.options.screenshots)
      this._stopScreencast();
    if (this._state.options.snapshots)
      this._snapshotter?.stop();
    this.flushHarEntries();
    const newNetworkFile = path13.join(this._state.tracesDir, this._state.traceName + `-pwnetcopy-${this._state.chunkOrdinal}.network`);
    const entries = [];
    entries.push({ name: "trace.trace", value: this._state.traceFile });
    entries.push({ name: "trace.network", value: newNetworkFile });
    for (const sha1 of /* @__PURE__ */ new Set([...this._state.traceSha1s, ...this._state.networkSha1s]))
      entries.push({ name: path13.join("resources", sha1), value: path13.join(this._state.resourcesDir, sha1) });
    this._state.traceSha1s = /* @__PURE__ */ new Set();
    if (params.mode === "discard") {
      this._isStopping = false;
      this._state.recording = false;
      return {};
    }
    this._fs.copyFile(this._state.networkFile, newNetworkFile);
    const zipFileName = this._state.traceFile + ".zip";
    if (params.mode === "archive")
      this._fs.zip(entries, zipFileName);
    const promise = progress3 ? progress3.race(this._fs.syncAndGetError()) : this._fs.syncAndGetError();
    const error3 = await promise.catch((e) => e);
    this._isStopping = false;
    if (this._state)
      this._state.recording = false;
    if (error3) {
      if (!isAbortError(error3) && this._context instanceof BrowserContext && !this._context._browser.isConnected())
        return {};
      throw error3;
    }
    if (params.mode === "entries")
      return { entries };
    const artifact = new Artifact(this._context, zipFileName);
    artifact.reportFinished();
    return { artifact };
  }
  async _captureSnapshot(snapshotName, sdkObject, metadata) {
    if (!this._snapshotter)
      return;
    if (!sdkObject.attribution.page)
      return;
    if (!this._snapshotter.started())
      return;
    if (!shouldCaptureSnapshot(metadata))
      return;
    await this._snapshotter.captureSnapshot(sdkObject.attribution.page, metadata.id, snapshotName).catch(() => {
    });
  }
  onBeforeCall(sdkObject, metadata) {
    const event = createBeforeActionTraceEvent(metadata, this._currentGroupId());
    if (!event)
      return Promise.resolve();
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.beforeSnapshot = `before@${metadata.id}`;
    this._state?.callIds.add(metadata.id);
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.beforeSnapshot, sdkObject, metadata);
  }
  onBeforeInputAction(sdkObject, metadata) {
    if (!this._state?.callIds.has(metadata.id))
      return Promise.resolve();
    const event = createInputActionTraceEvent(metadata);
    if (!event)
      return Promise.resolve();
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.inputSnapshot = `input@${metadata.id}`;
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.inputSnapshot, sdkObject, metadata);
  }
  onCallLog(sdkObject, metadata, logName, message) {
    if (!this._state?.callIds.has(metadata.id))
      return;
    if (metadata.internal)
      return;
    if (logName !== "api")
      return;
    const event = createActionLogTraceEvent(metadata, message);
    if (event)
      this._appendTraceEvent(event);
  }
  async onAfterCall(sdkObject, metadata) {
    if (!this._state?.callIds.has(metadata.id))
      return;
    this._state?.callIds.delete(metadata.id);
    const event = createAfterActionTraceEvent(metadata);
    if (!event)
      return;
    sdkObject.attribution.page?.temporarilyDisableTracingScreencastThrottling();
    event.afterSnapshot = `after@${metadata.id}`;
    this._appendTraceEvent(event);
    return this._captureSnapshot(event.afterSnapshot, sdkObject, metadata);
  }
  onEntryStarted(entry) {
    this._pendingHarEntries.add(entry);
  }
  onEntryFinished(entry) {
    this._pendingHarEntries.delete(entry);
    const event = { type: "resource-snapshot", snapshot: entry };
    const visited = visitTraceEvent(event, this._state.networkSha1s);
    this._fs.appendFile(
      this._state.networkFile,
      JSON.stringify(visited) + "\n",
      true
      /* flush */
    );
  }
  flushHarEntries() {
    const harLines = [];
    for (const entry of this._pendingHarEntries) {
      const event = { type: "resource-snapshot", snapshot: entry };
      const visited = visitTraceEvent(event, this._state.networkSha1s);
      harLines.push(JSON.stringify(visited));
    }
    this._pendingHarEntries.clear();
    if (harLines.length)
      this._fs.appendFile(
        this._state.networkFile,
        harLines.join("\n") + "\n",
        true
        /* flush */
      );
  }
  onContentBlob(sha1, buffer) {
    this._appendResource(sha1, buffer);
  }
  onSnapshotterBlob(blob) {
    this._appendResource(blob.sha1, blob.buffer);
  }
  onFrameSnapshot(snapshot) {
    this._appendTraceEvent({ type: "frame-snapshot", snapshot });
  }
  _onConsoleMessage(message) {
    const event = {
      type: "console",
      messageType: message.type(),
      text: message.text(),
      args: message.args().map((a) => ({ preview: a.toString(), value: a.rawValue() })),
      location: message.location(),
      time: monotonicTime(),
      pageId: message.page()?.guid
    };
    this._appendTraceEvent(event);
  }
  onDialog(dialog) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "dialog",
      params: { pageId: dialog.page().guid, type: dialog.type(), message: dialog.message(), defaultValue: dialog.defaultValue() }
    };
    this._appendTraceEvent(event);
  }
  onDownload(page, download) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "download",
      params: { pageId: page.guid, url: download.url, suggestedFilename: download.suggestedFilename() }
    };
    this._appendTraceEvent(event);
  }
  onPageOpen(page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "page",
      params: { pageId: page.guid, openerPageId: page.opener()?.guid }
    };
    this._appendTraceEvent(event);
  }
  onPageClose(page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "pageClosed",
      params: { pageId: page.guid }
    };
    this._appendTraceEvent(event);
  }
  _onPageError(error3, page) {
    const event = {
      type: "event",
      time: monotonicTime(),
      class: "BrowserContext",
      method: "pageError",
      params: { error: serializeError(error3) },
      pageId: page.guid
    };
    this._appendTraceEvent(event);
  }
  _startScreencastInPage(page) {
    page.setScreencastOptions(kScreencastOptions);
    const prefix = page.guid;
    this._screencastListeners.push(
      eventsHelper.addEventListener(page, Page.Events.ScreencastFrame, (params) => {
        const suffix = params.timestamp || Date.now();
        const sha1 = `${prefix}-${suffix}.jpeg`;
        const event = {
          type: "screencast-frame",
          pageId: page.guid,
          sha1,
          width: params.width,
          height: params.height,
          timestamp: monotonicTime(),
          frameSwapWallTime: params.frameSwapWallTime
        };
        this._appendResource(sha1, params.buffer);
        this._appendTraceEvent(event);
      })
    );
  }
  _appendTraceEvent(event) {
    const visited = visitTraceEvent(event, this._state.traceSha1s);
    const flush = this._state.options.live || event.type !== "event" && event.type !== "console" && event.type !== "log";
    this._fs.appendFile(this._state.traceFile, JSON.stringify(visited) + "\n", flush);
  }
  _appendResource(sha1, buffer) {
    if (this._allResources.has(sha1))
      return;
    this._allResources.add(sha1);
    const resourcePath = path13.join(this._state.resourcesDir, sha1);
    this._fs.writeFile(
      resourcePath,
      buffer,
      true
      /* skipIfExists */
    );
  }
};
function visitTraceEvent(object, sha1s) {
  if (Array.isArray(object))
    return object.map((o) => visitTraceEvent(o, sha1s));
  if (object instanceof Dispatcher)
    return `<${object._type}>`;
  if (object instanceof Buffer)
    return `<Buffer>`;
  if (object instanceof Date)
    return object;
  if (typeof object === "object") {
    const result = {};
    for (const key in object) {
      if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
        const sha1 = object[key];
        if (sha1)
          sha1s.add(sha1);
      }
      result[key] = visitTraceEvent(object[key], sha1s);
    }
    return result;
  }
  return object;
}
__name(visitTraceEvent, "visitTraceEvent");
function shouldCaptureSnapshot(metadata) {
  const metainfo = methodMetainfo.get(metadata.type + "." + metadata.method);
  return !!metainfo?.snapshot;
}
__name(shouldCaptureSnapshot, "shouldCaptureSnapshot");
function createBeforeActionTraceEvent(metadata, parentId) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  const event = {
    type: "before",
    callId: metadata.id,
    startTime: metadata.startTime,
    title: metadata.title,
    class: metadata.type,
    method: metadata.method,
    params: metadata.params,
    stepId: metadata.stepId,
    pageId: metadata.pageId
  };
  if (parentId)
    event.parentId = parentId;
  return event;
}
__name(createBeforeActionTraceEvent, "createBeforeActionTraceEvent");
function createInputActionTraceEvent(metadata) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "input",
    callId: metadata.id,
    point: metadata.point
  };
}
__name(createInputActionTraceEvent, "createInputActionTraceEvent");
function createActionLogTraceEvent(metadata, message) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "log",
    callId: metadata.id,
    time: monotonicTime(),
    message
  };
}
__name(createActionLogTraceEvent, "createActionLogTraceEvent");
function createAfterActionTraceEvent(metadata) {
  if (metadata.internal || metadata.method.startsWith("tracing"))
    return null;
  return {
    type: "after",
    callId: metadata.id,
    endTime: metadata.endTime,
    error: metadata.error?.error,
    result: metadata.result,
    point: metadata.point
  };
}
__name(createAfterActionTraceEvent, "createAfterActionTraceEvent");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/storageScriptSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source6 = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/storageScript.ts\nvar storageScript_exports = {};\n__export(storageScript_exports, {\n  StorageScript: () => StorageScript\n});\nmodule.exports = __toCommonJS(storageScript_exports);\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a;\n  try {\n    return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++)\n    bytes[i] = binary.charCodeAt(i);\n  return new TypedArrayConstructor(bytes.buffer);\n}\nfunction parseEvaluationResultValue(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("ref" in value)\n      return refs.get(value.ref);\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value) {\n      return new Date(value.d);\n    }\n    if ("u" in value)\n      return new URL(value.u);\n    if ("bi" in value)\n      return BigInt(value.bi);\n    if ("e" in value) {\n      const error = new Error(value.e.m);\n      error.name = value.e.n;\n      error.stack = value.e.s;\n      return error;\n    }\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value) {\n      const result = [];\n      refs.set(value.id, result);\n      for (const a of value.a)\n        result.push(parseEvaluationResultValue(a, handles, refs));\n      return result;\n    }\n    if ("o" in value) {\n      const result = {};\n      refs.set(value.id, result);\n      for (const { k, v } of value.o) {\n        if (k === "__proto__")\n          continue;\n        result[k] = parseEvaluationResultValue(v, handles, refs);\n      }\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n    if ("ta" in value)\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a = value.stack) == null ? void 0 : _a.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/storageScript.ts\nvar StorageScript = class {\n  constructor(isFirefox) {\n    this._isFirefox = isFirefox;\n    this._global = globalThis;\n  }\n  _idbRequestToPromise(request) {\n    return new Promise((resolve, reject) => {\n      request.addEventListener("success", () => resolve(request.result));\n      request.addEventListener("error", () => reject(request.error));\n    });\n  }\n  _isPlainObject(v) {\n    const ctor = v == null ? void 0 : v.constructor;\n    if (this._isFirefox) {\n      const constructorImpl = ctor == null ? void 0 : ctor.toString();\n      if ((constructorImpl == null ? void 0 : constructorImpl.startsWith("function Object() {")) && (constructorImpl == null ? void 0 : constructorImpl.includes("[native code]")))\n        return true;\n    }\n    return ctor === Object;\n  }\n  _trySerialize(value) {\n    let trivial = true;\n    const encoded = serializeAsCallArgument(value, (v) => {\n      const isTrivial = this._isPlainObject(v) || Array.isArray(v) || typeof v === "string" || typeof v === "number" || typeof v === "boolean" || Object.is(v, null);\n      if (!isTrivial)\n        trivial = false;\n      return { fallThrough: v };\n    });\n    if (trivial)\n      return { trivial: value };\n    return { encoded };\n  }\n  async _collectDB(dbInfo) {\n    if (!dbInfo.name)\n      throw new Error("Database name is empty");\n    if (!dbInfo.version)\n      throw new Error("Database version is unset");\n    const db = await this._idbRequestToPromise(indexedDB.open(dbInfo.name));\n    if (db.objectStoreNames.length === 0)\n      return { name: dbInfo.name, version: dbInfo.version, stores: [] };\n    const transaction = db.transaction(db.objectStoreNames, "readonly");\n    const stores = await Promise.all([...db.objectStoreNames].map(async (storeName) => {\n      const objectStore = transaction.objectStore(storeName);\n      const keys = await this._idbRequestToPromise(objectStore.getAllKeys());\n      const records = await Promise.all(keys.map(async (key) => {\n        const record = {};\n        if (objectStore.keyPath === null) {\n          const { encoded: encoded2, trivial: trivial2 } = this._trySerialize(key);\n          if (trivial2)\n            record.key = trivial2;\n          else\n            record.keyEncoded = encoded2;\n        }\n        const value = await this._idbRequestToPromise(objectStore.get(key));\n        const { encoded, trivial } = this._trySerialize(value);\n        if (trivial)\n          record.value = trivial;\n        else\n          record.valueEncoded = encoded;\n        return record;\n      }));\n      const indexes = [...objectStore.indexNames].map((indexName) => {\n        const index = objectStore.index(indexName);\n        return {\n          name: index.name,\n          keyPath: typeof index.keyPath === "string" ? index.keyPath : void 0,\n          keyPathArray: Array.isArray(index.keyPath) ? index.keyPath : void 0,\n          multiEntry: index.multiEntry,\n          unique: index.unique\n        };\n      });\n      return {\n        name: storeName,\n        records,\n        indexes,\n        autoIncrement: objectStore.autoIncrement,\n        keyPath: typeof objectStore.keyPath === "string" ? objectStore.keyPath : void 0,\n        keyPathArray: Array.isArray(objectStore.keyPath) ? objectStore.keyPath : void 0\n      };\n    }));\n    return {\n      name: dbInfo.name,\n      version: dbInfo.version,\n      stores\n    };\n  }\n  async collect(recordIndexedDB) {\n    const localStorage = Object.keys(this._global.localStorage).map((name) => ({ name, value: this._global.localStorage.getItem(name) }));\n    if (!recordIndexedDB)\n      return { localStorage };\n    try {\n      const databases = await this._global.indexedDB.databases();\n      const indexedDB2 = await Promise.all(databases.map((db) => this._collectDB(db)));\n      return { localStorage, indexedDB: indexedDB2 };\n    } catch (e) {\n      throw new Error("Unable to serialize IndexedDB: " + e.message);\n    }\n  }\n  async _restoreDB(dbInfo) {\n    const openRequest = this._global.indexedDB.open(dbInfo.name, dbInfo.version);\n    openRequest.addEventListener("upgradeneeded", () => {\n      var _a, _b;\n      const db2 = openRequest.result;\n      for (const store of dbInfo.stores) {\n        const objectStore = db2.createObjectStore(store.name, { autoIncrement: store.autoIncrement, keyPath: (_a = store.keyPathArray) != null ? _a : store.keyPath });\n        for (const index of store.indexes)\n          objectStore.createIndex(index.name, (_b = index.keyPathArray) != null ? _b : index.keyPath, { unique: index.unique, multiEntry: index.multiEntry });\n      }\n    });\n    const db = await this._idbRequestToPromise(openRequest);\n    if (db.objectStoreNames.length === 0)\n      return;\n    const transaction = db.transaction(db.objectStoreNames, "readwrite");\n    await Promise.all(dbInfo.stores.map(async (store) => {\n      const objectStore = transaction.objectStore(store.name);\n      await Promise.all(store.records.map(async (record) => {\n        var _a, _b;\n        await this._idbRequestToPromise(\n          objectStore.add(\n            (_a = record.value) != null ? _a : parseEvaluationResultValue(record.valueEncoded),\n            (_b = record.key) != null ? _b : parseEvaluationResultValue(record.keyEncoded)\n          )\n        );\n      }));\n    }));\n  }\n  async restore(originState) {\n    var _a, _b, _c;\n    const registrations = this._global.navigator.serviceWorker ? await this._global.navigator.serviceWorker.getRegistrations() : [];\n    await Promise.all(registrations.map(async (r) => {\n      if (!r.installing && !r.waiting && !r.active)\n        r.unregister().catch(() => {\n        });\n      else\n        await r.unregister().catch(() => {\n        });\n    }));\n    try {\n      for (const db of await ((_b = (_a = this._global.indexedDB).databases) == null ? void 0 : _b.call(_a)) || []) {\n        if (db.name)\n          this._global.indexedDB.deleteDatabase(db.name);\n      }\n      await Promise.all(((_c = originState == null ? void 0 : originState.indexedDB) != null ? _c : []).map((dbInfo) => this._restoreDB(dbInfo)));\n    } catch (e) {\n      throw new Error("Unable to restore IndexedDB: " + e.message);\n    }\n    this._global.sessionStorage.clear();\n    this._global.localStorage.clear();\n    for (const { name, value } of (originState == null ? void 0 : originState.localStorage) || [])\n      this._global.localStorage.setItem(name, value);\n  }\n};\n';

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browserContext.js
var BrowserContext = class _BrowserContext extends SdkObject {
  static {
    __name(this, "BrowserContext");
  }
  constructor(browser3, options2, browserContextId) {
    super(browser3, "browser-context");
    this._pageBindings = /* @__PURE__ */ new Map();
    this.requestInterceptors = [];
    this._closedStatus = "open";
    this._permissions = /* @__PURE__ */ new Map();
    this._downloads = /* @__PURE__ */ new Set();
    this._origins = /* @__PURE__ */ new Set();
    this._harRecorders = /* @__PURE__ */ new Map();
    this._tempDirs = [];
    this._creatingStorageStatePage = false;
    this.initScripts = [];
    this._routesInFlight = /* @__PURE__ */ new Set();
    this._playwrightBindingExposed = false;
    this.attribution.context = this;
    this._browser = browser3;
    this._options = options2;
    this._browserContextId = browserContextId;
    this._isPersistentContext = !browserContextId;
    this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
    this._selectors = new Selectors(options2.selectorEngines || [], options2.testIdAttributeName);
    this.fetchRequest = new BrowserContextAPIRequestContext(this);
    this.tracing = new Tracing(this, browser3.options.tracesDir);
    this.clock = new Clock(this);
    this.dialogManager = new DialogManager(this.instrumentation);
  }
  static {
    this.Events = {
      Console: "console",
      Close: "close",
      Page: "page",
      // Can't use just 'error' due to node.js special treatment of error events.
      // @see https://nodejs.org/api/events.html#events_error_events
      PageError: "pageerror",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      RequestAborted: "requestaborted",
      RequestFulfilled: "requestfulfilled",
      RequestContinued: "requestcontinued",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted",
      RecorderEvent: "recorderevent"
    };
  }
  isPersistentContext() {
    return this._isPersistentContext;
  }
  selectors() {
    return this._selectors;
  }
  async _initialize() {
    if (this.attribution.playwright.options.isInternalPlaywright)
      return;
    this._debugger = new Debugger(this);
    if (debugMode() === "inspector")
      await RecorderApp.show(this, { pauseOnNextStatement: true });
    if (this._debugger.isPaused())
      RecorderApp.showInspectorNoReply(this);
    this._debugger.on(Debugger.Events.PausedStateChanged, () => {
      if (this._debugger.isPaused())
        RecorderApp.showInspectorNoReply(this);
    });
    if (debugMode() === "console") {
      await this.extendInjectedScript(`
        function installConsoleApi(injectedScript) { injectedScript.consoleApi.install(); }
        module.exports = { default: () => installConsoleApi };
      `);
    }
    if (this._options.serviceWorkers === "block")
      await this.addInitScript(void 0, `
if (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };
`);
    if (this._options.permissions)
      await this.grantPermissions(this._options.permissions);
  }
  debugger() {
    return this._debugger;
  }
  async _ensureVideosPath() {
    if (this._options.recordVideo)
      await mkdirIfNeeded(path14.join(this._options.recordVideo.dir, "dummy"));
  }
  canResetForReuse() {
    if (this._closedStatus !== "open")
      return false;
    return true;
  }
  static reusableContextHash(params) {
    const paramsCopy = { ...params };
    if (paramsCopy.selectorEngines?.length === 0)
      delete paramsCopy.selectorEngines;
    for (const k of Object.keys(paramsCopy)) {
      const key = k;
      if (paramsCopy[key] === defaultNewContextParamValues[key])
        delete paramsCopy[key];
    }
    for (const key of paramsThatAllowContextReuse)
      delete paramsCopy[key];
    return JSON.stringify(paramsCopy);
  }
  async resetForReuse(progress3, params) {
    await this.tracing.resetForReuse(progress3);
    if (params) {
      for (const key of paramsThatAllowContextReuse)
        this._options[key] = params[key];
      if (params.testIdAttributeName)
        this.selectors().setTestIdAttributeName(params.testIdAttributeName);
    }
    let page = this.pages()[0];
    const otherPages = this.possiblyUninitializedPages().filter((p) => p !== page);
    for (const p of otherPages)
      await p.close();
    if (page && page.hasCrashed()) {
      await page.close();
      page = void 0;
    }
    await page?.mainFrame().gotoImpl(progress3, "about:blank", {});
    await this.clock.uninstall(progress3);
    await progress3.race(this.setUserAgent(this._options.userAgent));
    await progress3.race(this.doUpdateDefaultEmulatedMedia());
    await progress3.race(this.doUpdateDefaultViewport());
    await this.setStorageState(progress3, this._options.storageState, "resetForReuse");
    await page?.resetForReuse(progress3);
  }
  _browserClosed() {
    for (const page of this.pages())
      page._didClose();
    this._didCloseInternal();
  }
  _didCloseInternal() {
    if (this._closedStatus === "closed") {
      return;
    }
    this._clientCertificatesProxy?.close().catch(() => {
    });
    this.tracing.abort();
    if (this._isPersistentContext)
      this.onClosePersistent();
    this._closePromiseFulfill(new Error("Context closed"));
    this.emit(_BrowserContext.Events.Close);
  }
  pages() {
    return this.possiblyUninitializedPages().filter((page) => page.initializedOrUndefined());
  }
  async cookies(urls = []) {
    if (urls && !Array.isArray(urls))
      urls = [urls];
    return await this.doGetCookies(urls);
  }
  async clearCookies(options2) {
    const currentCookies = await this.cookies();
    await this.doClearCookies();
    const matches = /* @__PURE__ */ __name((cookie, prop, value) => {
      if (!value)
        return true;
      if (value instanceof RegExp) {
        value.lastIndex = 0;
        return value.test(cookie[prop]);
      }
      return cookie[prop] === value;
    }, "matches");
    const cookiesToReadd = currentCookies.filter((cookie) => {
      return !matches(cookie, "name", options2.name) || !matches(cookie, "domain", options2.domain) || !matches(cookie, "path", options2.path);
    });
    await this.addCookies(cookiesToReadd);
  }
  setHTTPCredentials(httpCredentials) {
    return this.doSetHTTPCredentials(httpCredentials);
  }
  getBindingClient(name) {
    return this._pageBindings.get(name)?.forClient;
  }
  async exposePlaywrightBindingIfNeeded() {
    if (this._playwrightBindingExposed)
      return;
    this._playwrightBindingExposed = true;
    await this.doExposePlaywrightBinding();
    this.bindingsInitScript = PageBinding.createInitScript();
    this.initScripts.push(this.bindingsInitScript);
    await this.doAddInitScript(this.bindingsInitScript);
    await this.safeNonStallingEvaluateInAllFrames(this.bindingsInitScript.source, "main");
  }
  needsPlaywrightBinding() {
    return this._playwrightBindingExposed;
  }
  async exposeBinding(progress3, name, needsHandle, playwrightBinding, forClient) {
    if (this._pageBindings.has(name))
      throw new Error(`Function "${name}" has been already registered`);
    for (const page of this.pages()) {
      if (page.getBinding(name))
        throw new Error(`Function "${name}" has been already registered in one of the pages`);
    }
    await progress3.race(this.exposePlaywrightBindingIfNeeded());
    const binding3 = new PageBinding(name, playwrightBinding, needsHandle);
    binding3.forClient = forClient;
    this._pageBindings.set(name, binding3);
    try {
      await progress3.race(this.doAddInitScript(binding3.initScript));
      await progress3.race(this.safeNonStallingEvaluateInAllFrames(binding3.initScript.source, "main"));
      return binding3;
    } catch (error3) {
      this._pageBindings.delete(name);
      throw error3;
    }
  }
  async removeExposedBindings(bindings) {
    bindings = bindings.filter((binding3) => this._pageBindings.get(binding3.name) === binding3);
    for (const binding3 of bindings)
      this._pageBindings.delete(binding3.name);
    await this.doRemoveInitScripts(bindings.map((binding3) => binding3.initScript));
    const cleanup = bindings.map((binding3) => `{ ${binding3.cleanupScript} };
`).join("");
    await this.safeNonStallingEvaluateInAllFrames(cleanup, "main");
  }
  async grantPermissions(permissions, origin) {
    let resolvedOrigin = "*";
    if (origin) {
      const url4 = new URL(origin);
      resolvedOrigin = url4.origin;
    }
    const existing = new Set(this._permissions.get(resolvedOrigin) || []);
    permissions.forEach((p) => existing.add(p));
    const list = [...existing.values()];
    this._permissions.set(resolvedOrigin, list);
    await this.doGrantPermissions(resolvedOrigin, list);
  }
  async clearPermissions() {
    this._permissions.clear();
    await this.doClearPermissions();
  }
  async setExtraHTTPHeaders(progress3, headers) {
    const oldHeaders = this._options.extraHTTPHeaders;
    this._options.extraHTTPHeaders = headers;
    try {
      await progress3.race(this.doUpdateExtraHTTPHeaders());
    } catch (error3) {
      this._options.extraHTTPHeaders = oldHeaders;
      this.doUpdateExtraHTTPHeaders().catch(() => {
      });
      throw error3;
    }
  }
  async setOffline(progress3, offline) {
    const oldOffline = this._options.offline;
    this._options.offline = offline;
    try {
      await progress3.race(this.doUpdateOffline());
    } catch (error3) {
      this._options.offline = oldOffline;
      this.doUpdateOffline().catch(() => {
      });
      throw error3;
    }
  }
  async _loadDefaultContextAsIs(progress3) {
    if (!this.possiblyUninitializedPages().length) {
      const waitForEvent2 = helper.waitForEvent(progress3, this, _BrowserContext.Events.Page);
      await Promise.race([waitForEvent2.promise, this._closePromise]);
    }
    const page = this.possiblyUninitializedPages()[0];
    if (!page)
      return;
    const pageOrError = await progress3.race(page.waitForInitializedOrError());
    if (pageOrError instanceof Error)
      throw pageOrError;
    await page.mainFrame()._waitForLoadState(progress3, "load");
    return page;
  }
  async _loadDefaultContext(progress3) {
    const defaultPage = await this._loadDefaultContextAsIs(progress3);
    if (!defaultPage)
      return;
    const browserName = this._browser.options.name;
    if (this._options.isMobile && browserName === "chromium" || this._options.locale && browserName === "webkit") {
      await this.newPage(progress3);
      await defaultPage.close();
    }
  }
  _authenticateProxyViaHeader() {
    const proxy = this._options.proxy || this._browser.options.proxy || { username: void 0, password: void 0 };
    const { username, password } = proxy;
    if (username) {
      this._options.httpCredentials = { username, password };
      const token = Buffer.from(`${username}:${password}`).toString("base64");
      this._options.extraHTTPHeaders = mergeHeaders([
        this._options.extraHTTPHeaders,
        singleHeader("Proxy-Authorization", `Basic ${token}`)
      ]);
    }
  }
  _authenticateProxyViaCredentials() {
    const proxy = this._options.proxy || this._browser.options.proxy;
    if (!proxy)
      return;
    const { username, password } = proxy;
    if (username)
      this._options.httpCredentials = { username, password: password || "" };
  }
  async addInitScript(progress3, source8) {
    const initScript = new InitScript(source8);
    this.initScripts.push(initScript);
    try {
      const promise = this.doAddInitScript(initScript);
      if (progress3)
        await progress3.race(promise);
      else
        await promise;
      return initScript;
    } catch (error3) {
      this.removeInitScripts([initScript]).catch(() => {
      });
      throw error3;
    }
  }
  async removeInitScripts(initScripts) {
    const set2 = new Set(initScripts);
    this.initScripts = this.initScripts.filter((script) => !set2.has(script));
    await this.doRemoveInitScripts(initScripts);
  }
  async addRequestInterceptor(progress3, handler) {
    this.requestInterceptors.push(handler);
    await this.doUpdateRequestInterception();
  }
  async removeRequestInterceptor(handler) {
    const index2 = this.requestInterceptors.indexOf(handler);
    if (index2 === -1)
      return;
    this.requestInterceptors.splice(index2, 1);
    await this.notifyRoutesInFlightAboutRemovedHandler(handler);
    await this.doUpdateRequestInterception();
  }
  isClosingOrClosed() {
    return this._closedStatus !== "open";
  }
  async _deleteAllDownloads() {
    await Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
  }
  async _deleteAllTempDirs() {
    await Promise.all(this._tempDirs.map(async (dir3) => await fs20.promises.unlink(dir3).catch((e) => {
    })));
  }
  setCustomCloseHandler(handler) {
    this._customCloseHandler = handler;
  }
  async close(options2) {
    if (this._closedStatus === "open") {
      if (options2.reason)
        this._closeReason = options2.reason;
      this.emit(_BrowserContext.Events.BeforeClose);
      this._closedStatus = "closing";
      for (const harRecorder of this._harRecorders.values())
        await harRecorder.flush();
      await this.tracing.flush();
      const promises = [];
      for (const { context: context2, artifact } of this._browser._idToVideo.values()) {
        if (context2 === this)
          promises.push(artifact.finishedPromise());
      }
      if (this._customCloseHandler) {
        await this._customCloseHandler();
      } else {
        await this.doClose(options2.reason);
      }
      promises.push(this._deleteAllDownloads());
      promises.push(this._deleteAllTempDirs());
      await Promise.all(promises);
      if (!this._customCloseHandler)
        this._didCloseInternal();
    }
    await this._closePromise;
  }
  async newPage(progress3, forStorageState) {
    let page;
    try {
      this._creatingStorageStatePage = !!forStorageState;
      page = await progress3.race(this.doCreateNewPage());
      const pageOrError = await progress3.race(page.waitForInitializedOrError());
      if (pageOrError instanceof Page) {
        if (pageOrError.isClosed())
          throw new Error("Page has been closed.");
        return pageOrError;
      }
      throw pageOrError;
    } catch (error3) {
      await page?.close({ reason: "Failed to create page" }).catch(() => {
      });
      throw error3;
    } finally {
      this._creatingStorageStatePage = false;
    }
  }
  addVisitedOrigin(origin) {
    this._origins.add(origin);
  }
  async storageState(progress3, indexedDB = false) {
    const result = {
      cookies: await this.cookies(),
      origins: []
    };
    const originsToSave = new Set(this._origins);
    const collectScript = `(() => {
      const module = {};
      ${source6}
      const script = new (module.exports.StorageScript())(${this._browser.options.name === "firefox"});
      return script.collect(${indexedDB});
    })()`;
    for (const page of this.pages()) {
      const origin = page.mainFrame().origin();
      if (!origin || !originsToSave.has(origin))
        continue;
      try {
        const storage = await page.mainFrame().nonStallingEvaluateInExistingContext(collectScript, "utility");
        if (storage.localStorage.length || storage.indexedDB?.length)
          result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
        originsToSave.delete(origin);
      } catch {
      }
    }
    if (originsToSave.size) {
      const page = await this.newPage(
        progress3,
        true
        /* forStorageState */
      );
      try {
        await page.addRequestInterceptor(progress3, (route) => {
          route.fulfill({ body: "<html></html>" }).catch(() => {
          });
        }, "prepend");
        for (const origin of originsToSave) {
          const frame = page.mainFrame();
          await frame.gotoImpl(progress3, origin, {});
          const storage = await progress3.race(frame.evaluateExpression(collectScript, { world: "utility" }));
          if (storage.localStorage.length || storage.indexedDB?.length)
            result.origins.push({ origin, localStorage: storage.localStorage, indexedDB: storage.indexedDB });
        }
      } finally {
        await page.close();
      }
    }
    return result;
  }
  isCreatingStorageStatePage() {
    return this._creatingStorageStatePage;
  }
  async setStorageState(progress3, state, mode) {
    let page;
    let interceptor;
    try {
      if (mode !== "initial") {
        await progress3.race(this.clearCache());
        await progress3.race(this.doClearCookies());
      }
      if (state?.cookies)
        await progress3.race(this.addCookies(state.cookies));
      const newOrigins = new Map(state?.origins?.map((p) => [p.origin, p]) || []);
      const allOrigins = /* @__PURE__ */ new Set([...this._origins, ...newOrigins.keys()]);
      if (allOrigins.size) {
        if (mode === "resetForReuse")
          page = this.pages()[0];
        if (!page)
          page = await this.newPage(
            progress3,
            mode !== "resetForReuse"
            /* forStorageState */
          );
        interceptor = /* @__PURE__ */ __name((route) => {
          route.fulfill({ body: "<html></html>" }).catch(() => {
          });
        }, "interceptor");
        await page.addRequestInterceptor(progress3, interceptor, "prepend");
        for (const origin of allOrigins) {
          const frame = page.mainFrame();
          await frame.gotoImpl(progress3, origin, {});
          const restoreScript = `(() => {
            const module = {};
            ${source6}
            const script = new (module.exports.StorageScript())(${this._browser.options.name === "firefox"});
            return script.restore(${JSON.stringify(newOrigins.get(origin))});
          })()`;
          await progress3.race(frame.evaluateExpression(restoreScript, { world: "utility" }));
        }
      }
      this._origins = /* @__PURE__ */ new Set([...newOrigins.keys()]);
    } catch (error3) {
      rewriteErrorMessage(error3, `Error setting storage state:
` + error3.message);
      throw error3;
    } finally {
      if (mode !== "resetForReuse")
        await page?.close();
      else if (interceptor)
        await page?.removeRequestInterceptor(interceptor);
    }
  }
  async extendInjectedScript(source8, arg) {
    const installInFrame = /* @__PURE__ */ __name((frame) => frame.extendInjectedScript(source8, arg).catch(() => {
    }), "installInFrame");
    const installInPage = /* @__PURE__ */ __name((page) => {
      page.on(Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
      return Promise.all(page.frames().map(installInFrame));
    }, "installInPage");
    this.on(_BrowserContext.Events.Page, installInPage);
    return Promise.all(this.pages().map(installInPage));
  }
  async safeNonStallingEvaluateInAllFrames(expression, world, options2 = {}) {
    await Promise.all(this.pages().map((page) => page.safeNonStallingEvaluateInAllFrames(expression, world, options2)));
  }
  harStart(page, options2) {
    const harId = createGuid();
    this._harRecorders.set(harId, new HarRecorder(this, page, options2));
    return harId;
  }
  async harExport(harId) {
    const recorder = this._harRecorders.get(harId || "");
    return recorder.export();
  }
  addRouteInFlight(route) {
    this._routesInFlight.add(route);
  }
  removeRouteInFlight(route) {
    this._routesInFlight.delete(route);
  }
  async notifyRoutesInFlightAboutRemovedHandler(handler) {
    await Promise.all([...this._routesInFlight].map((route) => route.removeHandler(handler)));
  }
};
function validateBrowserContextOptions(options2, browserOptions) {
  if (options2.noDefaultViewport && options2.deviceScaleFactor !== void 0)
    throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
  if (options2.noDefaultViewport && !!options2.isMobile)
    throw new Error(`"isMobile" option is not supported with null "viewport"`);
  if (options2.acceptDownloads === void 0 && browserOptions.name !== "electron")
    options2.acceptDownloads = "accept";
  else if (options2.acceptDownloads === void 0 && browserOptions.name === "electron")
    options2.acceptDownloads = "internal-browser-default";
  if (!options2.viewport && !options2.noDefaultViewport)
    options2.viewport = { width: 1280, height: 720 };
  if (options2.recordVideo) {
    if (!options2.recordVideo.size) {
      if (options2.noDefaultViewport) {
        options2.recordVideo.size = { width: 800, height: 600 };
      } else {
        const size = options2.viewport;
        const scale = Math.min(1, 800 / Math.max(size.width, size.height));
        options2.recordVideo.size = {
          width: Math.floor(size.width * scale),
          height: Math.floor(size.height * scale)
        };
      }
    }
    options2.recordVideo.size.width &= -2;
    options2.recordVideo.size.height &= -2;
  }
  if (options2.proxy)
    options2.proxy = normalizeProxySettings(options2.proxy);
  verifyGeolocation(options2.geolocation);
}
__name(validateBrowserContextOptions, "validateBrowserContextOptions");
function verifyGeolocation(geolocation) {
  if (!geolocation)
    return;
  geolocation.accuracy = geolocation.accuracy || 0;
  const { longitude, latitude, accuracy } = geolocation;
  if (longitude < -180 || longitude > 180)
    throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
  if (latitude < -90 || latitude > 90)
    throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
  if (accuracy < 0)
    throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
}
__name(verifyGeolocation, "verifyGeolocation");
function verifyClientCertificates(clientCertificates) {
  if (!clientCertificates)
    return;
  for (const cert of clientCertificates) {
    if (!cert.origin)
      throw new Error(`clientCertificates.origin is required`);
    if (!cert.cert && !cert.key && !cert.passphrase && !cert.pfx)
      throw new Error("None of cert, key, passphrase or pfx is specified");
    if (cert.cert && !cert.key)
      throw new Error("cert is specified without key");
    if (!cert.cert && cert.key)
      throw new Error("key is specified without cert");
    if (cert.pfx && (cert.cert || cert.key))
      throw new Error("pfx is specified together with cert, key or passphrase");
  }
}
__name(verifyClientCertificates, "verifyClientCertificates");
function normalizeProxySettings(proxy) {
  let { server, bypass } = proxy;
  let url4;
  try {
    url4 = new URL(server);
    if (!url4.host || !url4.protocol)
      url4 = new URL("http://" + server);
  } catch (e) {
    url4 = new URL("http://" + server);
  }
  if (url4.protocol === "socks4:" && (proxy.username || proxy.password))
    throw new Error(`Socks4 proxy protocol does not support authentication`);
  if (url4.protocol === "socks5:" && (proxy.username || proxy.password))
    throw new Error(`Browser does not support socks5 proxy authentication`);
  server = url4.protocol + "//" + url4.host;
  if (bypass)
    bypass = bypass.split(",").map((t) => t.trim()).join(",");
  return { ...proxy, server, bypass };
}
__name(normalizeProxySettings, "normalizeProxySettings");
var paramsThatAllowContextReuse = [
  "colorScheme",
  "forcedColors",
  "reducedMotion",
  "contrast",
  "screen",
  "userAgent",
  "viewport",
  "testIdAttributeName"
];
var defaultNewContextParamValues = {
  noDefaultViewport: false,
  ignoreHTTPSErrors: false,
  javaScriptEnabled: true,
  bypassCSP: false,
  offline: false,
  isMobile: false,
  hasTouch: false,
  acceptDownloads: "accept",
  strictSelectors: false,
  serviceWorkers: "allow",
  locale: "en-US"
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/cookieStore.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Cookie = class {
  static {
    __name(this, "Cookie");
  }
  constructor(data) {
    this._raw = data;
  }
  name() {
    return this._raw.name;
  }
  // https://datatracker.ietf.org/doc/html/rfc6265#section-5.4
  matches(url4) {
    if (this._raw.secure && (url4.protocol !== "https:" && !isLocalHostname(url4.hostname)))
      return false;
    if (!domainMatches(url4.hostname, this._raw.domain))
      return false;
    if (!pathMatches(url4.pathname, this._raw.path))
      return false;
    return true;
  }
  equals(other2) {
    return this._raw.name === other2._raw.name && this._raw.domain === other2._raw.domain && this._raw.path === other2._raw.path;
  }
  networkCookie() {
    return this._raw;
  }
  updateExpiresFrom(other2) {
    this._raw.expires = other2._raw.expires;
  }
  expired() {
    if (this._raw.expires === -1)
      return false;
    return this._raw.expires * 1e3 < Date.now();
  }
};
var CookieStore = class _CookieStore {
  static {
    __name(this, "CookieStore");
  }
  constructor() {
    this._nameToCookies = /* @__PURE__ */ new Map();
  }
  addCookies(cookies) {
    for (const cookie of cookies)
      this._addCookie(new Cookie(cookie));
  }
  cookies(url4) {
    const result = [];
    for (const cookie of this._cookiesIterator()) {
      if (cookie.matches(url4))
        result.push(cookie.networkCookie());
    }
    return result;
  }
  allCookies() {
    const result = [];
    for (const cookie of this._cookiesIterator())
      result.push(cookie.networkCookie());
    return result;
  }
  _addCookie(cookie) {
    let set2 = this._nameToCookies.get(cookie.name());
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this._nameToCookies.set(cookie.name(), set2);
    }
    for (const other2 of set2) {
      if (other2.equals(cookie))
        set2.delete(other2);
    }
    set2.add(cookie);
    _CookieStore.pruneExpired(set2);
  }
  *_cookiesIterator() {
    for (const [name, cookies] of this._nameToCookies) {
      _CookieStore.pruneExpired(cookies);
      for (const cookie of cookies)
        yield cookie;
      if (cookies.size === 0)
        this._nameToCookies.delete(name);
    }
  }
  static pruneExpired(cookies) {
    for (const cookie of cookies) {
      if (cookie.expired())
        cookies.delete(cookie);
    }
  }
};
function parseRawCookie(header) {
  const pairs2 = header.split(";").filter((s) => s.trim().length > 0).map((p) => {
    let key = "";
    let value2 = "";
    const separatorPos = p.indexOf("=");
    if (separatorPos === -1) {
      key = p.trim();
    } else {
      key = p.slice(0, separatorPos).trim();
      value2 = p.slice(separatorPos + 1).trim();
    }
    return [key, value2];
  });
  if (!pairs2.length)
    return null;
  const [name, value] = pairs2[0];
  const cookie = {
    name,
    value
  };
  for (let i = 1; i < pairs2.length; i++) {
    const [name2, value2] = pairs2[i];
    switch (name2.toLowerCase()) {
      case "expires":
        const expiresMs = +new Date(value2);
        if (isFinite(expiresMs)) {
          if (expiresMs <= 0)
            cookie.expires = 0;
          else
            cookie.expires = Math.min(expiresMs / 1e3, kMaxCookieExpiresDateInSeconds);
        }
        break;
      case "max-age":
        const maxAgeSec = parseInt(value2, 10);
        if (isFinite(maxAgeSec)) {
          if (maxAgeSec <= 0)
            cookie.expires = 0;
          else
            cookie.expires = Math.min(Date.now() / 1e3 + maxAgeSec, kMaxCookieExpiresDateInSeconds);
        }
        break;
      case "domain":
        cookie.domain = value2.toLocaleLowerCase() || "";
        if (cookie.domain && !cookie.domain.startsWith(".") && cookie.domain.includes("."))
          cookie.domain = "." + cookie.domain;
        break;
      case "path":
        cookie.path = value2 || "";
        break;
      case "secure":
        cookie.secure = true;
        break;
      case "httponly":
        cookie.httpOnly = true;
        break;
      case "samesite":
        switch (value2.toLowerCase()) {
          case "none":
            cookie.sameSite = "None";
            break;
          case "lax":
            cookie.sameSite = "Lax";
            break;
          case "strict":
            cookie.sameSite = "Strict";
            break;
        }
        break;
    }
  }
  return cookie;
}
__name(parseRawCookie, "parseRawCookie");
function domainMatches(value, domain2) {
  if (value === domain2)
    return true;
  if (!domain2.startsWith("."))
    return false;
  value = "." + value;
  return value.endsWith(domain2);
}
__name(domainMatches, "domainMatches");
function pathMatches(value, path30) {
  if (value === path30)
    return true;
  if (!value.endsWith("/"))
    value = value + "/";
  if (!path30.endsWith("/"))
    path30 = path30 + "/";
  return value.startsWith(path30);
}
__name(pathMatches, "pathMatches");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/formData.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MultipartFormData = class {
  static {
    __name(this, "MultipartFormData");
  }
  constructor() {
    this._chunks = [];
    this._boundary = generateUniqueBoundaryString();
  }
  contentTypeHeader() {
    return `multipart/form-data; boundary=${this._boundary}`;
  }
  addField(name, value) {
    this._beginMultiPartHeader(name);
    this._finishMultiPartHeader();
    this._chunks.push(Buffer.from(value));
    this._finishMultiPartField();
  }
  addFileField(name, value) {
    this._beginMultiPartHeader(name);
    this._chunks.push(Buffer.from(`; filename="${value.name}"`));
    this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || mime2.getType(value.name) || "application/octet-stream"}`));
    this._finishMultiPartHeader();
    this._chunks.push(value.buffer);
    this._finishMultiPartField();
  }
  finish() {
    this._addBoundary(true);
    return Buffer.concat(this._chunks);
  }
  _beginMultiPartHeader(name) {
    this._addBoundary();
    this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
  }
  _finishMultiPartHeader() {
    this._chunks.push(Buffer.from(`\r
\r
`));
  }
  _finishMultiPartField() {
    this._chunks.push(Buffer.from(`\r
`));
  }
  _addBoundary(isLastBoundary) {
    this._chunks.push(Buffer.from("--" + this._boundary));
    if (isLastBoundary)
      this._chunks.push(Buffer.from("--"));
    this._chunks.push(Buffer.from("\r\n"));
  }
};
var alphaNumericEncodingMap = [
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  65,
  66
];
function generateUniqueBoundaryString() {
  const charCodes = [];
  for (let i = 0; i < 16; i++)
    charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
  return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
}
__name(generateUniqueBoundaryString, "generateUniqueBoundaryString");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/socksClientCertificatesInterceptor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter11 } from "node:events";
import http22 from "node:http2";
import net4 from "node:net";
import require$$64 from "node:stream";
import tls3 from "node:tls";
import "node:fs";
import "node:path";
import "node:os";
var dummyServerTlsOptions = void 0;
function loadDummyServerCertsIfNeeded() {
  if (dummyServerTlsOptions)
    return;
  const { cert, key } = generateSelfSignedCertificate();
  dummyServerTlsOptions = { key, cert };
}
__name(loadDummyServerCertsIfNeeded, "loadDummyServerCertsIfNeeded");
var SocksProxyConnection = class {
  static {
    __name(this, "SocksProxyConnection");
  }
  constructor(socksProxy, uid, host, port) {
    this._firstPackageReceived = false;
    this._closed = false;
    this.socksProxy = socksProxy;
    this.uid = uid;
    this.host = host;
    this.port = port;
    this._serverCloseEventListener = () => {
      this._browserEncrypted.destroy();
    };
    this._browserEncrypted = new require$$64.Duplex({
      read: /* @__PURE__ */ __name(() => {
      }, "read"),
      write: /* @__PURE__ */ __name((data, encoding, callback) => {
        this.socksProxy._socksProxy.sendSocketData({ uid: this.uid, data });
        callback();
      }, "write"),
      destroy: /* @__PURE__ */ __name((error3, callback) => {
        if (error3)
          socksProxy._socksProxy.sendSocketError({ uid: this.uid, error: error3.message });
        else
          socksProxy._socksProxy.sendSocketEnd({ uid: this.uid });
        callback();
      }, "destroy")
    });
  }
  async connect() {
    const proxyAgent = this.socksProxy.getProxyAgent(this.host, this.port);
    if (proxyAgent)
      this._serverEncrypted = await proxyAgent.callback(new EventEmitter11(), { host: rewriteToLocalhostIfNeeded(this.host), port: this.port, secureEndpoint: false });
    else
      this._serverEncrypted = await createSocket(rewriteToLocalhostIfNeeded(this.host), this.port);
    this._serverEncrypted.once("close", this._serverCloseEventListener);
    this._serverEncrypted.once("error", (error3) => this._browserEncrypted.destroy(error3));
    if (this._closed) {
      this._serverEncrypted.destroy();
      return;
    }
    this.socksProxy._socksProxy.socketConnected({
      uid: this.uid,
      host: this._serverEncrypted.localAddress,
      port: this._serverEncrypted.localPort
    });
  }
  onClose() {
    this._serverEncrypted.destroy();
    this._browserEncrypted.destroy();
    this._closed = true;
  }
  onData(data) {
    if (!this._firstPackageReceived) {
      this._firstPackageReceived = true;
      if (data[0] === 22)
        this._establishTlsTunnel(this._browserEncrypted, data);
      else
        this._establishPlaintextTunnel(this._browserEncrypted);
    }
    this._browserEncrypted.push(data);
  }
  _establishPlaintextTunnel(browserEncrypted) {
    browserEncrypted.pipe(this._serverEncrypted);
    this._serverEncrypted.pipe(browserEncrypted);
  }
  _establishTlsTunnel(browserEncrypted, clientHello) {
    const browserALPNProtocols = parseALPNFromClientHello(clientHello) || ["http/1.1"];
    debugLogger.log("client-certificates", `Browser->Proxy ${this.host}:${this.port} offers ALPN ${browserALPNProtocols}`);
    const serverDecrypted = tls3.connect({
      socket: this._serverEncrypted,
      host: this.host,
      port: this.port,
      rejectUnauthorized: !this.socksProxy.ignoreHTTPSErrors,
      ALPNProtocols: browserALPNProtocols,
      servername: !net4.isIP(this.host) ? this.host : void 0,
      secureContext: this.socksProxy.secureContextMap.get(new URL(`https://${this.host}:${this.port}`).origin)
    }, async () => {
      const browserDecrypted = await this._upgradeToTLSIfNeeded(browserEncrypted, serverDecrypted.alpnProtocol);
      debugLogger.log("client-certificates", `Proxy->Server ${this.host}:${this.port} chooses ALPN ${browserDecrypted.alpnProtocol}`);
      browserDecrypted.pipe(serverDecrypted);
      serverDecrypted.pipe(browserDecrypted);
      const cleanup = /* @__PURE__ */ __name((error3) => this._serverEncrypted.destroy(error3), "cleanup");
      browserDecrypted.once("error", cleanup);
      serverDecrypted.once("error", cleanup);
      browserDecrypted.once("close", cleanup);
      serverDecrypted.once("close", cleanup);
      if (this._closed)
        serverDecrypted.destroy();
    });
    serverDecrypted.once("error", async (error3) => {
      debugLogger.log("client-certificates", `error when connecting to server: ${error3.message.replaceAll("\n", " ")}`);
      this._serverEncrypted.removeListener("close", this._serverCloseEventListener);
      this._serverEncrypted.destroy();
      const browserDecrypted = await this._upgradeToTLSIfNeeded(this._browserEncrypted, serverDecrypted.alpnProtocol);
      const responseBody = escapeHTML2("Playwright client-certificate error: " + error3.message).replaceAll("\n", " <br>");
      if (browserDecrypted.alpnProtocol === "h2") {
        if ("performServerHandshake" in http22) {
          const session2 = http22.performServerHandshake(browserDecrypted);
          session2.on("error", (error22) => {
            this._browserEncrypted.destroy(error22);
          });
          session2.once("stream", (stream2) => {
            const cleanup = /* @__PURE__ */ __name((error22) => {
              session2.close();
              this._browserEncrypted.destroy(error22);
            }, "cleanup");
            stream2.once("end", cleanup);
            stream2.once("error", cleanup);
            stream2.respond({
              [http22.constants.HTTP2_HEADER_CONTENT_TYPE]: "text/html",
              [http22.constants.HTTP2_HEADER_STATUS]: 503
            });
            stream2.end(responseBody);
          });
        } else {
          this._browserEncrypted.destroy(error3);
        }
      } else {
        browserDecrypted.end([
          "HTTP/1.1 503 Internal Server Error",
          "Content-Type: text/html; charset=utf-8",
          "Content-Length: " + Buffer.byteLength(responseBody),
          "",
          responseBody
        ].join("\r\n"));
      }
    });
  }
  async _upgradeToTLSIfNeeded(socket, alpnProtocol) {
    this._brorwserDecrypted ??= new Promise((resolve, reject) => {
      const dummyServer = tls3.createServer({
        ...dummyServerTlsOptions,
        ALPNProtocols: [alpnProtocol || "http/1.1"]
      });
      dummyServer.emit("connection", socket);
      dummyServer.once("secureConnection", (tlsSocket) => {
        dummyServer.close();
        resolve(tlsSocket);
      });
      dummyServer.once("error", (error3) => {
        dummyServer.close();
        reject(error3);
      });
    });
    return this._brorwserDecrypted;
  }
};
var ClientCertificatesProxy = class _ClientCertificatesProxy {
  static {
    __name(this, "ClientCertificatesProxy");
  }
  constructor(contextOptions) {
    this._connections = /* @__PURE__ */ new Map();
    this.secureContextMap = /* @__PURE__ */ new Map();
    verifyClientCertificates(contextOptions.clientCertificates);
    this.ignoreHTTPSErrors = contextOptions.ignoreHTTPSErrors;
    this._proxy = contextOptions.proxy;
    this._initSecureContexts(contextOptions.clientCertificates);
    this._socksProxy = new SocksProxy();
    this._socksProxy.setPattern("*");
    this._socksProxy.addListener(SocksProxy.Events.SocksRequested, async (payload) => {
      try {
        const connection = new SocksProxyConnection(this, payload.uid, payload.host, payload.port);
        await connection.connect();
        this._connections.set(payload.uid, connection);
      } catch (error3) {
        debugLogger.log("client-certificates", `Failed to connect to ${payload.host}:${payload.port}: ${error3.message}`);
        this._socksProxy.socketFailed({ uid: payload.uid, errorCode: error3.code });
      }
    });
    this._socksProxy.addListener(SocksProxy.Events.SocksData, (payload) => {
      this._connections.get(payload.uid)?.onData(payload.data);
    });
    this._socksProxy.addListener(SocksProxy.Events.SocksClosed, (payload) => {
      this._connections.get(payload.uid)?.onClose();
      this._connections.delete(payload.uid);
    });
    loadDummyServerCertsIfNeeded();
  }
  getProxyAgent(host, port) {
    const proxyFromOptions = createProxyAgent(this._proxy);
    if (proxyFromOptions)
      return proxyFromOptions;
    const proxyFromEnv2 = getProxyForUrl2(`https://${host}:${port}`);
    if (proxyFromEnv2)
      return createProxyAgent({ server: proxyFromEnv2 });
  }
  _initSecureContexts(clientCertificates) {
    const origin2certs = /* @__PURE__ */ new Map();
    for (const cert of clientCertificates || []) {
      const origin = normalizeOrigin(cert.origin);
      const certs = origin2certs.get(origin) || [];
      certs.push(cert);
      origin2certs.set(origin, certs);
    }
    for (const [origin, certs] of origin2certs) {
      try {
        this.secureContextMap.set(origin, tls3.createSecureContext(convertClientCertificatesToTLSOptions(certs)));
      } catch (error3) {
        error3 = rewriteOpenSSLErrorIfNeeded(error3);
        throw rewriteErrorMessage(error3, `Failed to load client certificate: ${error3.message}`);
      }
    }
  }
  static async create(progress3, contextOptions) {
    const proxy = new _ClientCertificatesProxy(contextOptions);
    try {
      await progress3.race(proxy._socksProxy.listen(0, "127.0.0.1"));
      return proxy;
    } catch (error3) {
      await proxy.close();
      throw error3;
    }
  }
  proxySettings() {
    return { server: `socks5://127.0.0.1:${this._socksProxy.port()}` };
  }
  async close() {
    await this._socksProxy.close();
  }
};
function normalizeOrigin(origin) {
  try {
    return new URL(origin).origin;
  } catch (error3) {
    return origin;
  }
}
__name(normalizeOrigin, "normalizeOrigin");
function convertClientCertificatesToTLSOptions(clientCertificates) {
  if (!clientCertificates || !clientCertificates.length)
    return;
  const tlsOptions = {
    pfx: [],
    key: [],
    cert: []
  };
  for (const cert of clientCertificates) {
    if (cert.cert)
      tlsOptions.cert.push(cert.cert);
    if (cert.key)
      tlsOptions.key.push({ pem: cert.key, passphrase: cert.passphrase });
    if (cert.pfx)
      tlsOptions.pfx.push({ buf: cert.pfx, passphrase: cert.passphrase });
  }
  return tlsOptions;
}
__name(convertClientCertificatesToTLSOptions, "convertClientCertificatesToTLSOptions");
function getMatchingTLSOptionsForOrigin(clientCertificates, origin) {
  const matchingCerts = clientCertificates?.filter(
    (c) => normalizeOrigin(c.origin) === origin
  );
  return convertClientCertificatesToTLSOptions(matchingCerts);
}
__name(getMatchingTLSOptionsForOrigin, "getMatchingTLSOptionsForOrigin");
function rewriteToLocalhostIfNeeded(host) {
  return host === "local.playwright" ? "localhost" : host;
}
__name(rewriteToLocalhostIfNeeded, "rewriteToLocalhostIfNeeded");
function rewriteOpenSSLErrorIfNeeded(error3) {
  if (error3.message !== "unsupported" && error3.code !== "ERR_CRYPTO_UNSUPPORTED_OPERATION")
    return error3;
  return rewriteErrorMessage(error3, [
    "Unsupported TLS certificate.",
    "Most likely, the security algorithm of the given certificate was deprecated by OpenSSL.",
    "For more details, see https://github.com/openssl/openssl/blob/master/README-PROVIDERS.md#the-legacy-provider",
    "You could probably modernize the certificate by following the steps at https://github.com/nodejs/node/issues/40672#issuecomment-1243648223"
  ].join("\n"));
}
__name(rewriteOpenSSLErrorIfNeeded, "rewriteOpenSSLErrorIfNeeded");
function parseALPNFromClientHello(buffer) {
  if (buffer.length < 6)
    return null;
  if (buffer[0] !== 22)
    return null;
  let offset = 5;
  if (buffer[offset] !== 1)
    return null;
  offset += 4;
  offset += 2;
  offset += 32;
  if (offset >= buffer.length)
    return null;
  const sessionIdLength = buffer[offset];
  offset += 1 + sessionIdLength;
  if (offset + 2 > buffer.length)
    return null;
  const cipherSuitesLength = buffer.readUInt16BE(offset);
  offset += 2 + cipherSuitesLength;
  if (offset >= buffer.length)
    return null;
  const compressionMethodsLength = buffer[offset];
  offset += 1 + compressionMethodsLength;
  if (offset + 2 > buffer.length)
    return null;
  const extensionsLength = buffer.readUInt16BE(offset);
  offset += 2;
  const extensionsEnd = offset + extensionsLength;
  if (extensionsEnd > buffer.length)
    return null;
  while (offset + 4 <= extensionsEnd) {
    const extensionType = buffer.readUInt16BE(offset);
    offset += 2;
    const extensionLength = buffer.readUInt16BE(offset);
    offset += 2;
    if (offset + extensionLength > extensionsEnd)
      return null;
    if (extensionType === 16)
      return parseALPNExtension(buffer.subarray(offset, offset + extensionLength));
    offset += extensionLength;
  }
  return null;
}
__name(parseALPNFromClientHello, "parseALPNFromClientHello");
function parseALPNExtension(buffer) {
  if (buffer.length < 2)
    return null;
  const listLength = buffer.readUInt16BE(0);
  if (listLength !== buffer.length - 2)
    return null;
  const protocols = [];
  let offset = 2;
  while (offset < buffer.length) {
    const protocolLength = buffer[offset];
    offset += 1;
    if (offset + protocolLength > buffer.length)
      break;
    const protocol = buffer.subarray(offset, offset + protocolLength).toString("utf8");
    protocols.push(protocol);
    offset += protocolLength;
  }
  return protocols.length > 0 ? protocols : null;
}
__name(parseALPNExtension, "parseALPNExtension");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/fetch.js
var APIRequestContext = class _APIRequestContext extends SdkObject {
  static {
    __name(this, "APIRequestContext");
  }
  constructor(parent) {
    super(parent, "request-context");
    this.fetchResponses = /* @__PURE__ */ new Map();
    this.fetchLog = /* @__PURE__ */ new Map();
    _APIRequestContext.allInstances.add(this);
  }
  static {
    this.Events = {
      Dispose: "dispose",
      Request: "request",
      RequestFinished: "requestfinished"
    };
  }
  static {
    this.allInstances = /* @__PURE__ */ new Set();
  }
  static findResponseBody(guid) {
    for (const request2 of _APIRequestContext.allInstances) {
      const body = request2.fetchResponses.get(guid);
      if (body)
        return body;
    }
    return void 0;
  }
  _disposeImpl() {
    _APIRequestContext.allInstances.delete(this);
    this.fetchResponses.clear();
    this.fetchLog.clear();
    this.emit(_APIRequestContext.Events.Dispose);
  }
  disposeResponse(fetchUid) {
    this.fetchResponses.delete(fetchUid);
    this.fetchLog.delete(fetchUid);
  }
  _storeResponseBody(body) {
    const uid = createGuid();
    this.fetchResponses.set(uid, body);
    return uid;
  }
  async fetch(progress3, params) {
    const defaults = this._defaultOptions();
    const headers = {
      "user-agent": defaults.userAgent,
      "accept": "*/*",
      "accept-encoding": "gzip,deflate,br"
    };
    if (defaults.extraHTTPHeaders) {
      for (const { name, value } of defaults.extraHTTPHeaders)
        setHeader(headers, name, value);
    }
    if (params.headers) {
      for (const { name, value } of params.headers)
        setHeader(headers, name, value);
    }
    const requestUrl = new URL(constructURLBasedOnBaseURL(defaults.baseURL, params.url));
    if (params.encodedParams) {
      requestUrl.search = params.encodedParams;
    } else if (params.params) {
      for (const { name, value } of params.params)
        requestUrl.searchParams.append(name, value);
    }
    const credentials = this._getHttpCredentials(requestUrl);
    if (credentials?.send === "always")
      setBasicAuthorizationHeader(headers, credentials);
    const method = params.method?.toUpperCase() || "GET";
    const proxy = defaults.proxy;
    let agent2;
    if (proxy?.server !== "per-context")
      agent2 = createProxyAgent(proxy, requestUrl);
    let maxRedirects = params.maxRedirects ?? (defaults.maxRedirects ?? 20);
    maxRedirects = maxRedirects === 0 ? -1 : maxRedirects;
    const options2 = {
      method,
      headers,
      agent: agent2,
      maxRedirects,
      ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, requestUrl.origin),
      __testHookLookup: params.__testHookLookup
    };
    if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
      options2.rejectUnauthorized = false;
    const postData = serializePostData(params, headers);
    if (postData)
      setHeader(headers, "content-length", String(postData.byteLength));
    const fetchResponse = await this._sendRequestWithRetries(progress3, requestUrl, options2, postData, params.maxRetries);
    const fetchUid = this._storeResponseBody(fetchResponse.body);
    this.fetchLog.set(fetchUid, progress3.metadata.log);
    const failOnStatusCode = params.failOnStatusCode !== void 0 ? params.failOnStatusCode : !!defaults.failOnStatusCode;
    if (failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400)) {
      let responseText = "";
      if (fetchResponse.body.byteLength) {
        let text = fetchResponse.body.toString("utf8");
        if (text.length > 1e3)
          text = text.substring(0, 997) + "...";
        responseText = `
Response text:
${text}`;
      }
      throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}${responseText}`);
    }
    return { ...fetchResponse, fetchUid };
  }
  _parseSetCookieHeader(responseUrl, setCookie) {
    if (!setCookie)
      return [];
    const url4 = new URL(responseUrl);
    const defaultPath = "/" + url4.pathname.substr(1).split("/").slice(0, -1).join("/");
    const cookies = [];
    for (const header of setCookie) {
      const cookie = parseCookie2(header);
      if (!cookie)
        continue;
      if (!cookie.domain)
        cookie.domain = url4.hostname;
      else
        assert3(cookie.domain.startsWith(".") || !cookie.domain.includes("."));
      if (!domainMatches(url4.hostname, cookie.domain))
        continue;
      if (!cookie.path || !cookie.path.startsWith("/"))
        cookie.path = defaultPath;
      cookies.push(cookie);
    }
    return cookies;
  }
  async _updateRequestCookieHeader(progress3, url4, headers) {
    if (getHeader(headers, "cookie") !== void 0)
      return;
    const contextCookies = await progress3.race(this._cookies(url4));
    const cookies = contextCookies.filter((c) => new Cookie(c).matches(url4));
    if (cookies.length) {
      const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
      setHeader(headers, "cookie", valueArray.join("; "));
    }
  }
  async _sendRequestWithRetries(progress3, url4, options2, postData, maxRetries) {
    maxRetries ??= 0;
    let backoff = 250;
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await this._sendRequest(progress3, url4, options2, postData);
      } catch (e) {
        if (isAbortError(e))
          throw e;
        e = rewriteOpenSSLErrorIfNeeded(e);
        if (maxRetries === 0)
          throw e;
        if (i === maxRetries)
          throw new Error(`Failed after ${i + 1} attempt(s): ${e}`);
        if (e.code !== "ECONNRESET")
          throw e;
        progress3.log(`  Received ECONNRESET, will retry after ${backoff}ms.`);
        await progress3.wait(backoff);
        backoff *= 2;
      }
    }
    throw new Error("Unreachable");
  }
  async _sendRequest(progress3, url4, options2, postData) {
    await this._updateRequestCookieHeader(progress3, url4, options2.headers);
    const requestCookies = getHeader(options2.headers, "cookie")?.split(";").map((p) => {
      const [name, value] = p.split("=").map((v) => v.trim());
      return { name, value };
    }) || [];
    const requestEvent = {
      url: url4,
      method: options2.method,
      headers: options2.headers,
      cookies: requestCookies,
      postData
    };
    this.emit(_APIRequestContext.Events.Request, requestEvent);
    let destroyRequest;
    const resultPromise = new Promise((fulfill, reject) => {
      const requestConstructor = (url4.protocol === "https:" ? https3 : http3).request;
      const agent2 = options2.agent || (url4.protocol === "https:" ? httpsHappyEyeballsAgent : httpHappyEyeballsAgent);
      const requestOptions = { ...options2, agent: agent2 };
      const startAt = monotonicTime();
      let reusedSocketAt;
      let dnsLookupAt;
      let tcpConnectionAt;
      let tlsHandshakeAt;
      let requestFinishAt;
      let serverIPAddress;
      let serverPort;
      let securityDetails;
      const listeners2 = [];
      const request2 = requestConstructor(url4, requestOptions, async (response) => {
        const responseAt = monotonicTime();
        const notifyRequestFinished = /* @__PURE__ */ __name((body2) => {
          const endAt = monotonicTime();
          const connectEnd = tlsHandshakeAt ?? tcpConnectionAt;
          const timings = {
            send: requestFinishAt - startAt,
            wait: responseAt - requestFinishAt,
            receive: endAt - responseAt,
            dns: dnsLookupAt ? dnsLookupAt - startAt : -1,
            connect: connectEnd ? connectEnd - startAt : -1,
            // "If [ssl] is defined then the time is also included in the connect field "
            ssl: tlsHandshakeAt ? tlsHandshakeAt - tcpConnectionAt : -1,
            blocked: reusedSocketAt ? reusedSocketAt - startAt : -1
          };
          const requestFinishedEvent = {
            requestEvent,
            httpVersion: response.httpVersion,
            statusCode: response.statusCode || 0,
            statusMessage: response.statusMessage || "",
            headers: response.headers,
            rawHeaders: response.rawHeaders,
            cookies,
            body: body2,
            timings,
            serverIPAddress,
            serverPort,
            securityDetails
          };
          this.emit(_APIRequestContext.Events.RequestFinished, requestFinishedEvent);
        }, "notifyRequestFinished");
        progress3.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);
        for (const [name, value] of Object.entries(response.headers))
          progress3.log(`  ${name}: ${value}`);
        const cookies = this._parseSetCookieHeader(response.url || url4.toString(), response.headers["set-cookie"]);
        if (cookies.length) {
          try {
            await this._addCookies(cookies);
          } catch (e) {
            await Promise.all(cookies.map((c) => this._addCookies([c]).catch(() => {
            })));
          }
        }
        if (redirectStatus.includes(response.statusCode) && options2.maxRedirects >= 0) {
          if (options2.maxRedirects === 0) {
            reject(new Error("Max redirect count exceeded"));
            request2.destroy();
            return;
          }
          const headers = { ...options2.headers };
          removeHeader(headers, `cookie`);
          const status = response.statusCode;
          let method = options2.method;
          if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
            method = "GET";
            postData = void 0;
            removeHeader(headers, `content-encoding`);
            removeHeader(headers, `content-language`);
            removeHeader(headers, `content-length`);
            removeHeader(headers, `content-location`);
            removeHeader(headers, `content-type`);
          }
          const redirectOptions = {
            method,
            headers,
            agent: options2.agent,
            maxRedirects: options2.maxRedirects - 1,
            ...getMatchingTLSOptionsForOrigin(this._defaultOptions().clientCertificates, url4.origin),
            __testHookLookup: options2.__testHookLookup
          };
          if (options2.rejectUnauthorized === false)
            redirectOptions.rejectUnauthorized = false;
          const locationHeaderValue = Buffer.from(response.headers.location ?? "", "latin1").toString("utf8");
          if (locationHeaderValue) {
            let locationURL;
            try {
              locationURL = new URL(locationHeaderValue, url4);
            } catch (error3) {
              reject(new Error(`uri requested responds with an invalid redirect URL: ${locationHeaderValue}`));
              request2.destroy();
              return;
            }
            if (headers["host"])
              headers["host"] = locationURL.host;
            notifyRequestFinished();
            fulfill(this._sendRequest(progress3, locationURL, redirectOptions, postData));
            request2.destroy();
            return;
          }
        }
        if (response.statusCode === 401 && !getHeader(options2.headers, "authorization")) {
          const auth = response.headers["www-authenticate"];
          const credentials = this._getHttpCredentials(url4);
          if (auth?.trim().startsWith("Basic") && credentials) {
            setBasicAuthorizationHeader(options2.headers, credentials);
            notifyRequestFinished();
            fulfill(this._sendRequest(progress3, url4, options2, postData));
            request2.destroy();
            return;
          }
        }
        response.on("aborted", () => reject(new Error("aborted")));
        const chunks = [];
        const notifyBodyFinished = /* @__PURE__ */ __name(() => {
          const body2 = Buffer.concat(chunks);
          notifyRequestFinished(body2);
          fulfill({
            url: response.url || url4.toString(),
            status: response.statusCode || 0,
            statusText: response.statusMessage || "",
            headers: toHeadersArray(response.rawHeaders),
            body: body2
          });
        }, "notifyBodyFinished");
        let body = response;
        let transform2;
        const encoding = response.headers["content-encoding"];
        if (encoding === "gzip" || encoding === "x-gzip") {
          transform2 = zlib.createGunzip({
            flush: zlib.constants.Z_SYNC_FLUSH,
            finishFlush: zlib.constants.Z_SYNC_FLUSH
          });
        } else if (encoding === "br") {
          transform2 = zlib.createBrotliDecompress({
            flush: zlib.constants.BROTLI_OPERATION_FLUSH,
            finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
          });
        } else if (encoding === "deflate") {
          transform2 = zlib.createInflate();
        }
        if (transform2) {
          const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);
          body = pipeline2(response, emptyStreamTransform, transform2, (e) => {
            if (e)
              reject(new Error(`failed to decompress '${encoding}' encoding: ${e.message}`));
          });
          body.on("error", (e) => reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`)));
        } else {
          body.on("error", reject);
        }
        body.on("data", (chunk) => chunks.push(chunk));
        body.on("end", notifyBodyFinished);
      });
      request2.on("error", reject);
      destroyRequest = /* @__PURE__ */ __name(() => request2.destroy(), "destroyRequest");
      listeners2.push(
        eventsHelper.addEventListener(this, _APIRequestContext.Events.Dispose, () => {
          reject(new Error("Request context disposed."));
          request2.destroy();
        })
      );
      request2.on("close", () => eventsHelper.removeEventListeners(listeners2));
      request2.on("socket", (socket) => {
        if (request2.reusedSocket) {
          reusedSocketAt = monotonicTime();
          return;
        }
        const happyEyeBallsTimings = timingForSocket(socket);
        dnsLookupAt = happyEyeBallsTimings.dnsLookupAt;
        tcpConnectionAt = happyEyeBallsTimings.tcpConnectionAt;
        listeners2.push(
          eventsHelper.addEventListener(socket, "lookup", () => {
            dnsLookupAt = monotonicTime();
          }),
          eventsHelper.addEventListener(socket, "connect", () => {
            tcpConnectionAt = monotonicTime();
          }),
          eventsHelper.addEventListener(socket, "secureConnect", () => {
            tlsHandshakeAt = monotonicTime();
            if (socket instanceof TLSSocket) {
              const peerCertificate = socket.getPeerCertificate();
              securityDetails = {
                protocol: socket.getProtocol() ?? void 0,
                subjectName: peerCertificate.subject.CN,
                validFrom: new Date(peerCertificate.valid_from).getTime() / 1e3,
                validTo: new Date(peerCertificate.valid_to).getTime() / 1e3,
                issuer: peerCertificate.issuer.CN
              };
            }
          })
        );
        serverIPAddress = socket.remoteAddress;
        serverPort = socket.remotePort;
      });
      request2.on("finish", () => {
        requestFinishAt = monotonicTime();
      });
      progress3.log(`\u2192 ${options2.method} ${url4.toString()}`);
      if (options2.headers) {
        for (const [name, value] of Object.entries(options2.headers))
          progress3.log(`  ${name}: ${value}`);
      }
      if (postData)
        request2.write(postData);
      request2.end();
    });
    return progress3.race(resultPromise).catch((error3) => {
      destroyRequest?.();
      throw error3;
    });
  }
  _getHttpCredentials(url4) {
    if (!this._defaultOptions().httpCredentials?.origin || url4.origin.toLowerCase() === this._defaultOptions().httpCredentials?.origin?.toLowerCase())
      return this._defaultOptions().httpCredentials;
    return void 0;
  }
};
var SafeEmptyStreamTransform = class extends Transform {
  static {
    __name(this, "SafeEmptyStreamTransform");
  }
  constructor(onEmptyStreamCallback) {
    super();
    this._receivedSomeData = false;
    this._onEmptyStreamCallback = onEmptyStreamCallback;
  }
  _transform(chunk, encoding, callback) {
    this._receivedSomeData = true;
    callback(null, chunk);
  }
  _flush(callback) {
    if (this._receivedSomeData)
      callback(null);
    else
      this._onEmptyStreamCallback();
  }
};
var BrowserContextAPIRequestContext = class extends APIRequestContext {
  static {
    __name(this, "BrowserContextAPIRequestContext");
  }
  constructor(context2) {
    super(context2);
    this._context = context2;
    context2.once(BrowserContext.Events.Close, () => this._disposeImpl());
  }
  tracing() {
    return this._context.tracing;
  }
  async dispose(options2) {
    this._closeReason = options2.reason;
    this.fetchResponses.clear();
  }
  _defaultOptions() {
    return {
      userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
      extraHTTPHeaders: this._context._options.extraHTTPHeaders,
      failOnStatusCode: void 0,
      httpCredentials: this._context._options.httpCredentials,
      proxy: this._context._options.proxy || this._context._browser.options.proxy,
      ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
      baseURL: this._context._options.baseURL,
      clientCertificates: this._context._options.clientCertificates
    };
  }
  async _addCookies(cookies) {
    await this._context.addCookies(cookies);
  }
  async _cookies(url4) {
    return await this._context.cookies(url4.toString());
  }
  async storageState(progress3, indexedDB) {
    return this._context.storageState(progress3, indexedDB);
  }
};
var GlobalAPIRequestContext = class extends APIRequestContext {
  static {
    __name(this, "GlobalAPIRequestContext");
  }
  constructor(playwright2, options2) {
    super(playwright2);
    this._cookieStore = new CookieStore();
    this.attribution.context = this;
    if (options2.storageState) {
      this._origins = options2.storageState.origins?.map((origin) => ({ indexedDB: [], ...origin }));
      this._cookieStore.addCookies(options2.storageState.cookies || []);
    }
    verifyClientCertificates(options2.clientCertificates);
    this._options = {
      baseURL: options2.baseURL,
      userAgent: options2.userAgent || getUserAgent(),
      extraHTTPHeaders: options2.extraHTTPHeaders,
      failOnStatusCode: !!options2.failOnStatusCode,
      ignoreHTTPSErrors: !!options2.ignoreHTTPSErrors,
      maxRedirects: options2.maxRedirects,
      httpCredentials: options2.httpCredentials,
      clientCertificates: options2.clientCertificates,
      proxy: options2.proxy
    };
    this._tracing = new Tracing(this, options2.tracesDir);
  }
  tracing() {
    return this._tracing;
  }
  async dispose(options2) {
    this._closeReason = options2.reason;
    await this._tracing.flush();
    await this._tracing.deleteTmpTracesDir();
    this._disposeImpl();
  }
  _defaultOptions() {
    return this._options;
  }
  async _addCookies(cookies) {
    this._cookieStore.addCookies(cookies);
  }
  async _cookies(url4) {
    return this._cookieStore.cookies(url4);
  }
  async storageState(progress3, indexedDB = false) {
    return {
      cookies: this._cookieStore.allCookies(),
      origins: (this._origins || []).map((origin) => ({ ...origin, indexedDB: indexedDB ? origin.indexedDB : [] }))
    };
  }
};
function toHeadersArray(rawHeaders) {
  const result = [];
  for (let i = 0; i < rawHeaders.length; i += 2)
    result.push({ name: rawHeaders[i], value: rawHeaders[i + 1] });
  return result;
}
__name(toHeadersArray, "toHeadersArray");
var redirectStatus = [301, 302, 303, 307, 308];
function parseCookie2(header) {
  const raw = parseRawCookie(header);
  if (!raw)
    return null;
  const cookie = {
    domain: "",
    path: "",
    expires: -1,
    httpOnly: false,
    secure: false,
    // From https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
    // The cookie-sending behavior if SameSite is not specified is SameSite=Lax.
    sameSite: "Lax",
    ...raw
  };
  return cookie;
}
__name(parseCookie2, "parseCookie");
function serializePostData(params, headers) {
  assert3((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
  if (params.jsonData !== void 0) {
    setHeader(headers, "content-type", "application/json", true);
    return Buffer.from(params.jsonData, "utf8");
  } else if (params.formData) {
    const searchParams = new URLSearchParams();
    for (const { name, value } of params.formData)
      searchParams.append(name, value);
    setHeader(headers, "content-type", "application/x-www-form-urlencoded", true);
    return Buffer.from(searchParams.toString(), "utf8");
  } else if (params.multipartData) {
    const formData = new MultipartFormData();
    for (const field of params.multipartData) {
      if (field.file)
        formData.addFileField(field.name, field.file);
      else if (field.value)
        formData.addField(field.name, field.value);
    }
    setHeader(headers, "content-type", formData.contentTypeHeader(), true);
    return formData.finish();
  } else if (params.postData !== void 0) {
    setHeader(headers, "content-type", "application/octet-stream", true);
    return params.postData;
  }
  return void 0;
}
__name(serializePostData, "serializePostData");
function setHeader(headers, name, value, keepExisting = false) {
  const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
  if (!existing)
    headers[name] = value;
  else if (!keepExisting)
    headers[existing[0]] = value;
}
__name(setHeader, "setHeader");
function getHeader(headers, name) {
  const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
  return existing ? existing[1] : void 0;
}
__name(getHeader, "getHeader");
function removeHeader(headers, name) {
  delete headers[name];
}
__name(removeHeader, "removeHeader");
function setBasicAuthorizationHeader(headers, credentials) {
  const { username, password } = credentials;
  const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
  setHeader(headers, "authorization", `Basic ${encoded}`);
}
__name(setBasicAuthorizationHeader, "setBasicAuthorizationHeader");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/androidDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/browserContextDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs25 from "node:fs";
import path18 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/artifactDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs21 from "node:fs";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/streamDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StreamSdkObject = class extends SdkObject {
  static {
    __name(this, "StreamSdkObject");
  }
  constructor(parent, stream) {
    super(parent, "stream");
    this.stream = stream;
  }
};
var StreamDispatcher = class extends Dispatcher {
  static {
    __name(this, "StreamDispatcher");
  }
  constructor(scope, stream) {
    super(scope, new StreamSdkObject(scope._object, stream), "Stream", {});
    this._type_Stream = true;
    this._ended = false;
    stream.once("end", () => this._ended = true);
    stream.once("error", () => this._ended = true);
  }
  async read(params, progress3) {
    const stream = this._object.stream;
    if (this._ended)
      return { binary: Buffer.from("") };
    if (!stream.readableLength) {
      const readyPromise = new ManualPromise();
      const done = /* @__PURE__ */ __name(() => readyPromise.resolve(), "done");
      stream.on("readable", done);
      stream.on("end", done);
      stream.on("error", done);
      await progress3.race(readyPromise).finally(() => {
        stream.off("readable", done);
        stream.off("end", done);
        stream.off("error", done);
      });
    }
    const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
    return { binary: buffer || Buffer.from("") };
  }
  async close(params, progress3) {
    this._object.stream.destroy();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/artifactDispatcher.js
var ArtifactDispatcher = class _ArtifactDispatcher extends Dispatcher {
  static {
    __name(this, "ArtifactDispatcher");
  }
  constructor(scope, artifact) {
    super(scope, artifact, "Artifact", {
      absolutePath: artifact.localPath()
    });
    this._type_Artifact = true;
  }
  static from(parentScope, artifact) {
    return _ArtifactDispatcher.fromNullable(parentScope, artifact);
  }
  static fromNullable(parentScope, artifact) {
    if (!artifact)
      return void 0;
    const result = parentScope.connection.existingDispatcher(artifact);
    return result || new _ArtifactDispatcher(parentScope, artifact);
  }
  async pathAfterFinished(params, progress3) {
    const path30 = await progress3.race(this._object.localPathAfterFinished());
    return { value: path30 };
  }
  async saveAs(params, progress3) {
    return await progress3.race(new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error3) => {
        if (error3) {
          reject(error3);
          return;
        }
        try {
          await mkdirIfNeeded(params.path);
          await fs21.promises.copyFile(localPath, params.path);
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    }));
  }
  async saveAsStream(params, progress3) {
    return await progress3.race(new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error3) => {
        if (error3) {
          reject(error3);
          return;
        }
        try {
          const readable = fs21.createReadStream(localPath, { highWaterMark: 1024 * 1024 });
          const stream = new StreamDispatcher(this, readable);
          resolve({ stream });
          await new Promise((resolve2) => {
            readable.on("close", resolve2);
            readable.on("end", resolve2);
            readable.on("error", resolve2);
          });
        } catch (e) {
          reject(e);
        }
      });
    }));
  }
  async stream(params, progress3) {
    const fileName = await progress3.race(this._object.localPathAfterFinished());
    const readable = fs21.createReadStream(fileName, { highWaterMark: 1024 * 1024 });
    return { stream: new StreamDispatcher(this, readable) };
  }
  async failure(params, progress3) {
    const error3 = await progress3.race(this._object.failureError());
    return { error: error3 || void 0 };
  }
  async cancel(params, progress3) {
    await progress3.race(this._object.cancel());
  }
  async delete(params, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    await progress3.race(this._object.delete());
    this._dispose();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/cdpSessionDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crConnection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var ConnectionEvents = {
  Disconnected: Symbol("ConnectionEvents.Disconnected")
};
var kBrowserCloseMessageId = -9999;
var CRConnection = class extends SdkObject {
  static {
    __name(this, "CRConnection");
  }
  constructor(parent, transport, protocolLogger, browserLogsCollector) {
    super(parent, "cr-connection");
    this._lastId = 0;
    this._sessions = /* @__PURE__ */ new Map();
    this._closed = false;
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.rootSession = new CRSession(this, null, "");
    this._sessions.set("", this.rootSession);
    this._transport.onmessage = this._onMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  _rawSend(sessionId, method, params) {
    const id = ++this._lastId;
    const message = { id, method, params };
    if (sessionId)
      message.sessionId = sessionId;
    this._protocolLogger("send", message);
    this._transport.send(message);
    return id;
  }
  async _onMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId)
      return;
    const session2 = this._sessions.get(message.sessionId || "");
    if (session2)
      session2._onMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.rootSession.dispose();
    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  async createBrowserSession() {
    const { sessionId } = await this.rootSession.send("Target.attachToBrowserTarget");
    return new CDPSession(this.rootSession, sessionId);
  }
};
var CRSession = class _CRSession extends SdkObject {
  static {
    __name(this, "CRSession");
  }
  constructor(connection, parentSession, sessionId, eventListener) {
    super(connection, "cr-session");
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this._closed = false;
    this.setMaxListeners(0);
    this._connection = connection;
    this._parentSession = parentSession;
    this._sessionId = sessionId;
    this._eventListener = eventListener;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  _markAsCrashed() {
    this._crashed = true;
  }
  createChildSession(sessionId, eventListener) {
    const session2 = new _CRSession(this._connection, this, sessionId, eventListener);
    this._connection._sessions.set(sessionId, session2);
    return session2;
  }
  async send(method, params) {
    if (this._crashed || this._closed || this._connection._closed || this._connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this._connection._browserDisconnectedLogs);
    const id = this._connection._rawSend(this._sessionId, method, params);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  _sendMayFail(method, params) {
    return this.send(method, params).catch((error3) => debugLogger.log("error", error3));
  }
  _onMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error) {
        callback.error.setMessage(object.error.message);
        callback.reject(callback.error);
      } else {
        callback.resolve(object.result);
      }
    } else if (object.id && object.error?.code === -32001) ;
    else {
      assert3(!object.id, object?.error?.message || void 0);
      Promise.resolve().then(() => {
        if (this._eventListener)
          this._eventListener(object.method, object.params);
        this.emit(object.method, object.params);
      });
    }
  }
  async detach() {
    if (this._closed)
      throw new Error(`Session already detached. Most likely the page has been closed.`);
    if (!this._parentSession)
      throw new Error("Root session cannot be closed");
    await this._sendMayFail("Runtime.runIfWaitingForDebugger");
    await this._parentSession.send("Target.detachFromTarget", { sessionId: this._sessionId });
    this.dispose();
  }
  dispose() {
    this._closed = true;
    this._connection._sessions.delete(this._sessionId);
    for (const callback of this._callbacks.values()) {
      callback.error.setMessage(`Internal server error, session closed.`);
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this._connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
};
var CDPSession = class _CDPSession extends SdkObject {
  static {
    __name(this, "CDPSession");
  }
  constructor(parentSession, sessionId) {
    super(parentSession, "cdp-session");
    this._listeners = [];
    this._session = parentSession.createChildSession(sessionId, (method, params) => this.emit(_CDPSession.Events.Event, { method, params }));
    this._listeners = [eventsHelper.addEventListener(parentSession, "Target.detachedFromTarget", (event) => {
      if (event.sessionId === sessionId)
        this._onClose();
    })];
  }
  static {
    this.Events = {
      Event: "event",
      Closed: "close"
    };
  }
  async send(method, params) {
    return await this._session.send(method, params);
  }
  async detach() {
    return await this._session.detach();
  }
  async attachToTarget(targetId) {
    const { sessionId } = await this.send("Target.attachToTarget", { targetId, flatten: true });
    return new _CDPSession(this._session, sessionId);
  }
  _onClose() {
    eventsHelper.removeEventListeners(this._listeners);
    this._session.dispose();
    this.emit(_CDPSession.Events.Closed);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/cdpSessionDispatcher.js
var CDPSessionDispatcher = class extends Dispatcher {
  static {
    __name(this, "CDPSessionDispatcher");
  }
  constructor(scope, cdpSession) {
    super(scope, cdpSession, "CDPSession", {});
    this._type_CDPSession = true;
    this.addObjectListener(CDPSession.Events.Event, ({ method, params }) => this._dispatchEvent("event", { method, params }));
    this.addObjectListener(CDPSession.Events.Closed, () => this._dispose());
  }
  async send(params, progress3) {
    return { result: await progress3.race(this._object.send(params.method, params.params)) };
  }
  async detach(_, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    await this._object.detach();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/dialogDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/pageDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/elementHandlerDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/frameDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/jsHandleDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSHandleDispatcher = class _JSHandleDispatcher extends Dispatcher {
  static {
    __name(this, "JSHandleDispatcher");
  }
  constructor(scope, jsHandle) {
    super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
      preview: jsHandle.toString()
    });
    this._type_JSHandle = true;
    jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", { preview }));
  }
  static fromJSHandle(scope, handle) {
    return scope.connection.existingDispatcher(handle) || new _JSHandleDispatcher(scope, handle);
  }
  async evaluateExpression(params, progress3) {
    const jsHandle = await progress3.race(this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)));
    return { value: serializeResult(jsHandle) };
  }
  async evaluateExpressionHandle(params, progress3) {
    const jsHandle = await progress3.race(this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)));
    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this.parentScope(), jsHandle) };
  }
  async getProperty(params, progress3) {
    const jsHandle = await progress3.race(this._object.getProperty(params.name));
    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this.parentScope(), jsHandle) };
  }
  async getPropertyList(params, progress3) {
    const map2 = await progress3.race(this._object.getProperties());
    const properties = [];
    for (const [name, value] of map2) {
      properties.push({ name, value: ElementHandleDispatcher.fromJSOrElementHandle(this.parentScope(), value) });
    }
    return { properties };
  }
  async jsonValue(params, progress3) {
    return { value: serializeResult(await progress3.race(this._object.jsonValue())) };
  }
  async dispose(_, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    this._object.dispose();
    this._dispose();
  }
};
function parseArgument(arg) {
  return parseSerializedValue(arg.value, arg.handles.map((a) => a._object));
}
__name(parseArgument, "parseArgument");
function serializeResult(arg) {
  return serializeValue(arg, (value) => ({ fallThrough: value }));
}
__name(serializeResult, "serializeResult");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/networkDispatchers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/tracingDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TracingDispatcher = class _TracingDispatcher extends Dispatcher {
  static {
    __name(this, "TracingDispatcher");
  }
  constructor(scope, tracing) {
    super(scope, tracing, "Tracing", {});
    this._type_Tracing = true;
    this._started = false;
  }
  static from(scope, tracing) {
    const result = scope.connection.existingDispatcher(tracing);
    return result || new _TracingDispatcher(scope, tracing);
  }
  async tracingStart(params, progress3) {
    this._object.start(params);
    this._started = true;
  }
  async tracingStartChunk(params, progress3) {
    return await this._object.startChunk(progress3, params);
  }
  async tracingGroup(params, progress3) {
    const { name, location: location2 } = params;
    this._object.group(name, location2, progress3.metadata);
  }
  async tracingGroupEnd(params, progress3) {
    this._object.groupEnd();
  }
  async tracingStopChunk(params, progress3) {
    const { artifact, entries } = await this._object.stopChunk(progress3, params);
    return { artifact: artifact ? ArtifactDispatcher.from(this, artifact) : void 0, entries };
  }
  async tracingStop(params, progress3) {
    this._started = false;
    await this._object.stop(progress3);
  }
  _onDispose() {
    if (this._started)
      this._object.stopChunk(void 0, { mode: "discard" }).then(() => this._object.stop(void 0)).catch(() => {
      });
    this._started = false;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/networkDispatchers.js
var RequestDispatcher = class _RequestDispatcher extends Dispatcher {
  static {
    __name(this, "RequestDispatcher");
  }
  static from(scope, request2) {
    const result = scope.connection.existingDispatcher(request2);
    return result || new _RequestDispatcher(scope, request2);
  }
  static fromNullable(scope, request2) {
    return request2 ? _RequestDispatcher.from(scope, request2) : void 0;
  }
  constructor(scope, request2) {
    const postData = request2.postDataBuffer();
    const frame = request2.frame();
    const page = request2.frame()?._page;
    const pageDispatcher = page ? scope.connection.existingDispatcher(page) : null;
    const frameDispatcher = frame ? FrameDispatcher.from(scope, frame) : null;
    super(pageDispatcher || frameDispatcher || scope, request2, "Request", {
      frame: FrameDispatcher.fromNullable(scope, request2.frame()),
      serviceWorker: WorkerDispatcher.fromNullable(scope, request2.serviceWorker()),
      url: request2.url(),
      resourceType: request2.resourceType(),
      method: request2.method(),
      postData: postData === null ? void 0 : postData,
      headers: request2.headers(),
      isNavigationRequest: request2.isNavigationRequest(),
      redirectedFrom: _RequestDispatcher.fromNullable(scope, request2.redirectedFrom())
    });
    this._type_Request = true;
    this._browserContextDispatcher = scope;
  }
  async rawRequestHeaders(params, progress3) {
    return { headers: await progress3.race(this._object.rawRequestHeaders()) };
  }
  async response(params, progress3) {
    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await progress3.race(this._object.response())) };
  }
};
var ResponseDispatcher = class _ResponseDispatcher extends Dispatcher {
  static {
    __name(this, "ResponseDispatcher");
  }
  constructor(scope, response) {
    super(scope, response, "Response", {
      // TODO: responses in popups can point to non-reported requests.
      request: scope,
      url: response.url(),
      status: response.status(),
      statusText: response.statusText(),
      headers: response.headers(),
      timing: response.timing(),
      fromServiceWorker: response.fromServiceWorker()
    });
    this._type_Response = true;
  }
  static from(scope, response) {
    const result = scope.connection.existingDispatcher(response);
    const requestDispatcher = RequestDispatcher.from(scope, response.request());
    return result || new _ResponseDispatcher(requestDispatcher, response);
  }
  static fromNullable(scope, response) {
    return response ? _ResponseDispatcher.from(scope, response) : void 0;
  }
  async body(params, progress3) {
    return { binary: await progress3.race(this._object.body()) };
  }
  async securityDetails(params, progress3) {
    return { value: await progress3.race(this._object.securityDetails()) || void 0 };
  }
  async serverAddr(params, progress3) {
    return { value: await progress3.race(this._object.serverAddr()) || void 0 };
  }
  async rawResponseHeaders(params, progress3) {
    return { headers: await progress3.race(this._object.rawResponseHeaders()) };
  }
  async sizes(params, progress3) {
    return { sizes: await progress3.race(this._object.sizes()) };
  }
};
var RouteDispatcher = class extends Dispatcher {
  static {
    __name(this, "RouteDispatcher");
  }
  constructor(scope, route) {
    super(scope, route, "Route", {
      // Context route can point to a non-reported request, so we send the request in the initializer.
      request: scope
    });
    this._type_Route = true;
    this._handled = false;
  }
  _checkNotHandled() {
    if (this._handled)
      throw new Error("Route is already handled!");
    this._handled = true;
  }
  async continue(params, progress3) {
    this._checkNotHandled();
    await this._object.continue({
      url: params.url,
      method: params.method,
      headers: params.headers,
      postData: params.postData,
      isFallback: params.isFallback
    });
  }
  async fulfill(params, progress3) {
    this._checkNotHandled();
    await this._object.fulfill(params);
  }
  async abort(params, progress3) {
    this._checkNotHandled();
    await this._object.abort(params.errorCode || "failed");
  }
  async redirectNavigationRequest(params, progress3) {
    this._checkNotHandled();
    this._object.redirectNavigationRequest(params.url);
  }
};
var WebSocketDispatcher = class extends Dispatcher {
  static {
    __name(this, "WebSocketDispatcher");
  }
  constructor(scope, webSocket) {
    super(scope, webSocket, "WebSocket", {
      url: webSocket.url()
    });
    this._type_EventTarget = true;
    this._type_WebSocket = true;
    this.addObjectListener(WebSocket2.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
    this.addObjectListener(WebSocket2.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
    this.addObjectListener(WebSocket2.Events.SocketError, (error3) => this._dispatchEvent("socketError", { error: error3 }));
    this.addObjectListener(WebSocket2.Events.Close, () => this._dispatchEvent("close", {}));
  }
};
var APIRequestContextDispatcher = class _APIRequestContextDispatcher extends Dispatcher {
  static {
    __name(this, "APIRequestContextDispatcher");
  }
  constructor(parentScope, request2) {
    const tracing = TracingDispatcher.from(parentScope, request2.tracing());
    super(parentScope, request2, "APIRequestContext", {
      tracing
    });
    this._type_APIRequestContext = true;
    this.adopt(tracing);
  }
  static from(scope, request2) {
    const result = scope.connection.existingDispatcher(request2);
    return result || new _APIRequestContextDispatcher(scope, request2);
  }
  static fromNullable(scope, request2) {
    return request2 ? _APIRequestContextDispatcher.from(scope, request2) : void 0;
  }
  async storageState(params, progress3) {
    return await this._object.storageState(progress3, params.indexedDB);
  }
  async dispose(params, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    await this._object.dispose(params);
    this._dispose();
  }
  async fetch(params, progress3) {
    const fetchResponse = await this._object.fetch(progress3, params);
    return {
      response: {
        url: fetchResponse.url,
        status: fetchResponse.status,
        statusText: fetchResponse.statusText,
        headers: fetchResponse.headers,
        fetchUid: fetchResponse.fetchUid
      }
    };
  }
  async fetchResponseBody(params, progress3) {
    return { binary: this._object.fetchResponses.get(params.fetchUid) };
  }
  async fetchLog(params, progress3) {
    const log3 = this._object.fetchLog.get(params.fetchUid) || [];
    return { log: log3 };
  }
  async disposeAPIResponse(params, progress3) {
    this._object.disposeResponse(params.fetchUid);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/ariaSnapshot.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseAriaSnapshotUnsafe(yaml3, text, options2 = {}) {
  const result = parseAriaSnapshot(yaml3, text, options2);
  if (result.errors.length)
    throw new Error(result.errors[0].message);
  return result.fragment;
}
__name(parseAriaSnapshotUnsafe, "parseAriaSnapshotUnsafe");
function parseAriaSnapshot(yaml3, text, options2 = {}) {
  const lineCounter = new yaml3.LineCounter();
  const parseOptions2 = {
    keepSourceTokens: true,
    lineCounter,
    ...options2
  };
  const yamlDoc = yaml3.parseDocument(text, parseOptions2);
  const errors2 = [];
  const convertRange = /* @__PURE__ */ __name((range) => {
    return [lineCounter.linePos(range[0]), lineCounter.linePos(range[1])];
  }, "convertRange");
  const addError = /* @__PURE__ */ __name((error3) => {
    errors2.push({
      message: error3.message,
      range: [lineCounter.linePos(error3.pos[0]), lineCounter.linePos(error3.pos[1])]
    });
  }, "addError");
  const convertSeq = /* @__PURE__ */ __name((container, seq2) => {
    for (const item of seq2.items) {
      const itemIsString = item instanceof yaml3.Scalar && typeof item.value === "string";
      if (itemIsString) {
        const childNode = KeyParser.parse(item, parseOptions2, errors2);
        if (childNode) {
          container.children = container.children || [];
          container.children.push(childNode);
        }
        continue;
      }
      const itemIsMap = item instanceof yaml3.YAMLMap;
      if (itemIsMap) {
        convertMap(container, item);
        continue;
      }
      errors2.push({
        message: "Sequence items should be strings or maps",
        range: convertRange(item.range || seq2.range)
      });
    }
  }, "convertSeq");
  const convertMap = /* @__PURE__ */ __name((container, map2) => {
    for (const entry of map2.items) {
      container.children = container.children || [];
      const keyIsString = entry.key instanceof yaml3.Scalar && typeof entry.key.value === "string";
      if (!keyIsString) {
        errors2.push({
          message: "Only string keys are supported",
          range: convertRange(entry.key.range || map2.range)
        });
        continue;
      }
      const key = entry.key;
      const value = entry.value;
      if (key.value === "text") {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString) {
          errors2.push({
            message: "Text value should be a string",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.children.push({
          kind: "text",
          text: valueOrRegex(value.value)
        });
        continue;
      }
      if (key.value === "/children") {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString || value.value !== "contain" && value.value !== "equal" && value.value !== "deep-equal") {
          errors2.push({
            message: 'Strict value should be "contain", "equal" or "deep-equal"',
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.containerMode = value.value;
        continue;
      }
      if (key.value.startsWith("/")) {
        const valueIsString = value instanceof yaml3.Scalar && typeof value.value === "string";
        if (!valueIsString) {
          errors2.push({
            message: "Property value should be a string",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.props = container.props ?? {};
        container.props[key.value.slice(1)] = valueOrRegex(value.value);
        continue;
      }
      const childNode = KeyParser.parse(key, parseOptions2, errors2);
      if (!childNode)
        continue;
      const valueIsScalar = value instanceof yaml3.Scalar;
      if (valueIsScalar) {
        const type = typeof value.value;
        if (type !== "string" && type !== "number" && type !== "boolean") {
          errors2.push({
            message: "Node value should be a string or a sequence",
            range: convertRange(entry.value.range || map2.range)
          });
          continue;
        }
        container.children.push({
          ...childNode,
          children: [{
            kind: "text",
            text: valueOrRegex(String(value.value))
          }]
        });
        continue;
      }
      const valueIsSequence = value instanceof yaml3.YAMLSeq;
      if (valueIsSequence) {
        container.children.push(childNode);
        convertSeq(childNode, value);
        continue;
      }
      errors2.push({
        message: "Map values should be strings or sequences",
        range: convertRange(entry.value.range || map2.range)
      });
    }
  }, "convertMap");
  const fragment = { kind: "role", role: "fragment" };
  yamlDoc.errors.forEach(addError);
  if (errors2.length)
    return { errors: errors2, fragment };
  if (!(yamlDoc.contents instanceof yaml3.YAMLSeq)) {
    errors2.push({
      message: 'Aria snapshot must be a YAML sequence, elements starting with " -"',
      range: yamlDoc.contents ? convertRange(yamlDoc.contents.range) : [{ line: 0, col: 0 }, { line: 0, col: 0 }]
    });
  }
  if (errors2.length)
    return { errors: errors2, fragment };
  convertSeq(fragment, yamlDoc.contents);
  if (errors2.length)
    return { errors: errors2, fragment: emptyFragment };
  if (fragment.children?.length === 1 && (!fragment.containerMode || fragment.containerMode === "contain"))
    return { fragment: fragment.children[0], errors: [] };
  return { fragment, errors: [] };
}
__name(parseAriaSnapshot, "parseAriaSnapshot");
var emptyFragment = { kind: "role", role: "fragment" };
function normalizeWhitespace(text) {
  return text.replace(/[\u200b\u00ad]/g, "").replace(/[\r\n\s\t]+/g, " ").trim();
}
__name(normalizeWhitespace, "normalizeWhitespace");
function valueOrRegex(value) {
  return value.startsWith("/") && value.endsWith("/") && value.length > 1 ? { pattern: value.slice(1, -1) } : normalizeWhitespace(value);
}
__name(valueOrRegex, "valueOrRegex");
var KeyParser = class _KeyParser {
  static {
    __name(this, "KeyParser");
  }
  static parse(text, options2, errors2) {
    try {
      return new _KeyParser(text.value, options2)._parse();
    } catch (e) {
      if (e instanceof ParserError) {
        const message = options2.prettyErrors === false ? e.message : e.message + ":\n\n" + text.value + "\n" + " ".repeat(e.pos) + "^\n";
        errors2.push({
          message,
          range: [options2.lineCounter.linePos(text.range[0]), options2.lineCounter.linePos(text.range[0] + e.pos)]
        });
        return null;
      }
      throw e;
    }
  }
  constructor(input, options2) {
    this._input = input;
    this._pos = 0;
    this._length = input.length;
    this._options = options2;
  }
  _peek() {
    return this._input[this._pos] || "";
  }
  _next() {
    if (this._pos < this._length)
      return this._input[this._pos++];
    return null;
  }
  _eof() {
    return this._pos >= this._length;
  }
  _isWhitespace() {
    return !this._eof() && /\s/.test(this._peek());
  }
  _skipWhitespace() {
    while (this._isWhitespace())
      this._pos++;
  }
  _readIdentifier(type) {
    if (this._eof())
      this._throwError(`Unexpected end of input when expecting ${type}`);
    const start = this._pos;
    while (!this._eof() && /[a-zA-Z]/.test(this._peek()))
      this._pos++;
    return this._input.slice(start, this._pos);
  }
  _readString() {
    let result = "";
    let escaped2 = false;
    while (!this._eof()) {
      const ch = this._next();
      if (escaped2) {
        result += ch;
        escaped2 = false;
      } else if (ch === "\\") {
        escaped2 = true;
      } else if (ch === '"') {
        return result;
      } else {
        result += ch;
      }
    }
    this._throwError("Unterminated string");
  }
  _throwError(message, offset = 0) {
    throw new ParserError(message, offset || this._pos);
  }
  _readRegex() {
    let result = "";
    let escaped2 = false;
    let insideClass = false;
    while (!this._eof()) {
      const ch = this._next();
      if (escaped2) {
        result += ch;
        escaped2 = false;
      } else if (ch === "\\") {
        escaped2 = true;
        result += ch;
      } else if (ch === "/" && !insideClass) {
        return { pattern: result };
      } else if (ch === "[") {
        insideClass = true;
        result += ch;
      } else if (ch === "]" && insideClass) {
        result += ch;
        insideClass = false;
      } else {
        result += ch;
      }
    }
    this._throwError("Unterminated regex");
  }
  _readStringOrRegex() {
    const ch = this._peek();
    if (ch === '"') {
      this._next();
      return normalizeWhitespace(this._readString());
    }
    if (ch === "/") {
      this._next();
      return this._readRegex();
    }
    return null;
  }
  _readAttributes(result) {
    let errorPos = this._pos;
    while (true) {
      this._skipWhitespace();
      if (this._peek() === "[") {
        this._next();
        this._skipWhitespace();
        errorPos = this._pos;
        const flagName = this._readIdentifier("attribute");
        this._skipWhitespace();
        let flagValue = "";
        if (this._peek() === "=") {
          this._next();
          this._skipWhitespace();
          errorPos = this._pos;
          while (this._peek() !== "]" && !this._isWhitespace() && !this._eof())
            flagValue += this._next();
        }
        this._skipWhitespace();
        if (this._peek() !== "]")
          this._throwError("Expected ]");
        this._next();
        this._applyAttribute(result, flagName, flagValue || "true", errorPos);
      } else {
        break;
      }
    }
  }
  _parse() {
    this._skipWhitespace();
    const role = this._readIdentifier("role");
    this._skipWhitespace();
    const name = this._readStringOrRegex() || "";
    const result = { kind: "role", role, name };
    this._readAttributes(result);
    this._skipWhitespace();
    if (!this._eof())
      this._throwError("Unexpected input");
    return result;
  }
  _applyAttribute(node, key, value, errorPos) {
    if (key === "checked") {
      this._assert(value === "true" || value === "false" || value === "mixed", 'Value of "checked" attribute must be a boolean or "mixed"', errorPos);
      node.checked = value === "true" ? true : value === "false" ? false : "mixed";
      return;
    }
    if (key === "disabled") {
      this._assert(value === "true" || value === "false", 'Value of "disabled" attribute must be a boolean', errorPos);
      node.disabled = value === "true";
      return;
    }
    if (key === "expanded") {
      this._assert(value === "true" || value === "false", 'Value of "expanded" attribute must be a boolean', errorPos);
      node.expanded = value === "true";
      return;
    }
    if (key === "active") {
      this._assert(value === "true" || value === "false", 'Value of "active" attribute must be a boolean', errorPos);
      node.active = value === "true";
      return;
    }
    if (key === "level") {
      this._assert(!isNaN(Number(value)), 'Value of "level" attribute must be a number', errorPos);
      node.level = Number(value);
      return;
    }
    if (key === "pressed") {
      this._assert(value === "true" || value === "false" || value === "mixed", 'Value of "pressed" attribute must be a boolean or "mixed"', errorPos);
      node.pressed = value === "true" ? true : value === "false" ? false : "mixed";
      return;
    }
    if (key === "selected") {
      this._assert(value === "true" || value === "false", 'Value of "selected" attribute must be a boolean', errorPos);
      node.selected = value === "true";
      return;
    }
    this._assert(false, `Unsupported attribute [${key}]`, errorPos);
  }
  _assert(value, message, valuePos) {
    if (!value)
      this._throwError(message || "Assertion error", valuePos);
  }
};
var ParserError = class extends Error {
  static {
    __name(this, "ParserError");
  }
  constructor(message, pos) {
    super(message);
    this.pos = pos;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/frameDispatcher.js
var FrameDispatcher = class _FrameDispatcher extends Dispatcher {
  static {
    __name(this, "FrameDispatcher");
  }
  constructor(scope, frame) {
    const gcBucket = frame._page.mainFrame() === frame ? "MainFrame" : "Frame";
    const pageDispatcher = scope.connection.existingDispatcher(frame._page);
    super(pageDispatcher || scope, frame, "Frame", {
      url: frame.url(),
      name: frame.name(),
      parentFrame: _FrameDispatcher.fromNullable(scope, frame.parentFrame()),
      loadStates: Array.from(frame._firedLifecycleEvents)
    }, gcBucket);
    this._type_Frame = true;
    this._browserContextDispatcher = scope;
    this._frame = frame;
    this.addObjectListener(Frame.Events.AddLifecycle, (lifecycleEvent) => {
      this._dispatchEvent("loadstate", { add: lifecycleEvent });
    });
    this.addObjectListener(Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
      this._dispatchEvent("loadstate", { remove: lifecycleEvent });
    });
    this.addObjectListener(Frame.Events.InternalNavigation, (event) => {
      if (!event.isPublic)
        return;
      const params = { url: event.url, name: event.name, error: event.error ? event.error.message : void 0 };
      if (event.newDocument)
        params.newDocument = { request: RequestDispatcher.fromNullable(this._browserContextDispatcher, event.newDocument.request || null) };
      this._dispatchEvent("navigated", params);
    });
  }
  static from(scope, frame) {
    const result = scope.connection.existingDispatcher(frame);
    return result || new _FrameDispatcher(scope, frame);
  }
  static fromNullable(scope, frame) {
    if (!frame)
      return;
    return _FrameDispatcher.from(scope, frame);
  }
  async goto(params, progress3) {
    return { response: ResponseDispatcher.fromNullable(this._browserContextDispatcher, await this._frame.goto(progress3, params.url, params)) };
  }
  async frameElement(params, progress3) {
    return { element: ElementHandleDispatcher.from(this, await progress3.race(this._frame.frameElement())) };
  }
  async evaluateExpression(params, progress3) {
    return { value: serializeResult(await progress3.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
  }
  async evaluateExpressionHandle(params, progress3) {
    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress3.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
  }
  async waitForSelector(params, progress3) {
    return { element: ElementHandleDispatcher.fromNullable(this, await this._frame.waitForSelector(progress3, params.selector, true, params)) };
  }
  async dispatchEvent(params, progress3) {
    return this._frame.dispatchEvent(progress3, params.selector, params.type, parseArgument(params.eventInit), params);
  }
  async evalOnSelector(params, progress3) {
    return { value: serializeResult(await progress3.race(this._frame.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
  async evalOnSelectorAll(params, progress3) {
    return { value: serializeResult(await progress3.race(this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
  async querySelector(params, progress3) {
    return { element: ElementHandleDispatcher.fromNullable(this, await progress3.race(this._frame.querySelector(params.selector, params))) };
  }
  async querySelectorAll(params, progress3) {
    const elements = await progress3.race(this._frame.querySelectorAll(params.selector));
    return { elements: elements.map((e) => ElementHandleDispatcher.from(this, e)) };
  }
  async queryCount(params, progress3) {
    return { value: await progress3.race(this._frame.queryCount(params.selector, params)) };
  }
  async content(params, progress3) {
    return { value: await progress3.race(this._frame.content()) };
  }
  async setContent(params, progress3) {
    return await this._frame.setContent(progress3, params.html, params);
  }
  async addScriptTag(params, progress3) {
    return { element: ElementHandleDispatcher.from(this, await progress3.race(this._frame.addScriptTag(params))) };
  }
  async addStyleTag(params, progress3) {
    return { element: ElementHandleDispatcher.from(this, await progress3.race(this._frame.addStyleTag(params))) };
  }
  async click(params, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    return await this._frame.click(progress3, params.selector, params);
  }
  async dblclick(params, progress3) {
    return await this._frame.dblclick(progress3, params.selector, params);
  }
  async dragAndDrop(params, progress3) {
    return await this._frame.dragAndDrop(progress3, params.source, params.target, params);
  }
  async tap(params, progress3) {
    return await this._frame.tap(progress3, params.selector, params);
  }
  async fill(params, progress3) {
    return await this._frame.fill(progress3, params.selector, params.value, params);
  }
  async focus(params, progress3) {
    await this._frame.focus(progress3, params.selector, params);
  }
  async blur(params, progress3) {
    await this._frame.blur(progress3, params.selector, params);
  }
  async textContent(params, progress3) {
    const value = await this._frame.textContent(progress3, params.selector, params);
    return { value: value === null ? void 0 : value };
  }
  async innerText(params, progress3) {
    return { value: await this._frame.innerText(progress3, params.selector, params) };
  }
  async innerHTML(params, progress3) {
    return { value: await this._frame.innerHTML(progress3, params.selector, params) };
  }
  async resolveSelector(params, progress3) {
    return await this._frame.resolveSelector(progress3, params.selector);
  }
  async getAttribute(params, progress3) {
    const value = await this._frame.getAttribute(progress3, params.selector, params.name, params);
    return { value: value === null ? void 0 : value };
  }
  async inputValue(params, progress3) {
    const value = await this._frame.inputValue(progress3, params.selector, params);
    return { value };
  }
  async isChecked(params, progress3) {
    return { value: await this._frame.isChecked(progress3, params.selector, params) };
  }
  async isDisabled(params, progress3) {
    return { value: await this._frame.isDisabled(progress3, params.selector, params) };
  }
  async isEditable(params, progress3) {
    return { value: await this._frame.isEditable(progress3, params.selector, params) };
  }
  async isEnabled(params, progress3) {
    return { value: await this._frame.isEnabled(progress3, params.selector, params) };
  }
  async isHidden(params, progress3) {
    return { value: await this._frame.isHidden(progress3, params.selector, params) };
  }
  async isVisible(params, progress3) {
    return { value: await this._frame.isVisible(progress3, params.selector, params) };
  }
  async hover(params, progress3) {
    return await this._frame.hover(progress3, params.selector, params);
  }
  async selectOption(params, progress3) {
    const elements = (params.elements || []).map((e) => e._elementHandle);
    return { values: await this._frame.selectOption(progress3, params.selector, elements, params.options || [], params) };
  }
  async setInputFiles(params, progress3) {
    return await this._frame.setInputFiles(progress3, params.selector, params);
  }
  async type(params, progress3) {
    return await this._frame.type(progress3, params.selector, params.text, params);
  }
  async press(params, progress3) {
    return await this._frame.press(progress3, params.selector, params.key, params);
  }
  async check(params, progress3) {
    return await this._frame.check(progress3, params.selector, params);
  }
  async uncheck(params, progress3) {
    return await this._frame.uncheck(progress3, params.selector, params);
  }
  async waitForTimeout(params, progress3) {
    return await this._frame.waitForTimeout(progress3, params.waitTimeout);
  }
  async waitForFunction(params, progress3) {
    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await this._frame.waitForFunctionExpression(progress3, params.expression, params.isFunction, parseArgument(params.arg), params)) };
  }
  async title(params, progress3) {
    return { value: await progress3.race(this._frame.title()) };
  }
  async highlight(params, progress3) {
    return await this._frame.highlight(progress3, params.selector);
  }
  async expect(params, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    let expectedValue = params.expectedValue ? parseArgument(params.expectedValue) : void 0;
    if (params.expression === "to.match.aria" && expectedValue)
      expectedValue = parseAriaSnapshotUnsafe(yaml2, expectedValue);
    const result = await this._frame.expect(progress3, params.selector, { ...params, expectedValue }, params.timeout);
    if (result.received !== void 0)
      result.received = serializeResult(result.received);
    return result;
  }
  async ariaSnapshot(params, progress3) {
    return { snapshot: await this._frame.ariaSnapshot(progress3, params.selector) };
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/elementHandlerDispatcher.js
var ElementHandleDispatcher = class _ElementHandleDispatcher extends JSHandleDispatcher {
  static {
    __name(this, "ElementHandleDispatcher");
  }
  constructor(scope, elementHandle) {
    super(scope, elementHandle);
    this._type_ElementHandle = true;
    this._elementHandle = elementHandle;
  }
  static from(scope, handle) {
    return scope.connection.existingDispatcher(handle) || new _ElementHandleDispatcher(scope, handle);
  }
  static fromNullable(scope, handle) {
    if (!handle)
      return void 0;
    return scope.connection.existingDispatcher(handle) || new _ElementHandleDispatcher(scope, handle);
  }
  static fromJSOrElementHandle(scope, handle) {
    const result = scope.connection.existingDispatcher(handle);
    if (result)
      return result;
    const elementHandle = handle.asElement();
    if (!elementHandle)
      return new JSHandleDispatcher(scope, handle);
    return new _ElementHandleDispatcher(scope, elementHandle);
  }
  async ownerFrame(params, progress3) {
    const frame = await this._elementHandle.ownerFrame();
    return { frame: frame ? FrameDispatcher.from(this._browserContextDispatcher(), frame) : void 0 };
  }
  async contentFrame(params, progress3) {
    const frame = await progress3.race(this._elementHandle.contentFrame());
    return { frame: frame ? FrameDispatcher.from(this._browserContextDispatcher(), frame) : void 0 };
  }
  async getAttribute(params, progress3) {
    const value = await this._elementHandle.getAttribute(progress3, params.name);
    return { value: value === null ? void 0 : value };
  }
  async inputValue(params, progress3) {
    const value = await this._elementHandle.inputValue(progress3);
    return { value };
  }
  async textContent(params, progress3) {
    const value = await this._elementHandle.textContent(progress3);
    return { value: value === null ? void 0 : value };
  }
  async innerText(params, progress3) {
    return { value: await this._elementHandle.innerText(progress3) };
  }
  async innerHTML(params, progress3) {
    return { value: await this._elementHandle.innerHTML(progress3) };
  }
  async isChecked(params, progress3) {
    return { value: await this._elementHandle.isChecked(progress3) };
  }
  async isDisabled(params, progress3) {
    return { value: await this._elementHandle.isDisabled(progress3) };
  }
  async isEditable(params, progress3) {
    return { value: await this._elementHandle.isEditable(progress3) };
  }
  async isEnabled(params, progress3) {
    return { value: await this._elementHandle.isEnabled(progress3) };
  }
  async isHidden(params, progress3) {
    return { value: await this._elementHandle.isHidden(progress3) };
  }
  async isVisible(params, progress3) {
    return { value: await this._elementHandle.isVisible(progress3) };
  }
  async dispatchEvent(params, progress3) {
    await this._elementHandle.dispatchEvent(progress3, params.type, parseArgument(params.eventInit));
  }
  async scrollIntoViewIfNeeded(params, progress3) {
    await this._elementHandle.scrollIntoViewIfNeeded(progress3);
  }
  async hover(params, progress3) {
    return await this._elementHandle.hover(progress3, params);
  }
  async click(params, progress3) {
    return await this._elementHandle.click(progress3, params);
  }
  async dblclick(params, progress3) {
    return await this._elementHandle.dblclick(progress3, params);
  }
  async tap(params, progress3) {
    return await this._elementHandle.tap(progress3, params);
  }
  async selectOption(params, progress3) {
    const elements = (params.elements || []).map((e) => e._elementHandle);
    return { values: await this._elementHandle.selectOption(progress3, elements, params.options || [], params) };
  }
  async fill(params, progress3) {
    return await this._elementHandle.fill(progress3, params.value, params);
  }
  async selectText(params, progress3) {
    await this._elementHandle.selectText(progress3, params);
  }
  async setInputFiles(params, progress3) {
    return await this._elementHandle.setInputFiles(progress3, params);
  }
  async focus(params, progress3) {
    await this._elementHandle.focus(progress3);
  }
  async type(params, progress3) {
    return await this._elementHandle.type(progress3, params.text, params);
  }
  async press(params, progress3) {
    return await this._elementHandle.press(progress3, params.key, params);
  }
  async check(params, progress3) {
    return await this._elementHandle.check(progress3, params);
  }
  async uncheck(params, progress3) {
    return await this._elementHandle.uncheck(progress3, params);
  }
  async boundingBox(params, progress3) {
    const value = await progress3.race(this._elementHandle.boundingBox());
    return { value: value || void 0 };
  }
  async screenshot(params, progress3) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    return { binary: await this._elementHandle.screenshot(progress3, { ...params, mask }) };
  }
  async querySelector(params, progress3) {
    const handle = await progress3.race(this._elementHandle.querySelector(params.selector, params));
    return { element: _ElementHandleDispatcher.fromNullable(this.parentScope(), handle) };
  }
  async querySelectorAll(params, progress3) {
    const elements = await progress3.race(this._elementHandle.querySelectorAll(params.selector));
    return { elements: elements.map((e) => _ElementHandleDispatcher.from(this.parentScope(), e)) };
  }
  async evalOnSelector(params, progress3) {
    return { value: serializeResult(await progress3.race(this._elementHandle.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
  async evalOnSelectorAll(params, progress3) {
    return { value: serializeResult(await progress3.race(this._elementHandle.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
  async waitForElementState(params, progress3) {
    await this._elementHandle.waitForElementState(progress3, params.state);
  }
  async waitForSelector(params, progress3) {
    return { element: _ElementHandleDispatcher.fromNullable(this.parentScope(), await this._elementHandle.waitForSelector(progress3, params.selector, params)) };
  }
  _browserContextDispatcher() {
    const parentScope = this.parentScope().parentScope();
    if (parentScope instanceof BrowserContextDispatcher)
      return parentScope;
    return parentScope.parentScope();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/webSocketRouteDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/generated/webSocketMockSource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source7 = `
var __commonJS = obj => {
  let required = false;
  let result;
  return function __require() {
    if (!required) {
      required = true;
      let fn;
      for (const name in obj) { fn = obj[name]; break; }
      const module = { exports: {} };
      fn(module.exports, module);
      result = module.exports;
    }
    return result;
  }
};
var __export = (target, all) => {for (var name in all) target[name] = all[name];};
var __toESM = mod => ({ ...mod, 'default': mod });
var __toCommonJS = mod => ({ ...mod, __esModule: true });


// packages/injected/src/webSocketMock.ts
var webSocketMock_exports = {};
__export(webSocketMock_exports, {
  inject: () => inject
});
module.exports = __toCommonJS(webSocketMock_exports);
function inject(globalThis) {
  if (globalThis.__pwWebSocketDispatch)
    return;
  function generateId() {
    const bytes = new Uint8Array(32);
    globalThis.crypto.getRandomValues(bytes);
    const hex = "0123456789abcdef";
    return [...bytes].map((value) => {
      const high = Math.floor(value / 16);
      const low = value % 16;
      return hex[high] + hex[low];
    }).join("");
  }
  function bufferToData(b) {
    let s = "";
    for (let i = 0; i < b.length; i++)
      s += String.fromCharCode(b[i]);
    return { data: globalThis.btoa(s), isBase64: true };
  }
  function stringToBuffer(s) {
    s = globalThis.atob(s);
    const b = new Uint8Array(s.length);
    for (let i = 0; i < s.length; i++)
      b[i] = s.charCodeAt(i);
    return b.buffer;
  }
  function messageToData(message, cb) {
    if (message instanceof globalThis.Blob)
      return message.arrayBuffer().then((buffer) => cb(bufferToData(new Uint8Array(buffer))));
    if (typeof message === "string")
      return cb({ data: message, isBase64: false });
    if (ArrayBuffer.isView(message))
      return cb(bufferToData(new Uint8Array(message.buffer, message.byteOffset, message.byteLength)));
    return cb(bufferToData(new Uint8Array(message)));
  }
  function dataToMessage(data, binaryType) {
    if (!data.isBase64)
      return data.data;
    const buffer = stringToBuffer(data.data);
    return binaryType === "arraybuffer" ? buffer : new Blob([buffer]);
  }
  const binding = globalThis.__pwWebSocketBinding;
  const NativeWebSocket = globalThis.WebSocket;
  const idToWebSocket = /* @__PURE__ */ new Map();
  globalThis.__pwWebSocketDispatch = (request) => {
    const ws = idToWebSocket.get(request.id);
    if (!ws)
      return;
    if (request.type === "connect")
      ws._apiConnect();
    if (request.type === "passthrough")
      ws._apiPassThrough();
    if (request.type === "ensureOpened")
      ws._apiEnsureOpened();
    if (request.type === "sendToPage")
      ws._apiSendToPage(dataToMessage(request.data, ws.binaryType));
    if (request.type === "closePage")
      ws._apiClosePage(request.code, request.reason, request.wasClean);
    if (request.type === "sendToServer")
      ws._apiSendToServer(dataToMessage(request.data, ws.binaryType));
    if (request.type === "closeServer")
      ws._apiCloseServer(request.code, request.reason, request.wasClean);
  };
  const _WebSocketMock = class _WebSocketMock extends EventTarget {
    constructor(url, protocols) {
      var _a, _b;
      super();
      // WebSocket.CLOSED
      this.CONNECTING = 0;
      // WebSocket.CONNECTING
      this.OPEN = 1;
      // WebSocket.OPEN
      this.CLOSING = 2;
      // WebSocket.CLOSING
      this.CLOSED = 3;
      // WebSocket.CLOSED
      this._oncloseListener = null;
      this._onerrorListener = null;
      this._onmessageListener = null;
      this._onopenListener = null;
      this.bufferedAmount = 0;
      this.extensions = "";
      this.protocol = "";
      this.readyState = 0;
      this._origin = "";
      this._passthrough = false;
      this._wsBufferedMessages = [];
      this._binaryType = "blob";
      this.url = new URL(url, globalThis.window.document.baseURI).href.replace(/^http/, "ws");
      this._origin = (_b = (_a = URL.parse(this.url)) == null ? void 0 : _a.origin) != null ? _b : "";
      this._protocols = protocols;
      this._id = generateId();
      idToWebSocket.set(this._id, this);
      binding({ type: "onCreate", id: this._id, url: this.url });
    }
    // --- native WebSocket implementation ---
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      this._binaryType = type;
      if (this._ws)
        this._ws.binaryType = type;
    }
    get onclose() {
      return this._oncloseListener;
    }
    set onclose(listener) {
      if (this._oncloseListener)
        this.removeEventListener("close", this._oncloseListener);
      this._oncloseListener = listener;
      if (this._oncloseListener)
        this.addEventListener("close", this._oncloseListener);
    }
    get onerror() {
      return this._onerrorListener;
    }
    set onerror(listener) {
      if (this._onerrorListener)
        this.removeEventListener("error", this._onerrorListener);
      this._onerrorListener = listener;
      if (this._onerrorListener)
        this.addEventListener("error", this._onerrorListener);
    }
    get onopen() {
      return this._onopenListener;
    }
    set onopen(listener) {
      if (this._onopenListener)
        this.removeEventListener("open", this._onopenListener);
      this._onopenListener = listener;
      if (this._onopenListener)
        this.addEventListener("open", this._onopenListener);
    }
    get onmessage() {
      return this._onmessageListener;
    }
    set onmessage(listener) {
      if (this._onmessageListener)
        this.removeEventListener("message", this._onmessageListener);
      this._onmessageListener = listener;
      if (this._onmessageListener)
        this.addEventListener("message", this._onmessageListener);
    }
    send(message) {
      if (this.readyState === _WebSocketMock.CONNECTING)
        throw new DOMException(\`Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.\`);
      if (this.readyState !== _WebSocketMock.OPEN)
        throw new DOMException(\`WebSocket is already in CLOSING or CLOSED state.\`);
      if (this._passthrough) {
        if (this._ws)
          this._apiSendToServer(message);
      } else {
        messageToData(message, (data) => binding({ type: "onMessageFromPage", id: this._id, data }));
      }
    }
    close(code, reason) {
      if (code !== void 0 && code !== 1e3 && (code < 3e3 || code > 4999))
        throw new DOMException(\`Failed to execute 'close' on 'WebSocket': The close code must be either 1000, or between 3000 and 4999. \${code} is neither.\`);
      if (this.readyState === _WebSocketMock.OPEN || this.readyState === _WebSocketMock.CONNECTING)
        this.readyState = _WebSocketMock.CLOSING;
      if (this._passthrough)
        this._apiCloseServer(code, reason, true);
      else
        binding({ type: "onClosePage", id: this._id, code, reason, wasClean: true });
    }
    // --- methods called from the routing API ---
    _apiEnsureOpened() {
      if (!this._ws)
        this._ensureOpened();
    }
    _apiSendToPage(message) {
      this._ensureOpened();
      if (this.readyState !== _WebSocketMock.OPEN)
        throw new DOMException(\`WebSocket is already in CLOSING or CLOSED state.\`);
      this.dispatchEvent(new MessageEvent("message", { data: message, origin: this._origin, cancelable: true }));
    }
    _apiSendToServer(message) {
      if (!this._ws)
        throw new Error("Cannot send a message before connecting to the server");
      if (this._ws.readyState === _WebSocketMock.CONNECTING)
        this._wsBufferedMessages.push(message);
      else
        this._ws.send(message);
    }
    _apiConnect() {
      if (this._ws)
        throw new Error("Can only connect to the server once");
      this._ws = new NativeWebSocket(this.url, this._protocols);
      this._ws.binaryType = this._binaryType;
      this._ws.onopen = () => {
        for (const message of this._wsBufferedMessages)
          this._ws.send(message);
        this._wsBufferedMessages = [];
        this._ensureOpened();
      };
      this._ws.onclose = (event) => {
        this._onWSClose(event.code, event.reason, event.wasClean);
      };
      this._ws.onmessage = (event) => {
        if (this._passthrough)
          this._apiSendToPage(event.data);
        else
          messageToData(event.data, (data) => binding({ type: "onMessageFromServer", id: this._id, data }));
      };
      this._ws.onerror = () => {
        const event = new Event("error", { cancelable: true });
        this.dispatchEvent(event);
      };
    }
    // This method connects to the server, and passes all messages through,
    // as if WebSocketMock was not engaged.
    _apiPassThrough() {
      this._passthrough = true;
      this._apiConnect();
    }
    _apiCloseServer(code, reason, wasClean) {
      if (!this._ws) {
        this._onWSClose(code, reason, wasClean);
        return;
      }
      if (this._ws.readyState === _WebSocketMock.CONNECTING || this._ws.readyState === _WebSocketMock.OPEN)
        this._ws.close(code, reason);
    }
    _apiClosePage(code, reason, wasClean) {
      if (this.readyState === _WebSocketMock.CLOSED)
        return;
      this.readyState = _WebSocketMock.CLOSED;
      this.dispatchEvent(new CloseEvent("close", { code, reason, wasClean, cancelable: true }));
      this._maybeCleanup();
      if (this._passthrough)
        this._apiCloseServer(code, reason, wasClean);
      else
        binding({ type: "onClosePage", id: this._id, code, reason, wasClean });
    }
    // --- internals ---
    _ensureOpened() {
      var _a;
      if (this.readyState !== _WebSocketMock.CONNECTING)
        return;
      this.extensions = ((_a = this._ws) == null ? void 0 : _a.extensions) || "";
      if (this._ws)
        this.protocol = this._ws.protocol;
      else if (Array.isArray(this._protocols))
        this.protocol = this._protocols[0] || "";
      else
        this.protocol = this._protocols || "";
      this.readyState = _WebSocketMock.OPEN;
      this.dispatchEvent(new Event("open", { cancelable: true }));
    }
    _onWSClose(code, reason, wasClean) {
      if (this._passthrough)
        this._apiClosePage(code, reason, wasClean);
      else
        binding({ type: "onCloseServer", id: this._id, code, reason, wasClean });
      if (this._ws) {
        this._ws.onopen = null;
        this._ws.onclose = null;
        this._ws.onmessage = null;
        this._ws.onerror = null;
        this._ws = void 0;
        this._wsBufferedMessages = [];
      }
      this._maybeCleanup();
    }
    _maybeCleanup() {
      if (this.readyState === _WebSocketMock.CLOSED && !this._ws)
        idToWebSocket.delete(this._id);
    }
  };
  _WebSocketMock.CONNECTING = 0;
  // WebSocket.CONNECTING
  _WebSocketMock.OPEN = 1;
  // WebSocket.OPEN
  _WebSocketMock.CLOSING = 2;
  // WebSocket.CLOSING
  _WebSocketMock.CLOSED = 3;
  let WebSocketMock = _WebSocketMock;
  globalThis.WebSocket = class WebSocket extends WebSocketMock {
  };
}
`;

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/webSocketRouteDispatcher.js
var WebSocketRouteDispatcher = class _WebSocketRouteDispatcher extends Dispatcher {
  static {
    __name(this, "WebSocketRouteDispatcher");
  }
  constructor(scope, id, url4, frame) {
    super(scope, new SdkObject(scope._object, "webSocketRoute"), "WebSocketRoute", { url: url4 });
    this._type_WebSocketRoute = true;
    this._id = id;
    this._frame = frame;
    this._eventListeners.push(
      // When the frame navigates or detaches, there will be no more communication
      // from the mock websocket, so pretend like it was closed.
      eventsHelper.addEventListener(frame._page, Page.Events.InternalFrameNavigatedToNewDocument, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      eventsHelper.addEventListener(frame._page, Page.Events.FrameDetached, (frame2) => {
        if (frame2 === this._frame)
          this._executionContextGone();
      }),
      eventsHelper.addEventListener(frame._page, Page.Events.Close, () => this._executionContextGone()),
      eventsHelper.addEventListener(frame._page, Page.Events.Crash, () => this._executionContextGone())
    );
    _WebSocketRouteDispatcher._idToDispatcher.set(this._id, this);
    scope._dispatchEvent("webSocketRoute", { webSocketRoute: this });
  }
  static {
    this._idToDispatcher = /* @__PURE__ */ new Map();
  }
  static async install(progress3, connection, target) {
    const context2 = target instanceof Page ? target.browserContext : target;
    let data = context2.getBindingClient(kBindingName);
    if (data && data.connection !== connection)
      throw new Error("Another client is already routing WebSockets");
    if (!data) {
      data = { counter: 0, connection, binding: null };
      data.binding = await context2.exposeBinding(progress3, kBindingName, false, (source8, payload) => {
        if (payload.type === "onCreate") {
          const contextDispatcher = connection.existingDispatcher(context2);
          const pageDispatcher = contextDispatcher ? PageDispatcher.fromNullable(contextDispatcher, source8.page) : void 0;
          let scope;
          if (pageDispatcher && matchesPattern(pageDispatcher, context2._options.baseURL, payload.url))
            scope = pageDispatcher;
          else if (contextDispatcher && matchesPattern(contextDispatcher, context2._options.baseURL, payload.url))
            scope = contextDispatcher;
          if (scope) {
            new _WebSocketRouteDispatcher(scope, payload.id, payload.url, source8.frame);
          } else {
            const request2 = { id: payload.id, type: "passthrough" };
            source8.frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request2)})`).catch(() => {
            });
          }
          return;
        }
        const dispatcher = _WebSocketRouteDispatcher._idToDispatcher.get(payload.id);
        if (payload.type === "onMessageFromPage")
          dispatcher?._dispatchEvent("messageFromPage", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onMessageFromServer")
          dispatcher?._dispatchEvent("messageFromServer", { message: payload.data.data, isBase64: payload.data.isBase64 });
        if (payload.type === "onClosePage")
          dispatcher?._dispatchEvent("closePage", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
        if (payload.type === "onCloseServer")
          dispatcher?._dispatchEvent("closeServer", { code: payload.code, reason: payload.reason, wasClean: payload.wasClean });
      }, data);
    }
    ++data.counter;
    return await target.addInitScript(progress3, `
      (() => {
        const module = {};
        ${source7}
        (module.exports.inject())(globalThis);
      })();
    `);
  }
  static async uninstall(connection, target, initScript) {
    const context2 = target instanceof Page ? target.browserContext : target;
    const data = context2.getBindingClient(kBindingName);
    if (!data || data.connection !== connection)
      return;
    if (--data.counter <= 0)
      await context2.removeExposedBindings([data.binding]);
    await target.removeInitScripts([initScript]);
  }
  async connect(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "connect" });
  }
  async ensureOpened(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "ensureOpened" });
  }
  async sendToPage(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "sendToPage", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async sendToServer(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "sendToServer", data: { data: params.message, isBase64: params.isBase64 } });
  }
  async closePage(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "closePage", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async closeServer(params, progress3) {
    await this._evaluateAPIRequest(progress3, { id: this._id, type: "closeServer", code: params.code, reason: params.reason, wasClean: params.wasClean });
  }
  async _evaluateAPIRequest(progress3, request2) {
    await progress3.race(this._frame.evaluateExpression(`globalThis.__pwWebSocketDispatch(${JSON.stringify(request2)})`).catch(() => {
    }));
  }
  _onDispose() {
    _WebSocketRouteDispatcher._idToDispatcher.delete(this._id);
  }
  _executionContextGone() {
    if (!this._disposed) {
      this._dispatchEvent("closePage", { wasClean: true });
      this._dispatchEvent("closeServer", { wasClean: true });
    }
  }
};
function matchesPattern(dispatcher, baseURL, url4) {
  for (const pattern of dispatcher._webSocketInterceptionPatterns || []) {
    const urlMatch = pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob;
    if (urlMatches(baseURL, url4, urlMatch, true))
      return true;
  }
  return false;
}
__name(matchesPattern, "matchesPattern");
var kBindingName = "__pwWebSocketBinding";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/pageDispatcher.js
var PageDispatcher = class _PageDispatcher extends Dispatcher {
  static {
    __name(this, "PageDispatcher");
  }
  constructor(parentScope, page) {
    const mainFrame = FrameDispatcher.from(parentScope, page.mainFrame());
    super(parentScope, page, "Page", {
      mainFrame,
      viewportSize: page.emulatedSize()?.viewport,
      isClosed: page.isClosed(),
      opener: _PageDispatcher.fromNullable(parentScope, page.opener())
    });
    this._type_EventTarget = true;
    this._type_Page = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this._webSocketInterceptionPatterns = [];
    this._bindings = [];
    this._initScripts = [];
    this._interceptionUrlMatchers = [];
    this._locatorHandlers = /* @__PURE__ */ new Set();
    this._jsCoverageActive = false;
    this._cssCoverageActive = false;
    this.adopt(mainFrame);
    this._page = page;
    this._requestInterceptor = (route, request2) => {
      const matchesSome = this._interceptionUrlMatchers.some((urlMatch) => urlMatches(this._page.browserContext._options.baseURL, request2.url(), urlMatch));
      if (!matchesSome) {
        route.continue({ isFallback: true }).catch(() => {
        });
        return;
      }
      this._dispatchEvent("route", { route: new RouteDispatcher(RequestDispatcher.from(this.parentScope(), request2), route) });
    };
    this.addObjectListener(Page.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(Page.Events.Crash, () => this._dispatchEvent("crash"));
    this.addObjectListener(Page.Events.Download, (download) => {
      this._dispatchEvent("download", { url: download.url, suggestedFilename: download.suggestedFilename(), artifact: ArtifactDispatcher.from(parentScope, download.artifact) });
    });
    this.addObjectListener(Page.Events.EmulatedSizeChanged, () => this._dispatchEvent("viewportSizeChanged", { viewportSize: page.emulatedSize()?.viewport }));
    this.addObjectListener(Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
      element: ElementHandleDispatcher.from(mainFrame, fileChooser.element()),
      isMultiple: fileChooser.isMultiple()
    }));
    this.addObjectListener(Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
    this.addObjectListener(Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
    this.addObjectListener(Page.Events.LocatorHandlerTriggered, (uid) => this._dispatchEvent("locatorHandlerTriggered", { uid }));
    this.addObjectListener(Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", { webSocket: new WebSocketDispatcher(this, webSocket) }));
    this.addObjectListener(Page.Events.Worker, (worker) => this._dispatchEvent("worker", { worker: new WorkerDispatcher(this, worker) }));
    this.addObjectListener(Page.Events.Video, (artifact) => this._dispatchEvent("video", { artifact: ArtifactDispatcher.from(parentScope, artifact) }));
    if (page.video)
      this._dispatchEvent("video", { artifact: ArtifactDispatcher.from(this.parentScope(), page.video) });
    const frames = page.frameManager.frames();
    for (let i = 1; i < frames.length; i++)
      this._onFrameAttached(frames[i]);
  }
  static from(parentScope, page) {
    return _PageDispatcher.fromNullable(parentScope, page);
  }
  static fromNullable(parentScope, page) {
    if (!page)
      return void 0;
    const result = parentScope.connection.existingDispatcher(page);
    return result || new _PageDispatcher(parentScope, page);
  }
  page() {
    return this._page;
  }
  async exposeBinding(params, progress3) {
    const binding3 = await this._page.exposeBinding(progress3, params.name, !!params.needsHandle, (source8, ...args) => {
      if (this._disposed)
        return;
      const binding22 = new BindingCallDispatcher(this, params.name, !!params.needsHandle, source8, args);
      this._dispatchEvent("bindingCall", { binding: binding22 });
      return binding22.promise();
    });
    this._bindings.push(binding3);
  }
  async setExtraHTTPHeaders(params, progress3) {
    await this._page.setExtraHTTPHeaders(progress3, params.headers);
  }
  async reload(params, progress3) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.reload(progress3, params)) };
  }
  async goBack(params, progress3) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goBack(progress3, params)) };
  }
  async goForward(params, progress3) {
    return { response: ResponseDispatcher.fromNullable(this.parentScope(), await this._page.goForward(progress3, params)) };
  }
  async requestGC(params, progress3) {
    await progress3.race(this._page.requestGC());
  }
  async registerLocatorHandler(params, progress3) {
    const uid = this._page.registerLocatorHandler(params.selector, params.noWaitAfter);
    this._locatorHandlers.add(uid);
    return { uid };
  }
  async resolveLocatorHandlerNoReply(params, progress3) {
    this._page.resolveLocatorHandler(params.uid, params.remove);
  }
  async unregisterLocatorHandler(params, progress3) {
    this._page.unregisterLocatorHandler(params.uid);
    this._locatorHandlers.delete(params.uid);
  }
  async emulateMedia(params, progress3) {
    await this._page.emulateMedia(progress3, {
      media: params.media,
      colorScheme: params.colorScheme,
      reducedMotion: params.reducedMotion,
      forcedColors: params.forcedColors,
      contrast: params.contrast
    });
  }
  async setViewportSize(params, progress3) {
    await this._page.setViewportSize(progress3, params.viewportSize);
  }
  async addInitScript(params, progress3) {
    this._initScripts.push(await this._page.addInitScript(progress3, params.source));
  }
  async setNetworkInterceptionPatterns(params, progress3) {
    const hadMatchers = this._interceptionUrlMatchers.length > 0;
    if (!params.patterns.length) {
      if (hadMatchers)
        await this._page.removeRequestInterceptor(this._requestInterceptor);
      this._interceptionUrlMatchers = [];
    } else {
      this._interceptionUrlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
      if (!hadMatchers)
        await this._page.addRequestInterceptor(progress3, this._requestInterceptor);
    }
  }
  async setWebSocketInterceptionPatterns(params, progress3) {
    this._webSocketInterceptionPatterns = params.patterns;
    if (params.patterns.length && !this._routeWebSocketInitScript)
      this._routeWebSocketInitScript = await WebSocketRouteDispatcher.install(progress3, this.connection, this._page);
  }
  async expectScreenshot(params, progress3) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    const locator = params.locator ? {
      frame: params.locator.frame._object,
      selector: params.locator.selector
    } : void 0;
    return await this._page.expectScreenshot(progress3, {
      ...params,
      locator,
      mask
    });
  }
  async screenshot(params, progress3) {
    const mask = (params.mask || []).map(({ frame, selector }) => ({
      frame: frame._object,
      selector
    }));
    return { binary: await this._page.screenshot(progress3, { ...params, mask }) };
  }
  async close(params, progress3) {
    if (!params.runBeforeUnload)
      progress3.metadata.potentiallyClosesScope = true;
    await this._page.close(params);
  }
  async updateSubscription(params, progress3) {
    if (params.event === "fileChooser")
      await this._page.setFileChooserInterceptedBy(params.enabled, this);
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
  async keyboardDown(params, progress3) {
    await this._page.keyboard.down(progress3, params.key);
  }
  async keyboardUp(params, progress3) {
    await this._page.keyboard.up(progress3, params.key);
  }
  async keyboardInsertText(params, progress3) {
    await this._page.keyboard.insertText(progress3, params.text);
  }
  async keyboardType(params, progress3) {
    await this._page.keyboard.type(progress3, params.text, params);
  }
  async keyboardPress(params, progress3) {
    await this._page.keyboard.press(progress3, params.key, params);
  }
  async mouseMove(params, progress3) {
    progress3.metadata.point = { x: params.x, y: params.y };
    await this._page.mouse.move(progress3, params.x, params.y, params);
  }
  async mouseDown(params, progress3) {
    progress3.metadata.point = this._page.mouse.currentPoint();
    await this._page.mouse.down(progress3, params);
  }
  async mouseUp(params, progress3) {
    progress3.metadata.point = this._page.mouse.currentPoint();
    await this._page.mouse.up(progress3, params);
  }
  async mouseClick(params, progress3) {
    progress3.metadata.point = { x: params.x, y: params.y };
    await this._page.mouse.click(progress3, params.x, params.y, params);
  }
  async mouseWheel(params, progress3) {
    await this._page.mouse.wheel(progress3, params.deltaX, params.deltaY);
  }
  async touchscreenTap(params, progress3) {
    progress3.metadata.point = { x: params.x, y: params.y };
    await this._page.touchscreen.tap(progress3, params.x, params.y);
  }
  async accessibilitySnapshot(params, progress3) {
    const rootAXNode = await progress3.race(this._page.accessibility.snapshot({
      interestingOnly: params.interestingOnly,
      root: params.root ? params.root._elementHandle : void 0
    }));
    return { rootAXNode: rootAXNode || void 0 };
  }
  async pdf(params, progress3) {
    if (!this._page.pdf)
      throw new Error("PDF generation is only supported for Headless Chromium");
    const buffer = await progress3.race(this._page.pdf(params));
    return { pdf: buffer };
  }
  async snapshotForAI(params, progress3) {
    return { snapshot: await this._page.snapshotForAI(progress3) };
  }
  async bringToFront(params, progress3) {
    await progress3.race(this._page.bringToFront());
  }
  async startJSCoverage(params, progress3) {
    const coverage = this._page.coverage;
    await coverage.startJSCoverage(progress3, params);
    this._jsCoverageActive = true;
  }
  async stopJSCoverage(params, progress3) {
    this._jsCoverageActive = false;
    const coverage = this._page.coverage;
    return await coverage.stopJSCoverage();
  }
  async startCSSCoverage(params, progress3) {
    const coverage = this._page.coverage;
    await coverage.startCSSCoverage(progress3, params);
    this._cssCoverageActive = true;
  }
  async stopCSSCoverage(params, progress3) {
    this._cssCoverageActive = false;
    const coverage = this._page.coverage;
    return await coverage.stopCSSCoverage();
  }
  _onFrameAttached(frame) {
    this._dispatchEvent("frameAttached", { frame: FrameDispatcher.from(this.parentScope(), frame) });
  }
  _onFrameDetached(frame) {
    this._dispatchEvent("frameDetached", { frame: FrameDispatcher.from(this.parentScope(), frame) });
  }
  _onDispose() {
    if (this._page.isClosedOrClosingOrCrashed())
      return;
    this._interceptionUrlMatchers = [];
    this._page.removeRequestInterceptor(this._requestInterceptor).catch(() => {
    });
    this._page.removeExposedBindings(this._bindings).catch(() => {
    });
    this._bindings = [];
    this._page.removeInitScripts(this._initScripts).catch(() => {
    });
    this._initScripts = [];
    if (this._routeWebSocketInitScript)
      WebSocketRouteDispatcher.uninstall(this.connection, this._page, this._routeWebSocketInitScript).catch(() => {
      });
    this._routeWebSocketInitScript = void 0;
    for (const uid of this._locatorHandlers)
      this._page.unregisterLocatorHandler(uid);
    this._locatorHandlers.clear();
    this._page.setFileChooserInterceptedBy(false, this).catch(() => {
    });
    if (this._jsCoverageActive)
      this._page.coverage.stopJSCoverage().catch(() => {
      });
    this._jsCoverageActive = false;
    if (this._cssCoverageActive)
      this._page.coverage.stopCSSCoverage().catch(() => {
      });
    this._cssCoverageActive = false;
  }
};
var WorkerDispatcher = class _WorkerDispatcher extends Dispatcher {
  static {
    __name(this, "WorkerDispatcher");
  }
  constructor(scope, worker) {
    super(scope, worker, "Worker", {
      url: worker.url
    });
    this._type_Worker = true;
    this.addObjectListener(Worker.Events.Close, () => this._dispatchEvent("close"));
  }
  static fromNullable(scope, worker) {
    if (!worker)
      return void 0;
    const result = scope.connection.existingDispatcher(worker);
    return result || new _WorkerDispatcher(scope, worker);
  }
  async evaluateExpression(params, progress3) {
    return { value: serializeResult(await progress3.race(this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
  async evaluateExpressionHandle(params, progress3) {
    return { handle: JSHandleDispatcher.fromJSHandle(this, await progress3.race(this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg)))) };
  }
};
var BindingCallDispatcher = class extends Dispatcher {
  static {
    __name(this, "BindingCallDispatcher");
  }
  constructor(scope, name, needsHandle, source8, args) {
    const frameDispatcher = FrameDispatcher.from(scope.parentScope(), source8.frame);
    super(scope, new SdkObject(scope._object, "bindingCall"), "BindingCall", {
      frame: frameDispatcher,
      name,
      args: needsHandle ? void 0 : args.map(serializeResult),
      handle: needsHandle ? ElementHandleDispatcher.fromJSOrElementHandle(frameDispatcher, args[0]) : void 0
    });
    this._type_BindingCall = true;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  promise() {
    return this._promise;
  }
  async resolve(params, progress3) {
    this._resolve(parseArgument(params.result));
    this._dispose();
  }
  async reject(params, progress3) {
    this._reject(parseError(params.error));
    this._dispose();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/dialogDispatcher.js
var DialogDispatcher = class extends Dispatcher {
  static {
    __name(this, "DialogDispatcher");
  }
  constructor(scope, dialog) {
    const page = PageDispatcher.fromNullable(scope, dialog.page().initializedOrUndefined());
    super(page || scope, dialog, "Dialog", {
      page,
      type: dialog.type(),
      message: dialog.message(),
      defaultValue: dialog.defaultValue()
    });
    this._type_Dialog = true;
  }
  async accept(params, progress3) {
    await progress3.race(this._object.accept(params.promptText));
  }
  async dismiss(params, progress3) {
    await progress3.race(this._object.dismiss());
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crBrowser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path17 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/download.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path15 from "node:path";
import "node:crypto";
import "node:fs";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var Download = class {
  static {
    __name(this, "Download");
  }
  constructor(page, downloadsPath, uuid, url4, suggestedFilename) {
    const unaccessibleErrorMessage = page.browserContext._options.acceptDownloads === "deny" ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
    this.artifact = new Artifact(page, path15.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
      return this._page.browserContext.cancelDownload(uuid);
    });
    this._page = page;
    this.url = url4;
    this._suggestedFilename = suggestedFilename;
    page.browserContext._downloads.add(this);
    if (suggestedFilename !== void 0)
      this._fireDownloadEvent();
  }
  page() {
    return this._page;
  }
  _filenameSuggested(suggestedFilename) {
    assert3(this._suggestedFilename === void 0);
    this._suggestedFilename = suggestedFilename;
    this._fireDownloadEvent();
  }
  suggestedFilename() {
    return this._suggestedFilename;
  }
  _fireDownloadEvent() {
    this._page.instrumentation.onDownload(this._page, this);
    this._page.emit(Page.Events.Download, this);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browser.js
var Browser = class _Browser extends SdkObject {
  static {
    __name(this, "Browser");
  }
  constructor(parent, options2) {
    super(parent, "browser");
    this._downloads = /* @__PURE__ */ new Map();
    this._defaultContext = null;
    this._startedClosing = false;
    this._idToVideo = /* @__PURE__ */ new Map();
    this._isCollocatedWithServer = true;
    this.attribution.browser = this;
    this.options = options2;
    this.instrumentation.onBrowserOpen(this);
  }
  static {
    this.Events = {
      Context: "context",
      Disconnected: "disconnected"
    };
  }
  sdkLanguage() {
    return this.options.sdkLanguage || this.attribution.playwright.options.sdkLanguage;
  }
  async newContext(progress3, options2) {
    validateBrowserContextOptions(options2, this.options);
    let clientCertificatesProxy;
    let context2;
    try {
      if (options2.clientCertificates?.length) {
        clientCertificatesProxy = await ClientCertificatesProxy.create(progress3, options2);
        options2 = { ...options2 };
        options2.proxyOverride = clientCertificatesProxy.proxySettings();
        options2.internalIgnoreHTTPSErrors = true;
      }
      context2 = await progress3.race(this.doCreateNewContext(options2));
      context2._clientCertificatesProxy = clientCertificatesProxy;
      if (options2.__testHookBeforeSetStorageState)
        await progress3.race(options2.__testHookBeforeSetStorageState());
      await context2.setStorageState(progress3, options2.storageState, "initial");
      this.emit(_Browser.Events.Context, context2);
      return context2;
    } catch (error3) {
      await context2?.close({ reason: "Failed to create context" }).catch(() => {
      });
      await clientCertificatesProxy?.close().catch(() => {
      });
      throw error3;
    }
  }
  async newContextForReuse(progress3, params) {
    const hash = BrowserContext.reusableContextHash(params);
    if (!this._contextForReuse || hash !== this._contextForReuse.hash || !this._contextForReuse.context.canResetForReuse()) {
      if (this._contextForReuse)
        await this._contextForReuse.context.close({ reason: "Context reused" });
      this._contextForReuse = { context: await this.newContext(progress3, params), hash };
      return this._contextForReuse.context;
    }
    await this._contextForReuse.context.resetForReuse(progress3, params);
    return this._contextForReuse.context;
  }
  contextForReuse() {
    return this._contextForReuse?.context;
  }
  _downloadCreated(page, uuid, url4, suggestedFilename) {
    const download = new Download(page, this.options.downloadsPath || "", uuid, url4, suggestedFilename);
    this._downloads.set(uuid, download);
  }
  _downloadFilenameSuggested(uuid, suggestedFilename) {
    const download = this._downloads.get(uuid);
    if (!download)
      return;
    download._filenameSuggested(suggestedFilename);
  }
  _downloadFinished(uuid, error3) {
    const download = this._downloads.get(uuid);
    if (!download)
      return;
    download.artifact.reportFinished(error3 ? new Error(error3) : void 0);
    this._downloads.delete(uuid);
  }
  _videoStarted(context2, videoId, path30, pageOrError) {
    const artifact = new Artifact(context2, path30);
    this._idToVideo.set(videoId, { context: context2, artifact });
    pageOrError.then((page) => {
      if (page instanceof Page) {
        page.video = artifact;
        page.emitOnContext(BrowserContext.Events.VideoStarted, artifact);
        page.emit(Page.Events.Video, artifact);
      }
    });
  }
  _takeVideo(videoId) {
    const video = this._idToVideo.get(videoId);
    this._idToVideo.delete(videoId);
    return video?.artifact;
  }
  _didClose() {
    for (const context2 of this.contexts())
      context2._browserClosed();
    if (this._defaultContext)
      this._defaultContext._browserClosed();
    this.emit(_Browser.Events.Disconnected);
    this.instrumentation.onBrowserClose(this);
  }
  async close(options2) {
    if (!this._startedClosing) {
      if (options2.reason)
        this._closeReason = options2.reason;
      this._startedClosing = true;
      await this.options.browserProcess.close();
    }
    if (this.isConnected())
      await new Promise((x) => this.once(_Browser.Events.Disconnected, x));
  }
  async killForTests() {
    await this.options.browserProcess.kill();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crPage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path16 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crAccessibility.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree(client, needle) {
  const { nodes } = await client.send("Accessibility.getFullAXTree");
  const tree = CRAXNode.createTree(client, nodes);
  return {
    tree,
    needle: needle ? await tree._findElement(needle) : null
  };
}
__name(getAccessibilityTree, "getAccessibilityTree");
var CRAXNode = class _CRAXNode {
  static {
    __name(this, "CRAXNode");
  }
  constructor(client, payload) {
    this._children = [];
    this._richlyEditable = false;
    this._editable = false;
    this._focusable = false;
    this._expanded = false;
    this._hidden = false;
    this._client = client;
    this._payload = payload;
    this._name = this._payload.name ? this._payload.name.value : "";
    this._role = this._payload.role ? this._payload.role.value : "Unknown";
    for (const property of this._payload.properties || []) {
      if (property.name === "editable") {
        this._richlyEditable = property.value.value === "richtext";
        this._editable = true;
      }
      if (property.name === "focusable")
        this._focusable = property.value.value;
      if (property.name === "expanded")
        this._expanded = property.value.value;
      if (property.name === "hidden")
        this._hidden = property.value.value;
    }
  }
  _isPlainTextField() {
    if (this._richlyEditable)
      return false;
    if (this._editable)
      return true;
    return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
  }
  _isTextOnlyObject() {
    const role = this._role;
    return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
  }
  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === void 0) {
      this._cachedHasFocusableChild = false;
      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }
    return this._cachedHasFocusableChild;
  }
  children() {
    return this._children;
  }
  async _findElement(element) {
    const objectId = element._objectId;
    const { node: { backendNodeId } } = await this._client.send("DOM.describeNode", { objectId });
    const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
    return needle || null;
  }
  find(predicate) {
    if (predicate(this))
      return this;
    for (const child of this._children) {
      const result = child.find(predicate);
      if (result)
        return result;
    }
    return null;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isPlainTextField() || this._isTextOnlyObject())
      return true;
    switch (this._role) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
    }
    if (this._hasFocusableChild())
      return false;
    if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
      return true;
    if (this._role === "heading" && this._name)
      return true;
    return false;
  }
  isControl() {
    switch (this._role) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = this._role;
    if (role === "Ignored" || this._hidden)
      return false;
    if (this._focusable || this._richlyEditable)
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!this._name;
  }
  normalizedRole() {
    switch (this._role) {
      case "RootWebArea":
        return "WebArea";
      case "StaticText":
        return "text";
      default:
        return this._role;
    }
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property of this._payload.properties || [])
      properties.set(property.name.toLowerCase(), property.value.value);
    if (this._payload.description)
      properties.set("description", this._payload.description.value);
    const node = {
      role: this.normalizedRole(),
      name: this._payload.name ? this._payload.name.value || "" : ""
    };
    const userStringProperties = [
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty))
        continue;
      node[userStringProperty] = properties.get(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
        continue;
      const value = properties.get(booleanProperty);
      if (!value)
        continue;
      node[booleanProperty] = value;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty))
        continue;
      node[numericalProperty] = properties.get(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = properties.get(tokenProperty);
      if (!value || value === "false")
        continue;
      node[tokenProperty] = value;
    }
    const axNode = node;
    if (this._payload.value) {
      if (typeof this._payload.value.value === "string")
        axNode.valueString = this._payload.value.value;
      if (typeof this._payload.value.value === "number")
        axNode.valueNumber = this._payload.value.value;
    }
    if (properties.has("checked"))
      axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
    if (properties.has("pressed"))
      axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
    return axNode;
  }
  static createTree(client, payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads)
      nodeById.set(payload.nodeId, new _CRAXNode(client, payload));
    for (const node of nodeById.values()) {
      for (const childId of node._payload.childIds || [])
        node._children.push(nodeById.get(childId));
    }
    return nodeById.values().next().value;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crCoverage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var CRCoverage = class {
  static {
    __name(this, "CRCoverage");
  }
  constructor(client) {
    this._jsCoverage = new JSCoverage(client);
    this._cssCoverage = new CSSCoverage(client);
  }
  async startJSCoverage(progress3, options2) {
    await raceUncancellableOperationWithCleanup(progress3, () => this._jsCoverage.start(options2), () => this._jsCoverage.stop());
  }
  async stopJSCoverage() {
    return await this._jsCoverage.stop();
  }
  async startCSSCoverage(progress3, options2) {
    await raceUncancellableOperationWithCleanup(progress3, () => this._cssCoverage.start(options2), () => this._cssCoverage.stop());
  }
  async stopCSSCoverage() {
    return await this._cssCoverage.stop();
  }
};
var JSCoverage = class {
  static {
    __name(this, "JSCoverage");
  }
  constructor(client) {
    this._reportAnonymousScripts = false;
    this._client = client;
    this._enabled = false;
    this._scriptIds = /* @__PURE__ */ new Set();
    this._scriptSources = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }
  async start(options2) {
    assert3(!this._enabled, "JSCoverage is already enabled");
    const {
      resetOnNavigation = true,
      reportAnonymousScripts = false
    } = options2;
    this._resetOnNavigation = resetOnNavigation;
    this._reportAnonymousScripts = reportAnonymousScripts;
    this._enabled = true;
    this._scriptIds.clear();
    this._scriptSources.clear();
    this._eventListeners = [
      eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)),
      eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))
    ];
    await Promise.all([
      this._client.send("Profiler.enable"),
      this._client.send("Profiler.startPreciseCoverage", { callCount: true, detailed: true }),
      this._client.send("Debugger.enable"),
      this._client.send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  _onDebuggerPaused() {
    this._client.send("Debugger.resume");
  }
  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation)
      return;
    this._scriptIds.clear();
    this._scriptSources.clear();
  }
  async _onScriptParsed(event) {
    this._scriptIds.add(event.scriptId);
    if (!event.url && !this._reportAnonymousScripts)
      return;
    const response = await this._client._sendMayFail("Debugger.getScriptSource", { scriptId: event.scriptId });
    if (response)
      this._scriptSources.set(event.scriptId, response.scriptSource);
  }
  async stop() {
    if (!this._enabled)
      return { entries: [] };
    const [profileResponse] = await Promise.all([
      this._client.send("Profiler.takePreciseCoverage"),
      this._client.send("Profiler.stopPreciseCoverage"),
      this._client.send("Profiler.disable"),
      this._client.send("Debugger.disable")
    ]);
    eventsHelper.removeEventListeners(this._eventListeners);
    this._enabled = false;
    const coverage = { entries: [] };
    for (const entry of profileResponse.result) {
      if (!this._scriptIds.has(entry.scriptId))
        continue;
      if (!entry.url && !this._reportAnonymousScripts)
        continue;
      const source8 = this._scriptSources.get(entry.scriptId);
      if (source8)
        coverage.entries.push({ ...entry, source: source8 });
      else
        coverage.entries.push(entry);
    }
    return coverage;
  }
};
var CSSCoverage = class {
  static {
    __name(this, "CSSCoverage");
  }
  constructor(client) {
    this._client = client;
    this._enabled = false;
    this._stylesheetURLs = /* @__PURE__ */ new Map();
    this._stylesheetSources = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }
  async start(options2) {
    assert3(!this._enabled, "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options2;
    this._resetOnNavigation = resetOnNavigation;
    this._enabled = true;
    this._stylesheetURLs.clear();
    this._stylesheetSources.clear();
    this._eventListeners = [
      eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
    ];
    await Promise.all([
      this._client.send("DOM.enable"),
      this._client.send("CSS.enable"),
      this._client.send("CSS.startRuleUsageTracking")
    ]);
  }
  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation)
      return;
    this._stylesheetURLs.clear();
    this._stylesheetSources.clear();
  }
  async _onStyleSheet(event) {
    const header = event.header;
    if (!header.sourceURL)
      return;
    const response = await this._client._sendMayFail("CSS.getStyleSheetText", { styleSheetId: header.styleSheetId });
    if (response) {
      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
      this._stylesheetSources.set(header.styleSheetId, response.text);
    }
  }
  async stop() {
    if (!this._enabled)
      return { entries: [] };
    const ruleTrackingResponse = await this._client.send("CSS.stopRuleUsageTracking");
    await Promise.all([
      this._client.send("CSS.disable"),
      this._client.send("DOM.disable")
    ]);
    eventsHelper.removeEventListeners(this._eventListeners);
    this._enabled = false;
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = { entries: [] };
    for (const styleSheetId of this._stylesheetURLs.keys()) {
      const url4 = this._stylesheetURLs.get(styleSheetId);
      const text = this._stylesheetSources.get(styleSheetId);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.entries.push({ url: url4, ranges, text });
    }
    return coverage;
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range of nestedRanges) {
    points.push({ offset: range.startOffset, type: 0, range });
    points.push({ offset: range.endOffset, type: 1, range });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset)
      return a.offset - b.offset;
    if (a.type !== b.type)
      return b.type - a.type;
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0)
      return bLength - aLength;
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results.length ? results[results.length - 1] : null;
      if (lastResult && lastResult.end === lastOffset)
        lastResult.end = point.offset;
      else
        results.push({ start: lastOffset, end: point.offset });
    }
    lastOffset = point.offset;
    if (point.type === 0)
      hitCountStack.push(point.range.count);
    else
      hitCountStack.pop();
  }
  return results.filter((range) => range.end - range.start > 1);
}
__name(convertToDisjointRanges, "convertToDisjointRanges");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crDragDrop.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crProtocolHelper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs22 from "node:fs";
function getExceptionMessage(exceptionDetails) {
  if (exceptionDetails.exception)
    return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
  let message = exceptionDetails.text;
  if (exceptionDetails.stackTrace) {
    for (const callframe of exceptionDetails.stackTrace.callFrames) {
      const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
      const functionName = callframe.functionName || "<anonymous>";
      message += `
    at ${functionName} (${location2})`;
    }
  }
  return message;
}
__name(getExceptionMessage, "getExceptionMessage");
async function releaseObject(client, objectId) {
  await client.send("Runtime.releaseObject", { objectId }).catch((error3) => {
  });
}
__name(releaseObject, "releaseObject");
async function saveProtocolStream(client, handle, path30) {
  let eof = false;
  await mkdirIfNeeded(path30);
  const fd = await fs22.promises.open(path30, "w");
  while (!eof) {
    const response = await client.send("IO.read", { handle });
    eof = response.eof;
    const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
    await fd.write(buf);
  }
  await fd.close();
  await client.send("IO.close", { handle });
}
__name(saveProtocolStream, "saveProtocolStream");
async function readProtocolStream(client, handle) {
  let eof = false;
  const chunks = [];
  while (!eof) {
    const response = await client.send("IO.read", { handle });
    eof = response.eof;
    const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
    chunks.push(buf);
  }
  await client.send("IO.close", { handle });
  return Buffer.concat(chunks);
}
__name(readProtocolStream, "readProtocolStream");
function toConsoleMessageLocation(stackTrace) {
  return stackTrace && stackTrace.callFrames.length ? {
    url: stackTrace.callFrames[0].url,
    lineNumber: stackTrace.callFrames[0].lineNumber,
    columnNumber: stackTrace.callFrames[0].columnNumber
  } : { url: "", lineNumber: 0, columnNumber: 0 };
}
__name(toConsoleMessageLocation, "toConsoleMessageLocation");
function exceptionToError(exceptionDetails) {
  const messageWithStack = getExceptionMessage(exceptionDetails);
  const lines = messageWithStack.split("\n");
  const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
  let messageWithName = "";
  let stack = "";
  if (firstStackTraceLine === -1) {
    messageWithName = messageWithStack;
  } else {
    messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
    stack = messageWithStack;
  }
  const { name, message } = splitErrorMessage(messageWithName);
  const err = new Error(message);
  err.stack = stack;
  const nameOverride = exceptionDetails.exception?.preview?.properties.find((o) => o.name === "name");
  err.name = nameOverride ? nameOverride.value ?? "Error" : name;
  return err;
}
__name(exceptionToError, "exceptionToError");
function toModifiersMask(modifiers) {
  let mask = 0;
  if (modifiers.has("Alt"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Meta"))
    mask |= 4;
  if (modifiers.has("Shift"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask, "toModifiersMask");
function toButtonsMask(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask, "toButtonsMask");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crDragDrop.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var DragManager = class {
  static {
    __name(this, "DragManager");
  }
  constructor(page) {
    this._dragState = null;
    this._lastPosition = { x: 0, y: 0 };
    this._crPage = page;
  }
  async cancelDrag() {
    if (!this._dragState)
      return false;
    await this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
      type: "dragCancel",
      x: this._lastPosition.x,
      y: this._lastPosition.y,
      data: {
        items: [],
        dragOperationsMask: 65535
      }
    });
    this._dragState = null;
    return true;
  }
  async interceptDragCausedByMove(progress3, x, y, button, buttons, modifiers, moveCallback) {
    this._lastPosition = { x, y };
    if (this._dragState) {
      await progress3.race(this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
        type: "dragOver",
        x,
        y,
        data: this._dragState,
        modifiers: toModifiersMask(modifiers)
      }));
      return;
    }
    if (button !== "left")
      return moveCallback();
    const client = this._crPage._mainFrameSession._client;
    let onDragIntercepted;
    const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
    function setupDragListeners() {
      let didStartDrag = Promise.resolve(false);
      let dragEvent = null;
      const dragListener = /* @__PURE__ */ __name((event) => dragEvent = event, "dragListener");
      const mouseListener = /* @__PURE__ */ __name(() => {
        didStartDrag = new Promise((callback) => {
          window.addEventListener("dragstart", dragListener, { once: true, capture: true });
          setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
        });
      }, "mouseListener");
      window.addEventListener("mousemove", mouseListener, { once: true, capture: true });
      window.__cleanupDrag = async () => {
        const val = await didStartDrag;
        window.removeEventListener("mousemove", mouseListener, { capture: true });
        window.removeEventListener("dragstart", dragListener, { capture: true });
        delete window.__cleanupDrag;
        return val;
      };
    }
    __name(setupDragListeners, "setupDragListeners");
    try {
      let expectingDrag = false;
      const scriptSource = `((__name => (${setupDragListeners.toString()}))(t => t))`;
      await progress3.race(this._crPage._page.safeNonStallingEvaluateInAllFrames(`(${scriptSource})()`, "utility"));
      client.on("Input.dragIntercepted", onDragIntercepted);
      await client.send("Input.setInterceptDrags", { enabled: true });
      try {
        await progress3.race(moveCallback());
        expectingDrag = (await Promise.all(this._crPage._page.frames().map(async (frame) => {
          return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag?.()", "utility").catch(() => false);
        }))).some((x2) => x2);
      } finally {
        client.off("Input.dragIntercepted", onDragIntercepted);
        await client.send("Input.setInterceptDrags", { enabled: false });
      }
      this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;
    } catch (error3) {
      this._crPage._page.safeNonStallingEvaluateInAllFrames("window.__cleanupDrag?.()", "utility").catch(() => {
      });
      throw error3;
    }
    if (this._dragState) {
      await progress3.race(this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x,
        y,
        data: this._dragState,
        modifiers: toModifiersMask(modifiers)
      }));
    }
  }
  isDragging() {
    return !!this._dragState;
  }
  async drop(progress3, x, y, modifiers) {
    assert3(this._dragState, "missing drag state");
    await progress3.race(this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
      type: "drop",
      x,
      y,
      data: this._dragState,
      modifiers: toModifiersMask(modifiers)
    }));
    this._dragState = null;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crExecutionContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CRExecutionContext = class {
  static {
    __name(this, "CRExecutionContext");
  }
  constructor(client, contextPayload) {
    this._client = client;
    this._contextId = contextPayload.id;
  }
  async rawEvaluateJSON(expression) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.evaluate", {
      expression,
      contextId: this._contextId,
      returnByValue: true
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return remoteObject.value;
  }
  async rawEvaluateHandle(context2, expression) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.evaluate", {
      expression,
      contextId: this._contextId
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return createHandle(context2, remoteObject);
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    const { exceptionDetails, result: remoteObject } = await this._client.send("Runtime.callFunctionOn", {
      functionDeclaration: expression,
      objectId: utilityScript._objectId,
      arguments: [
        { objectId: utilityScript._objectId },
        ...values.map((value) => ({ value })),
        ...handles.map((handle) => ({ objectId: handle._objectId }))
      ],
      returnByValue,
      awaitPromise: true,
      userGesture: true
    }).catch(rewriteError);
    if (exceptionDetails)
      throw new JavaScriptErrorInEvaluate(getExceptionMessage(exceptionDetails));
    return returnByValue ? parseEvaluationResultValue(remoteObject.value) : createHandle(utilityScript._context, remoteObject);
  }
  async getProperties(object) {
    const response = await this._client.send("Runtime.getProperties", {
      objectId: object._objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.result) {
      if (!property.enumerable || !property.value)
        continue;
      result.set(property.name, createHandle(object._context, property.value));
    }
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await releaseObject(this._client, handle._objectId);
  }
};
function rewriteError(error3) {
  if (error3.message.includes("Object reference chain is too long"))
    throw new Error("Cannot serialize result: object reference chain is too long.");
  if (error3.message.includes("Object couldn't be returned by value"))
    return { result: { type: "undefined" } };
  if (error3 instanceof TypeError && error3.message.startsWith("Converting circular structure to JSON"))
    rewriteErrorMessage(error3, error3.message + " Are you passing a nested JSHandle?");
  if (!isJavaScriptErrorInEvaluate(error3) && !isSessionClosedError(error3))
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  throw error3;
}
__name(rewriteError, "rewriteError");
function potentiallyUnserializableValue(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? parseUnserializableValue(unserializableValue) : value;
}
__name(potentiallyUnserializableValue, "potentiallyUnserializableValue");
function renderPreview(object) {
  if (object.type === "undefined")
    return "undefined";
  if ("value" in object)
    return String(object.value);
  if (object.unserializableValue)
    return String(object.unserializableValue);
  if (object.description === "Object" && object.preview) {
    const tokens = [];
    for (const { name, value } of object.preview.properties)
      tokens.push(`${name}: ${value}`);
    return `{${tokens.join(", ")}}`;
  }
  if (object.subtype === "array" && object.preview)
    return sparseArrayToString(object.preview.properties);
  return object.description;
}
__name(renderPreview, "renderPreview");
function createHandle(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  return new JSHandle(context2, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
}
__name(createHandle, "createHandle");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crInput.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/macEditingCommands.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var macEditingCommands = {
  "Backspace": "deleteBackward:",
  "Enter": "insertNewline:",
  "NumpadEnter": "insertNewline:",
  "Escape": "cancelOperation:",
  "ArrowUp": "moveUp:",
  "ArrowDown": "moveDown:",
  "ArrowLeft": "moveLeft:",
  "ArrowRight": "moveRight:",
  "F5": "complete:",
  "Delete": "deleteForward:",
  "Home": "scrollToBeginningOfDocument:",
  "End": "scrollToEndOfDocument:",
  "PageUp": "scrollPageUp:",
  "PageDown": "scrollPageDown:",
  "Shift+Backspace": "deleteBackward:",
  "Shift+Enter": "insertNewline:",
  "Shift+NumpadEnter": "insertNewline:",
  "Shift+Escape": "cancelOperation:",
  "Shift+ArrowUp": "moveUpAndModifySelection:",
  "Shift+ArrowDown": "moveDownAndModifySelection:",
  "Shift+ArrowLeft": "moveLeftAndModifySelection:",
  "Shift+ArrowRight": "moveRightAndModifySelection:",
  "Shift+F5": "complete:",
  "Shift+Delete": "deleteForward:",
  "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
  "Shift+End": "moveToEndOfDocumentAndModifySelection:",
  "Shift+PageUp": "pageUpAndModifySelection:",
  "Shift+PageDown": "pageDownAndModifySelection:",
  "Shift+Numpad5": "delete:",
  "Control+Tab": "selectNextKeyView:",
  "Control+Enter": "insertLineBreak:",
  "Control+NumpadEnter": "insertLineBreak:",
  "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
  "Control+KeyA": "moveToBeginningOfParagraph:",
  "Control+KeyB": "moveBackward:",
  "Control+KeyD": "deleteForward:",
  "Control+KeyE": "moveToEndOfParagraph:",
  "Control+KeyF": "moveForward:",
  "Control+KeyH": "deleteBackward:",
  "Control+KeyK": "deleteToEndOfParagraph:",
  "Control+KeyL": "centerSelectionInVisibleArea:",
  "Control+KeyN": "moveDown:",
  "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
  "Control+KeyP": "moveUp:",
  "Control+KeyT": "transpose:",
  "Control+KeyV": "pageDown:",
  "Control+KeyY": "yank:",
  "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
  "Control+ArrowUp": "scrollPageUp:",
  "Control+ArrowDown": "scrollPageDown:",
  "Control+ArrowLeft": "moveToLeftEndOfLine:",
  "Control+ArrowRight": "moveToRightEndOfLine:",
  "Shift+Control+Enter": "insertLineBreak:",
  "Shift+Control+NumpadEnter": "insertLineBreak:",
  "Shift+Control+Tab": "selectPreviousKeyView:",
  "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
  "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
  "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
  "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
  "Shift+Control+KeyF": "moveForwardAndModifySelection:",
  "Shift+Control+KeyN": "moveDownAndModifySelection:",
  "Shift+Control+KeyP": "moveUpAndModifySelection:",
  "Shift+Control+KeyV": "pageDownAndModifySelection:",
  "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
  "Shift+Control+ArrowUp": "scrollPageUp:",
  "Shift+Control+ArrowDown": "scrollPageDown:",
  "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
  "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
  "Alt+Backspace": "deleteWordBackward:",
  "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
  "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
  "Alt+Escape": "complete:",
  "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
  "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
  "Alt+ArrowLeft": "moveWordLeft:",
  "Alt+ArrowRight": "moveWordRight:",
  "Alt+Delete": "deleteWordForward:",
  "Alt+PageUp": "pageUp:",
  "Alt+PageDown": "pageDown:",
  "Shift+Alt+Backspace": "deleteWordBackward:",
  "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
  "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
  "Shift+Alt+Escape": "complete:",
  "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
  "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
  "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
  "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
  "Shift+Alt+Delete": "deleteWordForward:",
  "Shift+Alt+PageUp": "pageUp:",
  "Shift+Alt+PageDown": "pageDown:",
  "Control+Alt+KeyB": "moveWordBackward:",
  "Control+Alt+KeyF": "moveWordForward:",
  "Control+Alt+Backspace": "deleteWordBackward:",
  "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
  "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
  "Shift+Control+Alt+Backspace": "deleteWordBackward:",
  "Meta+NumpadSubtract": "cancel:",
  "Meta+Backspace": "deleteToBeginningOfLine:",
  "Meta+ArrowUp": "moveToBeginningOfDocument:",
  "Meta+ArrowDown": "moveToEndOfDocument:",
  "Meta+ArrowLeft": "moveToLeftEndOfLine:",
  "Meta+ArrowRight": "moveToRightEndOfLine:",
  "Shift+Meta+NumpadSubtract": "cancel:",
  "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
  "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
  "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
  "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
  "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
  "Meta+KeyA": "selectAll:",
  "Meta+KeyC": "copy:",
  "Meta+KeyX": "cut:",
  "Meta+KeyV": "paste:",
  "Meta+KeyZ": "undo:",
  "Shift+Meta+KeyZ": "redo:"
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crInput.js
var RawKeyboardImpl = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(_client, _isMac, _dragManger) {
    this._client = _client;
    this._isMac = _isMac;
    this._dragManger = _dragManger;
  }
  _commandsForCode(code, modifiers) {
    if (!this._isMac)
      return [];
    const parts = [];
    for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
      if (modifiers.has(modifier))
        parts.push(modifier);
    }
    parts.push(code);
    const shortcut = parts.join("+");
    let commands = macEditingCommands[shortcut] || [];
    if (isString(commands))
      commands = [commands];
    commands = commands.filter((x) => !x.startsWith("insert"));
    return commands.map((c) => c.substring(0, c.length - 1));
  }
  async keydown(progress3, modifiers, keyName, description, autoRepeat) {
    const { code, key, location: location2, text } = description;
    if (code === "Escape" && await progress3.race(this._dragManger.cancelDrag()))
      return;
    const commands = this._commandsForCode(code, modifiers);
    await progress3.race(this._client.send("Input.dispatchKeyEvent", {
      type: text ? "keyDown" : "rawKeyDown",
      modifiers: toModifiersMask(modifiers),
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code,
      commands,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location: location2,
      isKeypad: location2 === keypadLocation2
    }));
  }
  async keyup(progress3, modifiers, keyName, description) {
    const { code, key, location: location2 } = description;
    await progress3.race(this._client.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: toModifiersMask(modifiers),
      key,
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code,
      location: location2
    }));
  }
  async sendText(progress3, text) {
    await progress3.race(this._client.send("Input.insertText", { text }));
  }
};
var RawMouseImpl = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(page, client, dragManager) {
    this._page = page;
    this._client = client;
    this._dragManager = dragManager;
  }
  async move(progress3, x, y, button, buttons, modifiers, forClick) {
    const actualMove = /* @__PURE__ */ __name(async () => {
      await progress3.race(this._client.send("Input.dispatchMouseEvent", {
        type: "mouseMoved",
        button,
        buttons: toButtonsMask(buttons),
        x,
        y,
        modifiers: toModifiersMask(modifiers),
        force: buttons.size > 0 ? 0.5 : 0
      }));
    }, "actualMove");
    if (forClick) {
      await actualMove();
      return;
    }
    await this._dragManager.interceptDragCausedByMove(progress3, x, y, button, buttons, modifiers, actualMove);
  }
  async down(progress3, x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging())
      return;
    await progress3.race(this._client.send("Input.dispatchMouseEvent", {
      type: "mousePressed",
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount,
      force: buttons.size > 0 ? 0.5 : 0
    }));
  }
  async up(progress3, x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging()) {
      await this._dragManager.drop(progress3, x, y, modifiers);
      return;
    }
    await progress3.race(this._client.send("Input.dispatchMouseEvent", {
      type: "mouseReleased",
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount
    }));
  }
  async wheel(progress3, x, y, buttons, modifiers, deltaX, deltaY) {
    await progress3.race(this._client.send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      deltaX,
      deltaY
    }));
  }
};
var RawTouchscreenImpl = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async tap(progress3, x, y, modifiers) {
    await progress3.race(Promise.all([
      this._client.send("Input.dispatchTouchEvent", {
        type: "touchStart",
        modifiers: toModifiersMask(modifiers),
        touchPoints: [{
          x,
          y
        }]
      }),
      this._client.send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        modifiers: toModifiersMask(modifiers),
        touchPoints: []
      })
    ]));
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crNetworkManager.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/headers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function headersObjectToArray(headers, separator, setCookieSeparator) {
  if (!setCookieSeparator)
    setCookieSeparator = separator;
  const result = [];
  for (const name in headers) {
    const values = headers[name];
    if (values === void 0)
      continue;
    if (separator) {
      const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
      for (const value of values.split(sep))
        result.push({ name, value: value.trim() });
    } else {
      result.push({ name, value: values });
    }
  }
  return result;
}
__name(headersObjectToArray, "headersObjectToArray");
function headersArrayToObject(headers, lowerCase) {
  const result = {};
  for (const { name, value } of headers)
    result[lowerCase ? name.toLowerCase() : name] = value;
  return result;
}
__name(headersArrayToObject, "headersArrayToObject");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crNetworkManager.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var CRNetworkManager = class {
  static {
    __name(this, "CRNetworkManager");
  }
  constructor(page, serviceWorker) {
    this._requestIdToRequest = /* @__PURE__ */ new Map();
    this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
    this._credentials = null;
    this._attemptedAuthentications = /* @__PURE__ */ new Set();
    this._userRequestInterceptionEnabled = false;
    this._protocolRequestInterceptionEnabled = false;
    this._offline = false;
    this._extraHTTPHeaders = [];
    this._requestIdToRequestPausedEvent = /* @__PURE__ */ new Map();
    this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
    this._sessions = /* @__PURE__ */ new Map();
    this._page = page;
    this._serviceWorker = serviceWorker;
  }
  async addSession(session2, workerFrame, isMain) {
    const sessionInfo = { session: session2, isMain, workerFrame, eventListeners: [] };
    sessionInfo.eventListeners = [
      eventsHelper.addEventListener(session2, "Fetch.requestPaused", this._onRequestPaused.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Fetch.authRequired", this._onAuthRequired.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestServedFromCache", this._onRequestServedFromCache.bind(this)),
      eventsHelper.addEventListener(session2, "Network.responseReceived", this._onResponseReceived.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)),
      eventsHelper.addEventListener(session2, "Network.loadingFinished", this._onLoadingFinished.bind(this, sessionInfo)),
      eventsHelper.addEventListener(session2, "Network.loadingFailed", this._onLoadingFailed.bind(this, sessionInfo))
    ];
    if (this._page) {
      sessionInfo.eventListeners.push(...[
        eventsHelper.addEventListener(session2, "Network.webSocketCreated", (e) => this._page.frameManager.onWebSocketCreated(e.requestId, e.url)),
        eventsHelper.addEventListener(session2, "Network.webSocketWillSendHandshakeRequest", (e) => this._page.frameManager.onWebSocketRequest(e.requestId)),
        eventsHelper.addEventListener(session2, "Network.webSocketHandshakeResponseReceived", (e) => this._page.frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page.frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page.frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
        eventsHelper.addEventListener(session2, "Network.webSocketClosed", (e) => this._page.frameManager.webSocketClosed(e.requestId)),
        eventsHelper.addEventListener(session2, "Network.webSocketFrameError", (e) => this._page.frameManager.webSocketError(e.requestId, e.errorMessage))
      ]);
    }
    this._sessions.set(session2, sessionInfo);
    await Promise.all([
      session2.send("Network.enable"),
      this._updateProtocolRequestInterceptionForSession(
        sessionInfo,
        true
        /* initial */
      ),
      this._setOfflineForSession(
        sessionInfo,
        true
        /* initial */
      ),
      this._setExtraHTTPHeadersForSession(
        sessionInfo,
        true
        /* initial */
      )
    ]);
  }
  removeSession(session2) {
    const info3 = this._sessions.get(session2);
    if (info3)
      eventsHelper.removeEventListeners(info3.eventListeners);
    this._sessions.delete(session2);
  }
  async _forEachSession(cb) {
    await Promise.all([...this._sessions.values()].map((info3) => {
      if (info3.isMain)
        return cb(info3);
      return cb(info3).catch((e) => {
        if (isSessionClosedError(e))
          return;
        throw e;
      });
    }));
  }
  async authenticate(credentials) {
    this._credentials = credentials;
    await this._updateProtocolRequestInterception();
  }
  async setOffline(offline) {
    if (offline === this._offline)
      return;
    this._offline = offline;
    await this._forEachSession((info3) => this._setOfflineForSession(info3));
  }
  async _setOfflineForSession(info3, initial) {
    if (initial && !this._offline)
      return;
    if (info3.workerFrame)
      return;
    await info3.session.send("Network.emulateNetworkConditions", {
      offline: this._offline,
      // values of 0 remove any active throttling. crbug.com/456324#c9
      latency: 0,
      downloadThroughput: -1,
      uploadThroughput: -1
    });
  }
  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value;
    await this._updateProtocolRequestInterception();
  }
  async _updateProtocolRequestInterception() {
    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
    if (enabled === this._protocolRequestInterceptionEnabled)
      return;
    this._protocolRequestInterceptionEnabled = enabled;
    await this._forEachSession((info3) => this._updateProtocolRequestInterceptionForSession(info3));
  }
  async _updateProtocolRequestInterceptionForSession(info3, initial) {
    const enabled = this._protocolRequestInterceptionEnabled;
    if (initial && !enabled)
      return;
    const cachePromise = info3.session.send("Network.setCacheDisabled", { cacheDisabled: enabled });
    let fetchPromise = Promise.resolve(void 0);
    if (!info3.workerFrame) {
      if (enabled)
        fetchPromise = info3.session.send("Fetch.enable", { handleAuthRequests: true, patterns: [{ urlPattern: "*", requestStage: "Request" }] });
      else
        fetchPromise = info3.session.send("Fetch.disable");
    }
    await Promise.all([cachePromise, fetchPromise]);
  }
  async setExtraHTTPHeaders(extraHTTPHeaders) {
    if (!this._extraHTTPHeaders.length && !extraHTTPHeaders.length)
      return;
    this._extraHTTPHeaders = extraHTTPHeaders;
    await this._forEachSession((info3) => this._setExtraHTTPHeadersForSession(info3));
  }
  async _setExtraHTTPHeadersForSession(info3, initial) {
    if (initial && !this._extraHTTPHeaders.length)
      return;
    await info3.session.send("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._extraHTTPHeaders,
      false
      /* lowerCase */
    ) });
  }
  async clearCache() {
    await this._forEachSession(async (info3) => {
      await info3.session.send("Network.setCacheDisabled", { cacheDisabled: true });
      if (!this._protocolRequestInterceptionEnabled)
        await info3.session.send("Network.setCacheDisabled", { cacheDisabled: false });
      if (!info3.workerFrame)
        await info3.session.send("Network.clearBrowserCache");
    });
  }
  _onRequestWillBeSent(sessionInfo, event) {
    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
      const requestId = event.requestId;
      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
      if (requestPausedEvent) {
        this._onRequest(sessionInfo, event, requestPausedEvent.sessionInfo, requestPausedEvent.event);
        this._requestIdToRequestPausedEvent.delete(requestId);
      } else {
        this._requestIdToRequestWillBeSentEvent.set(event.requestId, { sessionInfo, event });
      }
    } else {
      this._onRequest(sessionInfo, event, void 0, void 0);
    }
  }
  _onRequestServedFromCache(event) {
    this._responseExtraInfoTracker.requestServedFromCache(event);
  }
  _onRequestWillBeSentExtraInfo(event) {
    this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
  }
  _onAuthRequired(sessionInfo, event) {
    let response = "Default";
    const shouldProvideCredentials = this._shouldProvideCredentials(event.request.url);
    if (this._attemptedAuthentications.has(event.requestId)) {
      response = "CancelAuth";
    } else if (shouldProvideCredentials) {
      response = "ProvideCredentials";
      this._attemptedAuthentications.add(event.requestId);
    }
    const { username, password } = shouldProvideCredentials && this._credentials ? this._credentials : { username: void 0, password: void 0 };
    sessionInfo.session._sendMayFail("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    });
  }
  _shouldProvideCredentials(url4) {
    if (!this._credentials)
      return false;
    return !this._credentials.origin || new URL(url4).origin.toLowerCase() === this._credentials.origin.toLowerCase();
  }
  _onRequestPaused(sessionInfo, event) {
    if (!event.networkId) {
      sessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: event.requestId });
      return;
    }
    if (event.request.url.startsWith("data:"))
      return;
    const requestId = event.networkId;
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
    if (requestWillBeSentEvent) {
      this._onRequest(requestWillBeSentEvent.sessionInfo, requestWillBeSentEvent.event, sessionInfo, event);
      this._requestIdToRequestWillBeSentEvent.delete(requestId);
    } else {
      const existingRequest = this._requestIdToRequest.get(requestId);
      const alreadyContinuedParams = existingRequest?._route?._alreadyContinuedParams;
      if (alreadyContinuedParams && !event.redirectedRequestId) {
        sessionInfo.session._sendMayFail("Fetch.continueRequest", {
          ...alreadyContinuedParams,
          requestId: event.requestId
        });
        return;
      }
      this._requestIdToRequestPausedEvent.set(requestId, { sessionInfo, event });
    }
  }
  _onRequest(requestWillBeSentSessionInfo, requestWillBeSentEvent, requestPausedSessionInfo, requestPausedEvent) {
    if (requestWillBeSentEvent.request.url.startsWith("data:"))
      return;
    let redirectedFrom = null;
    if (requestWillBeSentEvent.redirectResponse) {
      const request22 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
      if (request22) {
        this._handleRequestRedirect(request22, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);
        redirectedFrom = request22;
      }
    }
    let frame = requestWillBeSentEvent.frameId ? this._page?.frameManager.frame(requestWillBeSentEvent.frameId) : requestWillBeSentSessionInfo.workerFrame;
    if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId)
      frame = this._page.frameManager.frame(requestPausedEvent.frameId);
    if (!frame && this._page && requestWillBeSentEvent.frameId === (this._page?.delegate)._targetId) {
      frame = this._page.frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
    }
    const isInterceptedOptionsPreflight = !!requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && requestWillBeSentEvent.initiator.type === "preflight";
    if (isInterceptedOptionsPreflight && (this._page || this._serviceWorker).needsRequestInterception()) {
      const requestHeaders = requestPausedEvent.request.headers;
      const responseHeaders = [
        { name: "Access-Control-Allow-Origin", value: requestHeaders["Origin"] || "*" },
        { name: "Access-Control-Allow-Methods", value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE" },
        { name: "Access-Control-Allow-Credentials", value: "true" }
      ];
      if (requestHeaders["Access-Control-Request-Headers"])
        responseHeaders.push({ name: "Access-Control-Allow-Headers", value: requestHeaders["Access-Control-Request-Headers"] });
      requestPausedSessionInfo.session._sendMayFail("Fetch.fulfillRequest", {
        requestId: requestPausedEvent.requestId,
        responseCode: 204,
        responsePhrase: statusText(204),
        responseHeaders,
        body: ""
      });
      return;
    }
    if (!frame && !this._serviceWorker) {
      if (requestPausedEvent)
        requestPausedSessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: requestPausedEvent.requestId });
      return;
    }
    let route = null;
    let headersOverride;
    if (requestPausedEvent) {
      if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
        headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
        requestPausedSessionInfo.session._sendMayFail("Fetch.continueRequest", { requestId: requestPausedEvent.requestId, headers: headersOverride });
      } else {
        route = new RouteImpl(requestPausedSessionInfo.session, requestPausedEvent.requestId);
      }
    }
    const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
    const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
    const request2 = new InterceptableRequest({
      session: requestWillBeSentSessionInfo.session,
      context: (this._page || this._serviceWorker).browserContext,
      frame: frame || null,
      serviceWorker: this._serviceWorker || null,
      documentId,
      route,
      requestWillBeSentEvent,
      requestPausedEvent,
      redirectedFrom,
      headersOverride: headersOverride || null
    });
    this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request2);
    if (route) {
      request2.request.setRawRequestHeaders(headersObjectToArray(requestPausedEvent.request.headers, "\n"));
    }
    (this._page?.frameManager || this._serviceWorker).requestStarted(request2.request, route || void 0);
  }
  _createResponse(request2, responsePayload, hasExtraInfo) {
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const contentLengthHeader = Object.entries(responsePayload.headers).find((header) => header[0].toLowerCase() === "content-length");
      const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : void 0;
      const session2 = request2.session;
      const response2 = await session2.send("Network.getResponseBody", { requestId: request2._requestId });
      if (response2.body || !expectedLength)
        return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
      if (request2._route?._fulfilled)
        return Buffer.from("");
      const resource = await session2.send("Network.loadNetworkResource", { url: request2.request.url(), frameId: this._serviceWorker ? void 0 : request2.request.frame()._id, options: { disableCache: false, includeCredentials: true } });
      const chunks = [];
      while (resource.resource.stream) {
        const chunk = await session2.send("IO.read", { handle: resource.resource.stream });
        chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? "base64" : "utf-8"));
        if (chunk.eof) {
          await session2.send("IO.close", { handle: resource.resource.stream });
          break;
        }
      }
      return Buffer.concat(chunks);
    }, "getResponseBody");
    const timingPayload = responsePayload.timing;
    let timing;
    if (timingPayload && !this._responseExtraInfoTracker.servedFromCache(request2._requestId)) {
      timing = {
        startTime: (timingPayload.requestTime - request2._timestamp + request2._wallTime) * 1e3,
        domainLookupStart: timingPayload.dnsStart,
        domainLookupEnd: timingPayload.dnsEnd,
        connectStart: timingPayload.connectStart,
        secureConnectionStart: timingPayload.sslStart,
        connectEnd: timingPayload.connectEnd,
        requestStart: timingPayload.sendStart,
        responseStart: timingPayload.receiveHeadersEnd
      };
    } else {
      timing = {
        startTime: request2._wallTime * 1e3,
        domainLookupStart: -1,
        domainLookupEnd: -1,
        connectStart: -1,
        secureConnectionStart: -1,
        connectEnd: -1,
        requestStart: -1,
        responseStart: -1
      };
    }
    const response = new Response2(request2.request, responsePayload.status, responsePayload.statusText, headersObjectToArray(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);
    if (responsePayload?.remoteIPAddress && typeof responsePayload?.remotePort === "number") {
      response._serverAddrFinished({
        ipAddress: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      });
    } else {
      response._serverAddrFinished();
    }
    response._securityDetailsFinished({
      protocol: responsePayload?.securityDetails?.protocol,
      subjectName: responsePayload?.securityDetails?.subjectName,
      issuer: responsePayload?.securityDetails?.issuer,
      validFrom: responsePayload?.securityDetails?.validFrom,
      validTo: responsePayload?.securityDetails?.validTo
    });
    this._responseExtraInfoTracker.processResponse(request2._requestId, response, hasExtraInfo);
    return response;
  }
  _deleteRequest(request2) {
    this._requestIdToRequest.delete(request2._requestId);
    if (request2._interceptionId)
      this._attemptedAuthentications.delete(request2._interceptionId);
  }
  _handleRequestRedirect(request2, responsePayload, timestamp2, hasExtraInfo) {
    const response = this._createResponse(request2, responsePayload, hasExtraInfo);
    response.setTransferSize(null);
    response.setEncodedBodySize(null);
    response._requestFinished((timestamp2 - request2._timestamp) * 1e3);
    this._deleteRequest(request2);
    (this._page?.frameManager || this._serviceWorker).requestReceivedResponse(response);
    (this._page?.frameManager || this._serviceWorker).reportRequestFinished(request2.request, response);
  }
  _onResponseReceivedExtraInfo(event) {
    this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
  }
  _onResponseReceived(sessionInfo, event) {
    let request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2 && event.response.fromServiceWorker) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
      if (requestWillBeSentEvent) {
        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
        this._onRequest(sessionInfo, requestWillBeSentEvent.event, void 0, void 0);
        request2 = this._requestIdToRequest.get(event.requestId);
      }
    }
    if (!request2)
      return;
    const response = this._createResponse(request2, event.response, event.hasExtraInfo);
    (this._page?.frameManager || this._serviceWorker).requestReceivedResponse(response);
  }
  _onLoadingFinished(sessionInfo, event) {
    this._responseExtraInfoTracker.loadingFinished(event);
    const request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2)
      return;
    this._maybeUpdateRequestSession(sessionInfo, request2);
    const response = request2.request._existingResponse();
    if (response) {
      response.setTransferSize(event.encodedDataLength);
      response.responseHeadersSize().then((size) => response.setEncodedBodySize(event.encodedDataLength - size));
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request2._timestamp));
    }
    this._deleteRequest(request2);
    (this._page?.frameManager || this._serviceWorker).reportRequestFinished(request2.request, response);
  }
  _onLoadingFailed(sessionInfo, event) {
    this._responseExtraInfoTracker.loadingFailed(event);
    let request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
      if (requestWillBeSentEvent) {
        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
        this._onRequest(sessionInfo, requestWillBeSentEvent.event, void 0, void 0);
        request2 = this._requestIdToRequest.get(event.requestId);
      }
    }
    if (!request2)
      return;
    this._maybeUpdateRequestSession(sessionInfo, request2);
    const response = request2.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request2._timestamp));
    } else {
      request2.request.setRawRequestHeaders(null);
    }
    this._deleteRequest(request2);
    request2.request._setFailureText(event.errorText || event.blockedReason || "");
    (this._page?.frameManager || this._serviceWorker).requestFailed(request2.request, !!event.canceled);
  }
  _maybeUpdateRequestSession(sessionInfo, request2) {
    if (request2.session !== sessionInfo.session && !sessionInfo.isMain && (request2._documentId === request2._requestId || sessionInfo.workerFrame))
      request2.session = sessionInfo.session;
  }
};
var InterceptableRequest = class {
  static {
    __name(this, "InterceptableRequest");
  }
  constructor(options2) {
    const { session: session2, context: context2, frame, documentId, route, requestWillBeSentEvent, requestPausedEvent, redirectedFrom, serviceWorker, headersOverride } = options2;
    this.session = session2;
    this._timestamp = requestWillBeSentEvent.timestamp;
    this._wallTime = requestWillBeSentEvent.wallTime;
    this._requestId = requestWillBeSentEvent.requestId;
    this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
    this._documentId = documentId;
    this._route = route;
    this._originalRequestRoute = route ?? redirectedFrom?._originalRequestRoute;
    const {
      headers,
      method,
      url: url4,
      postDataEntries = null
    } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
    const type = (requestWillBeSentEvent.type || "").toLowerCase();
    let postDataBuffer = null;
    const entries = postDataEntries?.filter((entry) => entry.bytes);
    if (entries && entries.length)
      postDataBuffer = Buffer.concat(entries.map((entry) => Buffer.from(entry.bytes, "base64")));
    this.request = new Request(context2, frame, serviceWorker, redirectedFrom?.request || null, documentId, url4, type, method, postDataBuffer, headersOverride || headersObjectToArray(headers));
  }
};
var RouteImpl = class {
  static {
    __name(this, "RouteImpl");
  }
  constructor(session2, interceptionId) {
    this._fulfilled = false;
    this._session = session2;
    this._interceptionId = interceptionId;
  }
  async continue(overrides) {
    this._alreadyContinuedParams = {
      requestId: this._interceptionId,
      url: overrides.url,
      headers: overrides.headers,
      method: overrides.method,
      postData: overrides.postData ? overrides.postData.toString("base64") : void 0
    };
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.continueRequest", this._alreadyContinuedParams);
    });
  }
  async fulfill(response) {
    this._fulfilled = true;
    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    const responseHeaders = splitSetCookieHeader(response.headers);
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: response.status,
        responsePhrase: statusText(response.status),
        responseHeaders,
        body
      });
    });
  }
  async abort(errorCode = "failed") {
    const errorReason = errorReasons[errorCode];
    assert3(errorReason, "Unknown error code: " + errorCode);
    await catchDisallowedErrors(async () => {
      await this._session.send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason
      });
    });
  }
};
async function catchDisallowedErrors(callback) {
  try {
    return await callback();
  } catch (e) {
    if (isProtocolError(e) && e.message.includes("Invalid http status code or phrase"))
      throw e;
    if (isProtocolError(e) && e.message.includes("Unsafe header"))
      throw e;
  }
}
__name(catchDisallowedErrors, "catchDisallowedErrors");
function splitSetCookieHeader(headers) {
  const index2 = headers.findIndex(({ name }) => name.toLowerCase() === "set-cookie");
  if (index2 === -1)
    return headers;
  const header = headers[index2];
  const values = header.value.split("\n");
  if (values.length === 1)
    return headers;
  const result = headers.slice();
  result.splice(index2, 1, ...values.map((value) => ({ name: header.name, value })));
  return result;
}
__name(splitSetCookieHeader, "splitSetCookieHeader");
var errorReasons = {
  "aborted": "Aborted",
  "accessdenied": "AccessDenied",
  "addressunreachable": "AddressUnreachable",
  "blockedbyclient": "BlockedByClient",
  "blockedbyresponse": "BlockedByResponse",
  "connectionaborted": "ConnectionAborted",
  "connectionclosed": "ConnectionClosed",
  "connectionfailed": "ConnectionFailed",
  "connectionrefused": "ConnectionRefused",
  "connectionreset": "ConnectionReset",
  "internetdisconnected": "InternetDisconnected",
  "namenotresolved": "NameNotResolved",
  "timedout": "TimedOut",
  "failed": "Failed"
};
var ResponseExtraInfoTracker = class {
  static {
    __name(this, "ResponseExtraInfoTracker");
  }
  constructor() {
    this._requests = /* @__PURE__ */ new Map();
  }
  requestWillBeSentExtraInfo(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.requestWillBeSentExtraInfo.push(event);
    this._patchHeaders(info3, info3.requestWillBeSentExtraInfo.length - 1);
    this._checkFinished(info3);
  }
  requestServedFromCache(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.servedFromCache = true;
  }
  servedFromCache(requestId) {
    const info3 = this._requests.get(requestId);
    return !!info3?.servedFromCache;
  }
  responseReceivedExtraInfo(event) {
    const info3 = this._getOrCreateEntry(event.requestId);
    info3.responseReceivedExtraInfo.push(event);
    this._patchHeaders(info3, info3.responseReceivedExtraInfo.length - 1);
    this._checkFinished(info3);
  }
  processResponse(requestId, response, hasExtraInfo) {
    let info3 = this._requests.get(requestId);
    if (!hasExtraInfo || info3?.servedFromCache) {
      response.request().setRawRequestHeaders(null);
      response.setResponseHeadersSize(null);
      response.setRawResponseHeaders(null);
      return;
    }
    info3 = this._getOrCreateEntry(requestId);
    info3.responses.push(response);
    this._patchHeaders(info3, info3.responses.length - 1);
  }
  loadingFinished(event) {
    const info3 = this._requests.get(event.requestId);
    if (!info3)
      return;
    info3.loadingFinished = event;
    this._checkFinished(info3);
  }
  loadingFailed(event) {
    const info3 = this._requests.get(event.requestId);
    if (!info3)
      return;
    info3.loadingFailed = event;
    this._checkFinished(info3);
  }
  _getOrCreateEntry(requestId) {
    let info3 = this._requests.get(requestId);
    if (!info3) {
      info3 = {
        requestId,
        requestWillBeSentExtraInfo: [],
        responseReceivedExtraInfo: [],
        responses: []
      };
      this._requests.set(requestId, info3);
    }
    return info3;
  }
  _patchHeaders(info3, index2) {
    const response = info3.responses[index2];
    const requestExtraInfo = info3.requestWillBeSentExtraInfo[index2];
    if (response && requestExtraInfo) {
      response.request().setRawRequestHeaders(headersObjectToArray(requestExtraInfo.headers, "\n"));
      info3.requestWillBeSentExtraInfo[index2] = void 0;
    }
    const responseExtraInfo = info3.responseReceivedExtraInfo[index2];
    if (response && responseExtraInfo) {
      response.setResponseHeadersSize(responseExtraInfo.headersText?.length || 0);
      response.setRawResponseHeaders(headersObjectToArray(responseExtraInfo.headers, "\n"));
      info3.responseReceivedExtraInfo[index2] = void 0;
    }
  }
  _checkFinished(info3) {
    if (!info3.loadingFinished && !info3.loadingFailed)
      return;
    if (info3.responses.length <= info3.responseReceivedExtraInfo.length) {
      this._stopTracking(info3.requestId);
      return;
    }
  }
  _stopTracking(requestId) {
    this._requests.delete(requestId);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crPdf.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var PagePaperFormats = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};
var unitToPixels = {
  "px": 1,
  "in": 96,
  "cm": 37.8,
  "mm": 3.78
};
function convertPrintParameterToInches(text) {
  if (text === void 0)
    return void 0;
  let unit = text.substring(text.length - 2).toLowerCase();
  let valueText = "";
  if (unitToPixels.hasOwnProperty(unit)) {
    valueText = text.substring(0, text.length - 2);
  } else {
    unit = "px";
    valueText = text;
  }
  const value = Number(valueText);
  assert3(!isNaN(value), "Failed to parse parameter value: " + text);
  const pixels = value * unitToPixels[unit];
  return pixels / 96;
}
__name(convertPrintParameterToInches, "convertPrintParameterToInches");
var CRPDF = class {
  static {
    __name(this, "CRPDF");
  }
  constructor(client) {
    this._client = client;
  }
  async generate(options2) {
    const {
      scale = 1,
      displayHeaderFooter = false,
      headerTemplate = "",
      footerTemplate = "",
      printBackground = false,
      landscape = false,
      pageRanges = "",
      preferCSSPageSize = false,
      margin = {},
      tagged = false,
      outline = false
    } = options2;
    let paperWidth = 8.5;
    let paperHeight = 11;
    if (options2.format) {
      const format2 = PagePaperFormats[options2.format.toLowerCase()];
      assert3(format2, "Unknown paper format: " + options2.format);
      paperWidth = format2.width;
      paperHeight = format2.height;
    } else {
      paperWidth = convertPrintParameterToInches(options2.width) || paperWidth;
      paperHeight = convertPrintParameterToInches(options2.height) || paperHeight;
    }
    const marginTop = convertPrintParameterToInches(margin.top) || 0;
    const marginLeft = convertPrintParameterToInches(margin.left) || 0;
    const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
    const marginRight = convertPrintParameterToInches(margin.right) || 0;
    const generateDocumentOutline = outline;
    const generateTaggedPDF = tagged;
    const result = await this._client.send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale,
      paperWidth,
      paperHeight,
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      pageRanges,
      preferCSSPageSize,
      generateTaggedPDF,
      generateDocumentOutline
    });
    return await readProtocolStream(this._client, result.stream);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/defaultFontFamilies.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var platformToFontFamilies = {
  "linux": {
    "fontFamilies": {
      "standard": "Times New Roman",
      "fixed": "Monospace",
      "serif": "Times New Roman",
      "sansSerif": "Arial",
      "cursive": "Comic Sans MS",
      "fantasy": "Impact"
    }
  },
  "mac": {
    "fontFamilies": {
      "standard": "Times",
      "fixed": "Courier",
      "serif": "Times",
      "sansSerif": "Helvetica",
      "cursive": "Apple Chancery",
      "fantasy": "Papyrus"
    },
    "forScripts": [
      {
        "script": "jpan",
        "fontFamilies": {
          "standard": "Hiragino Kaku Gothic ProN",
          "fixed": "Osaka-Mono",
          "serif": "Hiragino Mincho ProN",
          "sansSerif": "Hiragino Kaku Gothic ProN"
        }
      },
      {
        "script": "hang",
        "fontFamilies": {
          "standard": "Apple SD Gothic Neo",
          "serif": "AppleMyungjo",
          "sansSerif": "Apple SD Gothic Neo"
        }
      },
      {
        "script": "hans",
        "fontFamilies": {
          "standard": ",PingFang SC,STHeiti",
          "serif": "Songti SC",
          "sansSerif": ",PingFang SC,STHeiti",
          "cursive": "Kaiti SC"
        }
      },
      {
        "script": "hant",
        "fontFamilies": {
          "standard": ",PingFang TC,Heiti TC",
          "serif": "Songti TC",
          "sansSerif": ",PingFang TC,Heiti TC",
          "cursive": "Kaiti TC"
        }
      }
    ]
  },
  "win": {
    "fontFamilies": {
      "standard": "Times New Roman",
      "fixed": "Consolas",
      "serif": "Times New Roman",
      "sansSerif": "Arial",
      "cursive": "Comic Sans MS",
      "fantasy": "Impact"
    },
    "forScripts": [
      {
        "script": "cyrl",
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Courier New",
          "serif": "Times New Roman",
          "sansSerif": "Arial"
        }
      },
      {
        "script": "arab",
        "fontFamilies": {
          "fixed": "Courier New",
          "sansSerif": "Segoe UI"
        }
      },
      {
        "script": "grek",
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Courier New",
          "serif": "Times New Roman",
          "sansSerif": "Arial"
        }
      },
      {
        "script": "jpan",
        "fontFamilies": {
          "standard": ",Meiryo,Yu Gothic",
          "fixed": "MS Gothic",
          "serif": ",Yu Mincho,MS PMincho",
          "sansSerif": ",Meiryo,Yu Gothic"
        }
      },
      {
        "script": "hang",
        "fontFamilies": {
          "standard": "Malgun Gothic",
          "fixed": "Gulimche",
          "serif": "Batang",
          "sansSerif": "Malgun Gothic",
          "cursive": "Gungsuh"
        }
      },
      {
        "script": "hans",
        "fontFamilies": {
          "standard": "Microsoft YaHei",
          "fixed": "NSimsun",
          "serif": "Simsun",
          "sansSerif": "Microsoft YaHei",
          "cursive": "KaiTi"
        }
      },
      {
        "script": "hant",
        "fontFamilies": {
          "standard": "Microsoft JhengHei",
          "fixed": "MingLiU",
          "serif": "PMingLiU",
          "sansSerif": "Microsoft JhengHei",
          "cursive": "DFKai-SB"
        }
      }
    ]
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/videoRecorder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/processLauncher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs23 from "node:fs";
import "node:crypto";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var gracefullyCloseSet = /* @__PURE__ */ new Set();
var killSet = /* @__PURE__ */ new Set();
async function gracefullyCloseAll() {
  await Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
  })));
}
__name(gracefullyCloseAll, "gracefullyCloseAll");
function gracefullyProcessExitDoNotHang(code) {
  setTimeout(() => process.exit(code), 3e4);
  gracefullyCloseAll().then(() => {
    process.exit(code);
  });
}
__name(gracefullyProcessExitDoNotHang, "gracefullyProcessExitDoNotHang");
function exitHandler() {
  for (const kill2 of killSet)
    kill2();
}
__name(exitHandler, "exitHandler");
var sigintHandlerCalled = false;
function sigintHandler() {
  const exitWithCode130 = /* @__PURE__ */ __name(() => {
    if (isUnderTest()) {
      setTimeout(() => process.exit(130), 1e3);
    } else {
      process.exit(130);
    }
  }, "exitWithCode130");
  if (sigintHandlerCalled) {
    process.off("SIGINT", sigintHandler);
    for (const kill2 of killSet)
      kill2();
    exitWithCode130();
  } else {
    sigintHandlerCalled = true;
    gracefullyCloseAll().then(() => exitWithCode130());
  }
}
__name(sigintHandler, "sigintHandler");
function sigtermHandler() {
  gracefullyCloseAll();
}
__name(sigtermHandler, "sigtermHandler");
function sighupHandler() {
  gracefullyCloseAll();
}
__name(sighupHandler, "sighupHandler");
var installedHandlers = /* @__PURE__ */ new Set();
var processHandlers = {
  exit: exitHandler,
  SIGINT: sigintHandler,
  SIGTERM: sigtermHandler,
  SIGHUP: sighupHandler
};
function addProcessHandlerIfNeeded(name) {
  if (!installedHandlers.has(name)) {
    installedHandlers.add(name);
    process.on(name, processHandlers[name]);
  }
}
__name(addProcessHandlerIfNeeded, "addProcessHandlerIfNeeded");
function removeProcessHandlersIfNeeded() {
  if (killSet.size)
    return;
  for (const handler of installedHandlers)
    process.off(handler, processHandlers[handler]);
  installedHandlers.clear();
}
__name(removeProcessHandlersIfNeeded, "removeProcessHandlersIfNeeded");
async function launchProcess(options2) {
  const stdio = options2.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
  options2.log(`<launching> ${options2.command} ${options2.args ? options2.args.join(" ") : ""}`);
  const spawnOptions = {
    // On non-windows platforms, `detached: true` makes child process a leader of a new
    // process group, making it possible to kill child process tree with `.kill(-pid)` command.
    // @see https://nodejs.org/api/child_process.html#child_process_options_detached
    detached: process.platform !== "win32",
    env: options2.env,
    cwd: options2.cwd,
    shell: options2.shell,
    stdio
  };
  const spawnedProcess = spawn(options2.command, options2.args || [], spawnOptions);
  const cleanup = /* @__PURE__ */ __name(async () => {
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
    const errors2 = await removeFolders(options2.tempDirectories);
    for (let i = 0; i < options2.tempDirectories.length; ++i) {
      if (errors2[i])
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options2.tempDirectories[i]}: ${errors2[i]}`);
    }
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
  }, "cleanup");
  spawnedProcess.on("error", () => {
  });
  if (!spawnedProcess.pid) {
    let failed;
    const failedPromise = new Promise((f, r) => failed = f);
    spawnedProcess.once("error", (error3) => {
      failed(new Error("Failed to launch: " + error3));
    });
    return failedPromise.then(async (error3) => {
      await cleanup();
      throw error3;
    });
  }
  options2.log(`<launched> pid=${spawnedProcess.pid}`);
  const stdout2 = createInterface({ input: spawnedProcess.stdout });
  stdout2.on("line", (data) => {
    options2.log(`[pid=${spawnedProcess.pid}][out] ` + data);
  });
  const stderr2 = createInterface({ input: spawnedProcess.stderr });
  stderr2.on("line", (data) => {
    options2.log(`[pid=${spawnedProcess.pid}][err] ` + data);
  });
  let processClosed = false;
  let fulfillCleanup = /* @__PURE__ */ __name(() => {
  }, "fulfillCleanup");
  const waitForCleanup = new Promise((f) => fulfillCleanup = f);
  spawnedProcess.once("close", (exitCode2, signal) => {
    options2.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode2}, signal=${signal}>`);
    processClosed = true;
    gracefullyCloseSet.delete(gracefullyClose);
    killSet.delete(killProcessAndCleanup);
    removeProcessHandlersIfNeeded();
    options2.onExit(exitCode2, signal);
    cleanup().then(fulfillCleanup);
  });
  addProcessHandlerIfNeeded("exit");
  if (options2.handleSIGINT)
    addProcessHandlerIfNeeded("SIGINT");
  if (options2.handleSIGTERM)
    addProcessHandlerIfNeeded("SIGTERM");
  if (options2.handleSIGHUP)
    addProcessHandlerIfNeeded("SIGHUP");
  gracefullyCloseSet.add(gracefullyClose);
  killSet.add(killProcessAndCleanup);
  let gracefullyClosing = false;
  async function gracefullyClose() {
    if (gracefullyClosing) {
      options2.log(`[pid=${spawnedProcess.pid}] <forcefully close>`);
      killProcess();
      await waitForCleanup;
      return;
    }
    gracefullyClosing = true;
    options2.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
    await options2.attemptToGracefullyClose().catch(() => killProcess());
    await waitForCleanup;
    options2.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
  }
  __name(gracefullyClose, "gracefullyClose");
  function killProcess() {
    gracefullyCloseSet.delete(gracefullyClose);
    killSet.delete(killProcessAndCleanup);
    removeProcessHandlersIfNeeded();
    options2.log(`[pid=${spawnedProcess.pid}] <kill>`);
    if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
      options2.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
      try {
        if (process.platform === "win32") {
          const taskkillProcess = spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, { shell: true });
          const [stdout22, stderr22] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
          if (stdout22)
            options2.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout22}`);
          if (stderr22)
            options2.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr22}`);
        } else {
          process.kill(-spawnedProcess.pid, "SIGKILL");
        }
      } catch (e) {
        options2.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
      }
    } else {
      options2.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
    }
  }
  __name(killProcess, "killProcess");
  function killProcessAndCleanup() {
    killProcess();
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
    for (const dir3 of options2.tempDirectories) {
      try {
        fs23.rmSync(dir3, { force: true, recursive: true, maxRetries: 5 });
      } catch (e) {
        options2.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${dir3}: ${e}`);
      }
    }
    options2.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
  }
  __name(killProcessAndCleanup, "killProcessAndCleanup");
  function killAndWait() {
    killProcess();
    return waitForCleanup;
  }
  __name(killAndWait, "killAndWait");
  return { launchedProcess: spawnedProcess, gracefullyClose, kill: killAndWait };
}
__name(launchProcess, "launchProcess");
function envArrayToObject(env3) {
  const result = {};
  for (const { name, value } of env3)
    result[name] = value;
  return result;
}
__name(envArrayToObject, "envArrayToObject");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/videoRecorder.js
import "node:os";
var fps = 25;
var VideoRecorder = class _VideoRecorder {
  static {
    __name(this, "VideoRecorder");
  }
  constructor(page, ffmpegPath) {
    this._process = null;
    this._gracefullyClose = null;
    this._lastWritePromise = Promise.resolve();
    this._lastFrameTimestamp = 0;
    this._lastFrameBuffer = null;
    this._lastWriteTimestamp = 0;
    this._frameQueue = [];
    this._isStopped = false;
    this._ffmpegPath = ffmpegPath;
    page.on(Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.frameSwapWallTime / 1e3));
  }
  static async launch(page, ffmpegPath, options2) {
    if (!options2.outputFile.endsWith(".webm"))
      throw new Error("File must have .webm extension");
    const recorder = new _VideoRecorder(page, ffmpegPath);
    await recorder._launch(options2);
    return recorder;
  }
  async _launch(options2) {
    const w = options2.width;
    const h = options2.height;
    const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i pipe:0 -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
    args.push(options2.outputFile);
    const { launchedProcess, gracefullyClose } = await launchProcess({
      command: this._ffmpegPath,
      args,
      stdio: "stdin",
      log: /* @__PURE__ */ __name((message) => debugLogger.log("browser", message), "log"),
      tempDirectories: [],
      attemptToGracefullyClose: /* @__PURE__ */ __name(async () => {
        debugLogger.log("browser", "Closing stdin...");
        launchedProcess.stdin.end();
      }, "attemptToGracefullyClose"),
      onExit: /* @__PURE__ */ __name((exitCode2, signal) => {
        debugLogger.log("browser", `ffmpeg onkill exitCode=${exitCode2} signal=${signal}`);
      }, "onExit")
    });
    launchedProcess.stdin.on("finish", () => {
      debugLogger.log("browser", "ffmpeg finished input.");
    });
    launchedProcess.stdin.on("error", () => {
      debugLogger.log("browser", "ffmpeg error.");
    });
    this._process = launchedProcess;
    this._gracefullyClose = gracefullyClose;
  }
  writeFrame(frame, timestamp2) {
    assert3(this._process);
    if (this._isStopped)
      return;
    if (this._lastFrameBuffer) {
      const durationSec = timestamp2 - this._lastFrameTimestamp;
      const repeatCount = Math.max(1, Math.round(fps * durationSec));
      for (let i = 0; i < repeatCount; ++i)
        this._frameQueue.push(this._lastFrameBuffer);
      this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
    }
    this._lastFrameBuffer = frame;
    this._lastFrameTimestamp = timestamp2;
    this._lastWriteTimestamp = monotonicTime();
  }
  async _sendFrames() {
    while (this._frameQueue.length)
      await this._sendFrame(this._frameQueue.shift());
  }
  async _sendFrame(frame) {
    return new Promise((f) => this._process.stdin.write(frame, f)).then((error3) => {
      if (error3)
        debugLogger.log("browser", `ffmpeg failed to write: ${String(error3)}`);
    });
  }
  async stop() {
    if (this._isStopped)
      return;
    this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + (monotonicTime() - this._lastWriteTimestamp) / 1e3);
    this._isStopped = true;
    await this._lastWritePromise;
    await this._gracefullyClose();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crPage.js
var CRPage = class {
  static {
    __name(this, "CRPage");
  }
  constructor(client, targetId, browserContext, opener, bits) {
    this._sessions = /* @__PURE__ */ new Map();
    this._nextWindowOpenPopupFeatures = [];
    this._targetId = targetId;
    this._opener = opener;
    this._isBackgroundPage = bits.isBackgroundPage;
    const dragManager = new DragManager(this);
    this.rawKeyboard = new RawKeyboardImpl(client, browserContext._browser._platform() === "mac", dragManager);
    this.rawMouse = new RawMouseImpl(this, client, dragManager);
    this.rawTouchscreen = new RawTouchscreenImpl(client);
    this._pdf = new CRPDF(client);
    this._coverage = new CRCoverage(client);
    this._browserContext = browserContext;
    this._page = new Page(this, browserContext);
    this.utilityWorldName = `__playwright_utility_world_${this._page.guid}`;
    this._networkManager = new CRNetworkManager(this._page, null);
    this.updateOffline();
    this.updateExtraHTTPHeaders();
    this.updateHttpCredentials();
    this.updateRequestInterception();
    this._mainFrameSession = new FrameSession(this, client, targetId, null);
    this._sessions.set(targetId, this._mainFrameSession);
    if (opener && !browserContext._options.noDefaultViewport) {
      const features2 = opener._nextWindowOpenPopupFeatures.shift() || [];
      const viewportSize = helper.getViewportSizeFromWindowFeatures(features2);
      if (viewportSize)
        this._page.setEmulatedSizeFromWindowOpen({ viewport: viewportSize, screen: viewportSize });
    }
    const createdEvent = this._isBackgroundPage ? CRBrowserContext.CREvents.BackgroundPage : BrowserContext.Events.Page;
    this._mainFrameSession._initialize(bits.hasUIWindow).then(
      () => this._page.reportAsNew(this._opener?._page, void 0, createdEvent),
      (error3) => this._page.reportAsNew(this._opener?._page, error3, createdEvent)
    );
  }
  static mainFrameSession(page) {
    const crPage = page.delegate;
    return crPage._mainFrameSession;
  }
  async _forAllFrameSessions(cb) {
    const frameSessions = Array.from(this._sessions.values());
    await Promise.all(frameSessions.map((frameSession) => {
      if (frameSession._isMainFrame())
        return cb(frameSession);
      return cb(frameSession).catch((e) => {
        if (isSessionClosedError(e))
          return;
        throw e;
      });
    }));
  }
  _sessionForFrame(frame) {
    while (!this._sessions.has(frame._id)) {
      const parent = frame.parentFrame();
      if (!parent)
        throw new Error(`Frame has been detached.`);
      frame = parent;
    }
    return this._sessions.get(frame._id);
  }
  _sessionForHandle(handle) {
    const frame = handle._context.frame;
    return this._sessionForFrame(frame);
  }
  willBeginDownload() {
    this._mainFrameSession._willBeginDownload();
  }
  didClose() {
    for (const session2 of this._sessions.values())
      session2.dispose();
    this._page._didClose();
  }
  async navigateFrame(frame, url4, referrer) {
    return this._sessionForFrame(frame)._navigate(frame, url4, referrer);
  }
  async updateExtraHTTPHeaders() {
    const headers = mergeHeaders([
      this._browserContext._options.extraHTTPHeaders,
      this._page.extraHTTPHeaders()
    ]);
    await this._networkManager.setExtraHTTPHeaders(headers);
  }
  async updateGeolocation() {
    await this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
  }
  async updateOffline() {
    await this._networkManager.setOffline(!!this._browserContext._options.offline);
  }
  async updateHttpCredentials() {
    await this._networkManager.authenticate(this._browserContext._options.httpCredentials || null);
  }
  async updateEmulatedViewportSize(preserveWindowBoundaries) {
    await this._mainFrameSession._updateViewport(preserveWindowBoundaries);
  }
  async bringToFront() {
    await this._mainFrameSession._client.send("Page.bringToFront");
  }
  async updateEmulateMedia() {
    await this._forAllFrameSessions((frame) => frame._updateEmulateMedia());
  }
  async updateUserAgent() {
    await this._forAllFrameSessions((frame) => frame._updateUserAgent());
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateFileChooserInterception() {
    await this._forAllFrameSessions((frame) => frame._updateFileChooserInterception(false));
  }
  async reload() {
    await this._mainFrameSession._client.send("Page.reload");
  }
  async _go(delta) {
    const history = await this._mainFrameSession._client.send("Page.getNavigationHistory");
    const entry = history.entries[history.currentIndex + delta];
    if (!entry)
      return false;
    await this._mainFrameSession._client.send("Page.navigateToHistoryEntry", { entryId: entry.id });
    return true;
  }
  goBack() {
    return this._go(-1);
  }
  goForward() {
    return this._go(1);
  }
  async requestGC() {
    await this._mainFrameSession._client.send("HeapProfiler.collectGarbage");
  }
  async addInitScript(initScript, world = "main") {
    await this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(initScript, world));
  }
  async exposePlaywrightBinding() {
    await this._forAllFrameSessions((frame) => frame.exposePlaywrightBinding());
  }
  async removeInitScripts(initScripts) {
    await this._forAllFrameSessions((frame) => frame._removeEvaluatesOnNewDocument(initScripts));
  }
  async closePage(runBeforeUnload) {
    if (runBeforeUnload)
      await this._mainFrameSession._client.send("Page.close");
    else
      await this._browserContext._browser._closePage(this);
  }
  async setBackgroundColor(color) {
    await this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", { color });
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const { visualViewport } = await progress3.race(this._mainFrameSession._client.send("Page.getLayoutMetrics"));
    if (!documentRect) {
      documentRect = {
        x: visualViewport.pageX + viewportRect.x,
        y: visualViewport.pageY + viewportRect.y,
        ...helper.enclosingIntSize({
          width: viewportRect.width / visualViewport.scale,
          height: viewportRect.height / visualViewport.scale
        })
      };
    }
    const clip = { ...documentRect, scale: viewportRect ? visualViewport.scale : 1 };
    if (scale === "css") {
      const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;
      clip.scale /= deviceScaleFactor;
    }
    const result = await progress3.race(this._mainFrameSession._client.send("Page.captureScreenshot", { format: format2, quality, clip, captureBeyondViewport: !fitsViewport }));
    return Buffer.from(result.data, "base64");
  }
  async getContentFrame(handle) {
    return this._sessionForHandle(handle)._getContentFrame(handle);
  }
  async getOwnerFrame(handle) {
    return this._sessionForHandle(handle)._getOwnerFrame(handle);
  }
  async getBoundingBox(handle) {
    return this._sessionForHandle(handle)._getBoundingBox(handle);
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
  }
  async setScreencastOptions(options2) {
    if (options2) {
      await this._mainFrameSession._startScreencast(this, {
        format: "jpeg",
        quality: options2.quality,
        maxWidth: options2.width,
        maxHeight: options2.height
      });
    } else {
      await this._mainFrameSession._stopScreencast(this);
    }
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    return this._sessionForHandle(handle)._getContentQuads(handle);
  }
  async setInputFilePaths(handle, files) {
    const frame = await handle.ownerFrame();
    if (!frame)
      throw new Error("Cannot set input files to detached input element");
    const parentSession = this._sessionForFrame(frame);
    await parentSession._client.send("DOM.setFileInputFiles", {
      objectId: handle._objectId,
      files
    });
  }
  async adoptElementHandle(handle, to) {
    return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree(this._mainFrameSession._client, needle);
  }
  async inputActionEpilogue() {
    await this._mainFrameSession._client.send("Page.enable").catch((e) => {
    });
  }
  async resetForReuse(progress3) {
    await this.rawMouse.move(progress3, -1, -1, "none", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), true);
  }
  async pdf(options2) {
    return this._pdf.generate(options2);
  }
  coverage() {
    return this._coverage;
  }
  async getFrameElement(frame) {
    let parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const parentSession = this._sessionForFrame(parent);
    const { backendNodeId } = await parentSession._client.send("DOM.getFrameOwner", { frameId: frame._id }).catch((e) => {
      if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
        rewriteErrorMessage(e, "Frame has been detached.");
      throw e;
    });
    parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return false;
  }
};
var FrameSession = class _FrameSession {
  static {
    __name(this, "FrameSession");
  }
  constructor(crPage, client, targetId, parentSession) {
    this._childSessions = /* @__PURE__ */ new Set();
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._eventListeners = [];
    this._firstNonInitialNavigationCommittedFulfill = () => {
    };
    this._firstNonInitialNavigationCommittedReject = (e) => {
    };
    this._swappedIn = false;
    this._videoRecorder = null;
    this._screencastId = null;
    this._screencastClients = /* @__PURE__ */ new Set();
    this._workerSessions = /* @__PURE__ */ new Map();
    this._initScriptIds = /* @__PURE__ */ new Map();
    this._client = client;
    this._crPage = crPage;
    this._page = crPage._page;
    this._targetId = targetId;
    this._parentSession = parentSession;
    if (parentSession)
      parentSession._childSessions.add(this);
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });
    this._firstNonInitialNavigationCommittedPromise.catch(() => {
    });
  }
  _isMainFrame() {
    return this._targetId === this._crPage._targetId;
  }
  _addRendererListeners() {
    this._eventListeners.push(...[
      eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)),
      eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
      eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
      eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)),
      eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
      eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)),
      eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)),
      eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
      eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)),
      eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)),
      eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)),
      eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()),
      eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)),
      eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))
    ]);
  }
  _addBrowserListeners() {
    this._eventListeners.push(...[
      eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()),
      eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)),
      eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))
    ]);
  }
  async _initialize(hasUIWindow) {
    if (!this._page.isStorageStatePage && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
      const { windowId } = await this._client.send("Browser.getWindowForTarget");
      this._windowId = windowId;
    }
    let screencastOptions;
    if (!this._page.isStorageStatePage && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
      const screencastId = createGuid();
      const outputFile = path16.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
      screencastOptions = {
        // validateBrowserContextOptions ensures correct video size.
        ...this._crPage._browserContext._options.recordVideo.size,
        outputFile
      };
      await this._crPage._browserContext._ensureVideosPath();
      await this._createVideoRecorder(screencastId, screencastOptions);
      this._crPage._page.waitForInitializedOrError().then((p) => {
        if (p instanceof Error)
          this._stopVideoRecording().catch(() => {
          });
      });
    }
    let lifecycleEventsEnabled;
    if (!this._isMainFrame())
      this._addRendererListeners();
    this._addBrowserListeners();
    const promises = [
      this._client.send("Page.enable"),
      this._client.send("Page.getFrameTree").then(({ frameTree }) => {
        if (this._isMainFrame()) {
          this._handleFrameTree(frameTree);
          this._addRendererListeners();
        }
        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)];
        for (const frame of localFrames) {
          this._client._sendMayFail("Page.createIsolatedWorld", {
            frameId: frame._id,
            grantUniveralAccess: true,
            worldName: this._crPage.utilityWorldName
          });
        }
        const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
        if (isInitialEmptyPage) {
          lifecycleEventsEnabled.catch((e) => {
          }).then(() => {
            this._eventListeners.push(eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
          });
        } else {
          this._firstNonInitialNavigationCommittedFulfill();
          this._eventListeners.push(eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
        }
      }),
      this._client.send("Log.enable", {}),
      lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
      this._client.send("Runtime.enable", {}),
      this._client.send("Page.addScriptToEvaluateOnNewDocument", {
        source: "",
        worldName: this._crPage.utilityWorldName
      }),
      this._crPage._networkManager.addSession(this._client, void 0, this._isMainFrame()),
      this._client.send("Target.setAutoAttach", {
        autoAttach: true,
        waitForDebuggerOnStart: true,
        flatten: true,
        filter: [
          { type: "iframe" },
          { type: "worker" },
          { type: "service_worker", exclude: !process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS }
        ]
      })
    ];
    if (!this._page.isStorageStatePage) {
      if (this._crPage._browserContext.needsPlaywrightBinding())
        promises.push(this.exposePlaywrightBinding());
      if (this._isMainFrame())
        promises.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
      const options2 = this._crPage._browserContext._options;
      if (options2.bypassCSP)
        promises.push(this._client.send("Page.setBypassCSP", { enabled: true }));
      if (options2.ignoreHTTPSErrors || options2.internalIgnoreHTTPSErrors)
        promises.push(this._client.send("Security.setIgnoreCertificateErrors", { ignore: true }));
      if (this._isMainFrame())
        promises.push(this._updateViewport());
      if (options2.hasTouch)
        promises.push(this._client.send("Emulation.setTouchEmulationEnabled", { enabled: true }));
      if (options2.javaScriptEnabled === false)
        promises.push(this._client.send("Emulation.setScriptExecutionDisabled", { value: true }));
      if (options2.userAgent || options2.locale)
        promises.push(this._updateUserAgent());
      if (options2.locale)
        promises.push(emulateLocale(this._client, options2.locale));
      if (options2.timezoneId)
        promises.push(emulateTimezone(this._client, options2.timezoneId));
      if (!this._crPage._browserContext._browser.options.headful)
        promises.push(this._setDefaultFontFamilies(this._client));
      promises.push(this._updateGeolocation(true));
      promises.push(this._updateEmulateMedia());
      promises.push(this._updateFileChooserInterception(true));
      for (const initScript of this._crPage._page.allInitScripts())
        promises.push(this._evaluateOnNewDocument(
          initScript,
          "main",
          true
          /* runImmediately */
        ));
      if (screencastOptions)
        promises.push(this._startVideoRecording(screencastOptions));
    }
    promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
    promises.push(this._firstNonInitialNavigationCommittedPromise);
    await Promise.all(promises);
  }
  dispose() {
    this._firstNonInitialNavigationCommittedReject(new TargetClosedError());
    for (const childSession of this._childSessions)
      childSession.dispose();
    if (this._parentSession)
      this._parentSession._childSessions.delete(this);
    eventsHelper.removeEventListeners(this._eventListeners);
    this._crPage._networkManager.removeSession(this._client);
    this._crPage._sessions.delete(this._targetId);
    this._client.dispose();
  }
  async _navigate(frame, url4, referrer) {
    const response = await this._client.send("Page.navigate", { url: url4, referrer, frameId: frame._id, referrerPolicy: "unsafeUrl" });
    if (response.isDownload)
      throw new NavigationAbortedError(response.loaderId, "Download is starting");
    if (response.errorText)
      throw new NavigationAbortedError(response.loaderId, `${response.errorText} at ${url4}`);
    return { newDocumentId: response.loaderId };
  }
  _onLifecycleEvent(event) {
    if (this._eventBelongsToStaleFrame(event.frameId))
      return;
    if (event.name === "load")
      this._page.frameManager.frameLifecycleEvent(event.frameId, "load");
    else if (event.name === "DOMContentLoaded")
      this._page.frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
  }
  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
    this._onFrameNavigated(frameTree.frame, true);
    if (!frameTree.childFrames)
      return;
    for (const child of frameTree.childFrames)
      this._handleFrameTree(child);
  }
  _eventBelongsToStaleFrame(frameId) {
    const frame = this._page.frameManager.frame(frameId);
    if (!frame)
      return true;
    const session2 = this._crPage._sessionForFrame(frame);
    return session2 && session2 !== this && !session2._swappedIn;
  }
  _onFrameAttached(frameId, parentFrameId) {
    const frameSession = this._crPage._sessions.get(frameId);
    if (frameSession && frameId !== this._targetId) {
      frameSession._swappedIn = true;
      const frame = this._page.frameManager.frame(frameId);
      if (frame)
        this._page.frameManager.removeChildFramesRecursively(frame);
      return;
    }
    if (parentFrameId && !this._page.frameManager.frame(parentFrameId)) {
      return;
    }
    this._page.frameManager.frameAttached(frameId, parentFrameId);
  }
  _onFrameNavigated(framePayload, initial) {
    if (this._eventBelongsToStaleFrame(framePayload.id))
      return;
    this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
    if (!initial)
      this._firstNonInitialNavigationCommittedFulfill();
  }
  _onFrameRequestedNavigation(payload) {
    if (this._eventBelongsToStaleFrame(payload.frameId))
      return;
    if (payload.disposition === "currentTab")
      this._page.frameManager.frameRequestedNavigation(payload.frameId);
  }
  _onFrameNavigatedWithinDocument(frameId, url4) {
    if (this._eventBelongsToStaleFrame(frameId))
      return;
    this._page.frameManager.frameCommittedSameDocumentNavigation(frameId, url4);
  }
  _onFrameDetached(frameId, reason) {
    if (this._crPage._sessions.has(frameId)) {
      return;
    }
    if (reason === "swap") {
      const frame = this._page.frameManager.frame(frameId);
      if (frame)
        this._page.frameManager.removeChildFramesRecursively(frame);
      return;
    }
    this._page.frameManager.frameDetached(frameId);
  }
  _onExecutionContextCreated(contextPayload) {
    const frame = contextPayload.auxData ? this._page.frameManager.frame(contextPayload.auxData.frameId) : null;
    if (!frame || this._eventBelongsToStaleFrame(frame._id))
      return;
    const delegate = new CRExecutionContext(this._client, contextPayload);
    let worldName = null;
    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
      worldName = "main";
    else if (contextPayload.name === this._crPage.utilityWorldName)
      worldName = "utility";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(contextPayload.id, context2);
  }
  _onExecutionContextDestroyed(executionContextId) {
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._contextIdToContext.delete(executionContextId);
    context2.frame._contextDestroyed(context2);
  }
  _onExecutionContextsCleared() {
    for (const contextId of Array.from(this._contextIdToContext.keys()))
      this._onExecutionContextDestroyed(contextId);
  }
  _onAttachedToTarget(event) {
    const session2 = this._client.createChildSession(event.sessionId);
    if (event.targetInfo.type === "iframe") {
      const targetId = event.targetInfo.targetId;
      const frame = this._page.frameManager.frame(targetId);
      if (!frame)
        return;
      this._page.frameManager.removeChildFramesRecursively(frame);
      for (const [contextId, context2] of this._contextIdToContext) {
        if (context2.frame === frame)
          this._onExecutionContextDestroyed(contextId);
      }
      const frameSession = new _FrameSession(this._crPage, session2, targetId, this);
      this._crPage._sessions.set(targetId, frameSession);
      frameSession._initialize(false).catch((e) => e);
      return;
    }
    if (event.targetInfo.type !== "worker") {
      session2.detach().catch(() => {
      });
      return;
    }
    const url4 = event.targetInfo.url;
    const worker = new Worker(this._page, url4);
    this._page.addWorker(event.sessionId, worker);
    this._workerSessions.set(event.sessionId, session2);
    session2.once("Runtime.executionContextCreated", async (event2) => {
      worker.createExecutionContext(new CRExecutionContext(session2, event2.context));
    });
    session2._sendMayFail("Runtime.enable");
    this._crPage._networkManager.addSession(session2, this._page.frameManager.frame(this._targetId) ?? void 0).catch(() => {
    });
    session2._sendMayFail("Runtime.runIfWaitingForDebugger");
    session2._sendMayFail("Target.setAutoAttach", {
      autoAttach: true,
      waitForDebuggerOnStart: true,
      flatten: true,
      filter: [
        { type: "worker" },
        { type: "service_worker", exclude: !process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS }
      ]
    });
    session2.on("Target.attachedToTarget", (event2) => this._onAttachedToTarget(event2));
    session2.on("Target.detachedFromTarget", (event2) => this._onDetachedFromTarget(event2));
    session2.on("Runtime.consoleAPICalled", (event2) => {
      const args = event2.args.map((o) => createHandle(worker.existingExecutionContext, o));
      this._page.addConsoleMessage(event2.type, args, toConsoleMessageLocation(event2.stackTrace));
    });
    session2.on("Runtime.exceptionThrown", (exception) => this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, exceptionToError(exception.exceptionDetails), this._page));
  }
  _onDetachedFromTarget(event) {
    const workerSession = this._workerSessions.get(event.sessionId);
    if (workerSession) {
      workerSession.dispose();
      this._page.removeWorker(event.sessionId);
      return;
    }
    const childFrameSession = this._crPage._sessions.get(event.targetId);
    if (!childFrameSession)
      return;
    if (childFrameSession._swappedIn) {
      childFrameSession.dispose();
      return;
    }
    this._client.send("Page.enable").catch((e) => null).then(() => {
      if (!childFrameSession._swappedIn)
        this._page.frameManager.frameDetached(event.targetId);
      childFrameSession.dispose();
    });
  }
  _onWindowOpen(event) {
    this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
  }
  async _onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      return;
    }
    const context2 = this._contextIdToContext.get(event.executionContextId);
    if (!context2)
      return;
    const values = event.args.map((arg) => createHandle(context2, arg));
    this._page.addConsoleMessage(event.type, values, toConsoleMessageLocation(event.stackTrace));
  }
  async _onBindingCalled(event) {
    const pageOrError = await this._crPage._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(event.executionContextId);
      if (context2)
        await this._page.onBindingCalled(event.payload, context2);
    }
  }
  _onDialog(event) {
    if (!this._page.frameManager.frame(this._targetId))
      return;
    this._page.browserContext.dialogManager.dialogDidOpen(new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, promptText) => {
        if (this._isMainFrame() && event.type === "beforeunload" && !accept)
          this._page.frameManager.frameAbortedNavigation(this._page.mainFrame()._id, "navigation cancelled by beforeunload dialog");
        await this._client.send("Page.handleJavaScriptDialog", { accept, promptText });
      },
      event.defaultPrompt
    ));
  }
  _handleException(exceptionDetails) {
    this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, exceptionToError(exceptionDetails), this._page);
  }
  async _onTargetCrashed() {
    this._client._markAsCrashed();
    this._page._didCrash();
  }
  _onLogEntryAdded(event) {
    const { level, text, args, source: source8, url: url4, lineNumber } = event.entry;
    if (args)
      args.map((arg) => releaseObject(this._client, arg.objectId));
    if (source8 !== "worker") {
      const location2 = {
        url: url4 || "",
        lineNumber: lineNumber || 0,
        columnNumber: 0
      };
      this._page.addConsoleMessage(level, [], location2, text);
    }
  }
  async _onFileChooserOpened(event) {
    if (!event.backendNodeId)
      return;
    const frame = this._page.frameManager.frame(event.frameId);
    if (!frame)
      return;
    let handle;
    try {
      const utilityContext = await frame._utilityContext();
      handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
    } catch (e) {
      return;
    }
    await this._page._onFileChooserOpened(handle);
  }
  _willBeginDownload() {
    if (!this._crPage._page.initializedOrUndefined()) {
      this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
    }
  }
  _onScreencastFrame(payload) {
    this._page.throttleScreencastFrameAck(() => {
      this._client.send("Page.screencastFrameAck", { sessionId: payload.sessionId }).catch(() => {
      });
    });
    const buffer = Buffer.from(payload.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer,
      frameSwapWallTime: payload.metadata.timestamp ? payload.metadata.timestamp * 1e3 : void 0,
      width: payload.metadata.deviceWidth,
      height: payload.metadata.deviceHeight
    });
  }
  async _createVideoRecorder(screencastId, options2) {
    assert3(!this._screencastId);
    const ffmpegPath = registry.findExecutable("ffmpeg").executablePathOrDie(this._page.browserContext._browser.sdkLanguage());
    this._videoRecorder = await VideoRecorder.launch(this._crPage._page, ffmpegPath, options2);
    this._screencastId = screencastId;
  }
  async _startVideoRecording(options2) {
    const screencastId = this._screencastId;
    assert3(screencastId);
    this._page.once(Page.Events.Close, () => this._stopVideoRecording().catch(() => {
    }));
    const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
    await this._startScreencast(this._videoRecorder, {
      format: "jpeg",
      quality: 90,
      maxWidth: options2.width,
      maxHeight: options2.height
    });
    gotFirstFrame.then(() => {
      this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options2.outputFile, this._crPage._page.waitForInitializedOrError());
    });
  }
  async _stopVideoRecording() {
    if (!this._screencastId)
      return;
    const screencastId = this._screencastId;
    this._screencastId = null;
    const recorder = this._videoRecorder;
    this._videoRecorder = null;
    await this._stopScreencast(recorder);
    await recorder.stop().catch(() => {
    });
    const video = this._crPage._browserContext._browser._takeVideo(screencastId);
    video?.reportFinished();
  }
  async _startScreencast(client, options2 = {}) {
    this._screencastClients.add(client);
    if (this._screencastClients.size === 1)
      await this._client.send("Page.startScreencast", options2);
  }
  async _stopScreencast(client) {
    this._screencastClients.delete(client);
    if (!this._screencastClients.size)
      await this._client._sendMayFail("Page.stopScreencast");
  }
  async _updateGeolocation(initial) {
    const geolocation = this._crPage._browserContext._options.geolocation;
    if (!initial || geolocation)
      await this._client.send("Emulation.setGeolocationOverride", geolocation || {});
  }
  async _updateViewport(preserveWindowBoundaries) {
    if (this._crPage._browserContext._browser.isClank())
      return;
    assert3(this._isMainFrame());
    const options2 = this._crPage._browserContext._options;
    const emulatedSize = this._page.emulatedSize();
    if (!emulatedSize)
      return;
    const viewportSize = emulatedSize.viewport;
    const screenSize = emulatedSize.screen;
    const isLandscape = screenSize.width > screenSize.height;
    const metricsOverride = {
      mobile: !!options2.isMobile,
      width: viewportSize.width,
      height: viewportSize.height,
      screenWidth: screenSize.width,
      screenHeight: screenSize.height,
      deviceScaleFactor: options2.deviceScaleFactor || 1,
      screenOrientation: !!options2.isMobile ? isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" } : { angle: 0, type: "landscapePrimary" },
      dontSetVisibleSize: preserveWindowBoundaries
    };
    if (JSON.stringify(this._metricsOverride) === JSON.stringify(metricsOverride))
      return;
    const promises = [];
    if (!preserveWindowBoundaries && this._windowId) {
      let insets = { width: 0, height: 0 };
      if (this._crPage._browserContext._browser.options.headful) {
        insets = { width: 24, height: 88 };
        if (process.platform === "win32")
          insets = { width: 16, height: 88 };
        else if (process.platform === "linux")
          insets = { width: 8, height: 85 };
        else if (process.platform === "darwin")
          insets = { width: 2, height: 80 };
        if (this._crPage._browserContext.isPersistentContext()) {
          insets.height += 46;
        }
      }
      promises.push(this.setWindowBounds({
        width: viewportSize.width + insets.width,
        height: viewportSize.height + insets.height
      }));
    }
    promises.push(this._client.send("Emulation.setDeviceMetricsOverride", metricsOverride));
    await Promise.all(promises);
    this._metricsOverride = metricsOverride;
  }
  async windowBounds() {
    const { bounds } = await this._client.send("Browser.getWindowBounds", {
      windowId: this._windowId
    });
    return bounds;
  }
  async setWindowBounds(bounds) {
    return await this._client.send("Browser.setWindowBounds", {
      windowId: this._windowId,
      bounds
    });
  }
  async _updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const media = emulatedMedia.media === "no-override" ? "" : emulatedMedia.media;
    const colorScheme = emulatedMedia.colorScheme === "no-override" ? "" : emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? "" : emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors === "no-override" ? "" : emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast === "no-override" ? "" : emulatedMedia.contrast;
    const features2 = [
      { name: "prefers-color-scheme", value: colorScheme },
      { name: "prefers-reduced-motion", value: reducedMotion },
      { name: "forced-colors", value: forcedColors },
      { name: "prefers-contrast", value: contrast }
    ];
    await this._client.send("Emulation.setEmulatedMedia", { media, features: features2 });
  }
  async _updateUserAgent() {
    const options2 = this._crPage._browserContext._options;
    await this._client.send("Emulation.setUserAgentOverride", {
      userAgent: options2.userAgent || "",
      acceptLanguage: options2.locale,
      userAgentMetadata: calculateUserAgentMetadata(options2)
    });
  }
  async _setDefaultFontFamilies(session2) {
    const fontFamilies = platformToFontFamilies[this._crPage._browserContext._browser._platform()];
    await session2.send("Page.setFontFamilies", fontFamilies);
  }
  async _updateFileChooserInterception(initial) {
    const enabled = this._page.fileChooserIntercepted();
    if (initial && !enabled)
      return;
    await this._client.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async _evaluateOnNewDocument(initScript, world, runImmediately) {
    const worldName = world === "utility" ? this._crPage.utilityWorldName : void 0;
    const { identifier } = await this._client.send("Page.addScriptToEvaluateOnNewDocument", { source: initScript.source, worldName, runImmediately });
    this._initScriptIds.set(initScript, identifier);
  }
  async _removeEvaluatesOnNewDocument(initScripts) {
    const ids = [];
    for (const script of initScripts) {
      const id = this._initScriptIds.get(script);
      if (id)
        ids.push(id);
      this._initScriptIds.delete(script);
    }
    await Promise.all(ids.map((identifier) => this._client.send("Page.removeScriptToEvaluateOnNewDocument", { identifier }).catch(() => {
    })));
  }
  async exposePlaywrightBinding() {
    await this._client.send("Runtime.addBinding", { name: PageBinding.kBindingName });
  }
  async _getContentFrame(handle) {
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
      return null;
    return this._page.frameManager.frame(nodeInfo.node.frameId);
  }
  async _getOwnerFrame(handle) {
    const documentElement = await handle.evaluateHandle((node) => {
      const doc = node;
      if (doc.documentElement && doc.documentElement.ownerDocument === doc)
        return doc.documentElement;
      return node.ownerDocument ? node.ownerDocument.documentElement : null;
    });
    if (!documentElement)
      return null;
    if (!documentElement._objectId)
      return null;
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: documentElement._objectId
    });
    const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
    documentElement.dispose();
    return frameId;
  }
  async _getBoundingBox(handle) {
    const result = await this._client._sendMayFail("DOM.getBoxModel", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    const quad = result.model.border;
    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
    const position = await this._framePosition();
    if (!position)
      return null;
    return { x: x + position.x, y: y + position.y, width, height };
  }
  async _framePosition() {
    const frame = this._page.frameManager.frame(this._targetId);
    if (!frame)
      return null;
    if (frame === this._page.mainFrame())
      return { x: 0, y: 0 };
    const element = await frame.frameElement();
    const box = await element.boundingBox();
    return box;
  }
  async _scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._client.send("DOM.scrollIntoViewIfNeeded", {
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      throw e;
    });
  }
  async _getContentQuads(handle) {
    const result = await this._client._sendMayFail("DOM.getContentQuads", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    const position = await this._framePosition();
    if (!position)
      return null;
    return result.quads.map((quad) => [
      { x: quad[0] + position.x, y: quad[1] + position.y },
      { x: quad[2] + position.x, y: quad[3] + position.y },
      { x: quad[4] + position.x, y: quad[5] + position.y },
      { x: quad[6] + position.x, y: quad[7] + position.y }
    ]);
  }
  async _adoptElementHandle(handle, to) {
    const nodeInfo = await this._client.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
  }
  async _adoptBackendNodeId(backendNodeId, to) {
    const result = await this._client._sendMayFail("DOM.resolveNode", {
      backendNodeId,
      executionContextId: to.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle(to, result.object).asElement();
  }
};
async function emulateLocale(session2, locale) {
  try {
    await session2.send("Emulation.setLocaleOverride", { locale });
  } catch (exception) {
    if (exception.message.includes("Another locale override is already in effect"))
      return;
    throw exception;
  }
}
__name(emulateLocale, "emulateLocale");
async function emulateTimezone(session2, timezoneId) {
  try {
    await session2.send("Emulation.setTimezoneOverride", { timezoneId });
  } catch (exception) {
    if (exception.message.includes("Timezone override is already in effect"))
      return;
    if (exception.message.includes("Invalid timezone"))
      throw new Error(`Invalid timezone ID: ${timezoneId}`);
    throw exception;
  }
}
__name(emulateTimezone, "emulateTimezone");
function calculateUserAgentMetadata(options2) {
  const ua = options2.userAgent;
  if (!ua)
    return void 0;
  const metadata = {
    mobile: !!options2.isMobile,
    model: "",
    architecture: "x86",
    platform: "Windows",
    platformVersion: ""
  };
  const androidMatch = ua.match(/Android (\d+(\.\d+)?(\.\d+)?)/);
  const iPhoneMatch = ua.match(/iPhone OS (\d+(_\d+)?)/);
  const iPadMatch = ua.match(/iPad; CPU OS (\d+(_\d+)?)/);
  const macOSMatch = ua.match(/Mac OS X (\d+(_\d+)?(_\d+)?)/);
  const windowsMatch = ua.match(/Windows\D+(\d+(\.\d+)?(\.\d+)?)/);
  if (androidMatch) {
    metadata.platform = "Android";
    metadata.platformVersion = androidMatch[1];
    metadata.architecture = "arm";
  } else if (iPhoneMatch) {
    metadata.platform = "iOS";
    metadata.platformVersion = iPhoneMatch[1];
    metadata.architecture = "arm";
  } else if (iPadMatch) {
    metadata.platform = "iOS";
    metadata.platformVersion = iPadMatch[1];
    metadata.architecture = "arm";
  } else if (macOSMatch) {
    metadata.platform = "macOS";
    metadata.platformVersion = macOSMatch[1];
    if (!ua.includes("Intel"))
      metadata.architecture = "arm";
  } else if (windowsMatch) {
    metadata.platform = "Windows";
    metadata.platformVersion = windowsMatch[1];
  } else if (ua.toLowerCase().includes("linux")) {
    metadata.platform = "Linux";
  }
  if (ua.includes("ARM"))
    metadata.architecture = "arm";
  return metadata;
}
__name(calculateUserAgentMetadata, "calculateUserAgentMetadata");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crServiceWorker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CRServiceWorker = class extends Worker {
  static {
    __name(this, "CRServiceWorker");
  }
  constructor(browserContext, session2, url4) {
    super(browserContext, url4);
    this._session = session2;
    this.browserContext = browserContext;
    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS)
      this._networkManager = new CRNetworkManager(null, this);
    session2.once("Runtime.executionContextCreated", (event) => {
      this.createExecutionContext(new CRExecutionContext(session2, event.context));
    });
    if (this._networkManager && this._isNetworkInspectionEnabled()) {
      this.updateRequestInterception();
      this.updateExtraHTTPHeaders();
      this.updateHttpCredentials();
      this.updateOffline();
      this._networkManager.addSession(
        session2,
        void 0,
        true
        /* isMain */
      ).catch(() => {
      });
    }
    session2.send("Runtime.enable", {}).catch((e) => {
    });
    session2.send("Runtime.runIfWaitingForDebugger").catch((e) => {
    });
    session2.on("Inspector.targetReloadedAfterCrash", () => {
      session2._sendMayFail("Runtime.runIfWaitingForDebugger", {});
    });
  }
  didClose() {
    this._networkManager?.removeSession(this._session);
    this._session.dispose();
    super.didClose();
  }
  async updateOffline() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setOffline(!!this.browserContext._options.offline).catch(() => {
    });
  }
  async updateHttpCredentials() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.authenticate(this.browserContext._options.httpCredentials || null).catch(() => {
    });
  }
  async updateExtraHTTPHeaders() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setExtraHTTPHeaders(this.browserContext._options.extraHTTPHeaders || []).catch(() => {
    });
  }
  async updateRequestInterception() {
    if (!this._isNetworkInspectionEnabled())
      return;
    await this._networkManager?.setRequestInterception(this.needsRequestInterception()).catch(() => {
    });
  }
  needsRequestInterception() {
    return this._isNetworkInspectionEnabled() && this.browserContext.requestInterceptors.length > 0;
  }
  reportRequestFinished(request2, response) {
    this.browserContext.emit(BrowserContext.Events.RequestFinished, { request: request2, response });
  }
  requestFailed(request2, _canceled) {
    this.browserContext.emit(BrowserContext.Events.RequestFailed, request2);
  }
  requestReceivedResponse(response) {
    this.browserContext.emit(BrowserContext.Events.Response, response);
  }
  requestStarted(request2, route) {
    this.browserContext.emit(BrowserContext.Events.Request, request2);
    if (route)
      new Route(request2, route).handle(this.browserContext.requestInterceptors);
  }
  _isNetworkInspectionEnabled() {
    return this.browserContext._options.serviceWorkers !== "block";
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crBrowser.js
var CRBrowser = class _CRBrowser extends Browser {
  static {
    __name(this, "CRBrowser");
  }
  constructor(parent, connection, options2) {
    super(parent, options2);
    this._clientRootSessionPromise = null;
    this._contexts = /* @__PURE__ */ new Map();
    this._crPages = /* @__PURE__ */ new Map();
    this._backgroundPages = /* @__PURE__ */ new Map();
    this._serviceWorkers = /* @__PURE__ */ new Map();
    this._version = "";
    this._tracingRecording = false;
    this._userAgent = "";
    this._connection = connection;
    this._session = this._connection.rootSession;
    this._connection.on(ConnectionEvents.Disconnected, () => this._didDisconnect());
    this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
    this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
    this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
    this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
  }
  static async connect(parent, transport, options2, devtools) {
    options2 = { ...options2 };
    const connection = new CRConnection(parent, transport, options2.protocolLogger, options2.browserLogsCollector);
    const browser3 = new _CRBrowser(parent, connection, options2);
    browser3._devtools = devtools;
    if (browser3.isClank())
      browser3._isCollocatedWithServer = false;
    const session2 = connection.rootSession;
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    const version6 = await session2.send("Browser.getVersion");
    browser3._version = version6.product.substring(version6.product.indexOf("/") + 1);
    browser3._userAgent = version6.userAgent;
    browser3.options.headful = !version6.userAgent.includes("Headless");
    if (!options2.persistent) {
      await session2.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true });
      return browser3;
    }
    browser3._defaultContext = new CRBrowserContext(browser3, void 0, options2.persistent);
    await Promise.all([
      session2.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: true, flatten: true }).then(async () => {
        await session2.send("Target.getTargetInfo");
      }),
      browser3._defaultContext._initialize()
    ]);
    await browser3._waitForAllPagesToBeInitialized();
    return browser3;
  }
  async doCreateNewContext(options2) {
    const proxy = options2.proxyOverride || options2.proxy;
    let proxyBypassList = void 0;
    if (proxy) {
      if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)
        proxyBypassList = proxy.bypass;
      else
        proxyBypassList = "<-loopback>" + (proxy.bypass ? `,${proxy.bypass}` : "");
    }
    const { browserContextId } = await this._session.send("Target.createBrowserContext", {
      disposeOnDetach: true,
      proxyServer: proxy ? proxy.server : void 0,
      proxyBypassList
    });
    const context2 = new CRBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._version;
  }
  userAgent() {
    return this._userAgent;
  }
  _platform() {
    if (this._userAgent.includes("Windows"))
      return "win";
    if (this._userAgent.includes("Macintosh"))
      return "mac";
    return "linux";
  }
  isClank() {
    return this.options.name === "clank";
  }
  async _waitForAllPagesToBeInitialized() {
    await Promise.all([...this._crPages.values()].map((crPage) => crPage._page.waitForInitializedOrError()));
  }
  _onAttachedToTarget({ targetInfo, sessionId }) {
    if (targetInfo.type === "browser")
      return;
    const session2 = this._session.createChildSession(sessionId);
    assert3(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
    let context2 = this._contexts.get(targetInfo.browserContextId) || null;
    if (!context2) {
      context2 = this._defaultContext;
    }
    if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
      this._devtools.install(session2);
      return;
    }
    const treatOtherAsPage = targetInfo.type === "other" && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;
    if (!context2 || targetInfo.type === "other" && !treatOtherAsPage) {
      session2.detach().catch(() => {
      });
      return;
    }
    assert3(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    assert3(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    assert3(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
    if (targetInfo.type === "background_page") {
      const backgroundPage = new CRPage(session2, targetInfo.targetId, context2, null, { hasUIWindow: false, isBackgroundPage: true });
      this._backgroundPages.set(targetInfo.targetId, backgroundPage);
      return;
    }
    if (targetInfo.type === "page" || treatOtherAsPage) {
      const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
      const crPage = new CRPage(session2, targetInfo.targetId, context2, opener, { hasUIWindow: targetInfo.type === "page", isBackgroundPage: false });
      this._crPages.set(targetInfo.targetId, crPage);
      return;
    }
    if (targetInfo.type === "service_worker") {
      const serviceWorker = new CRServiceWorker(context2, session2, targetInfo.url);
      this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
      context2.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
      return;
    }
    session2.detach().catch(() => {
    });
  }
  _onDetachedFromTarget(payload) {
    const targetId = payload.targetId;
    const crPage = this._crPages.get(targetId);
    if (crPage) {
      this._crPages.delete(targetId);
      crPage.didClose();
      return;
    }
    const backgroundPage = this._backgroundPages.get(targetId);
    if (backgroundPage) {
      this._backgroundPages.delete(targetId);
      backgroundPage.didClose();
      return;
    }
    const serviceWorker = this._serviceWorkers.get(targetId);
    if (serviceWorker) {
      this._serviceWorkers.delete(targetId);
      serviceWorker.didClose();
      return;
    }
  }
  _didDisconnect() {
    for (const crPage of this._crPages.values())
      crPage.didClose();
    this._crPages.clear();
    for (const backgroundPage of this._backgroundPages.values())
      backgroundPage.didClose();
    this._backgroundPages.clear();
    for (const serviceWorker of this._serviceWorkers.values())
      serviceWorker.didClose();
    this._serviceWorkers.clear();
    this._didClose();
  }
  _findOwningPage(frameId) {
    for (const crPage of this._crPages.values()) {
      const frame = crPage._page.frameManager.frame(frameId);
      if (frame)
        return crPage;
    }
    return null;
  }
  _onDownloadWillBegin(payload) {
    const page = this._findOwningPage(payload.frameId);
    if (!page) {
      return;
    }
    page.willBeginDownload();
    let originPage = page._page.initializedOrUndefined();
    if (!originPage && page._opener)
      originPage = page._opener._page.initializedOrUndefined();
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
  }
  _onDownloadProgress(payload) {
    if (payload.state === "completed")
      this._downloadFinished(payload.guid, "");
    if (payload.state === "canceled")
      this._downloadFinished(payload.guid, this._closeReason || "canceled");
  }
  async _closePage(crPage) {
    await this._session.send("Target.closeTarget", { targetId: crPage._targetId });
  }
  async newBrowserCDPSession() {
    return await this._connection.createBrowserSession();
  }
  async startTracing(page, options2 = {}) {
    assert3(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
    this._tracingClient = page ? page.delegate._mainFrameSession._client : this._session;
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler",
      "disabled-by-default-v8.cpu_profiler.hires"
    ];
    const {
      screenshots = false,
      categories = defaultCategories
    } = options2;
    if (screenshots)
      categories.push("disabled-by-default-devtools.screenshot");
    this._tracingRecording = true;
    await this._tracingClient.send("Tracing.start", {
      transferMode: "ReturnAsStream",
      categories: categories.join(",")
    });
  }
  async stopTracing() {
    assert3(this._tracingClient, "Tracing was not started.");
    const [event] = await Promise.all([
      new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)),
      this._tracingClient.send("Tracing.end")
    ]);
    const tracingPath = path17.join(this.options.artifactsDir, createGuid() + ".crtrace");
    await saveProtocolStream(this._tracingClient, event.stream, tracingPath);
    this._tracingRecording = false;
    const artifact = new Artifact(this, tracingPath);
    artifact.reportFinished();
    return artifact;
  }
  isConnected() {
    return !this._connection._closed;
  }
  async _clientRootSession() {
    if (!this._clientRootSessionPromise)
      this._clientRootSessionPromise = this._connection.createBrowserSession();
    return this._clientRootSessionPromise;
  }
};
var CRBrowserContext = class extends BrowserContext {
  static {
    __name(this, "CRBrowserContext");
  }
  static {
    this.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._authenticateProxyViaCredentials();
  }
  async _initialize() {
    assert3(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
    const promises = [super._initialize()];
    if (this._browser.options.name !== "clank" && this._options.acceptDownloads !== "internal-browser-default") {
      promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
        behavior: this._options.acceptDownloads === "accept" ? "allowAndName" : "deny",
        browserContextId: this._browserContextId,
        downloadPath: this._browser.options.downloadsPath,
        eventsEnabled: true
      }));
    }
    await Promise.all(promises);
  }
  _crPages() {
    return [...this._browser._crPages.values()].filter((crPage) => crPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._crPages().map((crPage) => crPage._page);
  }
  async doCreateNewPage() {
    const { targetId } = await this._browser._session.send("Target.createTarget", { url: "about:blank", browserContextId: this._browserContextId });
    return this._browser._crPages.get(targetId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._session.send("Storage.getCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const { name, value, domain: domain2, path: path210, expires, httpOnly, secure, sameSite } = c;
      const copy = {
        name,
        value,
        domain: domain2,
        path: path210,
        expires,
        httpOnly,
        secure,
        sameSite: sameSite ?? "Lax"
      };
      if (c.partitionKey) {
        copy._crHasCrossSiteAncestor = c.partitionKey.hasCrossSiteAncestor;
        copy.partitionKey = c.partitionKey.topLevelSite;
      }
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    function toChromiumCookie(cookie) {
      const { name, value, url: url4, domain: domain2, path: path210, expires, httpOnly, secure, sameSite, partitionKey, _crHasCrossSiteAncestor } = cookie;
      const copy = {
        name,
        value,
        url: url4,
        domain: domain2,
        path: path210,
        expires,
        httpOnly,
        secure,
        sameSite
      };
      if (partitionKey) {
        copy.partitionKey = {
          topLevelSite: partitionKey,
          // _crHasCrossSiteAncestor is non-standard, set it true by default if the cookie is partitioned.
          hasCrossSiteAncestor: _crHasCrossSiteAncestor ?? true
        };
      }
      return copy;
    }
    __name(toChromiumCookie, "toChromiumCookie");
    await this._browser._session.send("Storage.setCookies", {
      cookies: rewriteCookies(cookies).map(toChromiumCookie),
      browserContextId: this._browserContextId
    });
  }
  async doClearCookies() {
    await this._browser._session.send("Storage.clearCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geolocation"],
      ["midi", "midi"],
      ["notifications", "notifications"],
      ["camera", "videoCapture"],
      ["microphone", "audioCapture"],
      ["background-sync", "backgroundSync"],
      ["ambient-light-sensor", "sensors"],
      ["accelerometer", "sensors"],
      ["gyroscope", "sensors"],
      ["magnetometer", "sensors"],
      ["clipboard-read", "clipboardReadWrite"],
      ["clipboard-write", "clipboardSanitizedWrite"],
      ["payment-handler", "paymentHandler"],
      // chrome-specific permissions we have.
      ["midi-sysex", "midiSysex"],
      ["storage-access", "storageAccess"],
      ["local-fonts", "localFonts"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._browser._session.send("Browser.grantPermissions", { origin: origin === "*" ? void 0 : origin, browserContextId: this._browserContextId, permissions: filtered });
  }
  async doClearPermissions() {
    await this._browser._session.send("Browser.resetPermissions", { browserContextId: this._browserContextId });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    for (const page of this.pages())
      await page.delegate.updateGeolocation();
  }
  async doUpdateExtraHTTPHeaders() {
    for (const page of this.pages())
      await page.delegate.updateExtraHTTPHeaders();
    for (const sw of this.serviceWorkers())
      await sw.updateExtraHTTPHeaders();
  }
  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;
    for (const page of this.pages())
      await page.delegate.updateUserAgent();
  }
  async doUpdateOffline() {
    for (const page of this.pages())
      await page.delegate.updateOffline();
    for (const sw of this.serviceWorkers())
      await sw.updateOffline();
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page.delegate.updateHttpCredentials();
    for (const sw of this.serviceWorkers())
      await sw.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    for (const page of this.pages())
      await page.delegate.addInitScript(initScript);
  }
  async doRemoveInitScripts(initScripts) {
    for (const page of this.pages())
      await page.delegate.removeInitScripts(initScripts);
  }
  async doUpdateRequestInterception() {
    for (const page of this.pages())
      await page.delegate.updateRequestInterception();
    for (const sw of this.serviceWorkers())
      await sw.updateRequestInterception();
  }
  async doUpdateDefaultViewport() {
  }
  async doUpdateDefaultEmulatedMedia() {
  }
  async doExposePlaywrightBinding() {
    for (const page of this._crPages())
      await page.exposePlaywrightBinding();
  }
  async doClose(reason) {
    await this.dialogManager.closeBeforeUnloadDialogs();
    if (!this._browserContextId) {
      await this.stopVideoRecording();
      await this._browser.close({ reason });
      return;
    }
    await Promise.all(this._crPages().map((page) => page.closePage(true))).catch(() => {
    });
    await this._browser._session.send("Target.disposeBrowserContext", { browserContextId: this._browserContextId });
    this._browser._contexts.delete(this._browserContextId);
    for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
      if (serviceWorker.browserContext !== this)
        continue;
      serviceWorker.didClose();
      this._browser._serviceWorkers.delete(targetId);
    }
  }
  async stopVideoRecording() {
    await Promise.all(this._crPages().map((crPage) => crPage._mainFrameSession._stopVideoRecording()));
  }
  onClosePersistent() {
    for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined()) {
        backgroundPage.didClose();
        this._browser._backgroundPages.delete(targetId);
      }
    }
  }
  async clearCache() {
    for (const page of this._crPages())
      await page._networkManager.clearCache();
  }
  async cancelDownload(guid) {
    await this._browser._session.send("Browser.cancelDownload", {
      guid,
      browserContextId: this._browserContextId
    });
  }
  backgroundPages() {
    const result = [];
    for (const backgroundPage of this._browser._backgroundPages.values()) {
      if (backgroundPage._browserContext === this && backgroundPage._page.initializedOrUndefined())
        result.push(backgroundPage._page);
    }
    return result;
  }
  serviceWorkers() {
    return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker.browserContext === this);
  }
  async newCDPSession(page) {
    let targetId = null;
    if (page instanceof Page) {
      targetId = page.delegate._targetId;
    } else if (page instanceof Frame) {
      const session2 = page._page.delegate._sessions.get(page._id);
      if (!session2)
        throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
      targetId = session2._targetId;
    } else {
      throw new Error("page: expected Page or Frame");
    }
    const rootSession = await this._browser._clientRootSession();
    return rootSession.attachToTarget(targetId);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/writableStreamDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs24 from "node:fs";
var WritableStreamSdkObject = class extends SdkObject {
  static {
    __name(this, "WritableStreamSdkObject");
  }
  constructor(parent, streamOrDirectory, lastModifiedMs) {
    super(parent, "stream");
    this.streamOrDirectory = streamOrDirectory;
    this.lastModifiedMs = lastModifiedMs;
  }
};
var WritableStreamDispatcher = class extends Dispatcher {
  static {
    __name(this, "WritableStreamDispatcher");
  }
  constructor(scope, streamOrDirectory, lastModifiedMs) {
    super(scope, new WritableStreamSdkObject(scope._object, streamOrDirectory, lastModifiedMs), "WritableStream", {});
    this._type_WritableStream = true;
  }
  async write(params, progress3) {
    if (typeof this._object.streamOrDirectory === "string")
      throw new Error("Cannot write to a directory");
    const stream = this._object.streamOrDirectory;
    await progress3.race(new Promise((fulfill, reject) => {
      stream.write(params.binary, (error3) => {
        if (error3)
          reject(error3);
        else
          fulfill();
      });
    }));
  }
  async close(params, progress3) {
    if (typeof this._object.streamOrDirectory === "string")
      throw new Error("Cannot close a directory");
    const stream = this._object.streamOrDirectory;
    await progress3.race(new Promise((fulfill) => stream.end(fulfill)));
    if (this._object.lastModifiedMs)
      await progress3.race(fs24.promises.utimes(this.path(), new Date(this._object.lastModifiedMs), new Date(this._object.lastModifiedMs)));
  }
  path() {
    if (typeof this._object.streamOrDirectory === "string")
      return this._object.streamOrDirectory;
    return this._object.streamOrDirectory.path;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/browserContextDispatcher.js
var BrowserContextDispatcher = class _BrowserContextDispatcher extends Dispatcher {
  static {
    __name(this, "BrowserContextDispatcher");
  }
  constructor(parentScope, context2) {
    const requestContext = APIRequestContextDispatcher.from(parentScope, context2.fetchRequest);
    const tracing = TracingDispatcher.from(parentScope, context2.tracing);
    super(parentScope, context2, "BrowserContext", {
      isChromium: context2._browser.options.isChromium,
      requestContext,
      tracing,
      options: context2._options
    });
    this._type_EventTarget = true;
    this._type_BrowserContext = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this._webSocketInterceptionPatterns = [];
    this._bindings = [];
    this._initScripts = [];
    this._clockPaused = false;
    this._interceptionUrlMatchers = [];
    this.adopt(requestContext);
    this.adopt(tracing);
    this._requestInterceptor = (route, request2) => {
      const matchesSome = this._interceptionUrlMatchers.some((urlMatch) => urlMatches(this._context._options.baseURL, request2.url(), urlMatch));
      const routeDispatcher = this.connection.existingDispatcher(route);
      if (!matchesSome || routeDispatcher) {
        route.continue({ isFallback: true }).catch(() => {
        });
        return;
      }
      this._dispatchEvent("route", { route: new RouteDispatcher(RequestDispatcher.from(this, request2), route) });
    };
    this._context = context2;
    const onVideo = /* @__PURE__ */ __name((artifact) => {
      const artifactDispatcher = ArtifactDispatcher.from(parentScope, artifact);
      this._dispatchEvent("video", { artifact: artifactDispatcher });
    }, "onVideo");
    this.addObjectListener(BrowserContext.Events.VideoStarted, onVideo);
    for (const video of context2._browser._idToVideo.values()) {
      if (video.context === context2)
        onVideo(video.artifact);
    }
    for (const page of context2.pages())
      this._dispatchEvent("page", { page: PageDispatcher.from(this, page) });
    this.addObjectListener(BrowserContext.Events.Page, (page) => {
      this._dispatchEvent("page", { page: PageDispatcher.from(this, page) });
    });
    this.addObjectListener(BrowserContext.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(BrowserContext.Events.PageError, (error3, page) => {
      this._dispatchEvent("pageError", { error: serializeError(error3), page: PageDispatcher.from(this, page) });
    });
    this.addObjectListener(BrowserContext.Events.Console, (message) => {
      const page = message.page();
      if (this._shouldDispatchEvent(page, "console")) {
        const pageDispatcher = PageDispatcher.from(this, page);
        this._dispatchEvent("console", {
          page: pageDispatcher,
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => {
            const elementHandle = a.asElement();
            if (elementHandle)
              return ElementHandleDispatcher.from(FrameDispatcher.from(this, elementHandle._frame), elementHandle);
            return JSHandleDispatcher.fromJSHandle(pageDispatcher, a);
          }),
          location: message.location()
        });
      }
    });
    this._dialogHandler = (dialog) => {
      if (!this._shouldDispatchEvent(dialog.page(), "dialog"))
        return false;
      this._dispatchEvent("dialog", { dialog: new DialogDispatcher(this, dialog) });
      return true;
    };
    context2.dialogManager.addDialogHandler(this._dialogHandler);
    if (context2._browser.options.name === "chromium") {
      for (const page of context2.backgroundPages())
        this._dispatchEvent("backgroundPage", { page: PageDispatcher.from(this, page) });
      this.addObjectListener(CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", { page: PageDispatcher.from(this, page) }));
      for (const serviceWorker of context2.serviceWorkers())
        this._dispatchEvent("serviceWorker", { worker: new WorkerDispatcher(this, serviceWorker) });
      this.addObjectListener(CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", { worker: new WorkerDispatcher(this, serviceWorker) }));
    }
    this.addObjectListener(BrowserContext.Events.Request, (request2) => {
      const redirectFromDispatcher = request2.redirectedFrom() && this.connection.existingDispatcher(request2.redirectedFrom());
      if (!redirectFromDispatcher && !this._shouldDispatchNetworkEvent(request2, "request") && !request2.isNavigationRequest())
        return;
      const requestDispatcher = RequestDispatcher.from(this, request2);
      this._dispatchEvent("request", {
        request: requestDispatcher,
        page: PageDispatcher.fromNullable(this, request2.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.Response, (response) => {
      const requestDispatcher = this.connection.existingDispatcher(response.request());
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(response.request(), "response"))
        return;
      this._dispatchEvent("response", {
        response: ResponseDispatcher.from(this, response),
        page: PageDispatcher.fromNullable(this, response.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.RequestFailed, (request2) => {
      const requestDispatcher = this.connection.existingDispatcher(request2);
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request2, "requestFailed"))
        return;
      this._dispatchEvent("requestFailed", {
        request: RequestDispatcher.from(this, request2),
        failureText: request2._failureText || void 0,
        responseEndTiming: request2._responseEndTiming,
        page: PageDispatcher.fromNullable(this, request2.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.RequestFinished, ({ request: request2, response }) => {
      const requestDispatcher = this.connection.existingDispatcher(request2);
      if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request2, "requestFinished"))
        return;
      this._dispatchEvent("requestFinished", {
        request: RequestDispatcher.from(this, request2),
        response: ResponseDispatcher.fromNullable(this, response),
        responseEndTiming: request2._responseEndTiming,
        page: PageDispatcher.fromNullable(this, request2.frame()?._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(BrowserContext.Events.RecorderEvent, ({ event, data, page, code }) => {
      this._dispatchEvent("recorderEvent", { event, data, code, page: PageDispatcher.from(this, page) });
    });
  }
  static from(parentScope, context2) {
    const result = parentScope.connection.existingDispatcher(context2);
    return result || new _BrowserContextDispatcher(parentScope, context2);
  }
  _shouldDispatchNetworkEvent(request2, event) {
    return this._shouldDispatchEvent(request2.frame()?._page?.initializedOrUndefined(), event);
  }
  _shouldDispatchEvent(page, event) {
    if (this._subscriptions.has(event))
      return true;
    const pageDispatcher = page ? this.connection.existingDispatcher(page) : void 0;
    if (pageDispatcher?._subscriptions.has(event))
      return true;
    return false;
  }
  async createTempFiles(params, progress3) {
    const dir3 = this._context._browser.options.artifactsDir;
    const tmpDir = path18.join(dir3, "upload-" + createGuid());
    const tempDirWithRootName = params.rootDirName ? path18.join(tmpDir, path18.basename(params.rootDirName)) : tmpDir;
    await progress3.race(fs25.promises.mkdir(tempDirWithRootName, { recursive: true }));
    this._context._tempDirs.push(tmpDir);
    return {
      rootDir: params.rootDirName ? new WritableStreamDispatcher(this, tempDirWithRootName) : void 0,
      writableStreams: await Promise.all(params.items.map(async (item) => {
        await progress3.race(fs25.promises.mkdir(path18.dirname(path18.join(tempDirWithRootName, item.name)), { recursive: true }));
        const file = fs25.createWriteStream(path18.join(tempDirWithRootName, item.name));
        return new WritableStreamDispatcher(this, file, item.lastModifiedMs);
      }))
    };
  }
  async exposeBinding(params, progress3) {
    const binding3 = await this._context.exposeBinding(progress3, params.name, !!params.needsHandle, (source8, ...args) => {
      if (this._disposed)
        return;
      const pageDispatcher = PageDispatcher.from(this, source8.page);
      const binding22 = new BindingCallDispatcher(pageDispatcher, params.name, !!params.needsHandle, source8, args);
      this._dispatchEvent("bindingCall", { binding: binding22 });
      return binding22.promise();
    });
    this._bindings.push(binding3);
  }
  async newPage(params, progress3) {
    return { page: PageDispatcher.from(this, await this._context.newPage(progress3)) };
  }
  async cookies(params, progress3) {
    return { cookies: await progress3.race(this._context.cookies(params.urls)) };
  }
  async addCookies(params, progress3) {
    await this._context.addCookies(params.cookies);
  }
  async clearCookies(params, progress3) {
    const nameRe = params.nameRegexSource !== void 0 && params.nameRegexFlags !== void 0 ? new RegExp(params.nameRegexSource, params.nameRegexFlags) : void 0;
    const domainRe = params.domainRegexSource !== void 0 && params.domainRegexFlags !== void 0 ? new RegExp(params.domainRegexSource, params.domainRegexFlags) : void 0;
    const pathRe = params.pathRegexSource !== void 0 && params.pathRegexFlags !== void 0 ? new RegExp(params.pathRegexSource, params.pathRegexFlags) : void 0;
    await this._context.clearCookies({
      name: nameRe || params.name,
      domain: domainRe || params.domain,
      path: pathRe || params.path
    });
  }
  async grantPermissions(params, progress3) {
    await this._context.grantPermissions(params.permissions, params.origin);
  }
  async clearPermissions(params, progress3) {
    await this._context.clearPermissions();
  }
  async setGeolocation(params, progress3) {
    await this._context.setGeolocation(params.geolocation);
  }
  async setExtraHTTPHeaders(params, progress3) {
    await this._context.setExtraHTTPHeaders(progress3, params.headers);
  }
  async setOffline(params, progress3) {
    await this._context.setOffline(progress3, params.offline);
  }
  async setHTTPCredentials(params, progress3) {
    await progress3.race(this._context.setHTTPCredentials(params.httpCredentials));
  }
  async addInitScript(params, progress3) {
    this._initScripts.push(await this._context.addInitScript(progress3, params.source));
  }
  async setNetworkInterceptionPatterns(params, progress3) {
    const hadMatchers = this._interceptionUrlMatchers.length > 0;
    if (!params.patterns.length) {
      if (hadMatchers)
        await this._context.removeRequestInterceptor(this._requestInterceptor);
      this._interceptionUrlMatchers = [];
    } else {
      this._interceptionUrlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
      if (!hadMatchers)
        await this._context.addRequestInterceptor(progress3, this._requestInterceptor);
    }
  }
  async setWebSocketInterceptionPatterns(params, progress3) {
    this._webSocketInterceptionPatterns = params.patterns;
    if (params.patterns.length && !this._routeWebSocketInitScript)
      this._routeWebSocketInitScript = await WebSocketRouteDispatcher.install(progress3, this.connection, this._context);
  }
  async storageState(params, progress3) {
    return await progress3.race(this._context.storageState(progress3, params.indexedDB));
  }
  async close(params, progress3) {
    progress3.metadata.potentiallyClosesScope = true;
    await this._context.close(params);
  }
  async enableRecorder(params, progress3) {
    await RecorderApp.show(this._context, params);
  }
  async disableRecorder(params, progress3) {
    const recorder = Recorder.existingForContext(this._context);
    if (recorder)
      recorder.setMode("none");
  }
  async pause(params, progress3) {
  }
  async newCDPSession(params, progress3) {
    if (!this._object._browser.options.isChromium)
      throw new Error(`CDP session is only available in Chromium`);
    if (!params.page && !params.frame || params.page && params.frame)
      throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
    const crBrowserContext = this._object;
    return { session: new CDPSessionDispatcher(this, await progress3.race(crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))) };
  }
  async harStart(params, progress3) {
    const harId = this._context.harStart(params.page ? params.page._object : null, params.options);
    return { harId };
  }
  async harExport(params, progress3) {
    const artifact = await progress3.race(this._context.harExport(params.harId));
    if (!artifact)
      throw new Error("No HAR artifact. Ensure record.harPath is set.");
    return { artifact: ArtifactDispatcher.from(this, artifact) };
  }
  async clockFastForward(params, progress3) {
    await this._context.clock.fastForward(progress3, params.ticksString ?? params.ticksNumber ?? 0);
  }
  async clockInstall(params, progress3) {
    await this._context.clock.install(progress3, params.timeString ?? params.timeNumber ?? void 0);
  }
  async clockPauseAt(params, progress3) {
    await this._context.clock.pauseAt(progress3, params.timeString ?? params.timeNumber ?? 0);
    this._clockPaused = true;
  }
  async clockResume(params, progress3) {
    await this._context.clock.resume(progress3);
    this._clockPaused = false;
  }
  async clockRunFor(params, progress3) {
    await this._context.clock.runFor(progress3, params.ticksString ?? params.ticksNumber ?? 0);
  }
  async clockSetFixedTime(params, progress3) {
    await this._context.clock.setFixedTime(progress3, params.timeString ?? params.timeNumber ?? 0);
  }
  async clockSetSystemTime(params, progress3) {
    await this._context.clock.setSystemTime(progress3, params.timeString ?? params.timeNumber ?? 0);
  }
  async updateSubscription(params, progress3) {
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
  async registerSelectorEngine(params, progress3) {
    this._object.selectors().register(params.selectorEngine);
  }
  async setTestIdAttributeName(params, progress3) {
    this._object.selectors().setTestIdAttributeName(params.testIdAttributeName);
  }
  _onDispose() {
    if (this._context.isClosingOrClosed())
      return;
    this._context.dialogManager.removeDialogHandler(this._dialogHandler);
    this._interceptionUrlMatchers = [];
    this._context.removeRequestInterceptor(this._requestInterceptor).catch(() => {
    });
    this._context.removeExposedBindings(this._bindings).catch(() => {
    });
    this._bindings = [];
    this._context.removeInitScripts(this._initScripts).catch(() => {
    });
    this._initScripts = [];
    if (this._routeWebSocketInitScript)
      WebSocketRouteDispatcher.uninstall(this.connection, this._context, this._routeWebSocketInitScript).catch(() => {
      });
    this._routeWebSocketInitScript = void 0;
    if (this._clockPaused)
      this._context.clock.resumeNoReply();
    this._clockPaused = false;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/android/android.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter12 } from "node:events";
import fs26 from "node:fs";
import os8 from "node:os";
import path19 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/pipeTransport.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PipeTransport = class {
  static {
    __name(this, "PipeTransport");
  }
  constructor(pipeWrite, pipeRead, closeable, endian = "le") {
    this._data = Buffer.from([]);
    this._waitForNextTask = makeWaitForNextTask();
    this._closed = false;
    this._bytesLeft = 0;
    this._pipeWrite = pipeWrite;
    this._endian = endian;
    this._closeableStream = closeable;
    pipeRead.on("data", (buffer) => this._dispatch(buffer));
    pipeRead.on("close", () => {
      this._closed = true;
      if (this.onclose)
        this.onclose();
    });
    this.onmessage = void 0;
    this.onclose = void 0;
  }
  send(message) {
    if (this._closed)
      throw new Error("Pipe has been closed");
    const data = Buffer.from(message, "utf-8");
    const dataLength = Buffer.alloc(4);
    if (this._endian === "be")
      dataLength.writeUInt32BE(data.length, 0);
    else
      dataLength.writeUInt32LE(data.length, 0);
    this._pipeWrite.write(dataLength);
    this._pipeWrite.write(data);
  }
  close() {
    this._closeableStream.close();
  }
  _dispatch(buffer) {
    this._data = Buffer.concat([this._data, buffer]);
    while (true) {
      if (!this._bytesLeft && this._data.length < 4) {
        break;
      }
      if (!this._bytesLeft) {
        this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
        this._data = this._data.slice(4);
      }
      if (!this._bytesLeft || this._data.length < this._bytesLeft) {
        break;
      }
      const message = this._data.slice(0, this._bytesLeft);
      this._data = this._data.slice(this._bytesLeft);
      this._bytesLeft = 0;
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage(message.toString("utf-8"));
      });
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/chromiumSwitches.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var disabledFeatures = /* @__PURE__ */ __name((assistantMode) => [
  // See https://github.com/microsoft/playwright/pull/10380
  "AcceptCHFrame",
  // See https://github.com/microsoft/playwright/issues/14047
  "AvoidUnnecessaryBeforeUnloadCheckSync",
  "DestroyProfileOnBrowserClose",
  // See https://github.com/microsoft/playwright/pull/13854
  "DialMediaRouteProvider",
  "GlobalMediaControls",
  // See https://github.com/microsoft/playwright/pull/27605
  "HttpsUpgrades",
  // Hides the Lens feature in the URL address bar. Its not working in unofficial builds.
  "LensOverlay",
  // See https://github.com/microsoft/playwright/pull/8162
  "MediaRouter",
  // See https://github.com/microsoft/playwright/issues/28023
  "PaintHolding",
  // See https://github.com/microsoft/playwright/issues/32230
  "ThirdPartyStoragePartitioning",
  // See https://github.com/microsoft/playwright/issues/16126
  "Translate",
  // See https://issues.chromium.org/u/1/issues/435410220
  "AutoDeElevate",
  assistantMode ? "AutomationControlled" : ""
].filter(Boolean), "disabledFeatures");
var chromiumSwitches = /* @__PURE__ */ __name((assistantMode, channel2) => [
  "--disable-field-trial-config",
  // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
  "--disable-background-networking",
  "--disable-background-timer-throttling",
  "--disable-backgrounding-occluded-windows",
  "--disable-back-forward-cache",
  // Avoids surprises like main request not being intercepted during page.goBack().
  "--disable-breakpad",
  "--disable-client-side-phishing-detection",
  "--disable-component-extensions-with-background-pages",
  "--disable-component-update",
  // Avoids unneeded network activity after startup.
  "--no-default-browser-check",
  "--disable-default-apps",
  "--disable-dev-shm-usage",
  "--disable-extensions",
  "--disable-features=" + disabledFeatures(assistantMode).join(","),
  channel2 === "chromium-tip-of-tree" ? "--enable-features=CDPScreenshotNewSurface" : "",
  "--allow-pre-commit-input",
  "--disable-hang-monitor",
  "--disable-ipc-flooding-protection",
  "--disable-popup-blocking",
  "--disable-prompt-on-repost",
  "--disable-renderer-backgrounding",
  "--force-color-profile=srgb",
  "--metrics-recording-only",
  "--no-first-run",
  "--password-store=basic",
  "--use-mock-keychain",
  // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
  "--no-service-autorun",
  "--export-tagged-pdf",
  // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
  "--disable-search-engine-choice-screen",
  // https://issues.chromium.org/41491762
  "--unsafely-disable-devtools-self-xss-warnings",
  // Edge can potentially restart on Windows (msRelaunchNoCompatLayer) which looses its file descriptors (stdout/stderr) and CDP (3/4). Disable until fixed upstream.
  "--edge-skip-compat-layer-relaunch",
  assistantMode ? "" : "--enable-automation"
].filter(Boolean), "chromiumSwitches");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/android/android.js
var ARTIFACTS_FOLDER = path19.join(os8.tmpdir(), "playwright-artifacts-");
var Android = class extends SdkObject {
  static {
    __name(this, "Android");
  }
  constructor(parent, backend) {
    super(parent, "android");
    this._devices = /* @__PURE__ */ new Map();
    this._backend = backend;
  }
  async devices(progress3, options2) {
    const devices2 = (await progress3.race(this._backend.devices(options2))).filter((d) => d.status === "device");
    const newSerials = /* @__PURE__ */ new Set();
    for (const d of devices2) {
      newSerials.add(d.serial);
      if (this._devices.has(d.serial))
        continue;
      await progress3.race(AndroidDevice.create(this, d, options2).then((device) => this._devices.set(d.serial, device)));
    }
    for (const d of this._devices.keys()) {
      if (!newSerials.has(d))
        this._devices.delete(d);
    }
    return [...this._devices.values()];
  }
  _deviceClosed(device) {
    this._devices.delete(device.serial);
  }
};
var AndroidDevice = class _AndroidDevice extends SdkObject {
  static {
    __name(this, "AndroidDevice");
  }
  constructor(android, backend, model, options2) {
    super(android, "android-device");
    this._lastId = 0;
    this._callbacks = /* @__PURE__ */ new Map();
    this._webViews = /* @__PURE__ */ new Map();
    this._browserConnections = /* @__PURE__ */ new Set();
    this._isClosed = false;
    this._android = android;
    this._backend = backend;
    this.model = model;
    this.serial = backend.serial;
    this._options = options2;
    this.logName = "browser";
  }
  static {
    this.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Close: "close"
    };
  }
  static async create(android, backend, options2) {
    await backend.init();
    const model = await backend.runCommand("shell:getprop ro.product.model");
    const device = new _AndroidDevice(android, backend, model.toString().trim(), options2);
    await device._init();
    return device;
  }
  async _init() {
    await this._refreshWebViews();
    const poll = /* @__PURE__ */ __name(() => {
      this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
        this.close().catch(() => {
        });
      }), 500);
    }, "poll");
    poll();
  }
  async shell(command) {
    const result = await this._backend.runCommand(`shell:${command}`);
    await this._refreshWebViews();
    return result;
  }
  async open(progress3, command) {
    return await this._open(progress3, command);
  }
  async screenshot() {
    return await this._backend.runCommand(`shell:screencap -p`);
  }
  async _driver() {
    if (this._isClosed)
      return;
    if (!this._driverPromise) {
      const controller = new ProgressController();
      this._driverPromise = controller.run((progress3) => this._installDriver(progress3));
    }
    return this._driverPromise;
  }
  async _installDriver(progress3) {
    debug4("pw:android")("Stopping the old driver");
    await progress3.race(this.shell(`am force-stop com.microsoft.playwright.androiddriver`));
    if (!this._options.omitDriverInstall) {
      debug4("pw:android")("Uninstalling the old driver");
      await progress3.race(this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`));
      await progress3.race(this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`));
      debug4("pw:android")("Installing the new driver");
      const executable = registry.findExecutable("android");
      const packageManagerCommand = getPackageManagerExecCommand();
      for (const file of ["android-driver.apk", "android-driver-target.apk"]) {
        const fullName = path19.join(executable.directory, file);
        if (!fs26.existsSync(fullName))
          throw new Error(`Please install Android driver apk using '${packageManagerCommand} playwright install android'`);
        await this.installApk(progress3, await progress3.race(fs26.promises.readFile(fullName)));
      }
    } else {
      debug4("pw:android")("Skipping the driver installation");
    }
    debug4("pw:android")("Starting the new driver");
    this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => debug4("pw:android")(e));
    const socket = await this._waitForLocalAbstract(progress3, "playwright_android_driver_socket");
    const transport = new PipeTransport(socket, socket, socket, "be");
    transport.onmessage = (message) => {
      const response = JSON.parse(message);
      const { id, result, error: error3 } = response;
      const callback = this._callbacks.get(id);
      if (!callback)
        return;
      if (error3)
        callback.reject(new Error(error3));
      else
        callback.fulfill(result);
      this._callbacks.delete(id);
    };
    return transport;
  }
  async _waitForLocalAbstract(progress3, socketName) {
    let socket;
    debug4("pw:android")(`Polling the socket localabstract:${socketName}`);
    while (!socket) {
      try {
        socket = await this._open(progress3, `localabstract:${socketName}`);
      } catch (e) {
        if (isAbortError(e))
          throw e;
        await progress3.wait(250);
      }
    }
    debug4("pw:android")(`Connected to localabstract:${socketName}`);
    return socket;
  }
  async send(method, params = {}) {
    params = {
      ...params,
      // Patch the timeout in, just in case it's missing in one of the commands.
      timeout: params.timeout || 0
    };
    if (params.androidSelector) {
      params.selector = params.androidSelector;
      delete params.androidSelector;
    }
    const driver = await this._driver();
    if (!driver)
      throw new Error("Device is closed");
    const id = ++this._lastId;
    const result = new Promise((fulfill, reject) => this._callbacks.set(id, { fulfill, reject }));
    driver.send(JSON.stringify({ id, method, params }));
    return result;
  }
  async close() {
    if (this._isClosed)
      return;
    this._isClosed = true;
    if (this._pollingWebViews)
      clearTimeout(this._pollingWebViews);
    for (const connection of this._browserConnections)
      await connection.close();
    if (this._driverPromise) {
      const driver = await this._driver();
      driver?.close();
    }
    await this._backend.close();
    this._android._deviceClosed(this);
    this.emit(_AndroidDevice.Events.Close);
  }
  async launchBrowser(progress3, pkg = "com.android.chrome", options2) {
    debug4("pw:android")("Force-stopping", pkg);
    await this._backend.runCommand(`shell:am force-stop ${pkg}`);
    const socketName = isUnderTest() ? "webview_devtools_remote_playwright_test" : "playwright_" + createGuid() + "_devtools_remote";
    const commandLine = this._defaultArgs(options2, socketName).join(" ");
    debug4("pw:android")("Starting", pkg, commandLine);
    await progress3.race(this._backend.runCommand(`shell:echo "${Buffer.from(commandLine).toString("base64")}" | base64 -d > /data/local/tmp/chrome-command-line`));
    await progress3.race(this._backend.runCommand(`shell:am start -a android.intent.action.VIEW -d about:blank ${pkg}`));
    const browserContext = await this._connectToBrowser(progress3, socketName, options2);
    try {
      await progress3.race(this._backend.runCommand(`shell:rm /data/local/tmp/chrome-command-line`));
      return browserContext;
    } catch (error3) {
      await browserContext.close({ reason: "Failed to launch" }).catch(() => {
      });
      throw error3;
    }
  }
  _defaultArgs(options2, socketName) {
    const chromeArguments = [
      "_",
      "--disable-fre",
      "--no-default-browser-check",
      `--remote-debugging-socket-name=${socketName}`,
      ...chromiumSwitches(),
      ...this._innerDefaultArgs(options2)
    ];
    return chromeArguments;
  }
  _innerDefaultArgs(options2) {
    const { args = [], proxy } = options2;
    const chromeArguments = [];
    if (proxy) {
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
  async connectToWebView(progress3, socketName) {
    const webView = this._webViews.get(socketName);
    if (!webView)
      throw new Error("WebView has been closed");
    return await this._connectToBrowser(progress3, socketName);
  }
  async _connectToBrowser(progress3, socketName, options2 = {}) {
    const socket = await this._waitForLocalAbstract(progress3, socketName);
    try {
      const androidBrowser = new AndroidBrowser(this, socket);
      await progress3.race(androidBrowser._init());
      this._browserConnections.add(androidBrowser);
      const artifactsDir = await progress3.race(fs26.promises.mkdtemp(ARTIFACTS_FOLDER));
      const cleanupArtifactsDir = /* @__PURE__ */ __name(async () => {
        const errors2 = (await removeFolders([artifactsDir])).filter(Boolean);
        for (let i = 0; i < (errors2 || []).length; ++i)
          debug4("pw:android")(`exception while removing ${artifactsDir}: ${errors2[i]}`);
      }, "cleanupArtifactsDir");
      gracefullyCloseSet.add(cleanupArtifactsDir);
      socket.on("close", async () => {
        gracefullyCloseSet.delete(cleanupArtifactsDir);
        cleanupArtifactsDir().catch((e) => debug4("pw:android")(`could not cleanup artifacts dir: ${e}`));
      });
      const browserOptions = {
        name: "clank",
        isChromium: true,
        slowMo: 0,
        persistent: { ...options2, noDefaultViewport: true },
        artifactsDir,
        downloadsPath: artifactsDir,
        tracesDir: artifactsDir,
        browserProcess: new ClankBrowserProcess(androidBrowser),
        proxy: options2.proxy,
        protocolLogger: helper.debugProtocolLogger(),
        browserLogsCollector: new RecentLogsCollector(),
        originalLaunchOptions: {}
      };
      validateBrowserContextOptions(options2, browserOptions);
      const browser3 = await progress3.race(CRBrowser.connect(this.attribution.playwright, androidBrowser, browserOptions));
      const defaultContext = browser3._defaultContext;
      await defaultContext._loadDefaultContextAsIs(progress3);
      return defaultContext;
    } catch (error3) {
      socket.close();
      throw error3;
    }
  }
  _open(progress3, command) {
    return raceUncancellableOperationWithCleanup(progress3, () => this._backend.open(command), (socket) => socket.close());
  }
  webViews() {
    return [...this._webViews.values()];
  }
  async installApk(progress3, content, options2) {
    const args = options2 && options2.args ? options2.args : ["-r", "-t", "-S"];
    debug4("pw:android")("Opening install socket");
    const installSocket = await this._open(progress3, `shell:cmd package install ${args.join(" ")} ${content.length}`);
    debug4("pw:android")("Writing driver bytes: " + content.length);
    await progress3.race(installSocket.write(content));
    const success = await progress3.race(new Promise((f) => installSocket.on("data", f)));
    debug4("pw:android")("Written driver bytes: " + success);
    installSocket.close();
  }
  async push(progress3, content, path210, mode = 420) {
    const socket = await this._open(progress3, `sync:`);
    const sendHeader = /* @__PURE__ */ __name(async (command, length) => {
      const buffer = Buffer.alloc(command.length + 4);
      buffer.write(command, 0);
      buffer.writeUInt32LE(length, command.length);
      await progress3.race(socket.write(buffer));
    }, "sendHeader");
    const send2 = /* @__PURE__ */ __name(async (command, data) => {
      await sendHeader(command, data.length);
      await progress3.race(socket.write(data));
    }, "send");
    await send2("SEND", Buffer.from(`${path210},${mode}`));
    const maxChunk = 65535;
    for (let i = 0; i < content.length; i += maxChunk)
      await send2("DATA", content.slice(i, i + maxChunk));
    await sendHeader("DONE", Date.now() / 1e3 | 0);
    const result = await progress3.race(new Promise((f) => socket.once("data", f)));
    const code = result.slice(0, 4).toString();
    if (code !== "OKAY")
      throw new Error("Could not push: " + code);
    socket.close();
  }
  async _refreshWebViews() {
    const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
    if (this._isClosed)
      return;
    const socketNames = /* @__PURE__ */ new Set();
    for (const line of sockets) {
      const matchSocketName = line.match(/[^@]+@(.*?webview_devtools_remote_?.*)/);
      if (!matchSocketName)
        continue;
      const socketName = matchSocketName[1];
      socketNames.add(socketName);
      if (this._webViews.has(socketName))
        continue;
      const match = line.match(/[^@]+@.*?webview_devtools_remote_?(\d*)/);
      let pid2 = -1;
      if (match && match[1])
        pid2 = +match[1];
      const pkg = await this._extractPkg(pid2);
      if (this._isClosed)
        return;
      const webView = { pid: pid2, pkg, socketName };
      this._webViews.set(socketName, webView);
      this.emit(_AndroidDevice.Events.WebViewAdded, webView);
    }
    for (const p of this._webViews.keys()) {
      if (!socketNames.has(p)) {
        this._webViews.delete(p);
        this.emit(_AndroidDevice.Events.WebViewRemoved, p);
      }
    }
  }
  async _extractPkg(pid2) {
    let pkg = "";
    if (pid2 === -1)
      return pkg;
    const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid2}`)).toString().split("\n");
    for (const proc of procs) {
      const match = proc.match(/[^\s]+\s+(\d+).*$/);
      if (!match)
        continue;
      pkg = proc.substring(proc.lastIndexOf(" ") + 1);
    }
    return pkg;
  }
};
var AndroidBrowser = class extends EventEmitter12 {
  static {
    __name(this, "AndroidBrowser");
  }
  constructor(device, socket) {
    super();
    this._waitForNextTask = makeWaitForNextTask();
    this.setMaxListeners(0);
    this.device = device;
    this._socket = socket;
    this._socket.on("close", () => {
      this._waitForNextTask(() => {
        if (this.onclose)
          this.onclose();
      });
    });
    this._receiver = new wsReceiver2();
    this._receiver.on("message", (message) => {
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage(JSON.parse(message));
      });
    });
  }
  async _init() {
    await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
    await new Promise((f) => this._socket.once("data", f));
    this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
    }));
  }
  async send(s) {
    await this._socket.write(encodeWebFrame(JSON.stringify(s)));
  }
  async close() {
    this._socket.close();
  }
};
function encodeWebFrame(data) {
  return wsSender2.frame(Buffer.from(data), {
    opcode: 1,
    mask: true,
    fin: true,
    readOnly: true
  })[0];
}
__name(encodeWebFrame, "encodeWebFrame");
var ClankBrowserProcess = class {
  static {
    __name(this, "ClankBrowserProcess");
  }
  constructor(browser3) {
    this._browser = browser3;
  }
  async kill() {
  }
  async close() {
    await this._browser.close();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/androidDispatcher.js
var AndroidDispatcher = class extends Dispatcher {
  static {
    __name(this, "AndroidDispatcher");
  }
  constructor(scope, android) {
    super(scope, android, "Android", {});
    this._type_Android = true;
  }
  async devices(params, progress3) {
    const devices2 = await this._object.devices(progress3, params);
    return {
      devices: devices2.map((d) => AndroidDeviceDispatcher.from(this, d))
    };
  }
};
var AndroidDeviceDispatcher = class _AndroidDeviceDispatcher extends Dispatcher {
  static {
    __name(this, "AndroidDeviceDispatcher");
  }
  constructor(scope, device) {
    super(scope, device, "AndroidDevice", {
      model: device.model,
      serial: device.serial
    });
    this._type_EventTarget = true;
    this._type_AndroidDevice = true;
    for (const webView of device.webViews())
      this._dispatchEvent("webViewAdded", { webView });
    this.addObjectListener(AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", { webView }));
    this.addObjectListener(AndroidDevice.Events.WebViewRemoved, (socketName) => this._dispatchEvent("webViewRemoved", { socketName }));
    this.addObjectListener(AndroidDevice.Events.Close, () => this._dispatchEvent("close"));
  }
  static from(scope, device) {
    const result = scope.connection.existingDispatcher(device);
    return result || new _AndroidDeviceDispatcher(scope, device);
  }
  async wait(params, progress3) {
    await progress3.race(this._object.send("wait", params));
  }
  async fill(params, progress3) {
    await progress3.race(this._object.send("click", { selector: params.androidSelector }));
    await progress3.race(this._object.send("fill", params));
  }
  async tap(params, progress3) {
    await progress3.race(this._object.send("click", params));
  }
  async drag(params, progress3) {
    await progress3.race(this._object.send("drag", params));
  }
  async fling(params, progress3) {
    await progress3.race(this._object.send("fling", params));
  }
  async longTap(params, progress3) {
    await progress3.race(this._object.send("longClick", params));
  }
  async pinchClose(params, progress3) {
    await progress3.race(this._object.send("pinchClose", params));
  }
  async pinchOpen(params, progress3) {
    await progress3.race(this._object.send("pinchOpen", params));
  }
  async scroll(params, progress3) {
    await progress3.race(this._object.send("scroll", params));
  }
  async swipe(params, progress3) {
    await progress3.race(this._object.send("swipe", params));
  }
  async info(params, progress3) {
    const info3 = await progress3.race(this._object.send("info", params));
    fixupAndroidElementInfo(info3);
    return { info: info3 };
  }
  async inputType(params, progress3) {
    const text = params.text;
    const keyCodes = [];
    for (let i = 0; i < text.length; ++i) {
      const code = keyMap.get(text[i].toUpperCase());
      if (code === void 0)
        throw new Error("No mapping for " + text[i] + " found");
      keyCodes.push(code);
    }
    await progress3.race(Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", { keyCode }))));
  }
  async inputPress(params, progress3) {
    if (!keyMap.has(params.key))
      throw new Error("Unknown key: " + params.key);
    await progress3.race(this._object.send("inputPress", { keyCode: keyMap.get(params.key) }));
  }
  async inputTap(params, progress3) {
    await progress3.race(this._object.send("inputClick", params));
  }
  async inputSwipe(params, progress3) {
    await progress3.race(this._object.send("inputSwipe", params));
  }
  async inputDrag(params, progress3) {
    await progress3.race(this._object.send("inputDrag", params));
  }
  async screenshot(params, progress3) {
    return { binary: await progress3.race(this._object.screenshot()) };
  }
  async shell(params, progress3) {
    return { result: await progress3.race(this._object.shell(params.command)) };
  }
  async open(params, progress3) {
    const socket = await this._object.open(progress3, params.command);
    return { socket: new AndroidSocketDispatcher(this, new SocketSdkObject(this._object, socket)) };
  }
  async installApk(params, progress3) {
    await this._object.installApk(progress3, params.file, { args: params.args });
  }
  async push(params, progress3) {
    await progress3.race(this._object.push(progress3, params.file, params.path, params.mode));
  }
  async launchBrowser(params, progress3) {
    const context2 = await this._object.launchBrowser(progress3, params.pkg, params);
    return { context: BrowserContextDispatcher.from(this, context2) };
  }
  async close(params, progress3) {
    await this._object.close();
  }
  async connectToWebView(params, progress3) {
    return { context: BrowserContextDispatcher.from(this, await this._object.connectToWebView(progress3, params.socketName)) };
  }
};
var SocketSdkObject = class extends SdkObject {
  static {
    __name(this, "SocketSdkObject");
  }
  constructor(parent, socket) {
    super(parent, "socket");
    this._socket = socket;
    this._eventListeners = [
      eventsHelper.addEventListener(socket, "data", (data) => this.emit("data", data)),
      eventsHelper.addEventListener(socket, "close", () => {
        eventsHelper.removeEventListeners(this._eventListeners);
        this.emit("close");
      })
    ];
  }
  async write(data) {
    await this._socket.write(data);
  }
  close() {
    this._socket.close();
  }
};
var AndroidSocketDispatcher = class extends Dispatcher {
  static {
    __name(this, "AndroidSocketDispatcher");
  }
  constructor(scope, socket) {
    super(scope, socket, "AndroidSocket", {});
    this._type_AndroidSocket = true;
    this.addObjectListener("data", (data) => this._dispatchEvent("data", { data }));
    this.addObjectListener("close", () => {
      this._dispatchEvent("close");
      this._dispose();
    });
  }
  async write(params, progress3) {
    await progress3.race(this._object.write(params.data));
  }
  async close(params, progress3) {
    this._object.close();
  }
};
var keyMap = /* @__PURE__ */ new Map([
  ["Unknown", 0],
  ["SoftLeft", 1],
  ["SoftRight", 2],
  ["Home", 3],
  ["Back", 4],
  ["Call", 5],
  ["EndCall", 6],
  ["0", 7],
  ["1", 8],
  ["2", 9],
  ["3", 10],
  ["4", 11],
  ["5", 12],
  ["6", 13],
  ["7", 14],
  ["8", 15],
  ["9", 16],
  ["Star", 17],
  ["*", 17],
  ["Pound", 18],
  ["#", 18],
  ["DialUp", 19],
  ["DialDown", 20],
  ["DialLeft", 21],
  ["DialRight", 22],
  ["DialCenter", 23],
  ["VolumeUp", 24],
  ["VolumeDown", 25],
  ["Power", 26],
  ["Camera", 27],
  ["Clear", 28],
  ["A", 29],
  ["B", 30],
  ["C", 31],
  ["D", 32],
  ["E", 33],
  ["F", 34],
  ["G", 35],
  ["H", 36],
  ["I", 37],
  ["J", 38],
  ["K", 39],
  ["L", 40],
  ["M", 41],
  ["N", 42],
  ["O", 43],
  ["P", 44],
  ["Q", 45],
  ["R", 46],
  ["S", 47],
  ["T", 48],
  ["U", 49],
  ["V", 50],
  ["W", 51],
  ["X", 52],
  ["Y", 53],
  ["Z", 54],
  ["Comma", 55],
  [",", 55],
  ["Period", 56],
  [".", 56],
  ["AltLeft", 57],
  ["AltRight", 58],
  ["ShiftLeft", 59],
  ["ShiftRight", 60],
  ["Tab", 61],
  ["	", 61],
  ["Space", 62],
  [" ", 62],
  ["Sym", 63],
  ["Explorer", 64],
  ["Envelop", 65],
  ["Enter", 66],
  ["Del", 67],
  ["Grave", 68],
  ["Minus", 69],
  ["-", 69],
  ["Equals", 70],
  ["=", 70],
  ["LeftBracket", 71],
  ["(", 71],
  ["RightBracket", 72],
  [")", 72],
  ["Backslash", 73],
  ["\\", 73],
  ["Semicolon", 74],
  [";", 74],
  ["Apostrophe", 75],
  ["`", 75],
  ["Slash", 76],
  ["/", 76],
  ["At", 77],
  ["@", 77],
  ["Num", 78],
  ["HeadsetHook", 79],
  ["Focus", 80],
  ["Plus", 81],
  ["Menu", 82],
  ["Notification", 83],
  ["Search", 84],
  ["ChannelUp", 166],
  ["ChannelDown", 167],
  ["AppSwitch", 187],
  ["Assist", 219],
  ["Cut", 277],
  ["Copy", 278],
  ["Paste", 279]
]);
function fixupAndroidElementInfo(info3) {
  info3.clazz = info3.clazz || "";
  info3.pkg = info3.pkg || "";
  info3.res = info3.res || "";
  info3.desc = info3.desc || "";
  info3.text = info3.text || "";
  for (const child of info3.children || [])
    fixupAndroidElementInfo(child);
}
__name(fixupAndroidElementInfo, "fixupAndroidElementInfo");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/browserDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserDispatcher = class extends Dispatcher {
  static {
    __name(this, "BrowserDispatcher");
  }
  constructor(scope, browser3, options2 = {}) {
    super(scope, browser3, "Browser", { version: browser3.version(), name: browser3.options.name });
    this._type_Browser = true;
    this._isolatedContexts = /* @__PURE__ */ new Set();
    this._options = options2;
    if (!options2.isolateContexts) {
      this.addObjectListener(Browser.Events.Context, (context2) => this._dispatchEvent("context", { context: BrowserContextDispatcher.from(this, context2) }));
      this.addObjectListener(Browser.Events.Disconnected, () => this._didClose());
      if (browser3._defaultContext)
        this._dispatchEvent("context", { context: BrowserContextDispatcher.from(this, browser3._defaultContext) });
      for (const context2 of browser3.contexts())
        this._dispatchEvent("context", { context: BrowserContextDispatcher.from(this, context2) });
    }
  }
  _didClose() {
    this._dispatchEvent("close");
    this._dispose();
  }
  async newContext(params, progress3) {
    if (params.recordVideo && this._object.attribution.playwright.options.isServer)
      params.recordVideo.dir = this._object.options.artifactsDir;
    if (!this._options.isolateContexts) {
      const context22 = await this._object.newContext(progress3, params);
      const contextDispatcher2 = BrowserContextDispatcher.from(this, context22);
      return { context: contextDispatcher2 };
    }
    const context2 = await this._object.newContext(progress3, params);
    this._isolatedContexts.add(context2);
    context2.on(BrowserContext.Events.Close, () => this._isolatedContexts.delete(context2));
    const contextDispatcher = BrowserContextDispatcher.from(this, context2);
    this._dispatchEvent("context", { context: contextDispatcher });
    return { context: contextDispatcher };
  }
  async newContextForReuse(params, progress3) {
    const context2 = await this._object.newContextForReuse(progress3, params);
    const contextDispatcher = BrowserContextDispatcher.from(this, context2);
    this._dispatchEvent("context", { context: contextDispatcher });
    return { context: contextDispatcher };
  }
  async disconnectFromReusedContext(params, progress3) {
    const context2 = this._object.contextForReuse();
    const contextDispatcher = context2 ? this.connection.existingDispatcher(context2) : void 0;
    if (contextDispatcher) {
      await contextDispatcher.stopPendingOperations(new Error(params.reason));
      contextDispatcher._dispose();
    }
  }
  async close(params, progress3) {
    if (this._options.ignoreStopAndKill)
      return;
    progress3.metadata.potentiallyClosesScope = true;
    await this._object.close(params);
  }
  async killForTests(params, progress3) {
    if (this._options.ignoreStopAndKill)
      return;
    progress3.metadata.potentiallyClosesScope = true;
    await this._object.killForTests();
  }
  async defaultUserAgentForTest() {
    return { userAgent: this._object.userAgent() };
  }
  async newBrowserCDPSession(params, progress3) {
    if (!this._object.options.isChromium)
      throw new Error(`CDP session is only available in Chromium`);
    const crBrowser = this._object;
    return { session: new CDPSessionDispatcher(this, await crBrowser.newBrowserCDPSession()) };
  }
  async startTracing(params, progress3) {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    await crBrowser.startTracing(params.page ? params.page._object : void 0, params);
  }
  async stopTracing(params, progress3) {
    if (!this._object.options.isChromium)
      throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    return { artifact: ArtifactDispatcher.from(this, await crBrowser.stopTracing()) };
  }
  async cleanupContexts() {
    await Promise.all(Array.from(this._isolatedContexts).map((context2) => context2.close({ reason: "Global context cleanup (connection terminated)" })));
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/browserTypeDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserTypeDispatcher = class extends Dispatcher {
  static {
    __name(this, "BrowserTypeDispatcher");
  }
  constructor(scope, browserType, denyLaunch) {
    super(scope, browserType, "BrowserType", {
      executablePath: browserType.executablePath(),
      name: browserType.name()
    });
    this._type_BrowserType = true;
    this._denyLaunch = denyLaunch;
  }
  async launch(params, progress3) {
    if (this._denyLaunch)
      throw new Error(`Launching more browsers is not allowed.`);
    const browser3 = await this._object.launch(progress3, params);
    return { browser: new BrowserDispatcher(this, browser3) };
  }
  async launchPersistentContext(params, progress3) {
    if (this._denyLaunch)
      throw new Error(`Launching more browsers is not allowed.`);
    const browserContext = await this._object.launchPersistentContext(progress3, params.userDataDir, params);
    const browserDispatcher = new BrowserDispatcher(this, browserContext._browser);
    const contextDispatcher = BrowserContextDispatcher.from(browserDispatcher, browserContext);
    return { browser: browserDispatcher, context: contextDispatcher };
  }
  async connectOverCDP(params, progress3) {
    if (this._denyLaunch)
      throw new Error(`Launching more browsers is not allowed.`);
    const browser3 = await this._object.connectOverCDP(progress3, params.endpointURL, params);
    const browserDispatcher = new BrowserDispatcher(this, browser3);
    return {
      browser: browserDispatcher,
      defaultContext: browser3._defaultContext ? BrowserContextDispatcher.from(browserDispatcher, browser3._defaultContext) : void 0
    };
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/electronDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/electron/electron.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs27 from "node:fs";
import os9 from "node:os";
import path20 from "node:path";
import "node:crypto";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";

// node_modules/@cloudflare/playwright/lib/cloudflare/webSocketTransport.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { AsyncLocalStorage as AsyncLocalStorage2 } from "node:async_hooks";

// node_modules/@cloudflare/playwright/lib/cloudflare/chunking.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HEADER_SIZE = 4;
var MAX_MESSAGE_SIZE = 1048575;
var FIRST_CHUNK_DATA_SIZE = MAX_MESSAGE_SIZE - HEADER_SIZE;
var messageToChunks = /* @__PURE__ */ __name((data) => {
  const encoder2 = new TextEncoder();
  const encodedUint8Array = encoder2.encode(data);
  const firstChunk = new Uint8Array(
    Math.min(MAX_MESSAGE_SIZE, HEADER_SIZE + encodedUint8Array.length)
  );
  const view = new DataView(firstChunk.buffer);
  view.setUint32(0, encodedUint8Array.length, true);
  firstChunk.set(
    encodedUint8Array.slice(0, FIRST_CHUNK_DATA_SIZE),
    HEADER_SIZE
  );
  const chunks = [firstChunk];
  for (let i = FIRST_CHUNK_DATA_SIZE; i < data.length; i += MAX_MESSAGE_SIZE)
    chunks.push(encodedUint8Array.slice(i, i + MAX_MESSAGE_SIZE));
  return chunks;
}, "messageToChunks");
var chunksToMessage = /* @__PURE__ */ __name((chunks, sessionid) => {
  if (chunks.length === 0)
    return null;
  const emptyBuffer = new Uint8Array(0);
  const firstChunk = chunks[0] || emptyBuffer;
  const view = new DataView(firstChunk.buffer);
  const expectedBytes = view.getUint32(0, true);
  let totalBytes = -4;
  for (let i = 0; i < chunks.length; ++i) {
    const curChunk = chunks[i] || emptyBuffer;
    totalBytes += curChunk.length;
    if (totalBytes > expectedBytes) {
      throw new Error(
        `Should have gotten the exact number of bytes but we got more.  SessionID: ${sessionid}`
      );
    }
    if (totalBytes === expectedBytes) {
      const chunksToCombine = chunks.splice(0, i + 1);
      chunksToCombine[0] = firstChunk.subarray(HEADER_SIZE);
      const combined = new Uint8Array(expectedBytes);
      let offset = 0;
      for (let j = 0; j <= i; ++j) {
        const chunk = chunksToCombine[j] || emptyBuffer;
        combined.set(chunk, offset);
        offset += chunk.length;
      }
      const decoder2 = new TextDecoder();
      const message = decoder2.decode(combined);
      return message;
    }
  }
  return null;
}, "chunksToMessage");

// node_modules/@cloudflare/playwright/lib/cloudflare/webSocketTransport.js
var transportZone = new AsyncLocalStorage2();
var WebSocketTransport = class {
  static {
    __name(this, "WebSocketTransport");
  }
  constructor(ws3, sessionId) {
    this._chunks = [];
    this._pingInterval = setInterval(() => {
      return this._ws.send("ping");
    }, 1e3);
    this._ws = ws3;
    this.sessionId = sessionId;
    this._ws.addEventListener("message", (event) => {
      this._chunks.push(new Uint8Array(event.data));
      const message = chunksToMessage(this._chunks, sessionId);
      if (message && this.onmessage)
        this.onmessage(JSON.parse(message));
    });
    this._ws.addEventListener("close", () => {
      clearInterval(this._pingInterval);
      if (this.onclose)
        this.onclose();
    });
    this._ws.addEventListener("error", (e) => {
      console.error(`Websocket error: SessionID: ${sessionId}`, e);
      clearInterval(this._pingInterval);
    });
  }
  static async connect() {
    const transport = transportZone.getStore();
    if (!transport)
      throw new Error("Transport is not available in the current zone");
    return transport;
  }
  send(message) {
    for (const chunk of messageToChunks(JSON.stringify(message)))
      this._ws.send(chunk);
  }
  close() {
    clearInterval(this._pingInterval);
    this._ws.close();
    this.onclose?.();
  }
  async closeAndWait() {
    if (this._ws.readyState === WebSocket.CLOSED)
      return;
    this.close();
  }
  toString() {
    return this.sessionId;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/electron/electron.js
var ARTIFACTS_FOLDER2 = path20.join(os9.tmpdir(), "playwright-artifacts-");
var ElectronApplication = class _ElectronApplication extends SdkObject {
  static {
    __name(this, "ElectronApplication");
  }
  constructor(parent, browser3, nodeConnection, process2) {
    super(parent, "electron-app");
    this._nodeElectronHandlePromise = new ManualPromise();
    this._process = process2;
    this._browserContext = browser3._defaultContext;
    this._nodeConnection = nodeConnection;
    this._nodeSession = nodeConnection.rootSession;
    this._nodeSession.on("Runtime.executionContextCreated", async (event) => {
      if (!event.context.auxData || !event.context.auxData.isDefault)
        return;
      const crExecutionContext = new CRExecutionContext(this._nodeSession, event.context);
      this._nodeExecutionContext = new ExecutionContext(this, crExecutionContext, "electron");
      const { result: remoteObject } = await crExecutionContext._client.send("Runtime.evaluate", {
        expression: `require('electron')`,
        contextId: event.context.id,
        // Needed after Electron 28 to get access to require: https://github.com/microsoft/playwright/issues/28048
        includeCommandLineAPI: true
      });
      this._nodeElectronHandlePromise.resolve(new JSHandle(this._nodeExecutionContext, "object", "ElectronModule", remoteObject.objectId));
    });
    this._nodeSession.on("Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event));
    const appClosePromise = new Promise((f) => this.once(_ElectronApplication.Events.Close, f));
    this._browserContext.setCustomCloseHandler(async () => {
      await this._browserContext.stopVideoRecording();
      const electronHandle = await this._nodeElectronHandlePromise;
      await electronHandle.evaluate(({ app }) => app.quit()).catch(() => {
      });
      this._nodeConnection.close();
      await appClosePromise;
    });
  }
  static {
    this.Events = {
      Close: "close",
      Console: "console"
    };
  }
  async _onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      return;
    }
    if (!this._nodeExecutionContext)
      return;
    const args = event.args.map((arg) => createHandle(this._nodeExecutionContext, arg));
    const message = new ConsoleMessage(null, event.type, void 0, args, toConsoleMessageLocation(event.stackTrace));
    this.emit(_ElectronApplication.Events.Console, message);
  }
  async initialize() {
    await this._nodeSession.send("Runtime.enable", {});
    await this._nodeSession.send("Runtime.evaluate", { expression: "__playwright_run()" });
  }
  process() {
    return this._process;
  }
  context() {
    return this._browserContext;
  }
  async close() {
    await this._browserContext.close({ reason: "Application exited" });
  }
  async browserWindow(page) {
    const targetId = page.delegate._targetId;
    const electronHandle = await this._nodeElectronHandlePromise;
    return await electronHandle.evaluateHandle(({ BrowserWindow, webContents }, targetId2) => {
      const wc = webContents.fromDevToolsTargetId(targetId2);
      return BrowserWindow.fromWebContents(wc);
    }, targetId);
  }
};
var Electron = class extends SdkObject {
  static {
    __name(this, "Electron");
  }
  constructor(playwright2) {
    super(playwright2, "electron");
    this.logName = "browser";
  }
  async launch(progress3, options2) {
    let app = void 0;
    let electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...options2.args || []];
    if (os9.platform() === "linux") {
      const runningAsRoot = process.geteuid && process.geteuid() === 0;
      if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
        electronArguments.unshift("--no-sandbox");
    }
    const artifactsDir = await progress3.race(fs27.promises.mkdtemp(ARTIFACTS_FOLDER2));
    const browserLogsCollector = new RecentLogsCollector();
    const env3 = options2.env ? envArrayToObject(options2.env) : process.env;
    let command;
    if (options2.executablePath) {
      command = options2.executablePath;
    } else {
      try {
        command = require$$06;
      } catch (error3) {
        if (error3?.code === "MODULE_NOT_FOUND") {
          throw new Error("\n" + wrapInASCIIBox([
            "Electron executablePath not found!",
            "Please install it using `npm install -D electron` or set the executablePath to your Electron executable."
          ].join("\n"), 1));
        }
        throw error3;
      }
      electronArguments.unshift("-r", __require.resolve("./loader"));
    }
    let shell = false;
    if (process.platform === "win32") {
      shell = true;
      command = `"${command}"`;
      electronArguments = electronArguments.map((arg) => `"${arg}"`);
    }
    delete env3.NODE_OPTIONS;
    const { launchedProcess, gracefullyClose, kill: kill2 } = await launchProcess({
      command,
      args: electronArguments,
      env: env3,
      log: /* @__PURE__ */ __name((message) => {
        progress3.log(message);
        browserLogsCollector.log(message);
      }, "log"),
      shell,
      stdio: "pipe",
      cwd: options2.cwd,
      tempDirectories: [artifactsDir],
      attemptToGracefullyClose: /* @__PURE__ */ __name(() => app.close(), "attemptToGracefullyClose"),
      handleSIGINT: true,
      handleSIGTERM: true,
      handleSIGHUP: true,
      onExit: /* @__PURE__ */ __name(() => app?.emit(ElectronApplication.Events.Close), "onExit")
    });
    const waitForXserverError = waitForLine(progress3, launchedProcess, /Unable to open X display/).then(() => {
      throw new Error([
        "Unable to open X display!",
        `================================`,
        "Most likely this is because there is no X server available.",
        "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.",
        "For example: 'xvfb-run npm run test:e2e'",
        `================================`,
        progress3.metadata.log
      ].join("\n"));
    });
    const nodeMatchPromise = waitForLine(progress3, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
    const chromeMatchPromise = waitForLine(progress3, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/);
    const debuggerDisconnectPromise = waitForLine(progress3, launchedProcess, /Waiting for the debugger to disconnect\.\.\./);
    try {
      const nodeMatch = await nodeMatchPromise;
      const nodeTransport = await WebSocketTransport.connect(progress3, nodeMatch[1]);
      const nodeConnection = new CRConnection(this, nodeTransport, helper.debugProtocolLogger(), browserLogsCollector);
      debuggerDisconnectPromise.then(() => {
        nodeTransport.close();
      }).catch(() => {
      });
      const chromeMatch = await Promise.race([
        chromeMatchPromise,
        waitForXserverError
      ]);
      const chromeTransport = await WebSocketTransport.connect(progress3, chromeMatch[1]);
      const browserProcess = {
        onclose: void 0,
        process: launchedProcess,
        close: gracefullyClose,
        kill: kill2
      };
      const contextOptions = {
        ...options2,
        noDefaultViewport: true
      };
      const browserOptions = {
        name: "electron",
        isChromium: true,
        headful: true,
        persistent: contextOptions,
        browserProcess,
        protocolLogger: helper.debugProtocolLogger(),
        browserLogsCollector,
        artifactsDir,
        downloadsPath: artifactsDir,
        tracesDir: options2.tracesDir || artifactsDir,
        originalLaunchOptions: {}
      };
      validateBrowserContextOptions(contextOptions, browserOptions);
      const browser3 = await progress3.race(CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions));
      app = new ElectronApplication(this, browser3, nodeConnection, launchedProcess);
      await progress3.race(app.initialize());
      return app;
    } catch (error3) {
      await kill2();
      throw error3;
    }
  }
};
async function waitForLine(progress3, process2, regex) {
  const promise = new ManualPromise();
  const rl = createInterface({ input: process2.stderr });
  const failError = new Error("Process failed to launch!");
  const listeners2 = [
    eventsHelper.addEventListener(rl, "line", onLine),
    eventsHelper.addEventListener(rl, "close", () => promise.reject(failError)),
    eventsHelper.addEventListener(process2, "exit", () => promise.reject(failError)),
    // It is Ok to remove error handler because we did not create process and there is another listener.
    eventsHelper.addEventListener(process2, "error", () => promise.reject(failError))
  ];
  function onLine(line) {
    const match = line.match(regex);
    if (match)
      promise.resolve(match);
  }
  __name(onLine, "onLine");
  try {
    return await progress3.race(promise);
  } finally {
    eventsHelper.removeEventListeners(listeners2);
  }
}
__name(waitForLine, "waitForLine");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/electronDispatcher.js
var ElectronDispatcher = class extends Dispatcher {
  static {
    __name(this, "ElectronDispatcher");
  }
  constructor(scope, electron, denyLaunch) {
    super(scope, electron, "Electron", {});
    this._type_Electron = true;
    this._denyLaunch = denyLaunch;
  }
  async launch(params, progress3) {
    if (this._denyLaunch)
      throw new Error(`Launching more browsers is not allowed.`);
    const electronApplication = await this._object.launch(progress3, params);
    return { electronApplication: new ElectronApplicationDispatcher(this, electronApplication) };
  }
};
var ElectronApplicationDispatcher = class extends Dispatcher {
  static {
    __name(this, "ElectronApplicationDispatcher");
  }
  constructor(scope, electronApplication) {
    super(scope, electronApplication, "ElectronApplication", {
      context: BrowserContextDispatcher.from(scope, electronApplication.context())
    });
    this._type_EventTarget = true;
    this._type_ElectronApplication = true;
    this._subscriptions = /* @__PURE__ */ new Set();
    this.addObjectListener(ElectronApplication.Events.Close, () => {
      this._dispatchEvent("close");
      this._dispose();
    });
    this.addObjectListener(ElectronApplication.Events.Console, (message) => {
      if (!this._subscriptions.has("console"))
        return;
      this._dispatchEvent("console", {
        type: message.type(),
        text: message.text(),
        args: message.args().map((a) => JSHandleDispatcher.fromJSHandle(this, a)),
        location: message.location()
      });
    });
  }
  async browserWindow(params, progress3) {
    const handle = await progress3.race(this._object.browserWindow(params.page.page()));
    return { handle: JSHandleDispatcher.fromJSHandle(this, handle) };
  }
  async evaluateExpression(params, progress3) {
    const handle = await progress3.race(this._object._nodeElectronHandlePromise);
    return { value: serializeResult(await progress3.race(handle.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
  }
  async evaluateExpressionHandle(params, progress3) {
    const handle = await progress3.race(this._object._nodeElectronHandlePromise);
    const result = await progress3.race(handle.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)));
    return { handle: JSHandleDispatcher.fromJSHandle(this, result) };
  }
  async updateSubscription(params, progress3) {
    if (params.enabled)
      this._subscriptions.add(params.event);
    else
      this._subscriptions.delete(params.event);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/localUtilsDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/localUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs29 from "node:fs";
import os10 from "node:os";
import path22 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/harBackend.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs28 from "node:fs";
import path21 from "node:path";
var redirectStatus2 = [301, 302, 303, 307, 308];
var HarBackend = class {
  static {
    __name(this, "HarBackend");
  }
  constructor(harFile, baseDir, zipFile) {
    this.id = createGuid();
    this._harFile = harFile;
    this._baseDir = baseDir;
    this._zipFile = zipFile;
  }
  async lookup(url4, method, headers, postData, isNavigationRequest) {
    let entry;
    try {
      entry = await this._harFindResponse(url4, method, headers, postData);
    } catch (e) {
      return { action: "error", message: "HAR error: " + e.message };
    }
    if (!entry)
      return { action: "noentry" };
    if (entry.request.url !== url4 && isNavigationRequest)
      return { action: "redirect", redirectURL: entry.request.url };
    const response = entry.response;
    try {
      const buffer = await this._loadContent(response.content);
      return {
        action: "fulfill",
        status: response.status,
        headers: response.headers,
        body: buffer
      };
    } catch (e) {
      return { action: "error", message: e.message };
    }
  }
  async _loadContent(content) {
    const file = content._file;
    let buffer;
    if (file) {
      if (this._zipFile)
        buffer = await this._zipFile.read(file);
      else
        buffer = await fs28.promises.readFile(path21.resolve(this._baseDir, file));
    } else {
      buffer = Buffer.from(content.text || "", content.encoding === "base64" ? "base64" : "utf-8");
    }
    return buffer;
  }
  async _harFindResponse(url4, method, headers, postData) {
    const harLog = this._harFile.log;
    const visited = /* @__PURE__ */ new Set();
    while (true) {
      const entries = [];
      for (const candidate of harLog.entries) {
        if (candidate.request.url !== url4 || candidate.request.method !== method)
          continue;
        if (method === "POST" && postData && candidate.request.postData) {
          const buffer = await this._loadContent(candidate.request.postData);
          if (!buffer.equals(postData)) {
            const boundary = multipartBoundary(headers);
            if (!boundary)
              continue;
            const candidataBoundary = multipartBoundary(candidate.request.headers);
            if (!candidataBoundary)
              continue;
            if (postData.toString().replaceAll(boundary, "") !== buffer.toString().replaceAll(candidataBoundary, ""))
              continue;
          }
        }
        entries.push(candidate);
      }
      if (!entries.length)
        return;
      let entry = entries[0];
      if (entries.length > 1) {
        const list = [];
        for (const candidate of entries) {
          const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);
          list.push({ candidate, matchingHeaders });
        }
        list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);
        entry = list[0].candidate;
      }
      if (visited.has(entry))
        throw new Error(`Found redirect cycle for ${url4}`);
      visited.add(entry);
      const locationHeader = entry.response.headers.find((h) => h.name.toLowerCase() === "location");
      if (redirectStatus2.includes(entry.response.status) && locationHeader) {
        const locationURL = new URL(locationHeader.value, url4);
        url4 = locationURL.toString();
        if ((entry.response.status === 301 || entry.response.status === 302) && method === "POST" || entry.response.status === 303 && !["GET", "HEAD"].includes(method)) {
          method = "GET";
        }
        continue;
      }
      return entry;
    }
  }
  dispose() {
    this._zipFile?.close();
  }
};
function countMatchingHeaders(harHeaders, headers) {
  const set2 = new Set(headers.map((h) => h.name.toLowerCase() + ":" + h.value));
  let matches = 0;
  for (const h of harHeaders) {
    if (set2.has(h.name.toLowerCase() + ":" + h.value))
      ++matches;
  }
  return matches;
}
__name(countMatchingHeaders, "countMatchingHeaders");
function multipartBoundary(headers) {
  const contentType = headers.find((h) => h.name.toLowerCase() === "content-type");
  if (!contentType?.value.includes("multipart/form-data"))
    return void 0;
  const boundary = contentType.value.match(/boundary=(\S+)/);
  if (boundary)
    return boundary[1];
  return void 0;
}
__name(multipartBoundary, "multipartBoundary");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/zipFile.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZipFile = class {
  static {
    __name(this, "ZipFile");
  }
  constructor(fileName) {
    this._entries = /* @__PURE__ */ new Map();
    this._fileName = fileName;
    this._openedPromise = this._open();
  }
  async _open() {
    await new Promise((fulfill, reject) => {
      yauzl2.open(this._fileName, { autoClose: false }, (e, z) => {
        if (e) {
          reject(e);
          return;
        }
        this._zipFile = z;
        this._zipFile.on("entry", (entry) => {
          this._entries.set(entry.fileName, entry);
        });
        this._zipFile.on("end", fulfill);
      });
    });
  }
  async entries() {
    await this._openedPromise;
    return [...this._entries.keys()];
  }
  async read(entryPath) {
    await this._openedPromise;
    const entry = this._entries.get(entryPath);
    if (!entry)
      throw new Error(`${entryPath} not found in file ${this._fileName}`);
    return new Promise((resolve, reject) => {
      this._zipFile.openReadStream(entry, (error3, readStream) => {
        if (error3 || !readStream) {
          reject(error3 || "Entry not found");
          return;
        }
        const buffers = [];
        readStream.on("data", (data) => buffers.push(data));
        readStream.on("end", () => resolve(Buffer.concat(buffers)));
      });
    });
  }
  close() {
    this._zipFile?.close();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/traceUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function serializeClientSideCallMetadata(metadatas) {
  const fileNames = /* @__PURE__ */ new Map();
  const stacks = [];
  for (const m of metadatas) {
    if (!m.stack || !m.stack.length)
      continue;
    const stack = [];
    for (const frame of m.stack) {
      let ordinal = fileNames.get(frame.file);
      if (typeof ordinal !== "number") {
        ordinal = fileNames.size;
        fileNames.set(frame.file, ordinal);
      }
      const stackFrame = [ordinal, frame.line || 0, frame.column || 0, frame.function || ""];
      stack.push(stackFrame);
    }
    stacks.push([m.id, stack]);
  }
  return { files: [...fileNames.keys()], stacks };
}
__name(serializeClientSideCallMetadata, "serializeClientSideCallMetadata");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/localUtils.js
async function zip(progress3, stackSessions, params) {
  const promise = new ManualPromise();
  const zipFile = new yazl2.ZipFile();
  zipFile.on("error", (error3) => promise.reject(error3));
  const addFile = /* @__PURE__ */ __name((file, name) => {
    try {
      if (fs29.statSync(file).isFile())
        zipFile.addFile(file, name);
    } catch (e) {
    }
  }, "addFile");
  for (const entry of params.entries)
    addFile(entry.value, entry.name);
  const stackSession = params.stacksId ? stackSessions.get(params.stacksId) : void 0;
  if (stackSession?.callStacks.length) {
    await progress3.race(stackSession.writer);
    if (process.env.PW_LIVE_TRACE_STACKS) {
      zipFile.addFile(stackSession.file, "trace.stacks");
    } else {
      const buffer = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(stackSession.callStacks)));
      zipFile.addBuffer(buffer, "trace.stacks");
    }
  }
  if (params.includeSources) {
    const sourceFiles = /* @__PURE__ */ new Set();
    for (const { stack } of stackSession?.callStacks || []) {
      if (!stack)
        continue;
      for (const { file } of stack)
        sourceFiles.add(file);
    }
    for (const sourceFile of sourceFiles)
      addFile(sourceFile, "resources/src@" + await calculateSha1(sourceFile) + ".txt");
  }
  if (params.mode === "write") {
    await progress3.race(fs29.promises.mkdir(path22.dirname(params.zipFile), { recursive: true }));
    zipFile.end(void 0, () => {
      const chunks = [];
      zipFile.outputStream.on("data", (data) => chunks.push(data)).on("close", () => {
        fs29.writeFileSync(params.zipFile, Buffer.concat(chunks));
        promise.resolve();
      }).on("error", (error3) => promise.reject(error3));
    });
    await progress3.race(promise);
    await deleteStackSession(progress3, stackSessions, params.stacksId);
    return;
  }
  const tempFile = params.zipFile + ".tmp";
  await progress3.race(fs29.promises.rename(params.zipFile, tempFile));
  yauzl2.open(tempFile, (err, inZipFile) => {
    if (err) {
      promise.reject(err);
      return;
    }
    assert3(inZipFile);
    let pendingEntries = inZipFile.entryCount;
    inZipFile.on("entry", (entry) => {
      inZipFile.openReadStream(entry, (err2, readStream) => {
        if (err2) {
          promise.reject(err2);
          return;
        }
        zipFile.addReadStream(readStream, entry.fileName);
        if (--pendingEntries === 0) {
          zipFile.end(void 0, () => {
            const chunks = [];
            zipFile.outputStream.on("data", (data) => chunks.push(data)).on("close", () => {
              fs29.promises.unlink(tempFile).then(() => {
                fs29.writeFileSync(params.zipFile, Buffer.concat(chunks));
                promise.resolve();
              }).catch((error3) => promise.reject(error3));
            });
          });
        }
      });
    });
  });
  await progress3.race(promise);
  await deleteStackSession(progress3, stackSessions, params.stacksId);
}
__name(zip, "zip");
async function deleteStackSession(progress3, stackSessions, stacksId) {
  const session2 = stacksId ? stackSessions.get(stacksId) : void 0;
  if (!session2)
    return;
  stackSessions.delete(stacksId);
  if (session2.tmpDir)
    await progress3.race(removeFolders([session2.tmpDir]));
}
__name(deleteStackSession, "deleteStackSession");
async function harOpen(progress3, harBackends, params) {
  let harBackend;
  if (params.file.endsWith(".zip")) {
    const zipFile = new ZipFile(params.file);
    try {
      const entryNames = await progress3.race(zipFile.entries());
      const harEntryName = entryNames.find((e) => e.endsWith(".har"));
      if (!harEntryName)
        return { error: "Specified archive does not have a .har file" };
      const har = await progress3.race(zipFile.read(harEntryName));
      const harFile = JSON.parse(har.toString());
      harBackend = new HarBackend(harFile, null, zipFile);
    } catch (error3) {
      zipFile.close();
      throw error3;
    }
  } else {
    const harFile = JSON.parse(await progress3.race(fs29.promises.readFile(params.file, "utf-8")));
    harBackend = new HarBackend(harFile, path22.dirname(params.file), null);
  }
  harBackends.set(harBackend.id, harBackend);
  return { harId: harBackend.id };
}
__name(harOpen, "harOpen");
async function harLookup(progress3, harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (!harBackend)
    return { action: "error", message: `Internal error: har was not opened` };
  return await progress3.race(harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest));
}
__name(harLookup, "harLookup");
function harClose(harBackends, params) {
  const harBackend = harBackends.get(params.harId);
  if (harBackend) {
    harBackends.delete(harBackend.id);
    harBackend.dispose();
  }
}
__name(harClose, "harClose");
async function harUnzip(progress3, params) {
  const dir3 = path22.dirname(params.zipFile);
  const zipFile = new ZipFile(params.zipFile);
  try {
    for (const entry of await progress3.race(zipFile.entries())) {
      const buffer = await progress3.race(zipFile.read(entry));
      if (entry === "har.har")
        await progress3.race(fs29.promises.writeFile(params.harFile, buffer));
      else
        await progress3.race(fs29.promises.writeFile(path22.join(dir3, entry), buffer));
    }
    await progress3.race(fs29.promises.unlink(params.zipFile));
  } finally {
    zipFile.close();
  }
}
__name(harUnzip, "harUnzip");
async function tracingStarted(progress3, stackSessions, params) {
  let tmpDir = void 0;
  if (!params.tracesDir)
    tmpDir = await progress3.race(fs29.promises.mkdtemp(path22.join(os10.tmpdir(), "playwright-tracing-")));
  const traceStacksFile = path22.join(params.tracesDir || tmpDir, params.traceName + ".stacks");
  stackSessions.set(traceStacksFile, { callStacks: [], file: traceStacksFile, writer: Promise.resolve(), tmpDir });
  return { stacksId: traceStacksFile };
}
__name(tracingStarted, "tracingStarted");
async function traceDiscarded(progress3, stackSessions, params) {
  await deleteStackSession(progress3, stackSessions, params.stacksId);
}
__name(traceDiscarded, "traceDiscarded");
function addStackToTracingNoReply(stackSessions, params) {
  for (const session2 of stackSessions.values()) {
    session2.callStacks.push(params.callData);
    if (process.env.PW_LIVE_TRACE_STACKS) {
      session2.writer = session2.writer.then(() => {
        const buffer = Buffer.from(JSON.stringify(serializeClientSideCallMetadata(session2.callStacks)));
        return fs29.promises.writeFile(session2.file, buffer);
      });
    }
  }
}
__name(addStackToTracingNoReply, "addStackToTracingNoReply");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/jsonPipeDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JsonPipeDispatcher = class extends Dispatcher {
  static {
    __name(this, "JsonPipeDispatcher");
  }
  constructor(scope) {
    super(scope, new SdkObject(scope._object, "jsonPipe"), "JsonPipe", {});
    this._type_JsonPipe = true;
  }
  async send(params, progress3) {
    this.emit("message", params.message);
  }
  async close(params, progress3) {
    this.emit("close");
    if (!this._disposed) {
      this._dispatchEvent("closed", {});
      this._dispose();
    }
  }
  dispatch(message) {
    if (!this._disposed)
      this._dispatchEvent("message", { message });
  }
  wasClosed(reason) {
    if (!this._disposed) {
      this._dispatchEvent("closed", { reason });
      this._dispose();
    }
  }
  dispose() {
    this._dispose();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/socksInterceptor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import EventEmitter13 from "node:events";
var SocksInterceptor = class {
  static {
    __name(this, "SocksInterceptor");
  }
  constructor(transport, pattern, redirectPortForTest) {
    this._ids = /* @__PURE__ */ new Set();
    this._handler = new SocksProxyHandler(pattern, redirectPortForTest);
    let lastId = -1;
    this._channel = new Proxy(new EventEmitter13(), {
      get: /* @__PURE__ */ __name((obj, prop) => {
        if (prop in obj || obj[prop] !== void 0 || typeof prop !== "string")
          return obj[prop];
        return (params) => {
          try {
            const id = --lastId;
            this._ids.add(id);
            const validator = findValidator("SocksSupport", prop, "Params");
            params = validator(params, "", { tChannelImpl: tChannelForSocks, binary: "toBase64", isUnderTest });
            transport.send({ id, guid: this._socksSupportObjectGuid, method: prop, params, metadata: { stack: [], apiName: "", internal: true } });
          } catch (e) {
          }
        };
      }, "get")
    });
    this._handler.on(SocksProxyHandler.Events.SocksConnected, (payload) => this._channel.socksConnected(payload));
    this._handler.on(SocksProxyHandler.Events.SocksData, (payload) => this._channel.socksData(payload));
    this._handler.on(SocksProxyHandler.Events.SocksError, (payload) => this._channel.socksError(payload));
    this._handler.on(SocksProxyHandler.Events.SocksFailed, (payload) => this._channel.socksFailed(payload));
    this._handler.on(SocksProxyHandler.Events.SocksEnd, (payload) => this._channel.socksEnd(payload));
    this._channel.on("socksRequested", (payload) => this._handler.socketRequested(payload));
    this._channel.on("socksClosed", (payload) => this._handler.socketClosed(payload));
    this._channel.on("socksData", (payload) => this._handler.sendSocketData(payload));
  }
  cleanup() {
    this._handler.cleanup();
  }
  interceptMessage(message) {
    if (this._ids.has(message.id)) {
      this._ids.delete(message.id);
      return true;
    }
    if (message.method === "__create__" && message.params.type === "SocksSupport") {
      this._socksSupportObjectGuid = message.params.guid;
      return false;
    }
    if (this._socksSupportObjectGuid && message.guid === this._socksSupportObjectGuid) {
      const validator = findValidator("SocksSupport", message.method, "Event");
      const params = validator(message.params, "", { tChannelImpl: tChannelForSocks, binary: "fromBase64", isUnderTest });
      this._channel.emit(message.method, params);
      return true;
    }
    return false;
  }
};
function tChannelForSocks(names, arg, path30, context2) {
  throw new ValidationError(`${path30}: channels are not expected in SocksSupport`);
}
__name(tChannelForSocks, "tChannelForSocks");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/localUtilsDispatcher.js
var LocalUtilsDispatcher = class extends Dispatcher {
  static {
    __name(this, "LocalUtilsDispatcher");
  }
  constructor(scope, playwright2) {
    const localUtils2 = new SdkObject(playwright2, "localUtils", "localUtils");
    localUtils2.logName = "browser";
    const deviceDescriptors$1 = Object.entries(deviceDescriptors).map(([name, descriptor]) => ({ name, descriptor }));
    super(scope, localUtils2, "LocalUtils", {
      deviceDescriptors: deviceDescriptors$1
    });
    this._harBackends = /* @__PURE__ */ new Map();
    this._stackSessions = /* @__PURE__ */ new Map();
    this._type_LocalUtils = true;
  }
  async zip(params, progress3) {
    return await zip(progress3, this._stackSessions, params);
  }
  async harOpen(params, progress3) {
    return await harOpen(progress3, this._harBackends, params);
  }
  async harLookup(params, progress3) {
    return await harLookup(progress3, this._harBackends, params);
  }
  async harClose(params, progress3) {
    harClose(this._harBackends, params);
  }
  async harUnzip(params, progress3) {
    return await harUnzip(progress3, params);
  }
  async tracingStarted(params, progress3) {
    return await tracingStarted(progress3, this._stackSessions, params);
  }
  async traceDiscarded(params, progress3) {
    return await traceDiscarded(progress3, this._stackSessions, params);
  }
  async addStackToTracingNoReply(params, progress3) {
    addStackToTracingNoReply(this._stackSessions, params);
  }
  async connect(params, progress3) {
    const wsHeaders = {
      "User-Agent": getUserAgent(),
      "x-playwright-proxy": params.exposeNetwork ?? "",
      ...params.headers
    };
    const wsEndpoint = await urlToWSEndpoint(progress3, params.wsEndpoint);
    const transport = await WebSocketTransport.connect(progress3, wsEndpoint, { headers: wsHeaders, followRedirects: true, debugLogHeader: "x-playwright-debug-log" });
    const socksInterceptor = new SocksInterceptor(transport, params.exposeNetwork, params.socksProxyRedirectPortForTest);
    const pipe = new JsonPipeDispatcher(this);
    transport.onmessage = (json) => {
      if (socksInterceptor.interceptMessage(json))
        return;
      const cb = /* @__PURE__ */ __name(() => {
        try {
          pipe.dispatch(json);
        } catch (e) {
          transport.close();
        }
      }, "cb");
      if (params.slowMo)
        setTimeout(cb, params.slowMo);
      else
        cb();
    };
    pipe.on("message", (message) => {
      transport.send(message);
    });
    transport.onclose = (reason) => {
      socksInterceptor?.cleanup();
      pipe.wasClosed(reason);
    };
    pipe.on("close", () => transport.close());
    return { pipe, headers: transport.headers };
  }
  async globToRegex(params, progress3) {
    const regex = resolveGlobToRegexPattern(params.baseURL, params.glob, params.webSocketUrl);
    return { regex };
  }
};
async function urlToWSEndpoint(progress3, endpointURL) {
  if (endpointURL.startsWith("ws"))
    return endpointURL;
  progress3.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
  const fetchUrl = new URL(endpointURL);
  if (!fetchUrl.pathname.endsWith("/"))
    fetchUrl.pathname += "/";
  fetchUrl.pathname += "json";
  const json = await fetchData(progress3, {
    url: fetchUrl.toString(),
    method: "GET",
    headers: { "User-Agent": getUserAgent() }
  }, async (params, response) => {
    return new Error(`Unexpected status ${response.statusCode} when connecting to ${fetchUrl.toString()}.
This does not look like a Playwright server, try connecting via ws://.`);
  });
  const wsUrl = new URL(endpointURL);
  let wsEndpointPath = JSON.parse(json).wsEndpointPath;
  if (wsEndpointPath.startsWith("/"))
    wsEndpointPath = wsEndpointPath.substring(1);
  if (!wsUrl.pathname.endsWith("/"))
    wsUrl.pathname += "/";
  wsUrl.pathname += wsEndpointPath;
  wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
  return wsUrl.toString();
}
__name(urlToWSEndpoint, "urlToWSEndpoint");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/playwrightDispatcher.js
var PlaywrightDispatcher = class extends Dispatcher {
  static {
    __name(this, "PlaywrightDispatcher");
  }
  constructor(scope, playwright2, options2 = {}) {
    const denyLaunch = options2.denyLaunch ?? false;
    const chromium2 = new BrowserTypeDispatcher(scope, playwright2.chromium, denyLaunch);
    const firefox = new BrowserTypeDispatcher(scope, playwright2.firefox, denyLaunch);
    const webkit = new BrowserTypeDispatcher(scope, playwright2.webkit, denyLaunch);
    const _bidiChromium = new BrowserTypeDispatcher(scope, playwright2._bidiChromium, denyLaunch);
    const _bidiFirefox = new BrowserTypeDispatcher(scope, playwright2._bidiFirefox, denyLaunch);
    const android = new AndroidDispatcher(scope, playwright2.android);
    const initializer = {
      chromium: chromium2,
      firefox,
      webkit,
      _bidiChromium,
      _bidiFirefox,
      android,
      electron: new ElectronDispatcher(scope, playwright2.electron, denyLaunch),
      utils: playwright2.options.isServer ? void 0 : new LocalUtilsDispatcher(scope, playwright2),
      socksSupport: options2.socksProxy ? new SocksSupportDispatcher(scope, playwright2, options2.socksProxy) : void 0
    };
    let browserDispatcher;
    if (options2.preLaunchedBrowser) {
      const browserTypeDispatcher = initializer[options2.preLaunchedBrowser.options.name];
      browserDispatcher = new BrowserDispatcher(browserTypeDispatcher, options2.preLaunchedBrowser, {
        ignoreStopAndKill: true,
        isolateContexts: !options2.sharedBrowser
      });
      initializer.preLaunchedBrowser = browserDispatcher;
    }
    if (options2.preLaunchedAndroidDevice)
      initializer.preConnectedAndroidDevice = new AndroidDeviceDispatcher(android, options2.preLaunchedAndroidDevice);
    super(scope, playwright2, "Playwright", initializer);
    this._type_Playwright = true;
    this._browserDispatcher = browserDispatcher;
  }
  async newRequest(params, progress3) {
    const request2 = new GlobalAPIRequestContext(this._object, params);
    return { request: APIRequestContextDispatcher.from(this.parentScope(), request2) };
  }
  async cleanup() {
    await this._browserDispatcher?.cleanupContexts();
  }
};
var SocksSupportDispatcher = class extends Dispatcher {
  static {
    __name(this, "SocksSupportDispatcher");
  }
  constructor(scope, parent, socksProxy) {
    super(scope, new SdkObject(parent, "socksSupport"), "SocksSupport", {});
    this._type_SocksSupport = true;
    this._socksProxy = socksProxy;
    this._socksListeners = [
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksRequested, (payload) => this._dispatchEvent("socksRequested", payload)),
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksData, (payload) => this._dispatchEvent("socksData", payload)),
      eventsHelper.addEventListener(socksProxy, SocksProxy.Events.SocksClosed, (payload) => this._dispatchEvent("socksClosed", payload))
    ];
  }
  async socksConnected(params, progress3) {
    this._socksProxy?.socketConnected(params);
  }
  async socksFailed(params, progress3) {
    this._socksProxy?.socketFailed(params);
  }
  async socksData(params, progress3) {
    this._socksProxy?.sendSocketData(params);
  }
  async socksError(params, progress3) {
    this._socksProxy?.sendSocketError(params);
  }
  async socksEnd(params, progress3) {
    this._socksProxy?.sendSocketEnd(params);
  }
  _onDispose() {
    eventsHelper.removeEventListeners(this._socksListeners);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/remote/playwrightConnection.js
import "node:events";
import "node:net";
import "node:os";
import "node:fs";
import "node:path";
import "node:crypto";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:stream";
import "node:tls";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiBrowser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiConnection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter14 } from "node:events";
var kBrowserCloseMessageId2 = 0;
var BidiConnection = class {
  static {
    __name(this, "BidiConnection");
  }
  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
    this._lastId = 0;
    this._closed = false;
    this._browsingContextToSession = /* @__PURE__ */ new Map();
    this._transport = transport;
    this._onDisconnect = onDisconnect;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.browserSession = new BidiSession(this, "", (message) => {
      this.rawSend(message);
    });
    this._transport.onmessage = this._dispatchMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  _dispatchMessage(message) {
    this._protocolLogger("receive", message);
    const object = message;
    if (object.type === "event") {
      let context2;
      if ("context" in object.params)
        context2 = object.params.context;
      else if (object.method === "log.entryAdded" || object.method === "script.message")
        context2 = object.params.source?.context;
      if (context2) {
        const session2 = this._browsingContextToSession.get(context2);
        if (session2) {
          session2.dispatchMessage(message);
          return;
        }
      }
    } else if (message.id) {
      for (const session2 of this._browsingContextToSession.values()) {
        if (session2.hasCallback(message.id)) {
          session2.dispatchMessage(message);
          return;
        }
      }
    }
    this.browserSession.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.browserSession.dispose();
    this._onDisconnect();
  }
  isClosed() {
    return this._closed;
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  createMainFrameBrowsingContextSession(bowsingContextId) {
    const result = new BidiSession(this, bowsingContextId, (message) => this.rawSend(message));
    this._browsingContextToSession.set(bowsingContextId, result);
    return result;
  }
};
var BidiSession = class extends EventEmitter14 {
  static {
    __name(this, "BidiSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this._browsingContexts = /* @__PURE__ */ new Set();
    this.setMaxListeners(0);
    this.connection = connection;
    this.sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.off = super.removeListener;
    this.addListener = super.addListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  addFrameBrowsingContext(context2) {
    this._browsingContexts.add(context2);
    this.connection._browsingContextToSession.set(context2, this);
  }
  removeFrameBrowsingContext(context2) {
    this._browsingContexts.delete(context2);
    this.connection._browsingContextToSession.delete(context2);
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this.connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this.connection._browserDisconnectedLogs);
    const id = this.connection.nextMessageId();
    const messageObj = { id, method, params };
    this._rawSend(messageObj);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error3) => debugLogger.log("error", error3));
  }
  markAsCrashed() {
    this._crashed = true;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed = true;
    this.connection._browsingContextToSession.delete(this.sessionId);
    for (const context2 of this._browsingContexts)
      this.connection._browsingContextToSession.delete(context2);
    this._browsingContexts.clear();
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this.connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
  hasCallback(id) {
    return this._callbacks.has(id);
  }
  dispatchMessage(message) {
    const object = message;
    if (object.id === kBrowserCloseMessageId2)
      return;
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.type === "error") {
        callback.error.setMessage(object.error + "\nMessage: " + object.message);
        callback.reject(callback.error);
      } else if (object.type === "success") {
        callback.resolve(object.result);
      } else {
        callback.error.setMessage("Internal error, unexpected response type: " + JSON.stringify(object));
        callback.reject(callback.error);
      }
    } else if (object.id) ;
    else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiNetworkManager.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiProtocolCore.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Session2;
((Session22) => {
  ((UserPromptHandlerType2) => {
    UserPromptHandlerType2["Accept"] = "accept";
    UserPromptHandlerType2["Dismiss"] = "dismiss";
    UserPromptHandlerType2["Ignore"] = "ignore";
  })(Session22.UserPromptHandlerType || (Session22.UserPromptHandlerType = {}));
})(Session2 || (Session2 = {}));
var BrowsingContext;
((BrowsingContext2) => {
  ((ReadinessState2) => {
    ReadinessState2["None"] = "none";
    ReadinessState2["Interactive"] = "interactive";
    ReadinessState2["Complete"] = "complete";
  })(BrowsingContext2.ReadinessState || (BrowsingContext2.ReadinessState = {}));
})(BrowsingContext || (BrowsingContext = {}));
((BrowsingContext2) => {
  ((UserPromptType2) => {
    UserPromptType2["Alert"] = "alert";
    UserPromptType2["Beforeunload"] = "beforeunload";
    UserPromptType2["Confirm"] = "confirm";
    UserPromptType2["Prompt"] = "prompt";
  })(BrowsingContext2.UserPromptType || (BrowsingContext2.UserPromptType = {}));
})(BrowsingContext || (BrowsingContext = {}));
((BrowsingContext2) => {
  ((CreateType2) => {
    CreateType2["Tab"] = "tab";
    CreateType2["Window"] = "window";
  })(BrowsingContext2.CreateType || (BrowsingContext2.CreateType = {}));
})(BrowsingContext || (BrowsingContext = {}));
var Emulation;
((Emulation2) => {
  ((ForcedColorsModeTheme2) => {
    ForcedColorsModeTheme2["Light"] = "light";
    ForcedColorsModeTheme2["Dark"] = "dark";
  })(Emulation2.ForcedColorsModeTheme || (Emulation2.ForcedColorsModeTheme = {}));
})(Emulation || (Emulation = {}));
((Emulation2) => {
  ((ScreenOrientationNatural2) => {
    ScreenOrientationNatural2["Portrait"] = "portrait";
    ScreenOrientationNatural2["Landscape"] = "landscape";
  })(Emulation2.ScreenOrientationNatural || (Emulation2.ScreenOrientationNatural = {}));
})(Emulation || (Emulation = {}));
var Network2;
((Network22) => {
  ((CollectorType2) => {
    CollectorType2["Blob"] = "blob";
  })(Network22.CollectorType || (Network22.CollectorType = {}));
})(Network2 || (Network2 = {}));
((Network22) => {
  ((SameSite2) => {
    SameSite2["Strict"] = "strict";
    SameSite2["Lax"] = "lax";
    SameSite2["None"] = "none";
    SameSite2["Default"] = "default";
  })(Network22.SameSite || (Network22.SameSite = {}));
})(Network2 || (Network2 = {}));
((Network22) => {
  ((DataType2) => {
    DataType2["Response"] = "response";
  })(Network22.DataType || (Network22.DataType = {}));
})(Network2 || (Network2 = {}));
((Network22) => {
  ((InterceptPhase2) => {
    InterceptPhase2["BeforeRequestSent"] = "beforeRequestSent";
    InterceptPhase2["ResponseStarted"] = "responseStarted";
    InterceptPhase2["AuthRequired"] = "authRequired";
  })(Network22.InterceptPhase || (Network22.InterceptPhase = {}));
})(Network2 || (Network2 = {}));
var Script;
((Script2) => {
  ((ResultOwnership2) => {
    ResultOwnership2["Root"] = "root";
    ResultOwnership2["None"] = "none";
  })(Script2.ResultOwnership || (Script2.ResultOwnership = {}));
})(Script || (Script = {}));
var Log;
((Log2) => {
  ((Level2) => {
    Level2["Debug"] = "debug";
    Level2["Info"] = "info";
    Level2["Warn"] = "warn";
    Level2["Error"] = "error";
  })(Log2.Level || (Log2.Level = {}));
})(Log || (Log = {}));
var Input;
((Input2) => {
  ((PointerType2) => {
    PointerType2["Mouse"] = "mouse";
    PointerType2["Pen"] = "pen";
    PointerType2["Touch"] = "touch";
  })(Input2.PointerType || (Input2.PointerType = {}));
})(Input || (Input = {}));

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiProtocolPermissions.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Permissions;
((Permissions2) => {
  ((PermissionState2) => {
    PermissionState2["Granted"] = "granted";
    PermissionState2["Denied"] = "denied";
    PermissionState2["Prompt"] = "prompt";
  })(Permissions2.PermissionState || (Permissions2.PermissionState = {}));
})(Permissions || (Permissions = {}));

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiNetworkManager.js
var BidiNetworkManager = class {
  static {
    __name(this, "BidiNetworkManager");
  }
  constructor(bidiSession, page) {
    this._userRequestInterceptionEnabled = false;
    this._protocolRequestInterceptionEnabled = false;
    this._session = bidiSession;
    this._requests = /* @__PURE__ */ new Map();
    this._page = page;
    this._eventListeners = [
      eventsHelper.addEventListener(bidiSession, "network.beforeRequestSent", this._onBeforeRequestSent.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.responseStarted", this._onResponseStarted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.responseCompleted", this._onResponseCompleted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.fetchError", this._onFetchError.bind(this)),
      eventsHelper.addEventListener(bidiSession, "network.authRequired", this._onAuthRequired.bind(this))
    ];
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  _onBeforeRequestSent(param) {
    if (param.request.url.startsWith("data:"))
      return;
    const redirectedFrom = param.redirectCount ? this._requests.get(param.request.request) || null : null;
    const frame = redirectedFrom ? redirectedFrom.request.frame() : param.context ? this._page.frameManager.frame(param.context) : null;
    if (!frame)
      return;
    if (redirectedFrom)
      this._requests.delete(redirectedFrom._id);
    let route;
    if (param.intercepts) {
      if (redirectedFrom) {
        let params = {};
        if (redirectedFrom._originalRequestRoute?._alreadyContinuedHeaders)
          params = toBidiRequestHeaders(redirectedFrom._originalRequestRoute._alreadyContinuedHeaders ?? []);
        this._session.sendMayFail("network.continueRequest", {
          request: param.request.request,
          ...params
        });
      } else {
        route = new BidiRouteImpl(this._session, param.request.request);
      }
    }
    const request2 = new BidiRequest(frame, redirectedFrom, param, route);
    this._requests.set(request2._id, request2);
    this._page.frameManager.requestStarted(request2.request, route);
  }
  _onResponseStarted(params) {
    const request2 = this._requests.get(params.request.request);
    if (!request2)
      return;
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      throw new Error(`Response body is not available for requests in Bidi`);
    }, "getResponseBody");
    const timings = params.request.timings;
    const startTime = timings.requestTime;
    function relativeToStart(time3) {
      if (!time3)
        return -1;
      return time3 - startTime;
    }
    __name(relativeToStart, "relativeToStart");
    const timing = {
      startTime,
      requestStart: relativeToStart(timings.requestStart),
      responseStart: relativeToStart(timings.responseStart),
      domainLookupStart: relativeToStart(timings.dnsStart),
      domainLookupEnd: relativeToStart(timings.dnsEnd),
      connectStart: relativeToStart(timings.connectStart),
      secureConnectionStart: relativeToStart(timings.tlsStart),
      connectEnd: relativeToStart(timings.connectEnd)
    };
    const response = new Response2(request2.request, params.response.status, params.response.statusText, fromBidiHeaders(params.response.headers), timing, getResponseBody, false);
    response._serverAddrFinished();
    response._securityDetailsFinished();
    response.setRawResponseHeaders(null);
    response.setResponseHeadersSize(params.response.headersSize);
    this._page.frameManager.requestReceivedResponse(response);
  }
  _onResponseCompleted(params) {
    const request2 = this._requests.get(params.request.request);
    if (!request2)
      return;
    const response = request2.request._existingResponse();
    response.setTransferSize(params.response.bodySize);
    response.setEncodedBodySize(params.response.bodySize);
    const isRedirected = response.status() >= 300 && response.status() <= 399;
    const responseEndTime = params.request.timings.responseEnd - response.timing().startTime;
    if (isRedirected) {
      response._requestFinished(responseEndTime);
    } else {
      this._requests.delete(request2._id);
      response._requestFinished(responseEndTime);
    }
    response._setHttpVersion(params.response.protocol);
    this._page.frameManager.reportRequestFinished(request2.request, response);
  }
  _onFetchError(params) {
    const request2 = this._requests.get(params.request.request);
    if (!request2)
      return;
    this._requests.delete(request2._id);
    const response = request2.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(-1);
    }
    request2.request._setFailureText(params.errorText);
    this._page.frameManager.requestFailed(request2.request, params.errorText === "NS_BINDING_ABORTED");
  }
  _onAuthRequired(params) {
    const isBasic = params.response.authChallenges?.some((challenge) => challenge.scheme.startsWith("Basic"));
    const credentials = this._page.browserContext._options.httpCredentials;
    if (isBasic && credentials) {
      this._session.sendMayFail("network.continueWithAuth", {
        request: params.request.request,
        action: "provideCredentials",
        credentials: {
          type: "password",
          username: credentials.username,
          password: credentials.password
        }
      });
    } else {
      this._session.sendMayFail("network.continueWithAuth", {
        request: params.request.request,
        action: "default"
      });
    }
  }
  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value;
    await this._updateProtocolRequestInterception();
  }
  async setCredentials(credentials) {
    this._credentials = credentials;
    await this._updateProtocolRequestInterception();
  }
  async _updateProtocolRequestInterception(initial) {
    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
    if (enabled === this._protocolRequestInterceptionEnabled)
      return;
    this._protocolRequestInterceptionEnabled = enabled;
    if (initial && !enabled)
      return;
    const cachePromise = this._session.send("network.setCacheBehavior", { cacheBehavior: enabled ? "bypass" : "default" });
    let interceptPromise = Promise.resolve(void 0);
    if (enabled) {
      interceptPromise = this._session.send("network.addIntercept", {
        phases: [Network2.InterceptPhase.AuthRequired, Network2.InterceptPhase.BeforeRequestSent],
        urlPatterns: [{ type: "pattern" }]
        // urlPatterns: [{ type: 'string', pattern: '*' }],
      }).then((r) => {
        this._intercepId = r.intercept;
      });
    } else if (this._intercepId) {
      interceptPromise = this._session.send("network.removeIntercept", { intercept: this._intercepId });
      this._intercepId = void 0;
    }
    await Promise.all([cachePromise, interceptPromise]);
  }
};
var BidiRequest = class {
  static {
    __name(this, "BidiRequest");
  }
  constructor(frame, redirectedFrom, payload, route) {
    this._id = payload.request.request;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    const postDataBuffer = null;
    this.request = new Request(
      frame._page.browserContext,
      frame,
      null,
      redirectedFrom ? redirectedFrom.request : null,
      payload.navigation ?? void 0,
      payload.request.url,
      "other",
      payload.request.method,
      postDataBuffer,
      fromBidiHeaders(payload.request.headers)
    );
    this.request.setRawRequestHeaders(null);
    this.request._setBodySize(payload.request.bodySize || 0);
    this._originalRequestRoute = route ?? redirectedFrom?._originalRequestRoute;
    route?._setRequest(this.request);
  }
  _finalRequest() {
    let request2 = this;
    while (request2._redirectedTo)
      request2 = request2._redirectedTo;
    return request2;
  }
};
var BidiRouteImpl = class {
  static {
    __name(this, "BidiRouteImpl");
  }
  constructor(session2, requestId) {
    this._session = session2;
    this._requestId = requestId;
  }
  _setRequest(request2) {
    this._request = request2;
  }
  async continue(overrides) {
    let headers = overrides.headers || this._request.headers();
    if (overrides.postData && headers) {
      headers = headers.map((header) => {
        if (header.name.toLowerCase() === "content-length")
          return { name: header.name, value: overrides.postData.byteLength.toString() };
        return header;
      });
    }
    this._alreadyContinuedHeaders = headers;
    await this._session.sendMayFail("network.continueRequest", {
      request: this._requestId,
      url: overrides.url,
      method: overrides.method,
      ...toBidiRequestHeaders(this._alreadyContinuedHeaders),
      body: overrides.postData ? { type: "base64", value: Buffer.from(overrides.postData).toString("base64") } : void 0
    });
  }
  async fulfill(response) {
    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    await this._session.sendMayFail("network.provideResponse", {
      request: this._requestId,
      statusCode: response.status,
      reasonPhrase: statusText(response.status),
      ...toBidiResponseHeaders(response.headers),
      body: { type: "base64", value: base64body }
    });
  }
  async abort(errorCode) {
    await this._session.sendMayFail("network.failRequest", {
      request: this._requestId
    });
  }
};
function fromBidiHeaders(bidiHeaders) {
  const result = [];
  for (const { name, value } of bidiHeaders)
    result.push({ name, value: bidiBytesValueToString(value) });
  return result;
}
__name(fromBidiHeaders, "fromBidiHeaders");
function toBidiRequestHeaders(allHeaders) {
  const bidiHeaders = toBidiHeaders(allHeaders);
  return { headers: bidiHeaders };
}
__name(toBidiRequestHeaders, "toBidiRequestHeaders");
function toBidiResponseHeaders(headers) {
  const setCookieHeaders = headers.filter((h) => h.name.toLowerCase() === "set-cookie");
  const otherHeaders = headers.filter((h) => h.name.toLowerCase() !== "set-cookie");
  const rawCookies = setCookieHeaders.map((h) => parseRawCookie(h.value));
  const cookies = rawCookies.filter(Boolean).map((c) => {
    return {
      ...c,
      value: { type: "string", value: c.value },
      sameSite: toBidiSameSite(c.sameSite)
    };
  });
  return { cookies, headers: toBidiHeaders(otherHeaders) };
}
__name(toBidiResponseHeaders, "toBidiResponseHeaders");
function toBidiHeaders(headers) {
  return headers.map(({ name, value }) => ({ name, value: { type: "string", value } }));
}
__name(toBidiHeaders, "toBidiHeaders");
function bidiBytesValueToString(value) {
  if (value.type === "string")
    return value.value;
  if (value.type === "base64")
    return Buffer.from(value.type, "base64").toString("binary");
  return "unknown value type: " + value.type;
}
__name(bidiBytesValueToString, "bidiBytesValueToString");
function toBidiSameSite(sameSite) {
  if (!sameSite)
    return void 0;
  if (sameSite === "Strict")
    return Network2.SameSite.Strict;
  if (sameSite === "Lax")
    return Network2.SameSite.Lax;
  return Network2.SameSite.None;
}
__name(toBidiSameSite, "toBidiSameSite");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiPage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiExecutionContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiDeserializer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BidiDeserializer = class _BidiDeserializer {
  static {
    __name(this, "BidiDeserializer");
  }
  static deserialize(result) {
    if (!result)
      return void 0;
    switch (result.type) {
      case "array":
        return result.value?.map((value) => {
          return _BidiDeserializer.deserialize(value);
        });
      case "set":
        return result.value?.reduce((acc, value) => {
          return acc.add(_BidiDeserializer.deserialize(value));
        }, /* @__PURE__ */ new Set());
      case "object":
        return result.value?.reduce((acc, tuple) => {
          const { key, value } = _BidiDeserializer._deserializeTuple(tuple);
          acc[key] = value;
          return acc;
        }, {});
      case "map":
        return result.value?.reduce((acc, tuple) => {
          const { key, value } = _BidiDeserializer._deserializeTuple(tuple);
          return acc.set(key, value);
        }, /* @__PURE__ */ new Map());
      case "promise":
        return {};
      case "regexp":
        return new RegExp(result.value.pattern, result.value.flags);
      case "date":
        return new Date(result.value);
      case "undefined":
        return void 0;
      case "null":
        return null;
      case "number":
        return _BidiDeserializer._deserializeNumber(result.value);
      case "bigint":
        return BigInt(result.value);
      case "boolean":
        return Boolean(result.value);
      case "string":
        return result.value;
    }
    throw new Error(`Deserialization of type ${result.type} not supported.`);
  }
  static _deserializeNumber(value) {
    switch (value) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        return value;
    }
  }
  static _deserializeTuple([serializedKey, serializedValue]) {
    const key = typeof serializedKey === "string" ? serializedKey : _BidiDeserializer.deserialize(serializedKey);
    const value = _BidiDeserializer.deserialize(serializedValue);
    return { key, value };
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiSerializer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UnserializableError = class extends Error {
  static {
    __name(this, "UnserializableError");
  }
};
var BidiSerializer = class _BidiSerializer {
  static {
    __name(this, "BidiSerializer");
  }
  static serialize(arg) {
    switch (typeof arg) {
      case "symbol":
      case "function":
        throw new UnserializableError(`Unable to serializable ${typeof arg}`);
      case "object":
        return _BidiSerializer._serializeObject(arg);
      case "undefined":
        return {
          type: "undefined"
        };
      case "number":
        return _BidiSerializer._serializeNumber(arg);
      case "bigint":
        return {
          type: "bigint",
          value: arg.toString()
        };
      case "string":
        return {
          type: "string",
          value: arg
        };
      case "boolean":
        return {
          type: "boolean",
          value: arg
        };
    }
  }
  static _serializeNumber(arg) {
    let value;
    if (Object.is(arg, -0)) {
      value = "-0";
    } else if (Object.is(arg, Infinity)) {
      value = "Infinity";
    } else if (Object.is(arg, -Infinity)) {
      value = "-Infinity";
    } else if (Object.is(arg, NaN)) {
      value = "NaN";
    } else {
      value = arg;
    }
    return {
      type: "number",
      value
    };
  }
  static _serializeObject(arg) {
    if (arg === null) {
      return {
        type: "null"
      };
    } else if (Array.isArray(arg)) {
      const parsedArray = arg.map((subArg) => {
        return _BidiSerializer.serialize(subArg);
      });
      return {
        type: "array",
        value: parsedArray
      };
    } else if (isPlainObject(arg)) {
      try {
        JSON.stringify(arg);
      } catch (error3) {
        if (error3 instanceof TypeError && error3.message.startsWith("Converting circular structure to JSON")) {
          error3.message += " Recursive objects are not allowed.";
        }
        throw error3;
      }
      const parsedObject = [];
      for (const key in arg) {
        parsedObject.push([_BidiSerializer.serialize(key), _BidiSerializer.serialize(arg[key])]);
      }
      return {
        type: "object",
        value: parsedObject
      };
    } else if (isRegExp6(arg)) {
      return {
        type: "regexp",
        value: {
          pattern: arg.source,
          flags: arg.flags
        }
      };
    } else if (isDate3(arg)) {
      return {
        type: "date",
        value: arg.toISOString()
      };
    }
    throw new UnserializableError(
      "Custom object serialization not possible. Use plain objects instead."
    );
  }
};
var isPlainObject = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === Object;
}, "isPlainObject");
var isRegExp6 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === RegExp;
}, "isRegExp");
var isDate3 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj?.constructor === Date;
}, "isDate");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiExecutionContext.js
var BidiExecutionContext = class {
  static {
    __name(this, "BidiExecutionContext");
  }
  constructor(session2, realmInfo) {
    this._session = session2;
    if (realmInfo.type === "window") {
      this._target = {
        context: realmInfo.context,
        sandbox: realmInfo.sandbox
      };
    } else {
      this._target = {
        realm: realmInfo.realm
      };
    }
  }
  async rawEvaluateJSON(expression) {
    const response = await this._session.send("script.evaluate", {
      expression,
      target: this._target,
      serializationOptions: {
        maxObjectDepth: 10,
        maxDomDepth: 10
      },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "success")
      return BidiDeserializer.deserialize(response.result);
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async rawEvaluateHandle(context2, expression) {
    const response = await this._session.send("script.evaluate", {
      expression,
      target: this._target,
      resultOwnership: Script.ResultOwnership.Root,
      // Necessary for the handle to be returned.
      serializationOptions: { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "success") {
      if ("handle" in response.result)
        return createHandle2(context2, response.result);
      throw new JavaScriptErrorInEvaluate("Cannot get handle: " + JSON.stringify(response.result));
    }
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async evaluateWithArguments(functionDeclaration, returnByValue, utilityScript, values, handles) {
    const response = await this._session.send("script.callFunction", {
      functionDeclaration,
      target: this._target,
      arguments: [
        { handle: utilityScript._objectId },
        ...values.map(BidiSerializer.serialize),
        ...handles.map((handle) => ({ handle: handle._objectId }))
      ],
      resultOwnership: returnByValue ? void 0 : Script.ResultOwnership.Root,
      // Necessary for the handle to be returned.
      serializationOptions: returnByValue ? {} : { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    if (response.type === "success") {
      if (returnByValue)
        return parseEvaluationResultValue(BidiDeserializer.deserialize(response.result));
      return createHandle2(utilityScript._context, response.result);
    }
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
  async getProperties(handle) {
    const names = await handle.evaluate((object) => {
      const names2 = [];
      const descriptors = Object.getOwnPropertyDescriptors(object);
      for (const name in descriptors) {
        if (descriptors[name]?.enumerable)
          names2.push(name);
      }
      return names2;
    });
    const values = await Promise.all(names.map((name) => handle.evaluateHandle((object, name2) => object[name2], name)));
    const map2 = /* @__PURE__ */ new Map();
    for (let i = 0; i < names.length; i++)
      map2.set(names[i], values[i]);
    return map2;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("script.disown", {
      target: this._target,
      handles: [handle._objectId]
    });
  }
  async nodeIdForElementHandle(handle) {
    const shared = await this._remoteValueForReference({ handle: handle._objectId });
    if (!("sharedId" in shared))
      throw new Error("Element is not a node");
    return {
      sharedId: shared.sharedId
    };
  }
  async remoteObjectForNodeId(context2, nodeId) {
    const result = await this._remoteValueForReference(nodeId, true);
    if (!("handle" in result))
      throw new Error("Can't get remote object for nodeId");
    return createHandle2(context2, result);
  }
  async contentFrameIdForFrame(handle) {
    const contentWindow = await this._rawCallFunction("e => e.contentWindow", { handle: handle._objectId });
    if (contentWindow?.type === "window")
      return contentWindow.value.context;
    return null;
  }
  async frameIdForWindowHandle(handle) {
    if (!handle._objectId)
      throw new Error("JSHandle is not a DOM node handle");
    const contentWindow = await this._remoteValueForReference({ handle: handle._objectId });
    if (contentWindow.type === "window")
      return contentWindow.value.context;
    return null;
  }
  async _remoteValueForReference(reference, createHandle22) {
    return await this._rawCallFunction("e => e", reference, createHandle22);
  }
  async _rawCallFunction(functionDeclaration, arg, createHandle22) {
    const response = await this._session.send("script.callFunction", {
      functionDeclaration,
      target: this._target,
      arguments: [arg],
      // "Root" is necessary for the handle to be returned.
      resultOwnership: createHandle22 ? Script.ResultOwnership.Root : Script.ResultOwnership.None,
      serializationOptions: { maxObjectDepth: 0, maxDomDepth: 0 },
      awaitPromise: true,
      userActivation: true
    });
    if (response.type === "exception")
      throw new JavaScriptErrorInEvaluate(response.exceptionDetails.text + "\nFull val: " + JSON.stringify(response.exceptionDetails));
    if (response.type === "success")
      return response.result;
    throw new JavaScriptErrorInEvaluate("Unexpected response type: " + JSON.stringify(response));
  }
};
function renderPreview2(remoteObject) {
  if (remoteObject.type === "undefined")
    return "undefined";
  if (remoteObject.type === "null")
    return "null";
  if ("value" in remoteObject)
    return String(remoteObject.value);
  return `<${remoteObject.type}>`;
}
__name(renderPreview2, "renderPreview");
function remoteObjectValue(remoteObject) {
  if (remoteObject.type === "undefined")
    return void 0;
  if (remoteObject.type === "null")
    return null;
  if (remoteObject.type === "number" && typeof remoteObject.value === "string")
    return parseUnserializableValue(remoteObject.value);
  if ("value" in remoteObject)
    return remoteObject.value;
  return void 0;
}
__name(remoteObjectValue, "remoteObjectValue");
function createHandle2(context2, remoteObject) {
  if (remoteObject.type === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.handle);
  }
  const objectId = "handle" in remoteObject ? remoteObject.handle : void 0;
  return new JSHandle(context2, remoteObject.type, renderPreview2(remoteObject), objectId, remoteObjectValue(remoteObject));
}
__name(createHandle2, "createHandle");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiInput.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiKeyboard.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getBidiKeyValue = /* @__PURE__ */ __name((keyName) => {
  switch (keyName) {
    case "\r":
    case "\n":
      keyName = "Enter";
      break;
  }
  if ([...keyName].length === 1) {
    return keyName;
  }
  switch (keyName) {
    case "Cancel":
      return "\uE001";
    case "Help":
      return "\uE002";
    case "Backspace":
      return "\uE003";
    case "Tab":
      return "\uE004";
    case "Clear":
      return "\uE005";
    case "Enter":
      return "\uE007";
    case "Shift":
    case "ShiftLeft":
      return "\uE008";
    case "Control":
    case "ControlLeft":
      return "\uE009";
    case "Alt":
    case "AltLeft":
      return "\uE00A";
    case "Pause":
      return "\uE00B";
    case "Escape":
      return "\uE00C";
    case "PageUp":
      return "\uE00E";
    case "PageDown":
      return "\uE00F";
    case "End":
      return "\uE010";
    case "Home":
      return "\uE011";
    case "ArrowLeft":
      return "\uE012";
    case "ArrowUp":
      return "\uE013";
    case "ArrowRight":
      return "\uE014";
    case "ArrowDown":
      return "\uE015";
    case "Insert":
      return "\uE016";
    case "Delete":
      return "\uE017";
    case "NumpadEqual":
      return "\uE019";
    case "Numpad0":
      return "\uE01A";
    case "Numpad1":
      return "\uE01B";
    case "Numpad2":
      return "\uE01C";
    case "Numpad3":
      return "\uE01D";
    case "Numpad4":
      return "\uE01E";
    case "Numpad5":
      return "\uE01F";
    case "Numpad6":
      return "\uE020";
    case "Numpad7":
      return "\uE021";
    case "Numpad8":
      return "\uE022";
    case "Numpad9":
      return "\uE023";
    case "NumpadMultiply":
      return "\uE024";
    case "NumpadAdd":
      return "\uE025";
    case "NumpadSubtract":
      return "\uE027";
    case "NumpadDecimal":
      return "\uE028";
    case "NumpadDivide":
      return "\uE029";
    case "F1":
      return "\uE031";
    case "F2":
      return "\uE032";
    case "F3":
      return "\uE033";
    case "F4":
      return "\uE034";
    case "F5":
      return "\uE035";
    case "F6":
      return "\uE036";
    case "F7":
      return "\uE037";
    case "F8":
      return "\uE038";
    case "F9":
      return "\uE039";
    case "F10":
      return "\uE03A";
    case "F11":
      return "\uE03B";
    case "F12":
      return "\uE03C";
    case "Meta":
    case "MetaLeft":
      return "\uE03D";
    case "ShiftRight":
      return "\uE050";
    case "ControlRight":
      return "\uE051";
    case "AltRight":
      return "\uE052";
    case "MetaRight":
      return "\uE053";
    case "Space":
      return " ";
    case "Digit0":
      return "0";
    case "Digit1":
      return "1";
    case "Digit2":
      return "2";
    case "Digit3":
      return "3";
    case "Digit4":
      return "4";
    case "Digit5":
      return "5";
    case "Digit6":
      return "6";
    case "Digit7":
      return "7";
    case "Digit8":
      return "8";
    case "Digit9":
      return "9";
    case "KeyA":
      return "a";
    case "KeyB":
      return "b";
    case "KeyC":
      return "c";
    case "KeyD":
      return "d";
    case "KeyE":
      return "e";
    case "KeyF":
      return "f";
    case "KeyG":
      return "g";
    case "KeyH":
      return "h";
    case "KeyI":
      return "i";
    case "KeyJ":
      return "j";
    case "KeyK":
      return "k";
    case "KeyL":
      return "l";
    case "KeyM":
      return "m";
    case "KeyN":
      return "n";
    case "KeyO":
      return "o";
    case "KeyP":
      return "p";
    case "KeyQ":
      return "q";
    case "KeyR":
      return "r";
    case "KeyS":
      return "s";
    case "KeyT":
      return "t";
    case "KeyU":
      return "u";
    case "KeyV":
      return "v";
    case "KeyW":
      return "w";
    case "KeyX":
      return "x";
    case "KeyY":
      return "y";
    case "KeyZ":
      return "z";
    case "Semicolon":
      return ";";
    case "Equal":
      return "=";
    case "Comma":
      return ",";
    case "Minus":
      return "-";
    case "Period":
      return ".";
    case "Slash":
      return "/";
    case "Backquote":
      return "`";
    case "BracketLeft":
      return "[";
    case "Backslash":
      return "\\";
    case "BracketRight":
      return "]";
    case "Quote":
      return '"';
    default:
      throw new Error(`Unknown key: "${keyName}"`);
  }
}, "getBidiKeyValue");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiInput.js
var RawKeyboardImpl2 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async keydown(progress3, modifiers, keyName, description, autoRepeat) {
    keyName = resolveSmartModifierString(keyName);
    const actions = [];
    actions.push({ type: "keyDown", value: getBidiKeyValue(keyName) });
    await this._performActions(progress3, actions);
  }
  async keyup(progress3, modifiers, keyName, description) {
    keyName = resolveSmartModifierString(keyName);
    const actions = [];
    actions.push({ type: "keyUp", value: getBidiKeyValue(keyName) });
    await this._performActions(progress3, actions);
  }
  async sendText(progress3, text) {
    const actions = [];
    for (const char of text) {
      const value = getBidiKeyValue(char);
      actions.push({ type: "keyDown", value });
      actions.push({ type: "keyUp", value });
    }
    await this._performActions(progress3, actions);
  }
  async _performActions(progress3, actions) {
    await progress3.race(this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "key",
          id: "pw_keyboard",
          actions
        }
      ]
    }));
  }
};
var RawMouseImpl2 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  async move(progress3, x, y, button, buttons, modifiers, forClick) {
    await this._performActions(progress3, [{ type: "pointerMove", x, y }]);
  }
  async down(progress3, x, y, button, buttons, modifiers, clickCount) {
    await this._performActions(progress3, [{ type: "pointerDown", button: toBidiButton(button) }]);
  }
  async up(progress3, x, y, button, buttons, modifiers, clickCount) {
    await this._performActions(progress3, [{ type: "pointerUp", button: toBidiButton(button) }]);
  }
  async wheel(progress3, x, y, buttons, modifiers, deltaX, deltaY) {
    x = Math.floor(x);
    y = Math.floor(y);
    await progress3.race(this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "wheel",
          id: "pw_mouse_wheel",
          actions: [{ type: "scroll", x, y, deltaX, deltaY }]
        }
      ]
    }));
  }
  async _performActions(progress3, actions) {
    await progress3.race(this._session.send("input.performActions", {
      context: this._session.sessionId,
      actions: [
        {
          type: "pointer",
          id: "pw_mouse",
          parameters: {
            pointerType: Input.PointerType.Mouse
          },
          actions
        }
      ]
    }));
  }
};
var RawTouchscreenImpl2 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(session2) {
    this._session = session2;
  }
  async tap(progress3, x, y, modifiers) {
  }
};
function toBidiButton(button) {
  switch (button) {
    case "left":
      return 0;
    case "right":
      return 2;
    case "middle":
      return 1;
  }
  throw new Error("Unknown button: " + button);
}
__name(toBidiButton, "toBidiButton");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiPdf.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var PagePaperFormats2 = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};
var unitToPixels2 = {
  "px": 1,
  "in": 96,
  "cm": 37.8,
  "mm": 3.78
};
function convertPrintParameterToInches2(text) {
  if (text === void 0)
    return void 0;
  let unit = text.substring(text.length - 2).toLowerCase();
  let valueText = "";
  if (unitToPixels2.hasOwnProperty(unit)) {
    valueText = text.substring(0, text.length - 2);
  } else {
    unit = "px";
    valueText = text;
  }
  const value = Number(valueText);
  assert3(!isNaN(value), "Failed to parse parameter value: " + text);
  const pixels = value * unitToPixels2[unit];
  return pixels / 96;
}
__name(convertPrintParameterToInches2, "convertPrintParameterToInches");
var BidiPDF = class {
  static {
    __name(this, "BidiPDF");
  }
  constructor(session2) {
    this._session = session2;
  }
  async generate(options2) {
    const {
      scale = 1,
      printBackground = false,
      landscape = false,
      pageRanges = "",
      margin = {}
    } = options2;
    let paperWidth = 8.5;
    let paperHeight = 11;
    if (options2.format) {
      const format2 = PagePaperFormats2[options2.format.toLowerCase()];
      assert3(format2, "Unknown paper format: " + options2.format);
      paperWidth = format2.width;
      paperHeight = format2.height;
    } else {
      paperWidth = convertPrintParameterToInches2(options2.width) || paperWidth;
      paperHeight = convertPrintParameterToInches2(options2.height) || paperHeight;
    }
    const { data } = await this._session.send("browsingContext.print", {
      context: this._session.sessionId,
      background: printBackground,
      margin: {
        bottom: convertPrintParameterToInches2(margin.bottom) || 0,
        left: convertPrintParameterToInches2(margin.left) || 0,
        right: convertPrintParameterToInches2(margin.right) || 0,
        top: convertPrintParameterToInches2(margin.top) || 0
      },
      orientation: landscape ? "landscape" : "portrait",
      page: {
        width: paperWidth,
        height: paperHeight
      },
      pageRanges: pageRanges ? pageRanges.split(",").map((r) => r.trim()) : void 0,
      scale
    });
    return Buffer.from(data, "base64");
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiPage.js
var UTILITY_WORLD_NAME = "__playwright_utility_world__";
var kPlaywrightBindingChannel = "playwrightChannel";
var BidiPage = class {
  static {
    __name(this, "BidiPage");
  }
  constructor(browserContext, bidiSession, opener) {
    this._sessionListeners = [];
    this._initScriptIds = /* @__PURE__ */ new Map();
    this._session = bidiSession;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl2(bidiSession);
    this.rawMouse = new RawMouseImpl2(bidiSession);
    this.rawTouchscreen = new RawTouchscreenImpl2(bidiSession);
    this._realmToContext = /* @__PURE__ */ new Map();
    this._page = new Page(this, browserContext);
    this._browserContext = browserContext;
    this._networkManager = new BidiNetworkManager(this._session, this._page);
    this._pdf = new BidiPDF(this._session);
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
    this._sessionListeners = [
      eventsHelper.addEventListener(bidiSession, "script.realmCreated", this._onRealmCreated.bind(this)),
      eventsHelper.addEventListener(bidiSession, "script.message", this._onScriptMessage.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.contextDestroyed", this._onBrowsingContextDestroyed.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationStarted", this._onNavigationStarted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationCommitted", this._onNavigationCommitted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationAborted", this._onNavigationAborted.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.navigationFailed", this._onNavigationFailed.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.fragmentNavigated", this._onFragmentNavigated.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.historyUpdated", this._onHistoryUpdated.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.domContentLoaded", this._onDomContentLoaded.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.load", this._onLoad.bind(this)),
      eventsHelper.addEventListener(bidiSession, "browsingContext.userPromptOpened", this._onUserPromptOpened.bind(this)),
      eventsHelper.addEventListener(bidiSession, "log.entryAdded", this._onLogEntryAdded.bind(this))
    ];
    this._initialize().then(
      () => this._page.reportAsNew(this._opener?._page),
      (error3) => this._page.reportAsNew(this._opener?._page, error3)
    );
  }
  async _initialize() {
    this._onFrameAttached(this._session.sessionId, null);
    await Promise.all([
      this.updateHttpCredentials(),
      this.updateRequestInterception()
      // If the page is created by the Playwright client's call, some initialization
      // may be pending. Wait for it to complete before reporting the page as new.
    ]);
  }
  didClose() {
    this._session.dispose();
    eventsHelper.removeEventListeners(this._sessionListeners);
    this._page._didClose();
  }
  _onFrameAttached(frameId, parentFrameId) {
    return this._page.frameManager.frameAttached(frameId, parentFrameId);
  }
  _removeContextsForFrame(frame, notifyFrame) {
    for (const [contextId, context2] of this._realmToContext) {
      if (context2.frame === frame) {
        this._realmToContext.delete(contextId);
        if (notifyFrame)
          frame._contextDestroyed(context2);
      }
    }
  }
  _onRealmCreated(realmInfo) {
    if (this._realmToContext.has(realmInfo.realm))
      return;
    if (realmInfo.type !== "window")
      return;
    const frame = this._page.frameManager.frame(realmInfo.context);
    if (!frame)
      return;
    let worldName;
    if (!realmInfo.sandbox) {
      worldName = "main";
      this._touchUtilityWorld(realmInfo.context);
    } else if (realmInfo.sandbox === UTILITY_WORLD_NAME) {
      worldName = "utility";
    } else {
      return;
    }
    const delegate = new BidiExecutionContext(this._session, realmInfo);
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    frame._contextCreated(worldName, context2);
    this._realmToContext.set(realmInfo.realm, context2);
  }
  async _touchUtilityWorld(context2) {
    await this._session.sendMayFail("script.evaluate", {
      expression: "1 + 1",
      target: {
        context: context2,
        sandbox: UTILITY_WORLD_NAME
      },
      serializationOptions: {
        maxObjectDepth: 10,
        maxDomDepth: 10
      },
      awaitPromise: true,
      userActivation: true
    });
  }
  _onRealmDestroyed(params) {
    const context2 = this._realmToContext.get(params.realm);
    if (!context2)
      return false;
    this._realmToContext.delete(params.realm);
    context2.frame._contextDestroyed(context2);
    return true;
  }
  // TODO: route the message directly to the browser
  _onBrowsingContextDestroyed(params) {
    this._browserContext._browser._onBrowsingContextDestroyed(params);
  }
  _onNavigationStarted(params) {
    const frameId = params.context;
    this._page.frameManager.frameRequestedNavigation(frameId, params.navigation);
  }
  _onNavigationCommitted(params) {
    const frameId = params.context;
    this._page.frameManager.frameCommittedNewDocumentNavigation(
      frameId,
      params.url,
      "",
      params.navigation,
      /* initial */
      false
    );
  }
  _onDomContentLoaded(params) {
    const frameId = params.context;
    this._page.frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
  }
  _onLoad(params) {
    this._page.frameManager.frameLifecycleEvent(params.context, "load");
  }
  _onNavigationAborted(params) {
    this._page.frameManager.frameAbortedNavigation(params.context, "Navigation aborted", params.navigation || void 0);
  }
  _onNavigationFailed(params) {
    this._page.frameManager.frameAbortedNavigation(params.context, "Navigation failed", params.navigation || void 0);
  }
  _onFragmentNavigated(params) {
    this._page.frameManager.frameCommittedSameDocumentNavigation(params.context, params.url);
  }
  _onHistoryUpdated(params) {
    this._page.frameManager.frameCommittedSameDocumentNavigation(params.context, params.url);
  }
  _onUserPromptOpened(event) {
    this._page.browserContext.dialogManager.dialogDidOpen(new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, userText) => {
        await this._session.send("browsingContext.handleUserPrompt", { context: event.context, accept, userText });
      },
      event.defaultValue
    ));
  }
  _onLogEntryAdded(params) {
    if (params.type !== "console")
      return;
    const entry = params;
    const context2 = this._realmToContext.get(params.source.realm);
    if (!context2)
      return;
    const callFrame = params.stackTrace?.callFrames[0];
    const location2 = callFrame ?? { url: "", lineNumber: 1, columnNumber: 1 };
    this._page.addConsoleMessage(entry.method, entry.args.map((arg) => createHandle2(context2, arg)), location2, params.text || void 0);
  }
  async navigateFrame(frame, url4, referrer) {
    const { navigation } = await this._session.send("browsingContext.navigate", {
      context: frame._id,
      url: url4
    });
    return { newDocumentId: navigation || void 0 };
  }
  async updateExtraHTTPHeaders() {
  }
  async updateEmulateMedia() {
  }
  async updateUserAgent() {
  }
  async bringToFront() {
    await this._session.send("browsingContext.activate", {
      context: this._session.sessionId
    });
  }
  async updateEmulatedViewportSize() {
    const options2 = this._browserContext._options;
    const emulatedSize = this._page.emulatedSize();
    if (!emulatedSize)
      return;
    const viewportSize = emulatedSize.viewport;
    await this._session.send("browsingContext.setViewport", {
      context: this._session.sessionId,
      viewport: {
        width: viewportSize.width,
        height: viewportSize.height
      },
      devicePixelRatio: options2.deviceScaleFactor || 1
    });
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateOffline() {
  }
  async updateHttpCredentials() {
    await this._networkManager.setCredentials(this._browserContext._options.httpCredentials);
  }
  async updateFileChooserInterception() {
  }
  async reload() {
    await this._session.send("browsingContext.reload", {
      context: this._session.sessionId,
      // ignoreCache: true,
      wait: BrowsingContext.ReadinessState.Interactive
    });
  }
  async goBack() {
    return await this._session.send("browsingContext.traverseHistory", {
      context: this._session.sessionId,
      delta: -1
    }).then(() => true).catch(() => false);
  }
  async goForward() {
    return await this._session.send("browsingContext.traverseHistory", {
      context: this._session.sessionId,
      delta: 1
    }).then(() => true).catch(() => false);
  }
  async requestGC() {
    throw new Error("Method not implemented.");
  }
  async _onScriptMessage(event) {
    if (event.channel !== kPlaywrightBindingChannel)
      return;
    const pageOrError = await this._page.waitForInitializedOrError();
    if (pageOrError instanceof Error)
      return;
    const context2 = this._realmToContext.get(event.source.realm);
    if (!context2)
      return;
    if (event.data.type !== "string")
      return;
    await this._page.onBindingCalled(event.data.value, context2);
  }
  async addInitScript(initScript) {
    const { script } = await this._session.send("script.addPreloadScript", {
      // TODO: remove function call from the source.
      functionDeclaration: `() => { return ${initScript.source} }`,
      // TODO: push to iframes?
      contexts: [this._session.sessionId]
    });
    this._initScriptIds.set(initScript, script);
  }
  async removeInitScripts(initScripts) {
    const ids = [];
    for (const script of initScripts) {
      const id = this._initScriptIds.get(script);
      if (id)
        ids.push(id);
      this._initScriptIds.delete(script);
    }
    await Promise.all(ids.map((script) => this._session.send("script.removePreloadScript", { script })));
  }
  async closePage(runBeforeUnload) {
    await this._session.send("browsingContext.close", {
      context: this._session.sessionId,
      promptUnload: runBeforeUnload
    });
  }
  async setBackgroundColor(color) {
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const rect = documentRect || viewportRect;
    const { data } = await progress3.race(this._session.send("browsingContext.captureScreenshot", {
      context: this._session.sessionId,
      format: {
        type: `image/${format2 === "png" ? "png" : "jpeg"}`,
        quality: quality ? quality / 100 : 0.8
      },
      origin: documentRect ? "document" : "viewport",
      clip: {
        type: "box",
        ...rect
      }
    }));
    return Buffer.from(data, "base64");
  }
  async getContentFrame(handle) {
    const executionContext = toBidiExecutionContext(handle._context);
    const frameId = await executionContext.contentFrameIdForFrame(handle);
    if (!frameId)
      return null;
    return this._page.frameManager.frame(frameId);
  }
  async getOwnerFrame(handle) {
    const windowHandle = await handle.evaluateHandle((node) => {
      const doc = node.ownerDocument ?? node;
      return doc.defaultView;
    });
    if (!windowHandle)
      return null;
    const executionContext = toBidiExecutionContext(handle._context);
    return executionContext.frameIdForWindowHandle(windowHandle);
  }
  async getBoundingBox(handle) {
    const box = await handle.evaluate((element) => {
      if (!(element instanceof Element))
        return null;
      const rect = element.getBoundingClientRect();
      return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
    });
    if (!box)
      return null;
    const position = await this._framePosition(handle._frame);
    if (!position)
      return null;
    box.x += position.x;
    box.y += position.y;
    return box;
  }
  // TODO: move to Frame.
  async _framePosition(frame) {
    if (frame === this._page.mainFrame())
      return { x: 0, y: 0 };
    const element = await frame.frameElement();
    const box = await element.boundingBox();
    if (!box)
      return null;
    const style = await element.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch((e) => "error:notconnected");
    if (style === "error:notconnected" || style === "transformed")
      return null;
    box.x += style.left;
    box.y += style.top;
    return box;
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await handle.evaluateInUtility(([injected, node]) => {
      node.scrollIntoView({
        block: "center",
        inline: "center",
        behavior: "instant"
      });
    }, null).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    const quads = await handle.evaluateInUtility(([injected, node]) => {
      if (!node.isConnected)
        return "error:notconnected";
      const rects = node.getClientRects();
      if (!rects)
        return null;
      return [...rects].map((rect) => [
        { x: rect.left, y: rect.top },
        { x: rect.right, y: rect.top },
        { x: rect.right, y: rect.bottom },
        { x: rect.left, y: rect.bottom }
      ]);
    }, null);
    if (!quads || quads === "error:notconnected")
      return quads;
    const position = await this._framePosition(handle._frame);
    if (!position)
      return null;
    quads.forEach((quad) => quad.forEach((point) => {
      point.x += position.x;
      point.y += position.y;
    }));
    return quads;
  }
  async setInputFilePaths(handle, paths) {
    const fromContext = toBidiExecutionContext(handle._context);
    await this._session.send("input.setFiles", {
      context: this._session.sessionId,
      element: await fromContext.nodeIdForElementHandle(handle),
      files: paths
    });
  }
  async adoptElementHandle(handle, to) {
    const fromContext = toBidiExecutionContext(handle._context);
    const nodeId = await fromContext.nodeIdForElementHandle(handle);
    const executionContext = toBidiExecutionContext(to);
    return await executionContext.remoteObjectForNodeId(to, nodeId);
  }
  async getAccessibilityTree(needle) {
    throw new Error("Method not implemented.");
  }
  async inputActionEpilogue() {
  }
  async resetForReuse(progress3) {
  }
  async pdf(options2) {
    return this._pdf.generate(options2);
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const parentContext = await parent._mainContext();
    const list = await parentContext.evaluateHandle(() => {
      return [...document.querySelectorAll("iframe,frame")];
    });
    const length = await list.evaluate((list2) => list2.length);
    let foundElement = null;
    for (let i = 0; i < length; i++) {
      const element = await list.evaluateHandle((list2, i2) => list2[i2], i);
      const candidate = await element.contentFrame();
      if (frame === candidate) {
        foundElement = element;
        break;
      } else {
        element.dispose();
      }
    }
    list.dispose();
    if (!foundElement)
      throw new Error("Frame has been detached.");
    return foundElement;
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return true;
  }
};
function toBidiExecutionContext(executionContext) {
  return executionContext.delegate;
}
__name(toBidiExecutionContext, "toBidiExecutionContext");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiBrowser.js
var BidiBrowser = class _BidiBrowser extends Browser {
  static {
    __name(this, "BidiBrowser");
  }
  constructor(parent, transport, options2) {
    super(parent, options2);
    this._contexts = /* @__PURE__ */ new Map();
    this._bidiPages = /* @__PURE__ */ new Map();
    this._connection = new BidiConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._eventListeners = [
      eventsHelper.addEventListener(this._browserSession, "browsingContext.contextCreated", this._onBrowsingContextCreated.bind(this)),
      eventsHelper.addEventListener(this._browserSession, "script.realmDestroyed", this._onScriptRealmDestroyed.bind(this))
    ];
  }
  static async connect(parent, transport, options2) {
    const browser3 = new _BidiBrowser(parent, transport, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    browser3._bidiSessionInfo = await browser3._browserSession.send("session.new", {
      capabilities: {
        alwaysMatch: {
          acceptInsecureCerts: options2.persistent?.internalIgnoreHTTPSErrors || options2.persistent?.ignoreHTTPSErrors,
          proxy: getProxyConfiguration(options2.originalLaunchOptions.proxyOverride ?? options2.proxy),
          unhandledPromptBehavior: {
            default: Session2.UserPromptHandlerType.Ignore
          },
          webSocketUrl: true
        }
      }
    });
    await browser3._browserSession.send("session.subscribe", {
      events: [
        "browsingContext",
        "network",
        "log",
        "script"
      ]
    });
    if (options2.persistent) {
      const context2 = new BidiBrowserContext(browser3, void 0, options2.persistent);
      browser3._defaultContext = context2;
      await context2._initialize();
      const page = await browser3._defaultContext.doCreateNewPage();
      await page.waitForInitializedOrError();
    }
    return browser3;
  }
  _onDisconnect() {
    this._didClose();
  }
  async doCreateNewContext(options2) {
    const proxy = options2.proxyOverride || options2.proxy;
    const { userContext } = await this._browserSession.send("browser.createUserContext", {
      acceptInsecureCerts: options2.internalIgnoreHTTPSErrors || options2.ignoreHTTPSErrors,
      proxy: getProxyConfiguration(proxy)
    });
    const context2 = new BidiBrowserContext(this, userContext, options2);
    await context2._initialize();
    this._contexts.set(userContext, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._bidiSessionInfo.capabilities.browserVersion;
  }
  userAgent() {
    return this._bidiSessionInfo.capabilities.userAgent;
  }
  isConnected() {
    return !this._connection.isClosed();
  }
  _onBrowsingContextCreated(event) {
    if (event.parent) {
      const parentFrameId = event.parent;
      for (const page2 of this._bidiPages.values()) {
        const parentFrame = page2._page.frameManager.frame(parentFrameId);
        if (!parentFrame)
          continue;
        page2._session.addFrameBrowsingContext(event.context);
        page2._page.frameManager.frameAttached(event.context, parentFrameId);
        const frame = page2._page.frameManager.frame(event.context);
        if (frame)
          frame._url = event.url;
        return;
      }
      return;
    }
    let context2 = this._contexts.get(event.userContext);
    if (!context2)
      context2 = this._defaultContext;
    if (!context2)
      return;
    const session2 = this._connection.createMainFrameBrowsingContextSession(event.context);
    const opener = event.originalOpener && this._bidiPages.get(event.originalOpener);
    const page = new BidiPage(context2, session2, opener || null);
    page._page.mainFrame()._url = event.url;
    this._bidiPages.set(event.context, page);
  }
  _onBrowsingContextDestroyed(event) {
    if (event.parent) {
      this._browserSession.removeFrameBrowsingContext(event.context);
      const parentFrameId = event.parent;
      for (const page of this._bidiPages.values()) {
        const parentFrame = page._page.frameManager.frame(parentFrameId);
        if (!parentFrame)
          continue;
        page._page.frameManager.frameDetached(event.context);
        return;
      }
      return;
    }
    const bidiPage = this._bidiPages.get(event.context);
    if (!bidiPage)
      return;
    bidiPage.didClose();
    this._bidiPages.delete(event.context);
  }
  _onScriptRealmDestroyed(event) {
    for (const page of this._bidiPages.values()) {
      if (page._onRealmDestroyed(event))
        return;
    }
  }
};
var BidiBrowserContext = class extends BrowserContext {
  static {
    __name(this, "BidiBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._originToPermissions = /* @__PURE__ */ new Map();
    this._initScriptIds = /* @__PURE__ */ new Map();
    this._authenticateProxyViaHeader();
  }
  _bidiPages() {
    return [...this._browser._bidiPages.values()].filter((bidiPage) => bidiPage._browserContext === this);
  }
  async _initialize() {
    const promises = [
      super._initialize()
    ];
    promises.push(this.doUpdateDefaultViewport());
    if (this._options.geolocation)
      promises.push(this.setGeolocation(this._options.geolocation));
    if (this._options.locale) {
      promises.push(this._browser._browserSession.send("emulation.setLocaleOverride", {
        locale: this._options.locale,
        userContexts: [this._userContextId()]
      }));
    }
    await Promise.all(promises);
  }
  possiblyUninitializedPages() {
    return this._bidiPages().map((bidiPage) => bidiPage._page);
  }
  async doCreateNewPage() {
    const { context: context2 } = await this._browser._browserSession.send("browsingContext.create", {
      type: BrowsingContext.CreateType.Window,
      userContext: this._browserContextId
    });
    return this._browser._bidiPages.get(context2)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._browserSession.send(
      "storage.getCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
    return filterCookies(cookies.map((c) => {
      const copy = {
        name: c.name,
        value: bidiBytesValueToString(c.value),
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
        expires: c.expiry ?? -1,
        sameSite: c.sameSite ? fromBidiSameSite(c.sameSite) : "None"
      };
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    cookies = rewriteCookies(cookies);
    const promises = cookies.map((c) => {
      const cookie = {
        name: c.name,
        value: { type: "string", value: c.value },
        domain: c.domain,
        path: c.path,
        httpOnly: c.httpOnly,
        secure: c.secure,
        sameSite: c.sameSite && toBidiSameSite2(c.sameSite),
        expiry: c.expires === -1 || c.expires === void 0 ? void 0 : Math.round(c.expires)
      };
      return this._browser._browserSession.send(
        "storage.setCookie",
        { cookie, partition: { type: "storageKey", userContext: this._browserContextId } }
      );
    });
    await Promise.all(promises);
  }
  async doClearCookies() {
    await this._browser._browserSession.send(
      "storage.deleteCookies",
      { partition: { type: "storageKey", userContext: this._browserContextId } }
    );
  }
  async doGrantPermissions(origin, permissions) {
    const currentPermissions = this._originToPermissions.get(origin) || [];
    const toGrant = permissions.filter((permission2) => !currentPermissions.includes(permission2));
    this._originToPermissions.set(origin, [...currentPermissions, ...toGrant]);
    await Promise.all(toGrant.map((permission2) => this._setPermission(origin, permission2, Permissions.PermissionState.Granted)));
  }
  async doClearPermissions() {
    const currentPermissions = [...this._originToPermissions.entries()];
    this._originToPermissions = /* @__PURE__ */ new Map();
    await Promise.all(currentPermissions.map(([origin, permissions]) => permissions.map(
      (p) => this._setPermission(origin, p, Permissions.PermissionState.Prompt)
    )));
  }
  async _setPermission(origin, permission2, state) {
    await this._browser._browserSession.send("permissions.setPermission", {
      descriptor: {
        name: permission2
      },
      state,
      origin,
      userContext: this._userContextId()
    });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    await this._browser._browserSession.send("emulation.setGeolocationOverride", {
      coordinates: geolocation ? {
        latitude: geolocation.latitude,
        longitude: geolocation.longitude,
        accuracy: geolocation.accuracy
      } : null,
      userContexts: [this._userContextId()]
    });
  }
  async doUpdateExtraHTTPHeaders() {
  }
  async setUserAgent(userAgent) {
  }
  async doUpdateOffline() {
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page.delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    const { script } = await this._browser._browserSession.send("script.addPreloadScript", {
      // TODO: remove function call from the source.
      functionDeclaration: `() => { return ${initScript.source} }`,
      userContexts: [this._userContextId()]
    });
    this._initScriptIds.set(initScript, script);
  }
  async doRemoveInitScripts(initScripts) {
    const ids = [];
    for (const script of initScripts) {
      const id = this._initScriptIds.get(script);
      if (id)
        ids.push(id);
      this._initScriptIds.delete(script);
    }
    await Promise.all(ids.map((script) => this._browser._browserSession.send("script.removePreloadScript", { script })));
  }
  async doUpdateRequestInterception() {
  }
  async doUpdateDefaultViewport() {
    if (!this._options.viewport)
      return;
    await this._browser._browserSession.send("browsingContext.setViewport", {
      viewport: {
        width: this._options.viewport.width,
        height: this._options.viewport.height
      },
      devicePixelRatio: this._options.deviceScaleFactor || 1,
      userContexts: [this._userContextId()]
    });
  }
  async doUpdateDefaultEmulatedMedia() {
  }
  async doExposePlaywrightBinding() {
    const args = [{
      type: "channel",
      value: {
        channel: kPlaywrightBindingChannel,
        ownership: Script.ResultOwnership.Root
      }
    }];
    const functionDeclaration = `function addMainBinding(callback) { globalThis['${PageBinding.kBindingName}'] = callback; }`;
    const promises = [];
    promises.push(this._browser._browserSession.send("script.addPreloadScript", {
      functionDeclaration,
      arguments: args,
      userContexts: [this._userContextId()]
    }));
    promises.push(...this._bidiPages().map((page) => {
      const realms = [...page._realmToContext].filter(([realm, context2]) => context2.world === "main").map(([realm, context2]) => realm);
      return Promise.all(realms.map((realm) => {
        return page._session.send("script.callFunction", {
          functionDeclaration,
          arguments: args,
          target: { realm },
          awaitPromise: false,
          userActivation: false
        });
      }));
    }));
    await Promise.all(promises);
  }
  onClosePersistent() {
  }
  async clearCache() {
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      await this._browser.close({ reason });
      return;
    }
    await this._browser._browserSession.send("browser.removeUserContext", {
      userContext: this._browserContextId
    });
    this._browser._contexts.delete(this._browserContextId);
  }
  async cancelDownload(uuid) {
  }
  _userContextId() {
    if (this._browserContextId)
      return this._browserContextId;
    return "default";
  }
};
function fromBidiSameSite(sameSite) {
  switch (sameSite) {
    case "strict":
      return "Strict";
    case "lax":
      return "Lax";
    case "none":
      return "None";
  }
  return "None";
}
__name(fromBidiSameSite, "fromBidiSameSite");
function toBidiSameSite2(sameSite) {
  switch (sameSite) {
    case "Strict":
      return Network2.SameSite.Strict;
    case "Lax":
      return Network2.SameSite.Lax;
    case "None":
      return Network2.SameSite.None;
  }
  return Network2.SameSite.None;
}
__name(toBidiSameSite2, "toBidiSameSite");
function getProxyConfiguration(proxySettings) {
  if (!proxySettings)
    return void 0;
  const proxy = {
    proxyType: "manual"
  };
  const url4 = new URL(proxySettings.server);
  switch (url4.protocol) {
    case "http:":
      proxy.httpProxy = url4.host;
      break;
    case "https:":
      proxy.sslProxy = url4.host;
      break;
    case "socks4:":
      proxy.socksProxy = url4.host;
      proxy.socksVersion = 4;
      break;
    case "socks5:":
      proxy.socksProxy = url4.host;
      proxy.socksVersion = 5;
      break;
    default:
      throw new Error("Invalid proxy server protocol: " + proxySettings.server);
  }
  const bypass = proxySettings.bypass ?? process.env.PLAYWRIGHT_PROXY_BYPASS_FOR_TESTING;
  if (bypass)
    proxy.noProxy = bypass.split(",");
  return proxy;
}
__name(getProxyConfiguration, "getProxyConfiguration");
var Network3;
((Network22) => {
  ((SameSite2) => {
    SameSite2["Strict"] = "strict";
    SameSite2["Lax"] = "lax";
    SameSite2["None"] = "none";
  })(Network22.SameSite || (Network22.SameSite = {}));
})(Network3 || (Network3 = {}));

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/chromium.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs32 from "node:fs";
import os12 from "node:os";
import path24 from "node:path";
import "node:crypto";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browserType.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs30 from "node:fs";
import os11 from "node:os";
import path23 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/pipeTransport.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var PipeTransport2 = class {
  static {
    __name(this, "PipeTransport");
  }
  constructor(pipeWrite, pipeRead) {
    this._pendingBuffers = [];
    this._waitForNextTask = makeWaitForNextTask();
    this._closed = false;
    this._pipeRead = pipeRead;
    this._pipeWrite = pipeWrite;
    pipeRead.on("data", (buffer) => this._dispatch(buffer));
    pipeRead.on("close", () => {
      this._closed = true;
      if (this._onclose)
        this._onclose.call(null);
    });
    pipeRead.on("error", (e) => debugLogger.log("error", e));
    pipeWrite.on("error", (e) => debugLogger.log("error", e));
    this.onmessage = void 0;
  }
  get onclose() {
    return this._onclose;
  }
  set onclose(onclose) {
    this._onclose = onclose;
    if (onclose && !this._pipeRead.readable)
      onclose();
  }
  send(message) {
    if (this._closed)
      throw new Error("Pipe has been closed");
    this._pipeWrite.write(JSON.stringify(message));
    this._pipeWrite.write("\0");
  }
  close() {
    throw new Error("unimplemented");
  }
  _dispatch(buffer) {
    let end = buffer.indexOf("\0");
    if (end === -1) {
      this._pendingBuffers.push(buffer);
      return;
    }
    this._pendingBuffers.push(buffer.slice(0, end));
    const message = Buffer.concat(this._pendingBuffers).toString();
    this._waitForNextTask(() => {
      if (this.onmessage)
        this.onmessage.call(null, JSON.parse(message));
    });
    let start = end + 1;
    end = buffer.indexOf("\0", start);
    while (end !== -1) {
      const message2 = buffer.toString(void 0, start, end);
      this._waitForNextTask(() => {
        if (this.onmessage)
          this.onmessage.call(null, JSON.parse(message2));
      });
      start = end + 1;
      end = buffer.indexOf("\0", start);
    }
    this._pendingBuffers = [buffer.slice(start)];
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/browserType.js
var kNoXServerRunningError = "Looks like you launched a headed browser without having a XServer running.\nSet either 'headless: true' or use 'xvfb-run <your-playwright-app>' before running Playwright.\n\n<3 Playwright Team";
var BrowserType = class extends SdkObject {
  static {
    __name(this, "BrowserType");
  }
  constructor(parent, browserName) {
    super(parent, "browser-type");
    this.attribution.browserType = this;
    this._name = browserName;
    this.logName = "browser";
  }
  executablePath() {
    return registry.findExecutable(this._name).executablePath(this.attribution.playwright.options.sdkLanguage) || "";
  }
  name() {
    return this._name;
  }
  async launch(progress3, options2, protocolLogger) {
    options2 = this._validateLaunchOptions(options2);
    const seleniumHubUrl = options2.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
    if (seleniumHubUrl)
      return this._launchWithSeleniumHub(progress3, seleniumHubUrl, options2);
    return this._innerLaunchWithRetries(progress3, options2, void 0, helper.debugProtocolLogger(protocolLogger)).catch((e) => {
      throw this._rewriteStartupLog(e);
    });
  }
  async launchPersistentContext(progress3, userDataDir, options2) {
    const launchOptions = this._validateLaunchOptions(options2);
    let clientCertificatesProxy;
    if (options2.clientCertificates?.length) {
      clientCertificatesProxy = await ClientCertificatesProxy.create(progress3, options2);
      launchOptions.proxyOverride = clientCertificatesProxy.proxySettings();
      options2 = { ...options2 };
      options2.internalIgnoreHTTPSErrors = true;
    }
    try {
      const browser3 = await this._innerLaunchWithRetries(progress3, launchOptions, options2, helper.debugProtocolLogger(), userDataDir).catch((e) => {
        throw this._rewriteStartupLog(e);
      });
      browser3._defaultContext._clientCertificatesProxy = clientCertificatesProxy;
      return browser3._defaultContext;
    } catch (error3) {
      await clientCertificatesProxy?.close().catch(() => {
      });
      throw error3;
    }
  }
  async _innerLaunchWithRetries(progress3, options2, persistent, protocolLogger, userDataDir) {
    try {
      return await this._innerLaunch(progress3, options2, persistent, protocolLogger, userDataDir);
    } catch (error3) {
      const errorMessage = typeof error3 === "object" && typeof error3.message === "string" ? error3.message : "";
      if (errorMessage.includes("Inconsistency detected by ld.so")) {
        progress3.log(`<restarting browser due to hitting race condition in glibc>`);
        return this._innerLaunch(progress3, options2, persistent, protocolLogger, userDataDir);
      }
      throw error3;
    }
  }
  async _innerLaunch(progress3, options2, persistent, protocolLogger, maybeUserDataDir) {
    options2.proxy = options2.proxy ? normalizeProxySettings(options2.proxy) : void 0;
    const browserLogsCollector = new RecentLogsCollector();
    const { browserProcess, userDataDir, artifactsDir, transport } = await this._launchProcess(progress3, options2, !!persistent, browserLogsCollector, maybeUserDataDir);
    try {
      if (options2.__testHookBeforeCreateBrowser)
        await progress3.race(options2.__testHookBeforeCreateBrowser());
      const browserOptions = {
        name: this._name,
        isChromium: this._name === "chromium",
        channel: options2.channel,
        slowMo: options2.slowMo,
        persistent,
        headful: !options2.headless,
        artifactsDir,
        downloadsPath: options2.downloadsPath || artifactsDir,
        tracesDir: options2.tracesDir || artifactsDir,
        browserProcess,
        customExecutablePath: options2.executablePath,
        proxy: options2.proxy,
        protocolLogger,
        browserLogsCollector,
        wsEndpoint: transport instanceof WebSocketTransport ? transport.wsEndpoint : void 0,
        originalLaunchOptions: options2
      };
      if (persistent)
        validateBrowserContextOptions(persistent, browserOptions);
      copyTestHooks(options2, browserOptions);
      const browser3 = await progress3.race(this.connectToTransport(transport, browserOptions, browserLogsCollector));
      browser3._userDataDirForTest = userDataDir;
      if (persistent && !options2.ignoreAllDefaultArgs)
        await browser3._defaultContext._loadDefaultContext(progress3);
      return browser3;
    } catch (error3) {
      await browserProcess.close().catch(() => {
      });
      throw error3;
    }
  }
  async _prepareToLaunch(options2, isPersistent, userDataDir) {
    const {
      ignoreDefaultArgs,
      ignoreAllDefaultArgs,
      args = [],
      executablePath = null
    } = options2;
    await this._createArtifactDirs(options2);
    const tempDirectories = [];
    const artifactsDir = await fs30.promises.mkdtemp(path23.join(os11.tmpdir(), "playwright-artifacts-"));
    tempDirectories.push(artifactsDir);
    if (userDataDir) {
      assert3(path23.isAbsolute(userDataDir), "userDataDir must be an absolute path");
      if (!await existsAsync(userDataDir))
        await fs30.promises.mkdir(userDataDir, { recursive: true, mode: 448 });
    } else {
      userDataDir = await fs30.promises.mkdtemp(path23.join(os11.tmpdir(), `playwright_${this._name}dev_profile-`));
      tempDirectories.push(userDataDir);
    }
    await this.prepareUserDataDir(options2, userDataDir);
    const browserArguments = [];
    if (ignoreAllDefaultArgs)
      browserArguments.push(...args);
    else if (ignoreDefaultArgs)
      browserArguments.push(...this.defaultArgs(options2, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
    else
      browserArguments.push(...this.defaultArgs(options2, isPersistent, userDataDir));
    let executable;
    if (executablePath) {
      if (!await existsAsync(executablePath))
        throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
      executable = executablePath;
    } else {
      const registryExecutable = registry.findExecutable(this.getExecutableName(options2));
      if (!registryExecutable || registryExecutable.browserName !== this._name)
        throw new Error(`Unsupported ${this._name} channel "${options2.channel}"`);
      executable = registryExecutable.executablePathOrDie(this.attribution.playwright.options.sdkLanguage);
      await registry.validateHostRequirementsForExecutablesIfNeeded([registryExecutable], this.attribution.playwright.options.sdkLanguage);
    }
    return { executable, browserArguments, userDataDir, artifactsDir, tempDirectories };
  }
  async _launchProcess(progress3, options2, isPersistent, browserLogsCollector, userDataDir) {
    const {
      handleSIGINT = true,
      handleSIGTERM = true,
      handleSIGHUP = true
    } = options2;
    const env3 = options2.env ? envArrayToObject(options2.env) : process.env;
    const prepared = await progress3.race(this._prepareToLaunch(options2, isPersistent, userDataDir));
    let transport = void 0;
    let browserProcess = void 0;
    const exitPromise = new ManualPromise();
    const { launchedProcess, gracefullyClose, kill: kill2 } = await launchProcess({
      command: prepared.executable,
      args: prepared.browserArguments,
      env: this.amendEnvironment(env3, prepared.userDataDir, isPersistent),
      handleSIGINT,
      handleSIGTERM,
      handleSIGHUP,
      log: /* @__PURE__ */ __name((message) => {
        progress3.log(message);
        browserLogsCollector.log(message);
      }, "log"),
      stdio: "pipe",
      tempDirectories: prepared.tempDirectories,
      attemptToGracefullyClose: /* @__PURE__ */ __name(async () => {
        if (options2.__testHookGracefullyClose)
          await options2.__testHookGracefullyClose();
        if (transport) {
          this.attemptToGracefullyCloseBrowser(transport);
        } else {
          throw new Error("Force-killing the browser because no transport is available to gracefully close it.");
        }
      }, "attemptToGracefullyClose"),
      onExit: /* @__PURE__ */ __name((exitCode2, signal) => {
        exitPromise.resolve();
        if (browserProcess && browserProcess.onclose)
          browserProcess.onclose(exitCode2, signal);
      }, "onExit")
    });
    async function closeOrKill(timeout) {
      let timer;
      try {
        await Promise.race([
          gracefullyClose(),
          new Promise((resolve, reject) => timer = setTimeout(reject, timeout))
        ]);
      } catch (ignored) {
        await kill2().catch((ignored2) => {
        });
      } finally {
        clearTimeout(timer);
      }
    }
    __name(closeOrKill, "closeOrKill");
    browserProcess = {
      onclose: void 0,
      process: launchedProcess,
      close: /* @__PURE__ */ __name(() => closeOrKill(options2.__testHookBrowserCloseTimeout || DEFAULT_PLAYWRIGHT_TIMEOUT), "close"),
      kill: kill2
    };
    try {
      const { wsEndpoint } = await progress3.race([
        this.waitForReadyState(options2, browserLogsCollector),
        exitPromise.then(() => ({ wsEndpoint: void 0 }))
      ]);
      if (options2.cdpPort !== void 0 || !this.supportsPipeTransport()) {
        transport = await WebSocketTransport.connect(progress3, wsEndpoint);
      } else {
        const stdio = launchedProcess.stdio;
        transport = new PipeTransport2(stdio[3], stdio[4]);
      }
      return { browserProcess, artifactsDir: prepared.artifactsDir, userDataDir: prepared.userDataDir, transport };
    } catch (error3) {
      await closeOrKill(DEFAULT_PLAYWRIGHT_TIMEOUT).catch(() => {
      });
      throw error3;
    }
  }
  async _createArtifactDirs(options2) {
    if (options2.downloadsPath)
      await fs30.promises.mkdir(options2.downloadsPath, { recursive: true });
    if (options2.tracesDir)
      await fs30.promises.mkdir(options2.tracesDir, { recursive: true });
  }
  async connectOverCDP(progress3, endpointURL, options2) {
    throw new Error("CDP connections are only supported by Chromium");
  }
  async _launchWithSeleniumHub(progress3, hubUrl, options2) {
    throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
  }
  _validateLaunchOptions(options2) {
    const { devtools = false } = options2;
    let { headless = !devtools, downloadsPath, proxy } = options2;
    if (debugMode() === "inspector")
      headless = false;
    if (downloadsPath && !path23.isAbsolute(downloadsPath))
      downloadsPath = path23.join(process.cwd(), downloadsPath);
    if (options2.socksProxyPort)
      proxy = { server: `socks5://127.0.0.1:${options2.socksProxyPort}` };
    return { ...options2, devtools, headless, downloadsPath, proxy };
  }
  _createUserDataDirArgMisuseError(userDataDirArg) {
    switch (this.attribution.playwright.options.sdkLanguage) {
      case "java":
        return new Error(`Pass userDataDir parameter to 'BrowserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
      case "python":
        return new Error(`Pass user_data_dir parameter to 'browser_type.launch_persistent_context(user_data_dir, **kwargs)' instead of specifying '${userDataDirArg}' argument`);
      case "csharp":
        return new Error(`Pass userDataDir parameter to 'BrowserType.LaunchPersistentContextAsync(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
      default:
        return new Error(`Pass userDataDir parameter to 'browserType.launchPersistentContext(userDataDir, options)' instead of specifying '${userDataDirArg}' argument`);
    }
  }
  _rewriteStartupLog(error3) {
    if (!isProtocolError(error3))
      return error3;
    return this.doRewriteStartupLog(error3);
  }
  async waitForReadyState(options2, browserLogsCollector) {
    return {};
  }
  async prepareUserDataDir(options2, userDataDir) {
  }
  supportsPipeTransport() {
    return true;
  }
  getExecutableName(options2) {
    return options2.channel || this._name;
  }
};
function copyTestHooks(from, to) {
  for (const [key, value] of Object.entries(from)) {
    if (key.startsWith("__testHook"))
      to[key] = value;
  }
}
__name(copyTestHooks, "copyTestHooks");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/crDevTools.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs31 from "node:fs";
var kBindingName2 = "__pw_devtools__";
var CRDevTools = class {
  static {
    __name(this, "CRDevTools");
  }
  constructor(preferencesPath) {
    this._preferencesPath = preferencesPath;
    this._savePromise = Promise.resolve();
  }
  install(session2) {
    session2.on("Runtime.bindingCalled", async (event) => {
      if (event.name !== kBindingName2)
        return;
      const parsed = JSON.parse(event.payload);
      let result = void 0;
      if (this.__testHookOnBinding)
        this.__testHookOnBinding(parsed);
      if (parsed.method === "getPreferences") {
        if (this._prefs === void 0) {
          try {
            const json = await fs31.promises.readFile(this._preferencesPath, "utf8");
            this._prefs = JSON.parse(json);
          } catch (e) {
            this._prefs = {};
          }
        }
        result = this._prefs;
      } else if (parsed.method === "setPreference") {
        this._prefs[parsed.params[0]] = parsed.params[1];
        this._save();
      } else if (parsed.method === "removePreference") {
        delete this._prefs[parsed.params[0]];
        this._save();
      } else if (parsed.method === "clearPreferences") {
        this._prefs = {};
        this._save();
      }
      session2.send("Runtime.evaluate", {
        expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
        contextId: event.executionContextId
      }).catch((e) => null);
    });
    Promise.all([
      session2.send("Runtime.enable"),
      session2.send("Runtime.addBinding", { name: kBindingName2 }),
      session2.send("Page.enable"),
      session2.send("Page.addScriptToEvaluateOnNewDocument", { source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName2}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      ` }),
      session2.send("Runtime.runIfWaitingForDebugger")
    ]).catch((e) => null);
  }
  _save() {
    this._savePromise = this._savePromise.then(async () => {
      await fs31.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
    });
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/chromium/chromium.js
var ARTIFACTS_FOLDER3 = path24.join(os12.tmpdir(), "playwright-artifacts-");
var Chromium = class extends BrowserType {
  static {
    __name(this, "Chromium");
  }
  constructor(parent) {
    super(parent, "chromium");
    if (debugMode() === "inspector")
      this._devtools = this._createDevTools();
  }
  async connectOverCDP(progress3, endpointURL, options2) {
    return await this._connectOverCDPInternal(progress3, endpointURL, options2);
  }
  async _connectOverCDPInternal(progress3, endpointURL, options2, onClose) {
    let headersMap;
    if (options2.headers)
      headersMap = headersArrayToObject(options2.headers, false);
    if (!headersMap)
      headersMap = { "User-Agent": getUserAgent() };
    else if (headersMap && !Object.keys(headersMap).some((key) => key.toLowerCase() === "user-agent"))
      headersMap["User-Agent"] = getUserAgent();
    const artifactsDir = await progress3.race(fs32.promises.mkdtemp(ARTIFACTS_FOLDER3));
    const doCleanup = /* @__PURE__ */ __name(async () => {
      await removeFolders([artifactsDir]);
      const cb = onClose;
      onClose = void 0;
      await cb?.();
    }, "doCleanup");
    let chromeTransport;
    const doClose = /* @__PURE__ */ __name(async () => {
      await chromeTransport?.closeAndWait();
      await doCleanup();
    }, "doClose");
    try {
      const wsEndpoint = await urlToWSEndpoint2(progress3, endpointURL, headersMap);
      chromeTransport = await WebSocketTransport.connect(progress3, wsEndpoint, { headers: headersMap });
      const browserProcess = { close: doClose, kill: doClose };
      const noDefaultViewport = globalThis.navigator?.userAgent !== "Cloudflare-Workers";
      const persistent = new URL(endpointURL).searchParams.has("persistent") ? { noDefaultViewport } : void 0;
      const browserOptions = {
        slowMo: options2.slowMo,
        name: "chromium",
        isChromium: true,
        persistent,
        browserProcess,
        protocolLogger: helper.debugProtocolLogger(),
        browserLogsCollector: new RecentLogsCollector(),
        artifactsDir,
        downloadsPath: options2.downloadsPath || artifactsDir,
        tracesDir: options2.tracesDir || artifactsDir,
        originalLaunchOptions: {}
      };
      if (persistent)
        validateBrowserContextOptions(persistent, browserOptions);
      const browser3 = await progress3.race(CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions));
      browser3._isCollocatedWithServer = false;
      browser3.on(Browser.Events.Disconnected, doCleanup);
      return browser3;
    } catch (error3) {
      await doClose().catch(() => {
      });
      throw error3;
    }
  }
  _createDevTools() {
    const directory = registry.findExecutable("chromium").directory;
    return directory ? new CRDevTools(path24.join(directory, "devtools-preferences.json")) : void 0;
  }
  async connectToTransport(transport, options2, browserLogsCollector) {
    let devtools = this._devtools;
    if (options2.__testHookForDevTools) {
      devtools = this._createDevTools();
      await options2.__testHookForDevTools(devtools);
    }
    try {
      return await CRBrowser.connect(this.attribution.playwright, transport, options2, devtools);
    } catch (e) {
      if (browserLogsCollector.recentLogs().some((log3) => log3.includes("Failed to create a ProcessSingleton for your profile directory."))) {
        throw new Error(
          "Failed to create a ProcessSingleton for your profile directory. This usually means that the profile is already in use by another instance of Chromium."
        );
      }
      throw e;
    }
  }
  doRewriteStartupLog(error3) {
    if (!error3.logs)
      return error3;
    if (error3.logs.includes("Missing X server"))
      error3.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    if (!error3.logs.includes("crbug.com/357670") && !error3.logs.includes("No usable sandbox!") && !error3.logs.includes("crbug.com/638180"))
      return error3;
    error3.logs = [
      `Chromium sandboxing failed!`,
      `================================`,
      `To avoid the sandboxing issue, do either of the following:`,
      `  - (preferred): Configure your environment to support sandboxing`,
      `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
      `================================`,
      ``
    ].join("\n");
    return error3;
  }
  amendEnvironment(env3) {
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const message = { method: "Browser.close", id: kBrowserCloseMessageId, params: {} };
    transport.send(message);
  }
  async _launchWithSeleniumHub(progress3, hubUrl, options2) {
    await progress3.race(this._createArtifactDirs(options2));
    if (!hubUrl.endsWith("/"))
      hubUrl = hubUrl + "/";
    const args = this._innerDefaultArgs(options2);
    args.push("--remote-debugging-port=0");
    const isEdge = options2.channel && options2.channel.startsWith("msedge");
    let desiredCapabilities = {
      "browserName": isEdge ? "MicrosoftEdge" : "chrome",
      [isEdge ? "ms:edgeOptions" : "goog:chromeOptions"]: { args }
    };
    if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
      const remoteCapabilities = parseSeleniumRemoteParams({ name: "capabilities", value: process.env.SELENIUM_REMOTE_CAPABILITIES }, progress3);
      if (remoteCapabilities)
        desiredCapabilities = { ...desiredCapabilities, ...remoteCapabilities };
    }
    let headers = {};
    if (process.env.SELENIUM_REMOTE_HEADERS) {
      const remoteHeaders = parseSeleniumRemoteParams({ name: "headers", value: process.env.SELENIUM_REMOTE_HEADERS }, progress3);
      if (remoteHeaders)
        headers = remoteHeaders;
    }
    progress3.log(`<selenium> connecting to ${hubUrl}`);
    const response = await fetchData(progress3, {
      url: hubUrl + "session",
      method: "POST",
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        ...headers
      },
      data: JSON.stringify({
        capabilities: { alwaysMatch: desiredCapabilities }
      })
    }, seleniumErrorHandler);
    const value = JSON.parse(response).value;
    const sessionId = value.sessionId;
    progress3.log(`<selenium> connected to sessionId=${sessionId}`);
    const disconnectFromSelenium = /* @__PURE__ */ __name(async () => {
      progress3.log(`<selenium> disconnecting from sessionId=${sessionId}`);
      await fetchData(void 0, {
        url: hubUrl + "session/" + sessionId,
        method: "DELETE",
        headers
      }).catch((error3) => progress3.log(`<error disconnecting from selenium>: ${error3}`));
      progress3.log(`<selenium> disconnected from sessionId=${sessionId}`);
      gracefullyCloseSet.delete(disconnectFromSelenium);
    }, "disconnectFromSelenium");
    gracefullyCloseSet.add(disconnectFromSelenium);
    try {
      const capabilities = value.capabilities;
      let endpointURL;
      if (capabilities["se:cdp"]) {
        progress3.log(`<selenium> using selenium v4`);
        const endpointURLString2 = addProtocol(capabilities["se:cdp"]);
        endpointURL = new URL(endpointURLString2);
        if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1")
          endpointURL.hostname = new URL(hubUrl).hostname;
        progress3.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
      } else {
        progress3.log(`<selenium> using selenium v3`);
        const maybeChromeOptions = capabilities["goog:chromeOptions"];
        const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
        const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
        const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
        const endpointURLString2 = addProtocol(debuggerAddress || chromeOptionsURL).replace("localhost", "127.0.0.1");
        progress3.log(`<selenium> retrieved endpoint ${endpointURLString2} for sessionId=${sessionId}`);
        endpointURL = new URL(endpointURLString2);
        if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
          const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
          try {
            const sessionResponse = await fetchData(progress3, {
              url: sessionInfoUrl,
              method: "GET",
              headers
            }, seleniumErrorHandler);
            const proxyId = JSON.parse(sessionResponse).proxyId;
            endpointURL.hostname = new URL(proxyId).hostname;
            progress3.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
          } catch (e) {
            progress3.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
          }
        }
      }
      return await this._connectOverCDPInternal(progress3, endpointURL.toString(), {
        ...options2,
        headers: headersObjectToArray(headers)
      }, disconnectFromSelenium);
    } catch (e) {
      await disconnectFromSelenium();
      throw e;
    }
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const chromeArguments = this._innerDefaultArgs(options2);
    chromeArguments.push(`--user-data-dir=${userDataDir}`);
    if (options2.cdpPort !== void 0)
      chromeArguments.push(`--remote-debugging-port=${options2.cdpPort}`);
    else
      chromeArguments.push("--remote-debugging-pipe");
    if (isPersistent)
      chromeArguments.push("about:blank");
    else
      chromeArguments.push("--no-startup-window");
    return chromeArguments;
  }
  _innerDefaultArgs(options2) {
    const { args = [] } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
      throw new Error("Playwright manages remote debugging connection itself.");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const chromeArguments = [...chromiumSwitches(options2.assistantMode, options2.channel)];
    if (os12.platform() === "darwin") {
      chromeArguments.push("--enable-unsafe-swiftshader");
    }
    if (options2.devtools)
      chromeArguments.push("--auto-open-devtools-for-tabs");
    if (options2.headless) {
      chromeArguments.push("--headless");
      chromeArguments.push(
        "--hide-scrollbars",
        "--mute-audio",
        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
      );
    }
    if (options2.chromiumSandbox !== true)
      chromeArguments.push("--no-sandbox");
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      const proxyURL = new URL(proxy.server);
      const isSocks = proxyURL.protocol === "socks5:";
      if (isSocks && !options2.socksProxyPort) {
        chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
      }
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (options2.socksProxyPort)
        proxyBypassRules.push("<-loopback>");
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
  async waitForReadyState(options2, browserLogsCollector) {
    return waitForReadyState(options2, browserLogsCollector);
  }
  getExecutableName(options2) {
    if (options2.channel)
      return options2.channel;
    return options2.headless ? "chromium-headless-shell" : "chromium";
  }
};
async function waitForReadyState(options2, browserLogsCollector) {
  if (options2.cdpPort === void 0 && !options2.args?.some((a) => a.startsWith("--remote-debugging-port")))
    return {};
  const result = new ManualPromise();
  browserLogsCollector.onMessage((message) => {
    if (message.includes("Failed to create a ProcessSingleton for your profile directory.")) {
      result.reject(new Error("Failed to create a ProcessSingleton for your profile directory. This usually means that the profile is already in use by another instance of Chromium."));
    }
    const match = message.match(/DevTools listening on (.*)/);
    if (match)
      result.resolve({ wsEndpoint: match[1] });
  });
  return result;
}
__name(waitForReadyState, "waitForReadyState");
async function urlToWSEndpoint2(progress3, endpointURL, headers) {
  if (endpointURL.startsWith("ws"))
    return endpointURL;
  progress3.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
  const url4 = new URL(endpointURL);
  if (!url4.pathname.endsWith("/"))
    url4.pathname += "/";
  url4.pathname += "json/version/";
  const httpURL = url4.toString();
  const json = await fetchData(
    progress3,
    {
      url: httpURL,
      headers
    },
    async (_, resp) => new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`)
  );
  return JSON.parse(json).webSocketDebuggerUrl;
}
__name(urlToWSEndpoint2, "urlToWSEndpoint");
async function seleniumErrorHandler(params, response) {
  const body = await streamToString(response);
  let message = body;
  try {
    const json = JSON.parse(body);
    message = json.value.localizedMessage || json.value.message;
  } catch (e) {
  }
  return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
}
__name(seleniumErrorHandler, "seleniumErrorHandler");
function addProtocol(url4) {
  if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url4.startsWith(protocol)))
    return "http://" + url4;
  return url4;
}
__name(addProtocol, "addProtocol");
function streamToString(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on("error", reject);
    stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
  });
}
__name(streamToString, "streamToString");
function parseSeleniumRemoteParams(env3, progress3) {
  try {
    const parsed = JSON.parse(env3.value);
    progress3.log(`<selenium> using additional ${env3.name} "${env3.value}"`);
    return parsed;
  } catch (e) {
    progress3.log(`<selenium> ignoring additional ${env3.name} "${env3.value}": ${e}`);
  }
}
__name(parseSeleniumRemoteParams, "parseSeleniumRemoteParams");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/debugController.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var DebugController = class _DebugController extends SdkObject {
  static {
    __name(this, "DebugController");
  }
  constructor(playwright2) {
    super({ attribution: { isInternalPlaywright: true }, instrumentation: createInstrumentation() }, void 0, "DebugController");
    this._reportState = false;
    this._disposeListeners = /* @__PURE__ */ new Set();
    this._sdkLanguage = "javascript";
    this._generateAutoExpect = false;
    this._playwright = playwright2;
  }
  static {
    this.Events = {
      StateChanged: "stateChanged",
      InspectRequested: "inspectRequested",
      SourceChanged: "sourceChanged",
      Paused: "paused",
      SetModeRequested: "setModeRequested"
    };
  }
  initialize(codegenId, sdkLanguage) {
    this._sdkLanguage = sdkLanguage;
  }
  dispose() {
    this.setReportStateChanged(false);
  }
  setReportStateChanged(enabled) {
    if (this._reportState === enabled)
      return;
    this._reportState = enabled;
    if (enabled) {
      const listener = {
        onPageOpen: /* @__PURE__ */ __name((page) => {
          this._emitSnapshot(false);
          const handleNavigation = /* @__PURE__ */ __name(() => this._emitSnapshot(false), "handleNavigation");
          page.mainFrame().on(Frame.Events.InternalNavigation, handleNavigation);
          const dispose = /* @__PURE__ */ __name(() => page.mainFrame().off(Frame.Events.InternalNavigation, handleNavigation), "dispose");
          this._disposeListeners.add(dispose);
          page.on(Page.Events.Close, () => this._disposeListeners.delete(dispose));
        }, "onPageOpen"),
        onPageClose: /* @__PURE__ */ __name(() => this._emitSnapshot(false), "onPageClose")
      };
      this._playwright.instrumentation.addListener(listener, null);
      this._disposeListeners.add(() => this._playwright.instrumentation.removeListener(listener));
      this._emitSnapshot(true);
    } else {
      for (const dispose of this._disposeListeners)
        dispose();
      this._disposeListeners.clear();
    }
  }
  async setRecorderMode(progress3, params) {
    await progress3.race(this._closeBrowsersWithoutPages());
    this._generateAutoExpect = !!params.generateAutoExpect;
    if (params.mode === "none") {
      for (const recorder of await progress3.race(this._allRecorders())) {
        recorder.hideHighlightedSelector();
        recorder.setMode("none");
      }
      return;
    }
    if (!this._playwright.allBrowsers().length)
      await this._playwright.chromium.launch(progress3, { headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS });
    const pages = this._playwright.allPages();
    if (!pages.length) {
      const [browser3] = this._playwright.allBrowsers();
      const context2 = await browser3.newContextForReuse(progress3, {});
      await context2.newPage(progress3);
    }
    if (params.testIdAttributeName) {
      for (const page of this._playwright.allPages())
        page.browserContext.selectors().setTestIdAttributeName(params.testIdAttributeName);
    }
    for (const recorder of await progress3.race(this._allRecorders())) {
      recorder.hideHighlightedSelector();
      recorder.setMode(params.mode);
    }
  }
  async highlight(progress3, params) {
    if (params.selector)
      unsafeLocatorOrSelectorAsSelector(this._sdkLanguage, params.selector, "data-testid");
    const ariaTemplate = params.ariaTemplate ? parseAriaSnapshotUnsafe(yaml2, params.ariaTemplate) : void 0;
    for (const recorder of await progress3.race(this._allRecorders())) {
      if (ariaTemplate)
        recorder.setHighlightedAriaTemplate(ariaTemplate);
      else if (params.selector)
        recorder.setHighlightedSelector(params.selector);
    }
  }
  async hideHighlight(progress3) {
    for (const recorder of await progress3.race(this._allRecorders()))
      recorder.hideHighlightedSelector();
    await Promise.all(this._playwright.allPages().map((p) => p.hideHighlight().catch(() => {
    })));
  }
  async resume(progress3) {
    for (const recorder of await progress3.race(this._allRecorders()))
      recorder.resume();
  }
  kill() {
    gracefullyProcessExitDoNotHang(0);
  }
  _emitSnapshot(initial) {
    const pageCount = this._playwright.allPages().length;
    if (initial && !pageCount)
      return;
    this.emit(_DebugController.Events.StateChanged, {
      pageCount,
      browsers: this._playwright.allBrowsers().map((browser3) => ({
        id: browser3.guid,
        name: browser3.options.name,
        channel: browser3.options.channel,
        contexts: browser3.contexts().map((context2) => ({
          pages: context2.pages().map((page) => ({
            url: page.mainFrame().url()
          }))
        }))
      }))
    });
  }
  async _allRecorders() {
    const contexts = /* @__PURE__ */ new Set();
    for (const page of this._playwright.allPages())
      contexts.add(page.browserContext);
    const recorders = await Promise.all([...contexts].map((c) => Recorder.forContext(c, { omitCallTracking: true })));
    const nonNullRecorders = recorders.filter(Boolean);
    for (const recorder of recorders)
      wireListeners(recorder, this);
    return nonNullRecorders;
  }
  async _closeBrowsersWithoutPages() {
    for (const browser3 of this._playwright.allBrowsers()) {
      for (const context2 of browser3.contexts()) {
        if (!context2.pages().length)
          await context2.close({ reason: "Browser collected" });
      }
      if (!browser3.contexts())
        await browser3.close({ reason: "Browser collected" });
    }
  }
};
var wiredSymbol = Symbol("wired");
function wireListeners(recorder, debugController) {
  if (recorder[wiredSymbol])
    return;
  recorder[wiredSymbol] = true;
  const actions = [];
  const languageGenerator = new JavaScriptLanguageGenerator(
    /* isPlaywrightTest */
    true
  );
  const actionsChanged = /* @__PURE__ */ __name(() => {
    const aa = collapseActions(actions);
    const { header, footer, text, actionTexts } = generateCode(aa, languageGenerator, {
      browserName: "chromium",
      launchOptions: {},
      contextOptions: {},
      generateAutoExpect: debugController._generateAutoExpect
    });
    debugController.emit(DebugController.Events.SourceChanged, { text, header, footer, actions: actionTexts });
  }, "actionsChanged");
  recorder.on(RecorderEvent.ElementPicked, (elementInfo) => {
    const locator = asLocator(debugController._sdkLanguage, elementInfo.selector);
    debugController.emit(DebugController.Events.InspectRequested, { selector: elementInfo.selector, locator, ariaSnapshot: elementInfo.ariaSnapshot });
  });
  recorder.on(RecorderEvent.PausedStateChanged, (paused) => {
    debugController.emit(DebugController.Events.Paused, { paused });
  });
  recorder.on(RecorderEvent.ModeChanged, (mode) => {
    debugController.emit(DebugController.Events.SetModeRequested, { mode });
  });
  recorder.on(RecorderEvent.ActionAdded, (action) => {
    actions.push(action);
    actionsChanged();
  });
  recorder.on(RecorderEvent.SignalAdded, (signal) => {
    const lastAction = actions.findLast((a) => a.frame.pageGuid === signal.frame.pageGuid);
    if (lastAction)
      lastAction.action.signals.push(signal.signal);
    actionsChanged();
  });
}
__name(wireListeners, "wireListeners");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffAccessibility.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree2(session2, needle) {
  const objectId = needle ? needle._objectId : void 0;
  const { tree } = await session2.send("Accessibility.getFullAXTree", { objectId });
  const axNode = new FFAXNode(tree);
  return {
    tree: axNode,
    needle: needle ? axNode._findNeedle() : null
  };
}
__name(getAccessibilityTree2, "getAccessibilityTree");
var FFRoleToARIARole = new Map(Object.entries({
  "pushbutton": "button",
  "checkbutton": "checkbox",
  "editcombobox": "combobox",
  "content deletion": "deletion",
  "footnote": "doc-footnote",
  "non-native document": "document",
  "grouping": "group",
  "graphic": "img",
  "content insertion": "insertion",
  "animation": "marquee",
  "flat equation": "math",
  "menupopup": "menu",
  "check menu item": "menuitemcheckbox",
  "radio menu item": "menuitemradio",
  "listbox option": "option",
  "radiobutton": "radio",
  "statusbar": "status",
  "pagetab": "tab",
  "pagetablist": "tablist",
  "propertypage": "tabpanel",
  "entry": "textbox",
  "outline": "tree",
  "tree table": "treegrid",
  "outlineitem": "treeitem"
}));
var FFAXNode = class _FFAXNode {
  static {
    __name(this, "FFAXNode");
  }
  constructor(payload) {
    this._payload = payload;
    this._children = (payload.children || []).map((x) => new _FFAXNode(x));
    this._editable = !!payload.editable;
    this._richlyEditable = this._editable && (payload.tag !== "textarea" && payload.tag !== "input");
    this._focusable = !!payload.focusable;
    this._expanded = !!payload.expanded;
    this._name = this._payload.name;
    this._role = this._payload.role;
  }
  _isPlainTextField() {
    if (this._richlyEditable)
      return false;
    if (this._editable)
      return true;
    return this._role === "entry";
  }
  _isTextOnlyObject() {
    const role = this._role;
    return role === "text leaf" || role === "text" || role === "statictext";
  }
  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === void 0) {
      this._cachedHasFocusableChild = false;
      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }
    return this._cachedHasFocusableChild;
  }
  children() {
    return this._children;
  }
  _findNeedle() {
    if (this._payload.foundObject)
      return this;
    for (const child of this._children) {
      const found = child._findNeedle();
      if (found)
        return found;
    }
    return null;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isPlainTextField() || this._isTextOnlyObject())
      return true;
    switch (this._role) {
      case "graphic":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
    }
    if (this._hasFocusableChild())
      return false;
    if (this._focusable && this._role !== "document" && this._name)
      return true;
    if (this._role === "heading" && this._name)
      return true;
    return false;
  }
  isControl() {
    switch (this._role) {
      case "checkbutton":
      case "check menu item":
      case "check rich option":
      case "combobox":
      case "combobox option":
      case "color chooser":
      case "listbox":
      case "listbox option":
      case "listbox rich option":
      case "popup menu":
      case "menupopup":
      case "menuitem":
      case "menubar":
      case "button":
      case "pushbutton":
      case "radiobutton":
      case "radio menuitem":
      case "scrollbar":
      case "slider":
      case "spinbutton":
      case "switch":
      case "pagetab":
      case "entry":
      case "tree table":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    if (this._focusable || this._richlyEditable)
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!this._name.trim();
  }
  serialize() {
    const node = {
      role: FFRoleToARIARole.get(this._role) || this._role,
      name: this._name || ""
    };
    const userStringProperties = [
      "name",
      "description",
      "roledescription",
      "valuetext",
      "keyshortcuts"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload))
        continue;
      node[userStringProperty] = this._payload[userStringProperty];
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (this._role === "document" && booleanProperty === "focused")
        continue;
      const value = this._payload[booleanProperty];
      if (!value)
        continue;
      node[booleanProperty] = value;
    }
    const numericalProperties = [
      "level"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload))
        continue;
      node[numericalProperty] = this._payload[numericalProperty];
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "orientation"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === "false")
        continue;
      node[tokenProperty] = value;
    }
    const axNode = node;
    axNode.valueString = this._payload.value;
    if ("checked" in this._payload)
      axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
    if ("pressed" in this._payload)
      axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
    if ("invalid" in this._payload)
      axNode.invalid = this._payload.invalid === true ? "true" : "false";
    return axNode;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkAccessibility.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function getAccessibilityTree3(session2, needle) {
  const objectId = needle ? needle._objectId : void 0;
  const { axNode } = await session2.send("Page.accessibilitySnapshot", { objectId });
  const tree = new WKAXNode(axNode);
  return {
    tree,
    needle: needle ? tree._findNeedle() : null
  };
}
__name(getAccessibilityTree3, "getAccessibilityTree");
var WKRoleToARIARole = new Map(Object.entries({
  "TextField": "textbox"
}));
var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
  "WebArea": "HTML content",
  "Summary": "summary",
  "DescriptionList": "description list",
  "ImageMap": "image map",
  "ListMarker": "list marker",
  "Video": "video playback",
  "Mark": "highlighted",
  "contentinfo": "content information",
  "Details": "details",
  "DescriptionListDetail": "description",
  "DescriptionListTerm": "term",
  "alertdialog": "web alert dialog",
  "dialog": "web dialog",
  "status": "application status",
  "tabpanel": "tab panel",
  "application": "web application"
}));
var WKAXNode = class _WKAXNode {
  static {
    __name(this, "WKAXNode");
  }
  constructor(payload) {
    this._payload = payload;
    this._children = [];
    for (const payload2 of this._payload.children || [])
      this._children.push(new _WKAXNode(payload2));
  }
  children() {
    return this._children;
  }
  _findNeedle() {
    if (this._payload.found)
      return this;
    for (const child of this._children) {
      const found = child._findNeedle();
      if (found)
        return found;
    }
    return null;
  }
  isControl() {
    switch (this._payload.role) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "TextField":
      case "tree":
        return true;
      default:
        return false;
    }
  }
  _isTextControl() {
    switch (this._payload.role) {
      case "combobox":
      case "searchfield":
      case "textbox":
      case "TextField":
        return true;
    }
    return false;
  }
  _name() {
    if (this._payload.role === "text")
      return this._payload.value || "";
    return this._payload.name || "";
  }
  isInteresting(insideControl) {
    const { role, focusable } = this._payload;
    const name = this._name();
    if (role === "ScrollArea")
      return false;
    if (role === "WebArea")
      return true;
    if (focusable || role === "MenuListOption")
      return true;
    if (this.isControl())
      return true;
    if (insideControl)
      return false;
    return this.isLeafNode() && !!name;
  }
  _hasRedundantTextChild() {
    if (this._children.length !== 1)
      return false;
    const child = this._children[0];
    return child._payload.role === "text" && this._payload.name === child._payload.value;
  }
  isLeafNode() {
    if (!this._children.length)
      return true;
    if (this._isTextControl())
      return true;
    if (this._hasRedundantTextChild())
      return true;
    return false;
  }
  serialize() {
    const node = {
      role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
      name: this._name()
    };
    if ("description" in this._payload && this._payload.description !== node.name)
      node.description = this._payload.description;
    if ("roledescription" in this._payload) {
      const roledescription = this._payload.roledescription;
      if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
        node.roledescription = roledescription;
    }
    if ("value" in this._payload && this._payload.role !== "text") {
      if (typeof this._payload.value === "string")
        node.valueString = this._payload.value;
      else if (typeof this._payload.value === "number")
        node.valueNumber = this._payload.value;
    }
    if ("checked" in this._payload)
      node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
    if ("pressed" in this._payload)
      node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
    const userStringProperties = [
      "keyshortcuts",
      "valuetext"
    ];
    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload))
        continue;
      node[userStringProperty] = this._payload[userStringProperty];
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
        continue;
      const value = this._payload[booleanProperty];
      if (!value)
        continue;
      node[booleanProperty] = value;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload))
        continue;
      node[numericalProperty] = this._payload[numericalProperty];
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid"
    ];
    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === "false")
        continue;
      node[tokenProperty] = value;
    }
    const orientationIsApplicable = /* @__PURE__ */ new Set([
      "ScrollArea",
      "scrollbar",
      "listbox",
      "combobox",
      "menu",
      "tree",
      "separator",
      "slider",
      "tablist",
      "toolbar"
    ]);
    if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
      node.orientation = this._payload.orientation;
    return node;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/dispatchers/debugControllerDispatcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var DebugControllerDispatcher = class extends Dispatcher {
  static {
    __name(this, "DebugControllerDispatcher");
  }
  constructor(connection, debugController) {
    super(connection, debugController, "DebugController", {});
    this._type_DebugController = true;
    this._listeners = [
      eventsHelper.addEventListener(this._object, DebugController.Events.StateChanged, (params) => {
        this._dispatchEvent("stateChanged", params);
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.InspectRequested, ({ selector, locator, ariaSnapshot }) => {
        this._dispatchEvent("inspectRequested", { selector, locator, ariaSnapshot });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.SourceChanged, ({ text, header, footer, actions }) => {
        this._dispatchEvent("sourceChanged", { text, header, footer, actions });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.Paused, ({ paused }) => {
        this._dispatchEvent("paused", { paused });
      }),
      eventsHelper.addEventListener(this._object, DebugController.Events.SetModeRequested, ({ mode }) => {
        this._dispatchEvent("setModeRequested", { mode });
      })
    ];
  }
  async initialize(params, progress3) {
    this._object.initialize(params.codegenId, params.sdkLanguage);
  }
  async setReportStateChanged(params, progress3) {
    this._object.setReportStateChanged(params.enabled);
  }
  async setRecorderMode(params, progress3) {
    await this._object.setRecorderMode(progress3, params);
  }
  async highlight(params, progress3) {
    await this._object.highlight(progress3, params);
  }
  async hideHighlight(params, progress3) {
    await this._object.hideHighlight(progress3);
  }
  async resume(params, progress3) {
    await this._object.resume(progress3);
  }
  async kill(params, progress3) {
    this._object.kill();
  }
  _onDispose() {
    eventsHelper.removeEventListeners(this._listeners);
    this._object.dispose();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/remote/playwrightConnection.js
var PlaywrightConnection = class {
  static {
    __name(this, "PlaywrightConnection");
  }
  constructor(semaphore, ws3, controller, playwright2, initialize, id) {
    this._cleanups = [];
    this._disconnected = false;
    this._ws = ws3;
    this._semaphore = semaphore;
    this._id = id;
    this._profileName = (/* @__PURE__ */ new Date()).toISOString();
    const lock = this._semaphore.acquire();
    this._dispatcherConnection = new DispatcherConnection();
    this._dispatcherConnection.onmessage = async (message) => {
      await lock;
      if (ws3.readyState !== ws3.CLOSING) {
        const messageString = JSON.stringify(message);
        if (debugLogger.isEnabled("server:channel"))
          debugLogger.log("server:channel", `[${this._id}] ${monotonicTime() * 1e3} SEND \u25BA ${messageString}`);
        if (debugLogger.isEnabled("server:metadata"))
          this.logServerMetadata(message, messageString, "SEND");
        ws3.send(messageString);
      }
    };
    ws3.on("message", async (message) => {
      await lock;
      const messageString = Buffer.from(message).toString();
      const jsonMessage = JSON.parse(messageString);
      if (debugLogger.isEnabled("server:channel"))
        debugLogger.log("server:channel", `[${this._id}] ${monotonicTime() * 1e3} \u25C0 RECV ${messageString}`);
      if (debugLogger.isEnabled("server:metadata"))
        this.logServerMetadata(jsonMessage, messageString, "RECV");
      this._dispatcherConnection.dispatch(jsonMessage);
    });
    ws3.on("close", () => this._onDisconnect());
    ws3.on("error", (error3) => this._onDisconnect(error3));
    if (controller) {
      debugLogger.log("server", `[${this._id}] engaged reuse controller mode`);
      this._root = new DebugControllerDispatcher(this._dispatcherConnection, playwright2.debugController);
      return;
    }
    this._root = new RootDispatcher(this._dispatcherConnection, async (scope, params) => {
      await startProfiling();
      const options2 = await initialize();
      if (options2.preLaunchedBrowser) {
        const browser3 = options2.preLaunchedBrowser;
        browser3.options.sdkLanguage = params.sdkLanguage;
        browser3.on(Browser.Events.Disconnected, () => {
          this.close({ code: 1001, reason: "Browser closed" });
        });
      }
      if (options2.preLaunchedAndroidDevice) {
        const androidDevice = options2.preLaunchedAndroidDevice;
        androidDevice.on(AndroidDevice.Events.Close, () => {
          this.close({ code: 1001, reason: "Android device disconnected" });
        });
      }
      if (options2.dispose)
        this._cleanups.push(options2.dispose);
      const dispatcher = new PlaywrightDispatcher(scope, playwright2, options2);
      this._cleanups.push(() => dispatcher.cleanup());
      return dispatcher;
    });
  }
  async _onDisconnect(error3) {
    this._disconnected = true;
    debugLogger.log("server", `[${this._id}] disconnected. error: ${error3}`);
    await this._root.stopPendingOperations(new Error("Disconnected")).catch(() => {
    });
    this._root._dispose();
    debugLogger.log("server", `[${this._id}] starting cleanup`);
    for (const cleanup of this._cleanups)
      await cleanup().catch(() => {
      });
    await stopProfiling(this._profileName);
    this._semaphore.release();
    debugLogger.log("server", `[${this._id}] finished cleanup`);
  }
  logServerMetadata(message, messageString, direction) {
    const serverLogMetadata = {
      wallTime: Date.now(),
      id: message.id,
      guid: message.guid,
      method: message.method,
      payloadSizeInBytes: Buffer.byteLength(messageString, "utf-8")
    };
    debugLogger.log("server:metadata", (direction === "SEND" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(serverLogMetadata));
  }
  async close(reason) {
    if (this._disconnected)
      return;
    debugLogger.log("server", `[${this._id}] force closing connection: ${reason?.reason || ""} (${reason?.code || 0})`);
    try {
      this._ws.close(reason?.code, reason?.reason);
    } catch (e) {
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/playwright.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/android/backendAdb.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter15 } from "node:events";
import net5 from "node:net";
var AdbBackend = class {
  static {
    __name(this, "AdbBackend");
  }
  async devices(options2 = {}) {
    const result = await runCommand("host:devices", options2.host, options2.port);
    const lines = result.toString().trim().split("\n");
    return lines.map((line) => {
      const [serial, status] = line.trim().split("	");
      return new AdbDevice(serial, status, options2.host, options2.port);
    });
  }
};
var AdbDevice = class {
  static {
    __name(this, "AdbDevice");
  }
  constructor(serial, status, host, port) {
    this._closed = false;
    this.serial = serial;
    this.status = status;
    this.host = host;
    this.port = port;
  }
  async init() {
  }
  async close() {
    this._closed = true;
  }
  runCommand(command) {
    if (this._closed)
      throw new Error("Device is closed");
    return runCommand(command, this.host, this.port, this.serial);
  }
  async open(command) {
    if (this._closed)
      throw new Error("Device is closed");
    const result = await open4(command, this.host, this.port, this.serial);
    result.becomeSocket();
    return result;
  }
};
async function runCommand(command, host = "127.0.0.1", port = 5037, serial) {
  debug4("pw:adb:runCommand")(command, serial);
  const socket = new BufferedSocketWrapper(command, net5.createConnection({ host, port }));
  try {
    if (serial) {
      await socket.write(encodeMessage(`host:transport:${serial}`));
      const status2 = await socket.read(4);
      assert3(status2.toString() === "OKAY", status2.toString());
    }
    await socket.write(encodeMessage(command));
    const status = await socket.read(4);
    assert3(status.toString() === "OKAY", status.toString());
    let commandOutput;
    if (!command.startsWith("shell:")) {
      const remainingLength = parseInt((await socket.read(4)).toString(), 16);
      commandOutput = await socket.read(remainingLength);
    } else {
      commandOutput = await socket.readAll();
    }
    return commandOutput;
  } finally {
    socket.close();
  }
}
__name(runCommand, "runCommand");
async function open4(command, host = "127.0.0.1", port = 5037, serial) {
  const socket = new BufferedSocketWrapper(command, net5.createConnection({ host, port }));
  if (serial) {
    await socket.write(encodeMessage(`host:transport:${serial}`));
    const status2 = await socket.read(4);
    assert3(status2.toString() === "OKAY", status2.toString());
  }
  await socket.write(encodeMessage(command));
  const status = await socket.read(4);
  assert3(status.toString() === "OKAY", status.toString());
  return socket;
}
__name(open4, "open");
function encodeMessage(message) {
  let lenHex = message.length.toString(16);
  lenHex = "0".repeat(4 - lenHex.length) + lenHex;
  return Buffer.from(lenHex + message);
}
__name(encodeMessage, "encodeMessage");
var BufferedSocketWrapper = class extends EventEmitter15 {
  static {
    __name(this, "BufferedSocketWrapper");
  }
  constructor(command, socket) {
    super();
    this._buffer = Buffer.from([]);
    this._isSocket = false;
    this._isClosed = false;
    this._command = command;
    this._socket = socket;
    this._connectPromise = new Promise((f) => this._socket.on("connect", f));
    this._socket.on("data", (data) => {
      debug4("pw:adb:data")(data.toString());
      if (this._isSocket) {
        this.emit("data", data);
        return;
      }
      this._buffer = Buffer.concat([this._buffer, data]);
      if (this._notifyReader)
        this._notifyReader();
    });
    this._socket.on("close", () => {
      this._isClosed = true;
      if (this._notifyReader)
        this._notifyReader();
      this.close();
      this.emit("close");
    });
    this._socket.on("error", (error3) => this.emit("error", error3));
  }
  async write(data) {
    debug4("pw:adb:send")(data.toString().substring(0, 100) + "...");
    await this._connectPromise;
    await new Promise((f) => this._socket.write(data, f));
  }
  close() {
    if (this._isClosed)
      return;
    debug4("pw:adb")("Close " + this._command);
    this._socket.destroy();
  }
  async read(length) {
    await this._connectPromise;
    assert3(!this._isSocket, "Can not read by length in socket mode");
    while (this._buffer.length < length)
      await new Promise((f) => this._notifyReader = f);
    const result = this._buffer.slice(0, length);
    this._buffer = this._buffer.slice(length);
    debug4("pw:adb:recv")(result.toString().substring(0, 100) + "...");
    return result;
  }
  async readAll() {
    while (!this._isClosed)
      await new Promise((f) => this._notifyReader = f);
    return this._buffer;
  }
  becomeSocket() {
    assert3(!this._buffer.length);
    this._isSocket = true;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiChromium.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import os13 from "node:os";
var BidiChromium = class extends BrowserType {
  static {
    __name(this, "BidiChromium");
  }
  constructor(parent) {
    super(parent, "_bidiChromium");
  }
  async connectToTransport(transport, options2, browserLogsCollector) {
    const bidiTransport = await require$$06.connectBidiOverCdp(transport);
    transport[kBidiOverCdpWrapper] = bidiTransport;
    try {
      return BidiBrowser.connect(this.attribution.playwright, bidiTransport, options2);
    } catch (e) {
      if (browserLogsCollector.recentLogs().some((log3) => log3.includes("Failed to create a ProcessSingleton for your profile directory."))) {
        throw new Error(
          "Failed to create a ProcessSingleton for your profile directory. This usually means that the profile is already in use by another instance of Chromium."
        );
      }
      throw e;
    }
  }
  doRewriteStartupLog(error3) {
    if (!error3.logs)
      return error3;
    if (error3.logs.includes("Missing X server"))
      error3.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    if (!error3.logs.includes("crbug.com/357670") && !error3.logs.includes("No usable sandbox!") && !error3.logs.includes("crbug.com/638180"))
      return error3;
    error3.logs = [
      `Chromium sandboxing failed!`,
      `================================`,
      `To avoid the sandboxing issue, do either of the following:`,
      `  - (preferred): Configure your environment to support sandboxing`,
      `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`,
      `================================`,
      ``
    ].join("\n");
    return error3;
  }
  amendEnvironment(env3) {
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const bidiTransport = transport[kBidiOverCdpWrapper];
    if (bidiTransport)
      transport = bidiTransport;
    transport.send({ method: "browser.close", params: {}, id: kBrowserCloseMessageId2 });
  }
  supportsPipeTransport() {
    return false;
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const chromeArguments = this._innerDefaultArgs(options2);
    chromeArguments.push(`--user-data-dir=${userDataDir}`);
    chromeArguments.push("--remote-debugging-port=0");
    if (isPersistent)
      chromeArguments.push("about:blank");
    else
      chromeArguments.push("--no-startup-window");
    return chromeArguments;
  }
  async waitForReadyState(options2, browserLogsCollector) {
    return waitForReadyState({ ...options2, cdpPort: 0 }, browserLogsCollector);
  }
  _innerDefaultArgs(options2) {
    const { args = [] } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
      throw new Error("Playwright manages remote debugging connection itself.");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const chromeArguments = [...chromiumSwitches(options2.assistantMode)];
    if (os13.platform() === "darwin") {
      chromeArguments.push("--enable-unsafe-swiftshader");
    }
    if (options2.devtools)
      chromeArguments.push("--auto-open-devtools-for-tabs");
    if (options2.headless) {
      chromeArguments.push("--headless");
      chromeArguments.push(
        "--hide-scrollbars",
        "--mute-audio",
        "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4"
      );
    }
    if (options2.chromiumSandbox !== true)
      chromeArguments.push("--no-sandbox");
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      const proxyURL = new URL(proxy.server);
      const isSocks = proxyURL.protocol === "socks5:";
      if (isSocks && !options2.socksProxyPort) {
        chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
      }
      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = [];
      if (options2.socksProxyPort)
        proxyBypassRules.push("<-loopback>");
      if (proxy.bypass)
        proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
        proxyBypassRules.push("<-loopback>");
      if (proxyBypassRules.length > 0)
        chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
    }
    chromeArguments.push(...args);
    return chromeArguments;
  }
};
var kBidiOverCdpWrapper = Symbol("kBidiConnectionWrapper");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiFirefox.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import os14 from "node:os";
import path26 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/firefoxPrefs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import fs33 from "node:fs";
import path25 from "node:path";
async function createProfile(options2) {
  if (!fs33.existsSync(options2.path)) {
    await fs33.promises.mkdir(options2.path, {
      recursive: true
    });
  }
  await writePreferences({
    preferences: {
      ...defaultProfilePreferences(options2.preferences),
      ...options2.preferences
    },
    path: options2.path
  });
}
__name(createProfile, "createProfile");
function defaultProfilePreferences(extraPrefs) {
  const server = "dummy.test";
  const defaultPrefs = {
    // Make sure Shield doesn't hit the network.
    "app.normandy.api_url": "",
    // Disable Firefox old build background check
    "app.update.checkInstallTime": false,
    // Disable automatically upgrading Firefox
    "app.update.disabledForTesting": true,
    // Increase the APZ content response timeout to 1 minute
    "apz.content_response_timeout": 6e4,
    // Prevent various error message on the console
    // jest-puppeteer asserts that no error message is emitted by the console
    "browser.contentblocking.features.standard": "-tp,tpPrivate,cookieBehavior0,-cm,-fp",
    // Enable the dump function: which sends messages to the system
    // console
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1543115
    "browser.dom.window.dump.enabled": true,
    // Make sure newtab weather doesn't hit the network to retrieve weather data.
    "browser.newtabpage.activity-stream.discoverystream.region-weather-config": "",
    // Make sure newtab wallpapers don't hit the network to retrieve wallpaper data.
    "browser.newtabpage.activity-stream.newtabWallpapers.enabled": false,
    "browser.newtabpage.activity-stream.newtabWallpapers.v2.enabled": false,
    // Make sure Topsites doesn't hit the network to retrieve sponsored tiles.
    "browser.newtabpage.activity-stream.showSponsoredTopSites": false,
    // Disable topstories
    "browser.newtabpage.activity-stream.feeds.system.topstories": false,
    // Always display a blank page
    "browser.newtabpage.enabled": false,
    // Background thumbnails in particular cause grief: and disabling
    // thumbnails in general cannot hurt
    "browser.pagethumbnails.capturing_disabled": true,
    // Disable safebrowsing components.
    "browser.safebrowsing.blockedURIs.enabled": false,
    "browser.safebrowsing.downloads.enabled": false,
    "browser.safebrowsing.malware.enabled": false,
    "browser.safebrowsing.phishing.enabled": false,
    // Disable updates to search engines.
    "browser.search.update": false,
    // Do not restore the last open set of tabs if the browser has crashed
    "browser.sessionstore.resume_from_crash": false,
    // Skip check for default browser on startup
    "browser.shell.checkDefaultBrowser": false,
    // Disable newtabpage
    "browser.startup.homepage": "about:blank",
    // Do not redirect user when a milstone upgrade of Firefox is detected
    "browser.startup.homepage_override.mstone": "ignore",
    // Start with a blank page about:blank
    "browser.startup.page": 0,
    // Do not allow background tabs to be zombified on Android: otherwise for
    // tests that open additional tabs: the test harness tab itself might get
    // unloaded
    "browser.tabs.disableBackgroundZombification": false,
    // Do not warn when closing all other open tabs
    "browser.tabs.warnOnCloseOtherTabs": false,
    // Do not warn when multiple tabs will be opened
    "browser.tabs.warnOnOpen": false,
    // Do not automatically offer translations, as tests do not expect this.
    "browser.translations.automaticallyPopup": false,
    // Disable the UI tour.
    "browser.uitour.enabled": false,
    // Turn off search suggestions in the location bar so as not to trigger
    // network connections.
    "browser.urlbar.suggest.searches": false,
    // Disable first run splash page on Windows 10
    "browser.usedOnWindows10.introURL": "",
    // Do not warn on quitting Firefox
    "browser.warnOnQuit": false,
    // Defensively disable data reporting systems
    "datareporting.healthreport.documentServerURI": `http://${server}/dummy/healthreport/`,
    "datareporting.healthreport.logging.consoleEnabled": false,
    "datareporting.healthreport.service.enabled": false,
    "datareporting.healthreport.service.firstRun": false,
    "datareporting.healthreport.uploadEnabled": false,
    // Do not show datareporting policy notifications which can interfere with tests
    "datareporting.policy.dataSubmissionEnabled": false,
    "datareporting.policy.dataSubmissionPolicyBypassNotification": true,
    // DevTools JSONViewer sometimes fails to load dependencies with its require.js.
    // This doesn't affect Puppeteer but spams console (Bug 1424372)
    "devtools.jsonview.enabled": false,
    // Disable popup-blocker
    "dom.disable_open_during_load": false,
    // Enable the support for File object creation in the content process
    // Required for |Page.setFileInputFiles| protocol method.
    "dom.file.createInChild": true,
    // Disable the ProcessHangMonitor
    "dom.ipc.reportProcessHangs": false,
    // Disable slow script dialogues
    "dom.max_chrome_script_run_time": 0,
    "dom.max_script_run_time": 0,
    // Disable background timer throttling to allow tests to run in parallel
    // without a decrease in performance.
    "dom.min_background_timeout_value": 0,
    "dom.min_background_timeout_value_without_budget_throttling": 0,
    "dom.timeout.enable_budget_timer_throttling": false,
    // Disable HTTPS-First upgrades
    "dom.security.https_first": false,
    // Only load extensions from the application and user profile
    // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION
    "extensions.autoDisableScopes": 0,
    "extensions.enabledScopes": 5,
    // Disable metadata caching for installed add-ons by default
    "extensions.getAddons.cache.enabled": false,
    // Disable installing any distribution extensions or add-ons.
    "extensions.installDistroAddons": false,
    // Disabled screenshots extension
    "extensions.screenshots.disabled": true,
    // Turn off extension updates so they do not bother tests
    "extensions.update.enabled": false,
    // Turn off extension updates so they do not bother tests
    "extensions.update.notifyUser": false,
    // Make sure opening about:addons will not hit the network
    "extensions.webservice.discoverURL": `http://${server}/dummy/discoveryURL`,
    // Allow the application to have focus even it runs in the background
    "focusmanager.testmode": true,
    // Disable useragent updates
    "general.useragent.updates.enabled": false,
    // Always use network provider for geolocation tests so we bypass the
    // macOS dialog raised by the corelocation provider
    "geo.provider.testing": true,
    // Do not scan Wifi
    "geo.wifi.scan": false,
    // No hang monitor
    "hangmonitor.timeout": 0,
    // Show chrome errors and warnings in the error console
    "javascript.options.showInConsole": true,
    // Do not throttle rendering (requestAnimationFrame) in background tabs
    "layout.testing.top-level-always-active": true,
    // Disable download and usage of OpenH264: and Widevine plugins
    "media.gmp-manager.updateEnabled": false,
    // Disable the GFX sanity window
    "media.sanity-test.disabled": true,
    // Disable connectivity service pings
    "network.connectivity-service.enabled": false,
    // Disable experimental feature that is only available in Nightly
    "network.cookie.sameSite.laxByDefault": false,
    // Do not prompt for temporary redirects
    "network.http.prompt-temp-redirect": false,
    // Disable speculative connections so they are not reported as leaking
    // when they are hanging around
    "network.http.speculative-parallel-limit": 0,
    // Do not automatically switch between offline and online
    "network.manage-offline-status": false,
    // Make sure SNTP requests do not hit the network
    "network.sntp.pools": server,
    // Disable Flash.
    "plugin.state.flash": 0,
    "privacy.trackingprotection.enabled": false,
    // Can be removed once Firefox 89 is no longer supported
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1710839
    "remote.enabled": true,
    // Don't do network connections for mitm priming
    "security.certerrors.mitm.priming.enabled": false,
    // Local documents have access to all other local documents,
    // including directory listings
    "security.fileuri.strict_origin_policy": false,
    // Do not wait for the notification button security delay
    "security.notification_enable_delay": 0,
    // Do not automatically fill sign-in forms with known usernames and
    // passwords
    "signon.autofillForms": false,
    // Disable password capture, so that tests that include forms are not
    // influenced by the presence of the persistent doorhanger notification
    "signon.rememberSignons": false,
    // Disable first-run welcome page
    "startup.homepage_welcome_url": "about:blank",
    // Disable first-run welcome page
    "startup.homepage_welcome_url.additional": "",
    // Disable browser animations (tabs, fullscreen, sliding alerts)
    "toolkit.cosmeticAnimations.enabled": false,
    // Prevent starting into safe mode after application crashes
    "toolkit.startup.max_resumed_crashes": -1
  };
  return Object.assign(defaultPrefs, extraPrefs);
}
__name(defaultProfilePreferences, "defaultProfilePreferences");
async function writePreferences(options2) {
  const prefsPath = path25.join(options2.path, "prefs.js");
  const lines = Object.entries(options2.preferences).map(([key, value]) => {
    return `user_pref(${JSON.stringify(key)}, ${JSON.stringify(value)});`;
  });
  const result = await Promise.allSettled([
    fs33.promises.writeFile(path25.join(options2.path, "user.js"), lines.join("\n")),
    // Create a backup of the preferences file if it already exitsts.
    fs33.promises.access(prefsPath, fs33.constants.F_OK).then(
      async () => {
        await fs33.promises.copyFile(
          prefsPath,
          path25.join(options2.path, "prefs.js.playwright")
        );
      },
      // Swallow only if file does not exist
      () => {
      }
    )
  ]);
  for (const command of result) {
    if (command.status === "rejected") {
      throw command.reason;
    }
  }
}
__name(writePreferences, "writePreferences");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/bidiFirefox.js
var BidiFirefox = class extends BrowserType {
  static {
    __name(this, "BidiFirefox");
  }
  constructor(parent) {
    super(parent, "_bidiFirefox");
  }
  executablePath() {
    return "";
  }
  async connectToTransport(transport, options2) {
    return BidiBrowser.connect(this.attribution.playwright, transport, options2);
  }
  doRewriteStartupLog(error3) {
    if (!error3.logs)
      return error3;
    if (error3.logs.includes(`as root in a regular user's session is not supported.`))
      error3.logs = "\n" + wrapInASCIIBox(`Firefox is unable to launch if the $HOME folder isn't owned by the current user.
Workaround: Set the HOME=/root environment variable${process.env.GITHUB_ACTION ? " in your GitHub Actions workflow file" : ""} when running Playwright.`, 1);
    if (error3.logs.includes("no DISPLAY environment variable specified"))
      error3.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error3;
  }
  amendEnvironment(env3) {
    if (!path26.isAbsolute(os14.homedir()))
      throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os14.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
    env3 = {
      ...env3,
      "MOZ_CRASHREPORTER": "1",
      "MOZ_CRASHREPORTER_NO_REPORT": "1",
      "MOZ_CRASHREPORTER_SHUTDOWN": "1"
    };
    if (os14.platform() === "linux") {
      return { ...env3, SNAP_NAME: void 0, SNAP_INSTANCE_NAME: void 0 };
    }
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    transport.send({ method: "browser.close", params: {}, id: kBrowserCloseMessageId2 });
  }
  supportsPipeTransport() {
    return false;
  }
  async prepareUserDataDir(options2, userDataDir) {
    await createProfile({
      path: userDataDir,
      preferences: options2.firefoxUserPrefs || {}
    });
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--profile");
    const firefoxArguments = ["--remote-debugging-port=0"];
    if (headless)
      firefoxArguments.push("--headless");
    else
      firefoxArguments.push("--foreground");
    firefoxArguments.push(`--profile`, userDataDir);
    firefoxArguments.push(...args);
    return firefoxArguments;
  }
  async waitForReadyState(options2, browserLogsCollector) {
    const result = new ManualPromise();
    browserLogsCollector.onMessage((message) => {
      const match = message.match(/WebDriver BiDi listening on (ws:\/\/.*)$/);
      if (match)
        result.resolve({ wsEndpoint: match[1] + "/session" });
    });
    return result;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/firefox.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import os15 from "node:os";
import path27 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffBrowser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffConnection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter16 } from "node:events";
var ConnectionEvents2 = {
  Disconnected: Symbol("Disconnected")
};
var kBrowserCloseMessageId3 = -9999;
var FFConnection = class extends EventEmitter16 {
  static {
    __name(this, "FFConnection");
  }
  constructor(transport, protocolLogger, browserLogsCollector) {
    super();
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this._lastId = 0;
    this._sessions = /* @__PURE__ */ new Map();
    this._closed = false;
    this.rootSession = new FFSession(this, "", (message) => this._rawSend(message));
    this._sessions.set("", this.rootSession);
    this._transport.onmessage = this._onMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  _rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  async _onMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId3)
      return;
    const session2 = this._sessions.get(message.sessionId || "");
    if (session2)
      session2.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.rootSession.dispose();
    Promise.resolve().then(() => this.emit(ConnectionEvents2.Disconnected));
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
  createSession(sessionId) {
    const session2 = new FFSession(this, sessionId, (message) => this._rawSend({ ...message, sessionId }));
    this._sessions.set(sessionId, session2);
    return session2;
  }
};
var FFSession = class extends EventEmitter16 {
  static {
    __name(this, "FFSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._crashed = false;
    this.setMaxListeners(0);
    this._callbacks = /* @__PURE__ */ new Map();
    this._connection = connection;
    this._sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  markAsCrashed() {
    this._crashed = true;
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this._connection._closed || this._connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this._connection._browserDisconnectedLogs);
    const id = this._connection.nextMessageId();
    this._rawSend({ method, params, id });
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error3) => debugLogger.log("error", error3));
  }
  dispatchMessage(object) {
    if (object.id) {
      const callback = this._callbacks.get(object.id);
      if (callback) {
        this._callbacks.delete(object.id);
        if (object.error) {
          callback.error.setMessage(object.error.message);
          callback.reject(callback.error);
        } else {
          callback.resolve(object.result);
        }
      }
    } else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
  dispose() {
    this._disposed = true;
    this._connection._sessions.delete(this._sessionId);
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this._connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffPage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffExecutionContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FFExecutionContext = class {
  static {
    __name(this, "FFExecutionContext");
  }
  constructor(session2, executionContextId) {
    this._session = session2;
    this._executionContextId = executionContextId;
  }
  async rawEvaluateJSON(expression) {
    const payload = await this._session.send("Runtime.evaluate", {
      expression,
      returnByValue: true,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    return payload.result.value;
  }
  async rawEvaluateHandle(context2, expression) {
    const payload = await this._session.send("Runtime.evaluate", {
      expression,
      returnByValue: false,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    return createHandle3(context2, payload.result);
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    const payload = await this._session.send("Runtime.callFunction", {
      functionDeclaration: expression,
      args: [
        { objectId: utilityScript._objectId, value: void 0 },
        ...values.map((value) => ({ value })),
        ...handles.map((handle) => ({ objectId: handle._objectId, value: void 0 }))
      ],
      returnByValue,
      executionContextId: this._executionContextId
    }).catch(rewriteError2);
    checkException(payload.exceptionDetails);
    if (returnByValue)
      return parseEvaluationResultValue(payload.result.value);
    return createHandle3(utilityScript._context, payload.result);
  }
  async getProperties(object) {
    const response = await this._session.send("Runtime.getObjectProperties", {
      executionContextId: this._executionContextId,
      objectId: object._objectId
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.properties)
      result.set(property.name, createHandle3(object._context, property.value));
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("Runtime.disposeObject", {
      executionContextId: this._executionContextId,
      objectId: handle._objectId
    });
  }
};
function checkException(exceptionDetails) {
  if (!exceptionDetails)
    return;
  if (exceptionDetails.value)
    throw new JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
  else
    throw new JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
}
__name(checkException, "checkException");
function rewriteError2(error3) {
  if (error3.message.includes("cyclic object value") || error3.message.includes("Object is not serializable"))
    return { result: { type: "undefined", value: void 0 } };
  if (error3 instanceof TypeError && error3.message.startsWith("Converting circular structure to JSON"))
    rewriteErrorMessage(error3, error3.message + " Are you passing a nested JSHandle?");
  if (!isJavaScriptErrorInEvaluate(error3) && !isSessionClosedError(error3))
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  throw error3;
}
__name(rewriteError2, "rewriteError");
function potentiallyUnserializableValue2(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? parseUnserializableValue(unserializableValue) : value;
}
__name(potentiallyUnserializableValue2, "potentiallyUnserializableValue");
function renderPreview3(object) {
  if (object.type === "undefined")
    return "undefined";
  if (object.unserializableValue)
    return String(object.unserializableValue);
  if (object.type === "symbol")
    return "Symbol()";
  if (object.subtype === "regexp")
    return "RegExp";
  if (object.subtype === "weakmap")
    return "WeakMap";
  if (object.subtype === "weakset")
    return "WeakSet";
  if (object.subtype)
    return object.subtype[0].toUpperCase() + object.subtype.slice(1);
  if ("value" in object)
    return String(object.value);
}
__name(renderPreview3, "renderPreview");
function createHandle3(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  return new JSHandle(context2, remoteObject.subtype || remoteObject.type || "", renderPreview3(remoteObject), remoteObject.objectId, potentiallyUnserializableValue2(remoteObject));
}
__name(createHandle3, "createHandle");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffInput.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function toModifiersMask2(modifiers) {
  let mask = 0;
  if (modifiers.has("Alt"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Shift"))
    mask |= 4;
  if (modifiers.has("Meta"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask2, "toModifiersMask");
function toButtonNumber(button) {
  if (button === "left")
    return 0;
  if (button === "middle")
    return 1;
  if (button === "right")
    return 2;
  return 0;
}
__name(toButtonNumber, "toButtonNumber");
function toButtonsMask2(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask2, "toButtonsMask");
var RawKeyboardImpl3 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async keydown(progress3, modifiers, keyName, description, autoRepeat) {
    let text = description.text;
    if (text === "\r")
      text = "";
    const { code, key, location: location2 } = description;
    await progress3.race(this._client.send("Page.dispatchKeyEvent", {
      type: "keydown",
      keyCode: description.keyCodeWithoutLocation,
      code,
      key,
      repeat: autoRepeat,
      location: location2,
      text
    }));
  }
  async keyup(progress3, modifiers, keyName, description) {
    const { code, key, location: location2 } = description;
    await progress3.race(this._client.send("Page.dispatchKeyEvent", {
      type: "keyup",
      key,
      keyCode: description.keyCodeWithoutLocation,
      code,
      location: location2,
      repeat: false
    }));
  }
  async sendText(progress3, text) {
    await progress3.race(this._client.send("Page.insertText", { text }));
  }
};
var RawMouseImpl3 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async move(progress3, x, y, button, buttons, modifiers, forClick) {
    await progress3.race(this._client.send("Page.dispatchMouseEvent", {
      type: "mousemove",
      button: 0,
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers)
    }));
  }
  async down(progress3, x, y, button, buttons, modifiers, clickCount) {
    await progress3.race(this._client.send("Page.dispatchMouseEvent", {
      type: "mousedown",
      button: toButtonNumber(button),
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers),
      clickCount
    }));
  }
  async up(progress3, x, y, button, buttons, modifiers, clickCount) {
    await progress3.race(this._client.send("Page.dispatchMouseEvent", {
      type: "mouseup",
      button: toButtonNumber(button),
      buttons: toButtonsMask2(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask2(modifiers),
      clickCount
    }));
  }
  async wheel(progress3, x, y, buttons, modifiers, deltaX, deltaY) {
    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, { world: "utility" });
    await progress3.race(this._client.send("Page.dispatchWheelEvent", {
      deltaX,
      deltaY,
      x: Math.floor(x),
      y: Math.floor(y),
      deltaZ: 0,
      modifiers: toModifiersMask2(modifiers)
    }));
  }
  setPage(page) {
    this._page = page;
  }
};
var RawTouchscreenImpl3 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(client) {
    this._client = client;
  }
  async tap(progress3, x, y, modifiers) {
    await progress3.race(this._client.send("Page.dispatchTapEvent", {
      x,
      y,
      modifiers: toModifiersMask2(modifiers)
    }));
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffNetworkManager.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FFNetworkManager = class {
  static {
    __name(this, "FFNetworkManager");
  }
  constructor(session2, page) {
    this._session = session2;
    this._requests = /* @__PURE__ */ new Map();
    this._page = page;
    this._eventListeners = [
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)),
      eventsHelper.addEventListener(session2, "Network.responseReceived", this._onResponseReceived.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestFinished", this._onRequestFinished.bind(this)),
      eventsHelper.addEventListener(session2, "Network.requestFailed", this._onRequestFailed.bind(this))
    ];
  }
  dispose() {
    eventsHelper.removeEventListeners(this._eventListeners);
  }
  async setRequestInterception(enabled) {
    await Promise.all([
      this._session.send("Network.setRequestInterception", { enabled }),
      this._session.send("Page.setCacheDisabled", { cacheDisabled: enabled })
    ]);
  }
  _onRequestWillBeSent(event) {
    const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
    const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page.frameManager.frame(event.frameId) : null;
    if (!frame)
      return;
    if (event.method === "OPTIONS" && !event.isIntercepted)
      return;
    if (redirectedFrom)
      this._requests.delete(redirectedFrom._id);
    const request2 = new InterceptableRequest2(frame, redirectedFrom, event);
    let route;
    if (event.isIntercepted)
      route = new FFRouteImpl(this._session, request2);
    this._requests.set(request2._id, request2);
    this._page.frameManager.requestStarted(request2.request, route);
  }
  _onResponseReceived(event) {
    const request2 = this._requests.get(event.requestId);
    if (!request2)
      return;
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const response2 = await this._session.send("Network.getResponseBody", {
        requestId: request2._id
      });
      if (response2.evicted)
        throw new Error(`Response body for ${request2.request.method()} ${request2.request.url()} was evicted!`);
      return Buffer.from(response2.base64body, "base64");
    }, "getResponseBody");
    const startTime = event.timing.startTime;
    function relativeToStart(time3) {
      if (!time3)
        return -1;
      return (time3 - startTime) / 1e3;
    }
    __name(relativeToStart, "relativeToStart");
    const timing = {
      startTime: startTime / 1e3,
      domainLookupStart: relativeToStart(event.timing.domainLookupStart),
      domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
      connectStart: relativeToStart(event.timing.connectStart),
      secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
      connectEnd: relativeToStart(event.timing.connectEnd),
      requestStart: relativeToStart(event.timing.requestStart),
      responseStart: relativeToStart(event.timing.responseStart)
    };
    const response = new Response2(request2.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);
    if (event?.remoteIPAddress && typeof event?.remotePort === "number") {
      response._serverAddrFinished({
        ipAddress: event.remoteIPAddress,
        port: event.remotePort
      });
    } else {
      response._serverAddrFinished();
    }
    response._securityDetailsFinished({
      protocol: event?.securityDetails?.protocol,
      subjectName: event?.securityDetails?.subjectName,
      issuer: event?.securityDetails?.issuer,
      validFrom: event?.securityDetails?.validFrom,
      validTo: event?.securityDetails?.validTo
    });
    response.setRawResponseHeaders(null);
    response.setResponseHeadersSize(null);
    this._page.frameManager.requestReceivedResponse(response);
  }
  _onRequestFinished(event) {
    const request2 = this._requests.get(event.requestId);
    if (!request2)
      return;
    const response = request2.request._existingResponse();
    response.setTransferSize(event.transferSize);
    response.setEncodedBodySize(event.encodedBodySize);
    const isRedirected = response.status() >= 300 && response.status() <= 399;
    const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
    if (isRedirected) {
      response._requestFinished(responseEndTime);
    } else {
      this._requests.delete(request2._id);
      response._requestFinished(responseEndTime);
    }
    if (event.protocolVersion)
      response._setHttpVersion(event.protocolVersion);
    this._page.frameManager.reportRequestFinished(request2.request, response);
  }
  _onRequestFailed(event) {
    const request2 = this._requests.get(event.requestId);
    if (!request2)
      return;
    this._requests.delete(request2._id);
    const response = request2.request._existingResponse();
    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(-1);
    }
    request2.request._setFailureText(event.errorCode);
    this._page.frameManager.requestFailed(request2.request, event.errorCode === "NS_BINDING_ABORTED");
  }
};
var causeToResourceType = {
  TYPE_INVALID: "other",
  TYPE_OTHER: "other",
  TYPE_SCRIPT: "script",
  TYPE_IMAGE: "image",
  TYPE_STYLESHEET: "stylesheet",
  TYPE_OBJECT: "other",
  TYPE_DOCUMENT: "document",
  TYPE_SUBDOCUMENT: "document",
  TYPE_REFRESH: "document",
  TYPE_XBL: "other",
  TYPE_PING: "other",
  TYPE_XMLHTTPREQUEST: "xhr",
  TYPE_OBJECT_SUBREQUEST: "other",
  TYPE_DTD: "other",
  TYPE_FONT: "font",
  TYPE_MEDIA: "media",
  TYPE_WEBSOCKET: "websocket",
  TYPE_CSP_REPORT: "other",
  TYPE_XSLT: "other",
  TYPE_BEACON: "other",
  TYPE_FETCH: "fetch",
  TYPE_IMAGESET: "image",
  TYPE_WEB_MANIFEST: "manifest"
};
var internalCauseToResourceType = {
  TYPE_INTERNAL_EVENTSOURCE: "eventsource"
};
var InterceptableRequest2 = class {
  static {
    __name(this, "InterceptableRequest");
  }
  constructor(frame, redirectedFrom, payload) {
    this._id = payload.requestId;
    if (redirectedFrom)
      redirectedFrom._redirectedTo = this;
    let postDataBuffer = null;
    if (payload.postData)
      postDataBuffer = Buffer.from(payload.postData, "base64");
    this.request = new Request(
      frame._page.browserContext,
      frame,
      null,
      redirectedFrom ? redirectedFrom.request : null,
      payload.navigationId,
      payload.url,
      internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other",
      payload.method,
      postDataBuffer,
      payload.headers
    );
    this.request.setRawRequestHeaders(null);
  }
  _finalRequest() {
    let request2 = this;
    while (request2._redirectedTo)
      request2 = request2._redirectedTo;
    return request2;
  }
};
var FFRouteImpl = class {
  static {
    __name(this, "FFRouteImpl");
  }
  constructor(session2, request2) {
    this._session = session2;
    this._request = request2;
  }
  async continue(overrides) {
    await this._session.sendMayFail("Network.resumeInterceptedRequest", {
      requestId: this._request._id,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
    });
  }
  async fulfill(response) {
    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
    await this._session.sendMayFail("Network.fulfillInterceptedRequest", {
      requestId: this._request._id,
      status: response.status,
      statusText: statusText(response.status),
      headers: response.headers,
      base64body
    });
  }
  async abort(errorCode) {
    await this._session.sendMayFail("Network.abortInterceptedRequest", {
      requestId: this._request._id,
      errorCode
    });
  }
};
function parseMultivalueHeaders(headers) {
  const result = [];
  for (const header of headers) {
    const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
    const tokens = header.value.split(separator).map((s) => s.trim());
    for (const token of tokens)
      result.push({ name: header.name, value: token });
  }
  return result;
}
__name(parseMultivalueHeaders, "parseMultivalueHeaders");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffPage.js
var UTILITY_WORLD_NAME2 = "__playwright_utility_world__";
var FFPage = class {
  static {
    __name(this, "FFPage");
  }
  constructor(session2, browserContext, opener) {
    this.cspErrorsAsynchronousForInlineScripts = true;
    this._reportedAsNew = false;
    this._workers = /* @__PURE__ */ new Map();
    this._initScripts = [];
    this._session = session2;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl3(session2);
    this.rawMouse = new RawMouseImpl3(session2);
    this.rawTouchscreen = new RawTouchscreenImpl3(session2);
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._browserContext = browserContext;
    this._page = new Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._networkManager = new FFNetworkManager(session2, this._page);
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
    this._eventListeners = [
      eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)),
      eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)),
      eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)),
      eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))
    ];
    this._session.once("Page.ready", () => {
      if (this._reportedAsNew)
        return;
      this._reportedAsNew = true;
      this._page.reportAsNew(this._opener?._page);
    });
    this.addInitScript(new InitScript(""), UTILITY_WORLD_NAME2).catch((e) => this._markAsError(e));
  }
  async _markAsError(error3) {
    if (this._reportedAsNew)
      return;
    this._reportedAsNew = true;
    this._page.reportAsNew(this._opener?._page, error3);
  }
  _onWebSocketCreated(event) {
    this._page.frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
    this._page.frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
  }
  _onWebSocketClosed(event) {
    if (event.error)
      this._page.frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
    this._page.frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
  }
  _onWebSocketFrameReceived(event) {
    this._page.frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }
  _onWebSocketFrameSent(event) {
    this._page.frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }
  _onExecutionContextCreated(payload) {
    const { executionContextId, auxData } = payload;
    const frame = this._page.frameManager.frame(auxData.frameId);
    if (!frame)
      return;
    const delegate = new FFExecutionContext(this._session, executionContextId);
    let worldName = null;
    if (auxData.name === UTILITY_WORLD_NAME2)
      worldName = "utility";
    else if (!auxData.name)
      worldName = "main";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(executionContextId, context2);
  }
  _onExecutionContextDestroyed(payload) {
    const { executionContextId } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._contextIdToContext.delete(executionContextId);
    context2.frame._contextDestroyed(context2);
  }
  _onExecutionContextsCleared() {
    for (const executionContextId of Array.from(this._contextIdToContext.keys()))
      this._onExecutionContextDestroyed({ executionContextId });
  }
  _removeContextsForFrame(frame) {
    for (const [contextId, context2] of this._contextIdToContext) {
      if (context2.frame === frame)
        this._contextIdToContext.delete(contextId);
    }
  }
  _onLinkClicked(phase) {
    if (phase === "before")
      this._page.frameManager.frameWillPotentiallyRequestNavigation();
    else
      this._page.frameManager.frameDidPotentiallyRequestNavigation();
  }
  _onNavigationStarted(params) {
    this._page.frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
  }
  _onNavigationAborted(params) {
    this._page.frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
  }
  _onNavigationCommitted(params) {
    for (const [workerId, worker] of this._workers) {
      if (worker.frameId === params.frameId)
        this._onWorkerDestroyed({ workerId });
    }
    this._page.frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
  }
  _onSameDocumentNavigation(params) {
    this._page.frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
  }
  _onFrameAttached(params) {
    this._page.frameManager.frameAttached(params.frameId, params.parentFrameId);
  }
  _onFrameDetached(params) {
    this._page.frameManager.frameDetached(params.frameId);
  }
  _onEventFired(payload) {
    const { frameId, name } = payload;
    if (name === "load")
      this._page.frameManager.frameLifecycleEvent(frameId, "load");
    if (name === "DOMContentLoaded")
      this._page.frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
  }
  _onUncaughtError(params) {
    const { name, message } = splitErrorMessage(params.message);
    const error3 = new Error(message);
    error3.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
    error3.name = name;
    this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, error3, this._page);
  }
  _onConsole(payload) {
    const { type, args, executionContextId, location: location2 } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    this._page.addConsoleMessage(type === "warn" ? "warning" : type, args.map((arg) => createHandle3(context2, arg)), location2);
  }
  _onDialogOpened(params) {
    this._page.browserContext.dialogManager.dialogDidOpen(new Dialog(
      this._page,
      params.type,
      params.message,
      async (accept, promptText) => {
        await this._session.sendMayFail("Page.handleDialog", { dialogId: params.dialogId, accept, promptText });
      },
      params.defaultValue
    ));
  }
  async _onBindingCalled(event) {
    const pageOrError = await this._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(event.executionContextId);
      if (context2)
        await this._page.onBindingCalled(event.payload, context2);
    }
  }
  async _onFileChooserOpened(payload) {
    const { executionContextId, element } = payload;
    const context2 = this._contextIdToContext.get(executionContextId);
    if (!context2)
      return;
    const handle = createHandle3(context2, element).asElement();
    await this._page._onFileChooserOpened(handle);
  }
  async _onWorkerCreated(event) {
    const workerId = event.workerId;
    const worker = new Worker(this._page, event.url);
    const workerSession = new FFSession(this._session._connection, workerId, (message) => {
      this._session.send("Page.sendMessageToWorker", {
        frameId: event.frameId,
        workerId,
        message: JSON.stringify(message)
      }).catch((e) => {
        workerSession.dispatchMessage({ id: message.id, method: "", params: {}, error: { message: e.message, data: void 0 } });
      });
    });
    this._workers.set(workerId, { session: workerSession, frameId: event.frameId });
    this._page.addWorker(workerId, worker);
    workerSession.once("Runtime.executionContextCreated", (event2) => {
      worker.createExecutionContext(new FFExecutionContext(workerSession, event2.executionContextId));
    });
    workerSession.on("Runtime.console", (event2) => {
      const { type, args, location: location2 } = event2;
      const context2 = worker.existingExecutionContext;
      this._page.addConsoleMessage(type, args.map((arg) => createHandle3(context2, arg)), location2);
    });
  }
  _onWorkerDestroyed(event) {
    const workerId = event.workerId;
    const worker = this._workers.get(workerId);
    if (!worker)
      return;
    worker.session.dispose();
    this._workers.delete(workerId);
    this._page.removeWorker(workerId);
  }
  async _onDispatchMessageFromWorker(event) {
    const worker = this._workers.get(event.workerId);
    if (!worker)
      return;
    worker.session.dispatchMessage(JSON.parse(event.message));
  }
  async _onCrashed(event) {
    this._session.markAsCrashed();
    this._page._didCrash();
  }
  _onVideoRecordingStarted(event) {
    this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this._page.waitForInitializedOrError());
  }
  didClose() {
    this._markAsError(new TargetClosedError());
    this._session.dispose();
    eventsHelper.removeEventListeners(this._eventListeners);
    this._networkManager.dispose();
    this._page._didClose();
  }
  async navigateFrame(frame, url4, referer) {
    const response = await this._session.send("Page.navigate", { url: url4, referer, frameId: frame._id });
    return { newDocumentId: response.navigationId || void 0 };
  }
  async updateExtraHTTPHeaders() {
    await this._session.send("Network.setExtraHTTPHeaders", { headers: this._page.extraHTTPHeaders() || [] });
  }
  async updateEmulatedViewportSize() {
    const viewportSize = this._page.emulatedSize()?.viewport ?? null;
    await this._session.send("Page.setViewportSize", { viewportSize });
  }
  async bringToFront() {
    await this._session.send("Page.bringToFront", {});
  }
  async updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const colorScheme = emulatedMedia.colorScheme === "no-override" ? void 0 : emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? void 0 : emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors === "no-override" ? void 0 : emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast === "no-override" ? void 0 : emulatedMedia.contrast;
    await this._session.send("Page.setEmulatedMedia", {
      // Empty string means reset.
      type: emulatedMedia.media === "no-override" ? "" : emulatedMedia.media,
      colorScheme,
      reducedMotion,
      forcedColors,
      contrast
    });
  }
  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }
  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();
    await this._session.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async reload() {
    await this._session.send("Page.reload");
  }
  async goBack() {
    const { success } = await this._session.send("Page.goBack", { frameId: this._page.mainFrame()._id });
    return success;
  }
  async goForward() {
    const { success } = await this._session.send("Page.goForward", { frameId: this._page.mainFrame()._id });
    return success;
  }
  async requestGC() {
    await this._session.send("Heap.collectGarbage");
  }
  async addInitScript(initScript, worldName) {
    this._initScripts.push({ initScript, worldName });
    await this._updateInitScripts();
  }
  async removeInitScripts(initScripts) {
    const set2 = new Set(initScripts);
    this._initScripts = this._initScripts.filter((s) => !set2.has(s.initScript));
    await this._updateInitScripts();
  }
  async _updateInitScripts() {
    await this._session.send("Page.setInitScripts", { scripts: this._initScripts.map((s) => ({ script: s.initScript.source, worldName: s.worldName })) });
  }
  async closePage(runBeforeUnload) {
    await this._session.send("Page.close", { runBeforeUnload });
  }
  async setBackgroundColor(color) {
    if (color)
      throw new Error("Not implemented");
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    if (!documentRect) {
      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress3, () => ({ x: window.scrollX, y: window.scrollY }));
      documentRect = {
        x: viewportRect.x + scrollOffset.x,
        y: viewportRect.y + scrollOffset.y,
        width: viewportRect.width,
        height: viewportRect.height
      };
    }
    const { data } = await progress3.race(this._session.send("Page.screenshot", {
      mimeType: "image/" + format2,
      clip: documentRect,
      quality,
      omitDeviceScaleFactor: scale === "css"
    }));
    return Buffer.from(data, "base64");
  }
  async getContentFrame(handle) {
    const { contentFrameId } = await this._session.send("Page.describeNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!contentFrameId)
      return null;
    return this._page.frameManager.frame(contentFrameId);
  }
  async getOwnerFrame(handle) {
    const { ownerFrameId } = await this._session.send("Page.describeNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    return ownerFrameId || null;
  }
  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length)
      return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send("Page.scrollIntoViewIfNeeded", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
    if (options2) {
      const { screencastId } = await this._session.send("Page.startScreencast", options2);
      this._screencastId = screencastId;
    } else {
      await this._session.send("Page.stopScreencast");
    }
  }
  _onScreencastFrame(event) {
    if (!this._screencastId)
      return;
    const screencastId = this._screencastId;
    this._page.throttleScreencastFrameAck(() => {
      this._session.send("Page.screencastFrameAck", { screencastId }).catch((e) => debugLogger.log("error", e));
    });
    const buffer = Buffer.from(event.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }
  rafCountForStablePosition() {
    return 1;
  }
  async getContentQuads(handle) {
    const result = await this._session.sendMayFail("Page.getContentQuads", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!result)
      return null;
    return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
  }
  async setInputFilePaths(handle, files) {
    await this._session.send("Page.setFileInputFiles", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      files
    });
  }
  async adoptElementHandle(handle, to) {
    const result = await this._session.send("Page.adoptNode", {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      executionContextId: to.delegate._executionContextId
    });
    if (!result.remoteObject)
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle3(to, result.remoteObject);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree2(this._session, needle);
  }
  async inputActionEpilogue() {
  }
  async resetForReuse(progress3) {
    await this.rawMouse.move(progress3, -1, -1, "none", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), false);
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const context2 = await parent._mainContext();
    const result = await this._session.send("Page.adoptNode", {
      frameId: frame._id,
      executionContextId: context2.delegate._executionContextId
    });
    if (!result.remoteObject)
      throw new Error("Frame has been detached.");
    return createHandle3(context2, result.remoteObject);
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return false;
  }
};
function webSocketId(frameId, wsid) {
  return `${frameId}---${wsid}`;
}
__name(webSocketId, "webSocketId");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/ffBrowser.js
var FFBrowser = class _FFBrowser extends Browser {
  static {
    __name(this, "FFBrowser");
  }
  constructor(parent, connection, options2) {
    super(parent, options2);
    this._version = "";
    this._userAgent = "";
    this._connection = connection;
    this.session = connection.rootSession;
    this._ffPages = /* @__PURE__ */ new Map();
    this._contexts = /* @__PURE__ */ new Map();
    this._connection.on(ConnectionEvents2.Disconnected, () => this._onDisconnect());
    this.session.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
    this.session.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
    this.session.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
    this.session.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
    this.session.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
  }
  static async connect(parent, transport, options2) {
    const connection = new FFConnection(transport, options2.protocolLogger, options2.browserLogsCollector);
    const browser3 = new _FFBrowser(parent, connection, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    let firefoxUserPrefs = options2.originalLaunchOptions.firefoxUserPrefs ?? {};
    if (Object.keys(kBandaidFirefoxUserPrefs).length)
      firefoxUserPrefs = { ...kBandaidFirefoxUserPrefs, ...firefoxUserPrefs };
    const promises = [
      browser3.session.send("Browser.enable", {
        attachToDefaultContext: !!options2.persistent,
        userPrefs: Object.entries(firefoxUserPrefs).map(([name, value]) => ({ name, value }))
      }),
      browser3._initVersion()
    ];
    if (options2.persistent) {
      browser3._defaultContext = new FFBrowserContext(browser3, void 0, options2.persistent);
      promises.push(browser3._defaultContext._initialize());
    }
    const proxy = options2.originalLaunchOptions.proxyOverride || options2.proxy;
    if (proxy)
      promises.push(browser3.session.send("Browser.setBrowserProxy", toJugglerProxyOptions(proxy)));
    await Promise.all(promises);
    return browser3;
  }
  async _initVersion() {
    const result = await this.session.send("Browser.getInfo");
    this._version = result.version.substring(result.version.indexOf("/") + 1);
    this._userAgent = result.userAgent;
  }
  isConnected() {
    return !this._connection._closed;
  }
  async doCreateNewContext(options2) {
    if (options2.isMobile)
      throw new Error("options.isMobile is not supported in Firefox");
    const { browserContextId } = await this.session.send("Browser.createBrowserContext", { removeOnDetach: true });
    const context2 = new FFBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return this._version;
  }
  userAgent() {
    return this._userAgent;
  }
  _onDetachedFromTarget(payload) {
    const ffPage = this._ffPages.get(payload.targetId);
    this._ffPages.delete(payload.targetId);
    ffPage.didClose();
  }
  _onAttachedToTarget(payload) {
    const { targetId, browserContextId, openerId, type } = payload.targetInfo;
    assert3(type === "page");
    const context2 = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
    assert3(context2, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
    const session2 = this._connection.createSession(payload.sessionId);
    const opener = openerId ? this._ffPages.get(openerId) : null;
    const ffPage = new FFPage(session2, context2, opener);
    this._ffPages.set(targetId, ffPage);
  }
  _onDownloadCreated(payload) {
    const ffPage = this._ffPages.get(payload.pageTargetId);
    if (!ffPage)
      return;
    ffPage._page.frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
    let originPage = ffPage._page.initializedOrUndefined();
    if (!originPage) {
      ffPage._markAsError(new Error("Starting new page download"));
      if (ffPage._opener)
        originPage = ffPage._opener._page.initializedOrUndefined();
    }
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
  }
  _onDownloadFinished(payload) {
    const error3 = payload.canceled ? "canceled" : payload.error;
    this._downloadFinished(payload.uuid, error3);
  }
  _onVideoRecordingFinished(payload) {
    this._takeVideo(payload.screencastId)?.reportFinished();
  }
  _onDisconnect() {
    for (const video of this._idToVideo.values())
      video.artifact.reportFinished(new TargetClosedError());
    this._idToVideo.clear();
    for (const ffPage of this._ffPages.values())
      ffPage.didClose();
    this._ffPages.clear();
    this._didClose();
  }
};
var FFBrowserContext = class extends BrowserContext {
  static {
    __name(this, "FFBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
  }
  async _initialize() {
    assert3(!this._ffPages().length);
    const browserContextId = this._browserContextId;
    const promises = [
      super._initialize(),
      this._updateInitScripts()
    ];
    if (this._options.acceptDownloads !== "internal-browser-default") {
      promises.push(this._browser.session.send("Browser.setDownloadOptions", {
        browserContextId,
        downloadOptions: {
          behavior: this._options.acceptDownloads === "accept" ? "saveToDisk" : "cancel",
          downloadsDir: this._browser.options.downloadsPath
        }
      }));
    }
    promises.push(this.doUpdateDefaultViewport());
    if (this._options.hasTouch)
      promises.push(this._browser.session.send("Browser.setTouchOverride", { browserContextId, hasTouch: true }));
    if (this._options.userAgent)
      promises.push(this._browser.session.send("Browser.setUserAgentOverride", { browserContextId, userAgent: this._options.userAgent }));
    if (this._options.bypassCSP)
      promises.push(this._browser.session.send("Browser.setBypassCSP", { browserContextId, bypassCSP: true }));
    if (this._options.ignoreHTTPSErrors || this._options.internalIgnoreHTTPSErrors)
      promises.push(this._browser.session.send("Browser.setIgnoreHTTPSErrors", { browserContextId, ignoreHTTPSErrors: true }));
    if (this._options.javaScriptEnabled === false)
      promises.push(this._browser.session.send("Browser.setJavaScriptDisabled", { browserContextId, javaScriptDisabled: true }));
    if (this._options.locale)
      promises.push(this._browser.session.send("Browser.setLocaleOverride", { browserContextId, locale: this._options.locale }));
    if (this._options.timezoneId)
      promises.push(this._browser.session.send("Browser.setTimezoneOverride", { browserContextId, timezoneId: this._options.timezoneId }));
    if (this._options.extraHTTPHeaders || this._options.locale)
      promises.push(this.doUpdateExtraHTTPHeaders());
    if (this._options.httpCredentials)
      promises.push(this.setHTTPCredentials(this._options.httpCredentials));
    if (this._options.geolocation)
      promises.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline)
      promises.push(this.doUpdateOffline());
    promises.push(this.doUpdateDefaultEmulatedMedia());
    if (this._options.recordVideo) {
      promises.push(this._ensureVideosPath().then(() => {
        return this._browser.session.send("Browser.setVideoRecordingOptions", {
          // validateBrowserContextOptions ensures correct video size.
          options: {
            ...this._options.recordVideo.size,
            dir: this._options.recordVideo.dir
          },
          browserContextId: this._browserContextId
        });
      }));
    }
    const proxy = this._options.proxyOverride || this._options.proxy;
    if (proxy) {
      promises.push(this._browser.session.send("Browser.setContextProxy", {
        browserContextId: this._browserContextId,
        ...toJugglerProxyOptions(proxy)
      }));
    }
    await Promise.all(promises);
  }
  _ffPages() {
    return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._ffPages().map((ffPage) => ffPage._page);
  }
  async doCreateNewPage() {
    const { targetId } = await this._browser.session.send("Browser.newPage", {
      browserContextId: this._browserContextId
    }).catch((e) => {
      if (e.message.includes("Failed to override timezone"))
        throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
      throw e;
    });
    return this._browser._ffPages.get(targetId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser.session.send("Browser.getCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const { name, value, domain: domain2, path: path30, expires, httpOnly, secure, sameSite } = c;
      return {
        name,
        value,
        domain: domain2,
        path: path30,
        expires,
        httpOnly,
        secure,
        sameSite
      };
    }), urls);
  }
  async addCookies(cookies) {
    const cc = rewriteCookies(cookies).map((c) => {
      const { name, value, url: url4, domain: domain2, path: path30, expires, httpOnly, secure, sameSite } = c;
      return {
        name,
        value,
        url: url4,
        domain: domain2,
        path: path30,
        expires: expires === -1 ? void 0 : expires,
        httpOnly,
        secure,
        sameSite
      };
    });
    await this._browser.session.send("Browser.setCookies", { browserContextId: this._browserContextId, cookies: cc });
  }
  async doClearCookies() {
    await this._browser.session.send("Browser.clearCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geo"],
      ["persistent-storage", "persistent-storage"],
      ["push", "push"],
      ["notifications", "desktop-notification"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._browser.session.send("Browser.grantPermissions", { origin, browserContextId: this._browserContextId, permissions: filtered });
  }
  async doClearPermissions() {
    await this._browser.session.send("Browser.resetPermissions", { browserContextId: this._browserContextId });
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    await this._browser.session.send("Browser.setGeolocationOverride", { browserContextId: this._browserContextId, geolocation: geolocation || null });
  }
  async doUpdateExtraHTTPHeaders() {
    let allHeaders = this._options.extraHTTPHeaders || [];
    if (this._options.locale)
      allHeaders = mergeHeaders([allHeaders, singleHeader("Accept-Language", this._options.locale)]);
    await this._browser.session.send("Browser.setExtraHTTPHeaders", { browserContextId: this._browserContextId, headers: allHeaders });
  }
  async setUserAgent(userAgent) {
    await this._browser.session.send("Browser.setUserAgentOverride", { browserContextId: this._browserContextId, userAgent: userAgent || null });
  }
  async doUpdateOffline() {
    await this._browser.session.send("Browser.setOnlineOverride", { browserContextId: this._browserContextId, override: this._options.offline ? "offline" : "online" });
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    let credentials = null;
    if (httpCredentials) {
      const { username, password, origin } = httpCredentials;
      credentials = { username, password, origin };
    }
    await this._browser.session.send("Browser.setHTTPCredentials", { browserContextId: this._browserContextId, credentials });
  }
  async doAddInitScript(initScript) {
    await this._updateInitScripts();
  }
  async doRemoveInitScripts(initScripts) {
    await this._updateInitScripts();
  }
  async _updateInitScripts() {
    const bindingScripts = [...this._pageBindings.values()].map((binding3) => binding3.initScript.source);
    if (this.bindingsInitScript)
      bindingScripts.unshift(this.bindingsInitScript.source);
    const initScripts = this.initScripts.map((script) => script.source);
    await this._browser.session.send("Browser.setInitScripts", { browserContextId: this._browserContextId, scripts: [...bindingScripts, ...initScripts].map((script) => ({ script })) });
  }
  async doUpdateRequestInterception() {
    await Promise.all([
      this._browser.session.send("Browser.setRequestInterception", { browserContextId: this._browserContextId, enabled: this.requestInterceptors.length > 0 }),
      this._browser.session.send("Browser.setCacheDisabled", { browserContextId: this._browserContextId, cacheDisabled: this.requestInterceptors.length > 0 })
    ]);
  }
  async doUpdateDefaultViewport() {
    if (!this._options.viewport)
      return;
    const viewport = {
      viewportSize: { width: this._options.viewport.width, height: this._options.viewport.height },
      deviceScaleFactor: this._options.deviceScaleFactor || 1
    };
    await this._browser.session.send("Browser.setDefaultViewport", { browserContextId: this._browserContextId, viewport });
  }
  async doUpdateDefaultEmulatedMedia() {
    if (this._options.colorScheme !== "no-override") {
      await this._browser.session.send("Browser.setColorScheme", {
        browserContextId: this._browserContextId,
        colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
      });
    }
    if (this._options.reducedMotion !== "no-override") {
      await this._browser.session.send("Browser.setReducedMotion", {
        browserContextId: this._browserContextId,
        reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
      });
    }
    if (this._options.forcedColors !== "no-override") {
      await this._browser.session.send("Browser.setForcedColors", {
        browserContextId: this._browserContextId,
        forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
      });
    }
    if (this._options.contrast !== "no-override") {
      await this._browser.session.send("Browser.setContrast", {
        browserContextId: this._browserContextId,
        contrast: this._options.contrast !== void 0 ? this._options.contrast : "no-preference"
      });
    }
  }
  async doExposePlaywrightBinding() {
    this._browser.session.send("Browser.addBinding", { browserContextId: this._browserContextId, name: PageBinding.kBindingName, script: "" });
  }
  onClosePersistent() {
  }
  async clearCache() {
    await this._browser.session.send("Browser.clearCache");
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      if (this._options.recordVideo) {
        await this._browser.session.send("Browser.setVideoRecordingOptions", {
          options: void 0,
          browserContextId: this._browserContextId
        });
      }
      await this._browser.close({ reason });
    } else {
      await this._browser.session.send("Browser.removeBrowserContext", { browserContextId: this._browserContextId });
      this._browser._contexts.delete(this._browserContextId);
    }
  }
  async cancelDownload(uuid) {
    await this._browser.session.send("Browser.cancelDownload", { uuid });
  }
};
function toJugglerProxyOptions(proxy) {
  const proxyServer = new URL(proxy.server);
  let port = parseInt(proxyServer.port, 10);
  let type = "http";
  if (proxyServer.protocol === "socks5:")
    type = "socks";
  else if (proxyServer.protocol === "socks4:")
    type = "socks4";
  else if (proxyServer.protocol === "https:")
    type = "https";
  if (proxyServer.port === "") {
    if (proxyServer.protocol === "http:")
      port = 80;
    else if (proxyServer.protocol === "https:")
      port = 443;
  }
  return {
    type,
    bypass: proxy.bypass ? proxy.bypass.split(",").map((domain2) => domain2.trim()) : [],
    host: proxyServer.hostname,
    port,
    username: proxy.username,
    password: proxy.password
  };
}
__name(toJugglerProxyOptions, "toJugglerProxyOptions");
var kBandaidFirefoxUserPrefs = {};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/firefox/firefox.js
var Firefox = class extends BrowserType {
  static {
    __name(this, "Firefox");
  }
  constructor(parent) {
    super(parent, "firefox");
  }
  connectToTransport(transport, options2) {
    return FFBrowser.connect(this.attribution.playwright, transport, options2);
  }
  doRewriteStartupLog(error3) {
    if (!error3.logs)
      return error3;
    if (error3.logs.includes(`as root in a regular user's session is not supported.`))
      error3.logs = "\n" + wrapInASCIIBox(`Firefox is unable to launch if the $HOME folder isn't owned by the current user.
Workaround: Set the HOME=/root environment variable${process.env.GITHUB_ACTION ? " in your GitHub Actions workflow file" : ""} when running Playwright.`, 1);
    if (error3.logs.includes("no DISPLAY environment variable specified"))
      error3.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error3;
  }
  amendEnvironment(env3) {
    if (!path27.isAbsolute(os15.homedir()))
      throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os15.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
    if (os15.platform() === "linux") {
      return { ...env3, SNAP_NAME: void 0, SNAP_INSTANCE_NAME: void 0 };
    }
    return env3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    const message = { method: "Browser.close", params: {}, id: kBrowserCloseMessageId3 };
    transport.send(message);
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--profile");
    if (args.find((arg) => arg.startsWith("-juggler")))
      throw new Error("Use the port parameter instead of -juggler argument");
    const firefoxArguments = ["-no-remote"];
    if (headless) {
      firefoxArguments.push("-headless");
    } else {
      firefoxArguments.push("-wait-for-browser");
      firefoxArguments.push("-foreground");
    }
    firefoxArguments.push(`-profile`, userDataDir);
    firefoxArguments.push("-juggler-pipe");
    firefoxArguments.push(...args);
    if (isPersistent)
      firefoxArguments.push("about:blank");
    else
      firefoxArguments.push("-silent");
    return firefoxArguments;
  }
  waitForReadyState(options2, browserLogsCollector) {
    const result = new ManualPromise();
    browserLogsCollector.onMessage((message) => {
      if (message.includes("Juggler listening to the pipe"))
        result.resolve({});
    });
    return result;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/webkit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path29 from "node:path";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkConnection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { EventEmitter as EventEmitter17 } from "node:events";
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var kBrowserCloseMessageId4 = -9999;
var kPageProxyMessageReceived = Symbol("kPageProxyMessageReceived");
var WKConnection = class {
  static {
    __name(this, "WKConnection");
  }
  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
    this._lastId = 0;
    this._closed = false;
    this._transport = transport;
    this._onDisconnect = onDisconnect;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.browserSession = new WKSession(this, "", (message) => {
      this.rawSend(message);
    });
    this._transport.onmessage = this._dispatchMessage.bind(this);
    this._transport.onclose = this._onClose.bind(this);
  }
  nextMessageId() {
    return ++this._lastId;
  }
  rawSend(message) {
    this._protocolLogger("send", message);
    this._transport.send(message);
  }
  _dispatchMessage(message) {
    this._protocolLogger("receive", message);
    if (message.id === kBrowserCloseMessageId4)
      return;
    if (message.pageProxyId) {
      const payload = { message, pageProxyId: message.pageProxyId };
      this.browserSession.dispatchMessage({ method: kPageProxyMessageReceived, params: payload });
      return;
    }
    this.browserSession.dispatchMessage(message);
  }
  _onClose(reason) {
    this._closed = true;
    this._transport.onmessage = void 0;
    this._transport.onclose = void 0;
    this._browserDisconnectedLogs = helper.formatBrowserLogs(this._browserLogsCollector.recentLogs(), reason);
    this.browserSession.dispose();
    this._onDisconnect();
  }
  isClosed() {
    return this._closed;
  }
  close() {
    if (!this._closed)
      this._transport.close();
  }
};
var WKSession = class extends EventEmitter17 {
  static {
    __name(this, "WKSession");
  }
  constructor(connection, sessionId, rawSend) {
    super();
    this._disposed = false;
    this._callbacks = /* @__PURE__ */ new Map();
    this._crashed = false;
    this.setMaxListeners(0);
    this.connection = connection;
    this.sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.off = super.removeListener;
    this.addListener = super.addListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  async send(method, params) {
    if (this._crashed || this._disposed || this.connection._browserDisconnectedLogs)
      throw new ProtocolError(this._crashed ? "crashed" : "closed", void 0, this.connection._browserDisconnectedLogs);
    const id = this.connection.nextMessageId();
    const messageObj = { id, method, params };
    this._rawSend(messageObj);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, { resolve, reject, error: new ProtocolError("error", method) });
    });
  }
  sendMayFail(method, params) {
    return this.send(method, params).catch((error3) => debugLogger.log("error", error3));
  }
  markAsCrashed() {
    this._crashed = true;
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    for (const callback of this._callbacks.values()) {
      callback.error.type = this._crashed ? "crashed" : "closed";
      callback.error.logs = this.connection._browserDisconnectedLogs;
      callback.reject(callback.error);
    }
    this._callbacks.clear();
    this._disposed = true;
  }
  dispatchMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error) {
        callback.error.setMessage(object.error.message);
        callback.reject(callback.error);
      } else {
        callback.resolve(object.result);
      }
    } else if (object.id && !object.error) {
      assert3(this.isDisposed());
    } else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkBrowser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkPage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import path28 from "node:path";
import "node:fs";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkExecutionContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WKExecutionContext = class {
  static {
    __name(this, "WKExecutionContext");
  }
  constructor(session2, contextId) {
    this._session = session2;
    this._contextId = contextId;
  }
  async rawEvaluateJSON(expression) {
    try {
      const response = await this._session.send("Runtime.evaluate", {
        expression,
        contextId: this._contextId,
        returnByValue: true
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      return response.result.value;
    } catch (error3) {
      throw rewriteError3(error3);
    }
  }
  async rawEvaluateHandle(context2, expression) {
    try {
      const response = await this._session.send("Runtime.evaluate", {
        expression,
        contextId: this._contextId,
        returnByValue: false
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      return createHandle4(context2, response.result);
    } catch (error3) {
      throw rewriteError3(error3);
    }
  }
  async evaluateWithArguments(expression, returnByValue, utilityScript, values, handles) {
    try {
      const response = await this._session.send("Runtime.callFunctionOn", {
        functionDeclaration: expression,
        objectId: utilityScript._objectId,
        arguments: [
          { objectId: utilityScript._objectId },
          ...values.map((value) => ({ value })),
          ...handles.map((handle) => ({ objectId: handle._objectId }))
        ],
        returnByValue,
        emulateUserGesture: true,
        awaitPromise: true
      });
      if (response.wasThrown)
        throw new JavaScriptErrorInEvaluate(response.result.description);
      if (returnByValue)
        return parseEvaluationResultValue(response.result.value);
      return createHandle4(utilityScript._context, response.result);
    } catch (error3) {
      throw rewriteError3(error3);
    }
  }
  async getProperties(object) {
    const response = await this._session.send("Runtime.getProperties", {
      objectId: object._objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property of response.properties) {
      if (!property.enumerable || !property.value)
        continue;
      result.set(property.name, createHandle4(object._context, property.value));
    }
    return result;
  }
  async releaseHandle(handle) {
    if (!handle._objectId)
      return;
    await this._session.send("Runtime.releaseObject", { objectId: handle._objectId });
  }
};
function potentiallyUnserializableValue3(remoteObject) {
  const value = remoteObject.value;
  const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
  return isUnserializable ? parseUnserializableValue(remoteObject.description) : value;
}
__name(potentiallyUnserializableValue3, "potentiallyUnserializableValue");
function rewriteError3(error3) {
  if (error3.message.includes("Object has too long reference chain"))
    throw new Error("Cannot serialize result: object reference chain is too long.");
  if (!isJavaScriptErrorInEvaluate(error3) && !isSessionClosedError(error3))
    return new Error("Execution context was destroyed, most likely because of a navigation.");
  return error3;
}
__name(rewriteError3, "rewriteError");
function renderPreview4(object) {
  if (object.type === "undefined")
    return "undefined";
  if ("value" in object)
    return String(object.value);
  if (object.description === "Object" && object.preview) {
    const tokens = [];
    for (const { name, value } of object.preview.properties)
      tokens.push(`${name}: ${value}`);
    return `{${tokens.join(", ")}}`;
  }
  if (object.subtype === "array" && object.preview)
    return sparseArrayToString(object.preview.properties);
  return object.description;
}
__name(renderPreview4, "renderPreview");
function createHandle4(context2, remoteObject) {
  if (remoteObject.subtype === "node") {
    assert3(context2 instanceof FrameExecutionContext);
    return new ElementHandle(context2, remoteObject.objectId);
  }
  const isPromise = remoteObject.className === "Promise";
  return new JSHandle(context2, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview4(remoteObject), remoteObject.objectId, potentiallyUnserializableValue3(remoteObject));
}
__name(createHandle4, "createHandle");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkInput.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
function toModifiersMask3(modifiers) {
  let mask = 0;
  if (modifiers.has("Shift"))
    mask |= 1;
  if (modifiers.has("Control"))
    mask |= 2;
  if (modifiers.has("Alt"))
    mask |= 4;
  if (modifiers.has("Meta"))
    mask |= 8;
  return mask;
}
__name(toModifiersMask3, "toModifiersMask");
function toButtonsMask3(buttons) {
  let mask = 0;
  if (buttons.has("left"))
    mask |= 1;
  if (buttons.has("right"))
    mask |= 2;
  if (buttons.has("middle"))
    mask |= 4;
  return mask;
}
__name(toButtonsMask3, "toButtonsMask");
var RawKeyboardImpl4 = class {
  static {
    __name(this, "RawKeyboardImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async keydown(progress3, modifiers, keyName, description, autoRepeat) {
    const parts = [];
    for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
      if (modifiers.has(modifier))
        parts.push(modifier);
    }
    const { code, keyCode, key, text } = description;
    parts.push(code);
    const shortcut = parts.join("+");
    let commands = macEditingCommands[shortcut];
    if (isString(commands))
      commands = [commands];
    await progress3.race(this._pageProxySession.send("Input.dispatchKeyEvent", {
      type: "keyDown",
      modifiers: toModifiersMask3(modifiers),
      windowsVirtualKeyCode: keyCode,
      code,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      macCommands: commands,
      isKeypad: description.location === keypadLocation2
    }));
  }
  async keyup(progress3, modifiers, keyName, description) {
    const { code, key } = description;
    await progress3.race(this._pageProxySession.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: toModifiersMask3(modifiers),
      key,
      windowsVirtualKeyCode: description.keyCode,
      code,
      isKeypad: description.location === keypadLocation2
    }));
  }
  async sendText(progress3, text) {
    await progress3.race(this._session.send("Page.insertText", { text }));
  }
};
var RawMouseImpl4 = class {
  static {
    __name(this, "RawMouseImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  setSession(session2) {
    this._session = session2;
  }
  async move(progress3, x, y, button, buttons, modifiers, forClick) {
    await progress3.race(this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "move",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers)
    }));
  }
  async down(progress3, x, y, button, buttons, modifiers, clickCount) {
    await progress3.race(this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "down",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers),
      clickCount
    }));
  }
  async up(progress3, x, y, button, buttons, modifiers, clickCount) {
    await progress3.race(this._pageProxySession.send("Input.dispatchMouseEvent", {
      type: "up",
      button,
      buttons: toButtonsMask3(buttons),
      x,
      y,
      modifiers: toModifiersMask3(modifiers),
      clickCount
    }));
  }
  async wheel(progress3, x, y, buttons, modifiers, deltaX, deltaY) {
    if (this._page?.browserContext._options.isMobile)
      throw new Error("Mouse wheel is not supported in mobile WebKit");
    await this._session.send("Page.updateScrollingState");
    await progress3.race(this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, { world: "utility" }));
    await progress3.race(this._pageProxySession.send("Input.dispatchWheelEvent", {
      x,
      y,
      deltaX,
      deltaY,
      modifiers: toModifiersMask3(modifiers)
    }));
  }
  setPage(page) {
    this._page = page;
  }
};
var RawTouchscreenImpl4 = class {
  static {
    __name(this, "RawTouchscreenImpl");
  }
  constructor(session2) {
    this._pageProxySession = session2;
  }
  async tap(progress3, x, y, modifiers) {
    await progress3.race(this._pageProxySession.send("Input.dispatchTapEvent", {
      x,
      y,
      modifiers: toModifiersMask3(modifiers)
    }));
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkInterceptableRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var errorReasons2 = {
  "aborted": "Cancellation",
  "accessdenied": "AccessControl",
  "addressunreachable": "General",
  "blockedbyclient": "Cancellation",
  "blockedbyresponse": "General",
  "connectionaborted": "General",
  "connectionclosed": "General",
  "connectionfailed": "General",
  "connectionrefused": "General",
  "connectionreset": "General",
  "internetdisconnected": "General",
  "namenotresolved": "General",
  "timedout": "Timeout",
  "failed": "General"
};
var WKInterceptableRequest = class {
  static {
    __name(this, "WKInterceptableRequest");
  }
  constructor(session2, frame, event, redirectedFrom, documentId) {
    this._session = session2;
    this._requestId = event.requestId;
    const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
    let postDataBuffer = null;
    this._timestamp = event.timestamp;
    this._wallTime = event.walltime * 1e3;
    if (event.request.postData)
      postDataBuffer = Buffer.from(event.request.postData, "base64");
    this.request = new Request(
      frame._page.browserContext,
      frame,
      null,
      redirectedFrom?.request || null,
      documentId,
      event.request.url,
      resourceType,
      event.request.method,
      postDataBuffer,
      headersObjectToArray(event.request.headers)
    );
  }
  adoptRequestFromNewProcess(newSession, requestId) {
    this._session = newSession;
    this._requestId = requestId;
  }
  createResponse(responsePayload) {
    const getResponseBody = /* @__PURE__ */ __name(async () => {
      const response2 = await this._session.send("Network.getResponseBody", { requestId: this._requestId });
      return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
    }, "getResponseBody");
    const timingPayload = responsePayload.timing;
    const timing = {
      startTime: this._wallTime,
      domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
      domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
      connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
      secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
      connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
      requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
      responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
    };
    const setCookieSeparator = process.platform === "darwin" ? "," : "playwright-set-cookie-separator";
    const response = new Response2(this.request, responsePayload.status, responsePayload.statusText, headersObjectToArray(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody, responsePayload.source === "service-worker");
    response.setRawResponseHeaders(null);
    response.setTransferSize(null);
    if (responsePayload.requestHeaders && Object.keys(responsePayload.requestHeaders).length) {
      const headers = { ...responsePayload.requestHeaders };
      if (!headers["host"])
        headers["Host"] = new URL(this.request.url()).host;
      this.request.setRawRequestHeaders(headersObjectToArray(headers));
    } else {
      this.request.setRawRequestHeaders(null);
    }
    return response;
  }
};
var WKRouteImpl = class {
  static {
    __name(this, "WKRouteImpl");
  }
  constructor(session2, requestId) {
    this._session = session2;
    this._requestId = requestId;
  }
  async abort(errorCode) {
    const errorType = errorReasons2[errorCode];
    assert3(errorType, "Unknown error code: " + errorCode);
    await this._session.sendMayFail("Network.interceptRequestWithError", { requestId: this._requestId, errorType });
  }
  async fulfill(response) {
    if (300 <= response.status && response.status < 400)
      throw new Error("Cannot fulfill with redirect status: " + response.status);
    let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
    const headers = headersArrayToObject(
      response.headers,
      true
      /* lowerCase */
    );
    const contentType = headers["content-type"];
    if (contentType)
      mimeType = contentType.split(";")[0].trim();
    await this._session.sendMayFail("Network.interceptRequestWithResponse", {
      requestId: this._requestId,
      status: response.status,
      statusText: statusText(response.status),
      mimeType,
      headers,
      base64Encoded: response.isBase64,
      content: response.body
    });
  }
  async continue(overrides) {
    await this._session.sendMayFail("Network.interceptWithRequest", {
      requestId: this._requestId,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers ? headersArrayToObject(
        overrides.headers,
        false
        /* lowerCase */
      ) : void 0,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
    });
  }
};
function wkMillisToRoundishMillis(value) {
  if (value === -1e3)
    return -1;
  if (value <= 0) {
    return -1;
  }
  return (value * 1e3 | 0) / 1e3;
}
__name(wkMillisToRoundishMillis, "wkMillisToRoundishMillis");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkProvisionalPage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";
var WKProvisionalPage = class {
  static {
    __name(this, "WKProvisionalPage");
  }
  constructor(session2, page) {
    this._sessionListeners = [];
    this._mainFrameId = null;
    this._session = session2;
    this._wkPage = page;
    this._coopNavigationRequest = page._page.mainFrame().pendingDocument()?.request;
    const overrideFrameId = /* @__PURE__ */ __name((handler) => {
      return (payload) => {
        if (payload.frameId)
          payload.frameId = this._wkPage._page.frameManager.mainFrame()._id;
        handler(payload);
      };
    }, "overrideFrameId");
    const wkPage = this._wkPage;
    this._sessionListeners = [
      eventsHelper.addEventListener(session2, "Network.requestWillBeSent", overrideFrameId((e) => this._onRequestWillBeSent(e))),
      eventsHelper.addEventListener(session2, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session2, e))),
      eventsHelper.addEventListener(session2, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(session2, e))),
      eventsHelper.addEventListener(session2, "Network.loadingFinished", overrideFrameId((e) => this._onLoadingFinished(e))),
      eventsHelper.addEventListener(session2, "Network.loadingFailed", overrideFrameId((e) => this._onLoadingFailed(e)))
    ];
    this.initializationPromise = this._wkPage._initializeSession(session2, true, ({ frameTree }) => this._handleFrameTree(frameTree));
  }
  coopNavigationRequest() {
    return this._coopNavigationRequest;
  }
  dispose() {
    eventsHelper.removeEventListeners(this._sessionListeners);
  }
  commit() {
    assert3(this._mainFrameId);
    this._wkPage._onFrameAttached(this._mainFrameId, null);
  }
  _onRequestWillBeSent(event) {
    if (this._coopNavigationRequest && this._coopNavigationRequest.url() === event.request.url) {
      this._wkPage._adoptRequestFromNewProcess(this._coopNavigationRequest, this._session, event.requestId);
      return;
    }
    this._wkPage._onRequestWillBeSent(this._session, event);
  }
  _onLoadingFinished(event) {
    this._coopNavigationRequest = void 0;
    this._wkPage._onLoadingFinished(event);
  }
  _onLoadingFailed(event) {
    this._coopNavigationRequest = void 0;
    this._wkPage._onLoadingFailed(this._session, event);
  }
  _handleFrameTree(frameTree) {
    assert3(!frameTree.frame.parentId);
    this._mainFrameId = frameTree.frame.id;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkWorkers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WKWorkers = class {
  static {
    __name(this, "WKWorkers");
  }
  constructor(page) {
    this._sessionListeners = [];
    this._workerSessions = /* @__PURE__ */ new Map();
    this._page = page;
  }
  setSession(session2) {
    eventsHelper.removeEventListeners(this._sessionListeners);
    this.clear();
    this._sessionListeners = [
      eventsHelper.addEventListener(session2, "Worker.workerCreated", (event) => {
        const worker = new Worker(this._page, event.url);
        const workerSession = new WKSession(session2.connection, event.workerId, (message) => {
          session2.send("Worker.sendMessageToWorker", {
            workerId: event.workerId,
            message: JSON.stringify(message)
          }).catch((e) => {
            workerSession.dispatchMessage({ id: message.id, error: { message: e.message } });
          });
        });
        this._workerSessions.set(event.workerId, workerSession);
        worker.createExecutionContext(new WKExecutionContext(workerSession, void 0));
        this._page.addWorker(event.workerId, worker);
        workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
        Promise.all([
          workerSession.send("Runtime.enable"),
          workerSession.send("Console.enable"),
          session2.send("Worker.initialized", { workerId: event.workerId })
        ]).catch((e) => {
          this._page.removeWorker(event.workerId);
        });
      }),
      eventsHelper.addEventListener(session2, "Worker.dispatchMessageFromWorker", (event) => {
        const workerSession = this._workerSessions.get(event.workerId);
        if (!workerSession)
          return;
        workerSession.dispatchMessage(JSON.parse(event.message));
      }),
      eventsHelper.addEventListener(session2, "Worker.workerTerminated", (event) => {
        const workerSession = this._workerSessions.get(event.workerId);
        if (!workerSession)
          return;
        workerSession.dispose();
        this._workerSessions.delete(event.workerId);
        this._page.removeWorker(event.workerId);
      })
    ];
  }
  clear() {
    this._page.clearWorkers();
    this._workerSessions.clear();
  }
  async initializeSession(session2) {
    await session2.send("Worker.enable");
  }
  async _onConsoleMessage(worker, event) {
    const { type, level, text, parameters, url: url4, line: lineNumber, column: columnNumber } = event.message;
    let derivedType = type || "";
    if (type === "log")
      derivedType = level;
    else if (type === "timing")
      derivedType = "timeEnd";
    const handles = (parameters || []).map((p) => {
      return createHandle4(worker.existingExecutionContext, p);
    });
    const location2 = {
      url: url4 || "",
      lineNumber: (lineNumber || 1) - 1,
      columnNumber: (columnNumber || 1) - 1
    };
    this._page.addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkPage.js
var UTILITY_WORLD_NAME3 = "__playwright_utility_world__";
var WKPage = class _WKPage {
  static {
    __name(this, "WKPage");
  }
  constructor(browserContext, pageProxySession, opener) {
    this._provisionalPage = null;
    this._requestIdToRequest = /* @__PURE__ */ new Map();
    this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
    this._sessionListeners = [];
    this._firstNonInitialNavigationCommittedFulfill = () => {
    };
    this._firstNonInitialNavigationCommittedReject = (e) => {
    };
    this._lastConsoleMessage = null;
    this._requestIdToResponseReceivedPayloadEvent = /* @__PURE__ */ new Map();
    this._recordingVideoFile = null;
    this._screencastGeneration = 0;
    this._pageProxySession = pageProxySession;
    this._opener = opener;
    this.rawKeyboard = new RawKeyboardImpl4(pageProxySession);
    this.rawMouse = new RawMouseImpl4(pageProxySession);
    this.rawTouchscreen = new RawTouchscreenImpl4(pageProxySession);
    this._contextIdToContext = /* @__PURE__ */ new Map();
    this._page = new Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._workers = new WKWorkers(this._page);
    this._session = void 0;
    this._browserContext = browserContext;
    this._page.on(Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
    this._eventListeners = [
      eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)),
      eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))
    ];
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });
    this._firstNonInitialNavigationCommittedPromise.catch(() => {
    });
    if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
      const viewportSize = helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
      opener._nextWindowOpenPopupFeatures = void 0;
      if (viewportSize)
        this._page.setEmulatedSizeFromWindowOpen({ viewport: viewportSize, screen: viewportSize });
    }
  }
  async _initializePageProxySession() {
    if (this._page.isStorageStatePage)
      return;
    const promises = [
      this._pageProxySession.send("Dialog.enable"),
      this._pageProxySession.send("Emulation.setActiveAndFocused", { active: true })
    ];
    const contextOptions = this._browserContext._options;
    if (contextOptions.javaScriptEnabled === false)
      promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", { enabled: false }));
    promises.push(this._updateViewport());
    promises.push(this.updateHttpCredentials());
    if (this._browserContext._permissions.size) {
      for (const [key, value] of this._browserContext._permissions)
        promises.push(this._grantPermissions(key, value));
    }
    if (this._browserContext._options.recordVideo) {
      const outputFile = path28.join(this._browserContext._options.recordVideo.dir, createGuid() + ".webm");
      promises.push(this._browserContext._ensureVideosPath().then(() => {
        return this._startVideo({
          // validateBrowserContextOptions ensures correct video size.
          ...this._browserContext._options.recordVideo.size,
          outputFile
        });
      }));
    }
    await Promise.all(promises);
  }
  _setSession(session2) {
    eventsHelper.removeEventListeners(this._sessionListeners);
    this._session = session2;
    this.rawKeyboard.setSession(session2);
    this.rawMouse.setSession(session2);
    this._addSessionListeners();
    this._workers.setSession(session2);
  }
  // This method is called for provisional targets as well. The session passed as the parameter
  // may be different from the current session and may be destroyed without becoming current.
  async _initializeSession(session2, provisional, resourceTreeHandler) {
    await this._initializeSessionMayThrow(session2, resourceTreeHandler).catch((e) => {
      if (provisional && session2.isDisposed())
        return;
      if (this._session === session2)
        throw e;
    });
  }
  async _initializeSessionMayThrow(session2, resourceTreeHandler) {
    const [, frameTree] = await Promise.all([
      // Page agent must be enabled before Runtime.
      session2.send("Page.enable"),
      session2.send("Page.getResourceTree")
    ]);
    resourceTreeHandler(frameTree);
    const promises = [
      // Resource tree should be received before first execution context.
      session2.send("Runtime.enable"),
      session2.send("Page.createUserWorld", { name: UTILITY_WORLD_NAME3 }).catch((_) => {
      }),
      // Worlds are per-process
      session2.send("Console.enable"),
      session2.send("Network.enable"),
      this._workers.initializeSession(session2)
    ];
    if (this._page.browserContext.needsPlaywrightBinding())
      promises.push(session2.send("Runtime.addBinding", { name: PageBinding.kBindingName }));
    if (this._page.needsRequestInterception()) {
      promises.push(session2.send("Network.setInterceptionEnabled", { enabled: true }));
      promises.push(session2.send("Network.setResourceCachingDisabled", { disabled: true }));
      promises.push(session2.send("Network.addInterception", { url: ".*", stage: "request", isRegex: true }));
    }
    if (this._page.isStorageStatePage) {
      await Promise.all(promises);
      return;
    }
    const contextOptions = this._browserContext._options;
    if (contextOptions.userAgent)
      promises.push(this.updateUserAgent());
    const emulatedMedia = this._page.emulatedMedia();
    if (emulatedMedia.media || emulatedMedia.colorScheme || emulatedMedia.reducedMotion || emulatedMedia.forcedColors || emulatedMedia.contrast)
      promises.push(_WKPage._setEmulateMedia(session2, emulatedMedia.media, emulatedMedia.colorScheme, emulatedMedia.reducedMotion, emulatedMedia.forcedColors, emulatedMedia.contrast));
    const bootstrapScript = this._calculateBootstrapScript();
    if (bootstrapScript.length)
      promises.push(session2.send("Page.setBootstrapScript", { source: bootstrapScript }));
    this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript).catch((e) => {
    }));
    if (contextOptions.bypassCSP)
      promises.push(session2.send("Page.setBypassCSP", { enabled: true }));
    const emulatedSize = this._page.emulatedSize();
    if (emulatedSize) {
      promises.push(session2.send("Page.setScreenSizeOverride", {
        width: emulatedSize.screen.width,
        height: emulatedSize.screen.height
      }));
    }
    promises.push(this.updateEmulateMedia());
    promises.push(session2.send("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._calculateExtraHTTPHeaders(),
      false
      /* lowerCase */
    ) }));
    if (contextOptions.offline)
      promises.push(session2.send("Network.setEmulateOfflineState", { offline: true }));
    promises.push(session2.send("Page.setTouchEmulationEnabled", { enabled: !!contextOptions.hasTouch }));
    if (contextOptions.timezoneId) {
      promises.push(session2.send("Page.setTimeZone", { timeZone: contextOptions.timezoneId }).catch((e) => {
        throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
      }));
    }
    if (this._page.fileChooserIntercepted())
      promises.push(session2.send("Page.setInterceptFileChooserDialog", { enabled: true }));
    promises.push(session2.send("Page.overrideSetting", { setting: "DeviceOrientationEventEnabled", value: contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "FullScreenEnabled", value: !contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "NotificationsEnabled", value: !contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "PointerLockEnabled", value: !contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "InputTypeMonthEnabled", value: contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "InputTypeWeekEnabled", value: contextOptions.isMobile }));
    promises.push(session2.send("Page.overrideSetting", { setting: "FixedBackgroundsPaintRelativeToDocument", value: contextOptions.isMobile }));
    await Promise.all(promises);
  }
  _onDidCommitProvisionalTarget(event) {
    const { oldTargetId, newTargetId } = event;
    assert3(this._provisionalPage);
    assert3(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
    assert3(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
    const newSession = this._provisionalPage._session;
    this._provisionalPage.commit();
    this._provisionalPage.dispose();
    this._provisionalPage = null;
    this._setSession(newSession);
  }
  _onTargetDestroyed(event) {
    const { targetId, crashed } = event;
    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
      this._maybeCancelCoopNavigationRequest(this._provisionalPage);
      this._provisionalPage._session.dispose();
      this._provisionalPage.dispose();
      this._provisionalPage = null;
    } else if (this._session.sessionId === targetId) {
      this._session.dispose();
      eventsHelper.removeEventListeners(this._sessionListeners);
      if (crashed) {
        this._session.markAsCrashed();
        this._page._didCrash();
      }
    }
  }
  didClose() {
    this._pageProxySession.dispose();
    eventsHelper.removeEventListeners(this._sessionListeners);
    eventsHelper.removeEventListeners(this._eventListeners);
    if (this._session)
      this._session.dispose();
    if (this._provisionalPage) {
      this._provisionalPage._session.dispose();
      this._provisionalPage.dispose();
      this._provisionalPage = null;
    }
    this._firstNonInitialNavigationCommittedReject(new TargetClosedError());
    this._page._didClose();
  }
  dispatchMessageToSession(message) {
    this._pageProxySession.dispatchMessage(message);
  }
  handleProvisionalLoadFailed(event) {
    if (!this._page.initializedOrUndefined()) {
      this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
      return;
    }
    if (!this._provisionalPage)
      return;
    let errorText = event.error;
    if (errorText.includes("cancelled"))
      errorText += "; maybe frame was detached?";
    this._page.frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
  }
  handleWindowOpen(event) {
    this._nextWindowOpenPopupFeatures = event.windowFeatures;
  }
  async _onTargetCreated(event) {
    const { targetInfo } = event;
    const session2 = new WKSession(this._pageProxySession.connection, targetInfo.targetId, (message) => {
      this._pageProxySession.send("Target.sendMessageToTarget", {
        message: JSON.stringify(message),
        targetId: targetInfo.targetId
      }).catch((e) => {
        session2.dispatchMessage({ id: message.id, error: { message: e.message } });
      });
    });
    assert3(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
    if (!targetInfo.isProvisional) {
      assert3(!this._page.initializedOrUndefined());
      let pageOrError;
      try {
        this._setSession(session2);
        await Promise.all([
          this._initializePageProxySession(),
          this._initializeSession(session2, false, ({ frameTree }) => this._handleFrameTree(frameTree))
        ]);
        pageOrError = this._page;
      } catch (e) {
        pageOrError = e;
      }
      if (targetInfo.isPaused)
        this._pageProxySession.sendMayFail("Target.resume", { targetId: targetInfo.targetId });
      if (pageOrError instanceof Page && this._page.mainFrame().url() === "") {
        try {
          await this._firstNonInitialNavigationCommittedPromise;
        } catch (e) {
          pageOrError = e;
        }
      }
      this._page.reportAsNew(this._opener?._page, pageOrError instanceof Page ? void 0 : pageOrError);
    } else {
      assert3(targetInfo.isProvisional);
      assert3(!this._provisionalPage);
      this._provisionalPage = new WKProvisionalPage(session2, this);
      if (targetInfo.isPaused) {
        this._provisionalPage.initializationPromise.then(() => {
          this._pageProxySession.sendMayFail("Target.resume", { targetId: targetInfo.targetId });
        });
      }
    }
  }
  _onDispatchMessageFromTarget(event) {
    const { targetId, message } = event;
    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
      this._provisionalPage._session.dispatchMessage(JSON.parse(message));
    else if (this._session.sessionId === targetId)
      this._session.dispatchMessage(JSON.parse(message));
    else
      throw new Error("Unknown target: " + targetId);
  }
  _addSessionListeners() {
    this._sessionListeners = [
      eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)),
      eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)),
      eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)),
      eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)),
      eventsHelper.addEventListener(this._session, "Page.willCheckNavigationPolicy", (event) => this._onWillCheckNavigationPolicy(event.frameId)),
      eventsHelper.addEventListener(this._session, "Page.didCheckNavigationPolicy", (event) => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)),
      eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId, event.delay, event.targetIsCurrentFrame)),
      eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._page.frameManager.frameLifecycleEvent(event.frameId, "load")),
      eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._page.frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded")),
      eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)),
      eventsHelper.addEventListener(this._session, "Runtime.bindingCalled", (event) => this._onBindingCalled(event.contextId, event.argument)),
      eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)),
      eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)),
      eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)),
      eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)),
      eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)),
      eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(this._session, e)),
      eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page.frameManager.onWebSocketCreated(e.requestId, e.url)),
      eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page.frameManager.onWebSocketRequest(e.requestId)),
      eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page.frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page.frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page.frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)),
      eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page.frameManager.webSocketClosed(e.requestId)),
      eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page.frameManager.webSocketError(e.requestId, e.errorMessage))
    ];
  }
  async _updateState(method, params) {
    await this._forAllSessions((session2) => session2.send(method, params).then());
  }
  async _forAllSessions(callback) {
    const sessions = [
      this._session
    ];
    if (this._provisionalPage)
      sessions.push(this._provisionalPage._session);
    await Promise.all(sessions.map((session2) => callback(session2).catch((e) => {
    })));
  }
  _onWillCheckNavigationPolicy(frameId) {
    if (this._provisionalPage)
      return;
    this._page.frameManager.frameRequestedNavigation(frameId);
  }
  _onDidCheckNavigationPolicy(frameId, cancel) {
    if (!cancel)
      return;
    if (this._provisionalPage)
      return;
    this._page.frameManager.frameAbortedNavigation(frameId, "Navigation canceled by policy check");
  }
  _onFrameScheduledNavigation(frameId, delay, targetIsCurrentFrame) {
    if (targetIsCurrentFrame)
      this._page.frameManager.frameRequestedNavigation(frameId);
  }
  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
    this._onFrameNavigated(frameTree.frame, true);
    this._page.frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
    this._page.frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
    if (!frameTree.childFrames)
      return;
    for (const child of frameTree.childFrames)
      this._handleFrameTree(child);
  }
  _onFrameAttached(frameId, parentFrameId) {
    return this._page.frameManager.frameAttached(frameId, parentFrameId);
  }
  _onFrameNavigated(framePayload, initial) {
    const frame = this._page.frameManager.frame(framePayload.id);
    assert3(frame);
    this._removeContextsForFrame(frame, true);
    if (!framePayload.parentId)
      this._workers.clear();
    this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
    if (!initial)
      this._firstNonInitialNavigationCommittedFulfill();
  }
  _onFrameNavigatedWithinDocument(frameId, url4) {
    this._page.frameManager.frameCommittedSameDocumentNavigation(frameId, url4);
  }
  _onFrameDetached(frameId) {
    this._page.frameManager.frameDetached(frameId);
  }
  _removeContextsForFrame(frame, notifyFrame) {
    for (const [contextId, context2] of this._contextIdToContext) {
      if (context2.frame === frame) {
        this._contextIdToContext.delete(contextId);
        if (notifyFrame)
          frame._contextDestroyed(context2);
      }
    }
  }
  _onExecutionContextCreated(contextPayload) {
    if (this._contextIdToContext.has(contextPayload.id))
      return;
    const frame = this._page.frameManager.frame(contextPayload.frameId);
    if (!frame)
      return;
    const delegate = new WKExecutionContext(this._session, contextPayload.id);
    let worldName = null;
    if (contextPayload.type === "normal")
      worldName = "main";
    else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME3)
      worldName = "utility";
    const context2 = new FrameExecutionContext(delegate, frame, worldName);
    if (worldName)
      frame._contextCreated(worldName, context2);
    this._contextIdToContext.set(contextPayload.id, context2);
  }
  async _onBindingCalled(contextId, argument) {
    const pageOrError = await this._page.waitForInitializedOrError();
    if (!(pageOrError instanceof Error)) {
      const context2 = this._contextIdToContext.get(contextId);
      if (context2)
        await this._page.onBindingCalled(argument, context2);
    }
  }
  async navigateFrame(frame, url4, referrer) {
    if (this._pageProxySession.isDisposed())
      throw new TargetClosedError();
    const pageProxyId = this._pageProxySession.sessionId;
    const result = await this._pageProxySession.connection.browserSession.send("Playwright.navigate", { url: url4, pageProxyId, frameId: frame._id, referrer });
    return { newDocumentId: result.loaderId };
  }
  _onConsoleMessage(event) {
    const { type, level, text, parameters, url: url4, line: lineNumber, column: columnNumber, source: source8 } = event.message;
    if (level === "error" && source8 === "javascript") {
      const { name, message } = splitErrorMessage(text);
      let stack;
      if (event.message.stackTrace) {
        stack = text + "\n" + event.message.stackTrace.callFrames.map((callFrame) => {
          return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
        }).join("\n");
      } else {
        stack = "";
      }
      this._lastConsoleMessage = null;
      const error3 = new Error(message);
      error3.stack = stack;
      error3.name = name;
      this._page.emitOnContextOnceInitialized(BrowserContext.Events.PageError, error3, this._page);
      return;
    }
    let derivedType = type || "";
    if (type === "log")
      derivedType = level;
    else if (type === "timing")
      derivedType = "timeEnd";
    const handles = [];
    for (const p of parameters || []) {
      let context2;
      if (p.objectId) {
        const objectId = JSON.parse(p.objectId);
        context2 = this._contextIdToContext.get(objectId.injectedScriptId);
      } else {
        context2 = [...this._contextIdToContext.values()].find((c) => c.frame === this._page.mainFrame());
      }
      if (!context2)
        return;
      handles.push(createHandle4(context2, p));
    }
    this._lastConsoleMessage = {
      derivedType,
      text,
      handles,
      count: 0,
      location: {
        url: url4 || "",
        lineNumber: (lineNumber || 1) - 1,
        columnNumber: (columnNumber || 1) - 1
      }
    };
    this._onConsoleRepeatCountUpdated({ count: 1 });
  }
  _onConsoleRepeatCountUpdated(event) {
    if (this._lastConsoleMessage) {
      const {
        derivedType,
        text,
        handles,
        count: count3,
        location: location2
      } = this._lastConsoleMessage;
      for (let i = count3; i < event.count; ++i)
        this._page.addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
      this._lastConsoleMessage.count = event.count;
    }
  }
  _onDialog(event) {
    this._page.browserContext.dialogManager.dialogDidOpen(new Dialog(
      this._page,
      event.type,
      event.message,
      async (accept, promptText) => {
        if (event.type === "beforeunload" && !accept)
          this._page.frameManager.frameAbortedNavigation(this._page.mainFrame()._id, "navigation cancelled by beforeunload dialog");
        await this._pageProxySession.send("Dialog.handleJavaScriptDialog", { accept, promptText });
      },
      event.defaultPrompt
    ));
  }
  async _onFileChooserOpened(event) {
    let handle;
    try {
      const context2 = await this._page.frameManager.frame(event.frameId)._mainContext();
      handle = createHandle4(context2, event.element).asElement();
    } catch (e) {
      return;
    }
    await this._page._onFileChooserOpened(handle);
  }
  static async _setEmulateMedia(session2, mediaType, colorScheme, reducedMotion, forcedColors, contrast) {
    const promises = [];
    promises.push(session2.send("Page.setEmulatedMedia", { media: mediaType === "no-override" ? "" : mediaType }));
    let appearance = void 0;
    switch (colorScheme) {
      case "light":
        appearance = "Light";
        break;
      case "dark":
        appearance = "Dark";
        break;
      case "no-override":
        appearance = void 0;
        break;
    }
    promises.push(session2.send("Page.overrideUserPreference", { name: "PrefersColorScheme", value: appearance }));
    let reducedMotionWk = void 0;
    switch (reducedMotion) {
      case "reduce":
        reducedMotionWk = "Reduce";
        break;
      case "no-preference":
        reducedMotionWk = "NoPreference";
        break;
      case "no-override":
        reducedMotionWk = void 0;
        break;
    }
    promises.push(session2.send("Page.overrideUserPreference", { name: "PrefersReducedMotion", value: reducedMotionWk }));
    let forcedColorsWk = void 0;
    switch (forcedColors) {
      case "active":
        forcedColorsWk = "Active";
        break;
      case "none":
        forcedColorsWk = "None";
        break;
      case "no-override":
        forcedColorsWk = void 0;
        break;
    }
    promises.push(session2.send("Page.setForcedColors", { forcedColors: forcedColorsWk }));
    let contrastWk = void 0;
    switch (contrast) {
      case "more":
        contrastWk = "More";
        break;
      case "no-preference":
        contrastWk = "NoPreference";
        break;
      case "no-override":
        contrastWk = void 0;
        break;
    }
    promises.push(session2.send("Page.overrideUserPreference", { name: "PrefersContrast", value: contrastWk }));
    await Promise.all(promises);
  }
  async updateExtraHTTPHeaders() {
    await this._updateState("Network.setExtraHTTPHeaders", { headers: headersArrayToObject(
      this._calculateExtraHTTPHeaders(),
      false
      /* lowerCase */
    ) });
  }
  _calculateExtraHTTPHeaders() {
    const locale = this._browserContext._options.locale;
    const headers = mergeHeaders([
      this._browserContext._options.extraHTTPHeaders,
      this._page.extraHTTPHeaders(),
      locale ? singleHeader("Accept-Language", locale) : void 0
    ]);
    return headers;
  }
  async updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();
    const colorScheme = emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors;
    const contrast = emulatedMedia.contrast;
    await this._forAllSessions((session2) => _WKPage._setEmulateMedia(session2, emulatedMedia.media, colorScheme, reducedMotion, forcedColors, contrast));
  }
  async updateEmulatedViewportSize() {
    this._browserContext._validateEmulatedViewport(this._page.emulatedSize()?.viewport);
    await this._updateViewport();
  }
  async updateUserAgent() {
    const contextOptions = this._browserContext._options;
    this._updateState("Page.overrideUserAgent", { value: contextOptions.userAgent });
  }
  async bringToFront() {
    this._pageProxySession.send("Target.activate", {
      targetId: this._session.sessionId
    });
  }
  async _updateViewport() {
    const options2 = this._browserContext._options;
    const emulatedSize = this._page.emulatedSize();
    if (!emulatedSize)
      return;
    const viewportSize = emulatedSize.viewport;
    const screenSize = emulatedSize.screen;
    const promises = [
      this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
        width: viewportSize.width,
        height: viewportSize.height,
        fixedLayout: !!options2.isMobile,
        deviceScaleFactor: options2.deviceScaleFactor || 1
      }),
      this._session.send("Page.setScreenSizeOverride", {
        width: screenSize.width,
        height: screenSize.height
      })
    ];
    if (options2.isMobile) {
      const angle = viewportSize.width > viewportSize.height ? 90 : 0;
      promises.push(this._pageProxySession.send("Emulation.setOrientationOverride", { angle }));
    }
    await Promise.all(promises);
    if (!this._browserContext._browser?.options.headful && (hostPlatform === "ubuntu22.04-x64" || hostPlatform.startsWith("debian12")))
      await new Promise((r) => setTimeout(r, 500));
  }
  async updateRequestInterception() {
    const enabled = this._page.needsRequestInterception();
    await Promise.all([
      this._updateState("Network.setInterceptionEnabled", { enabled }),
      this._updateState("Network.setResourceCachingDisabled", { disabled: enabled }),
      this._updateState("Network.addInterception", { url: ".*", stage: "request", isRegex: true })
    ]);
  }
  async updateOffline() {
    await this._updateState("Network.setEmulateOfflineState", { offline: !!this._browserContext._options.offline });
  }
  async updateHttpCredentials() {
    const credentials = this._browserContext._options.httpCredentials || { username: "", password: "", origin: "" };
    await this._pageProxySession.send("Emulation.setAuthCredentials", { username: credentials.username, password: credentials.password, origin: credentials.origin });
  }
  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();
    await this._session.send("Page.setInterceptFileChooserDialog", { enabled }).catch(() => {
    });
  }
  async reload() {
    await this._session.send("Page.reload");
  }
  goBack() {
    return this._session.send("Page.goBack").then(() => true).catch((error3) => {
      if (error3 instanceof Error && error3.message.includes(`Protocol error (Page.goBack): Failed to go`))
        return false;
      throw error3;
    });
  }
  goForward() {
    return this._session.send("Page.goForward").then(() => true).catch((error3) => {
      if (error3 instanceof Error && error3.message.includes(`Protocol error (Page.goForward): Failed to go`))
        return false;
      throw error3;
    });
  }
  async requestGC() {
    await this._session.send("Heap.gc");
  }
  async addInitScript(initScript) {
    await this._updateBootstrapScript();
  }
  async removeInitScripts(initScripts) {
    await this._updateBootstrapScript();
  }
  async exposePlaywrightBinding() {
    await this._updateState("Runtime.addBinding", { name: PageBinding.kBindingName });
  }
  _calculateBootstrapScript() {
    const scripts = [];
    if (!this._page.browserContext._options.isMobile) {
      scripts.push("delete window.orientation");
      scripts.push("delete window.ondevicemotion");
      scripts.push("delete window.ondeviceorientation");
    }
    scripts.push('if (!window.safari) window.safari = { pushNotification: { toString() { return "[object SafariRemoteNotification]"; } } };');
    scripts.push("if (!window.GestureEvent) window.GestureEvent = function GestureEvent() {};");
    scripts.push(this._publicKeyCredentialScript());
    scripts.push(...this._page.allInitScripts().map((script) => script.source));
    return scripts.join(";\n");
  }
  _publicKeyCredentialScript() {
    function polyfill() {
      window.PublicKeyCredential ??= {
        async getClientCapabilities() {
          return {};
        },
        async isConditionalMediationAvailable() {
          return false;
        },
        async isUserVerifyingPlatformAuthenticatorAvailable() {
          return false;
        }
      };
    }
    __name(polyfill, "polyfill");
    return `(${polyfill.toString()})();`;
  }
  async _updateBootstrapScript() {
    await this._updateState("Page.setBootstrapScript", { source: this._calculateBootstrapScript() });
  }
  async closePage(runBeforeUnload) {
    await this._stopVideo();
    await this._pageProxySession.sendMayFail("Target.close", {
      targetId: this._session.sessionId,
      runBeforeUnload
    });
  }
  async setBackgroundColor(color) {
    await this._session.send("Page.setDefaultBackgroundColorOverride", { color });
  }
  _toolbarHeight() {
    if (this._page.browserContext._browser?.options.headful)
      return hostPlatform === "mac10.15" ? 55 : 59;
    return 0;
  }
  async _startVideo(options2) {
    assert3(!this._recordingVideoFile);
    const { screencastId } = await this._pageProxySession.send("Screencast.startVideo", {
      file: options2.outputFile,
      width: options2.width,
      height: options2.height,
      toolbarHeight: this._toolbarHeight()
    });
    this._recordingVideoFile = options2.outputFile;
    this._browserContext._browser._videoStarted(this._browserContext, screencastId, options2.outputFile, this._page.waitForInitializedOrError());
  }
  async _stopVideo() {
    if (!this._recordingVideoFile)
      return;
    await this._pageProxySession.sendMayFail("Screencast.stopVideo");
    this._recordingVideoFile = null;
  }
  validateScreenshotDimension(side, omitDeviceScaleFactor) {
    if (process.platform === "darwin")
      return;
    if (!omitDeviceScaleFactor && this._page.browserContext._options.deviceScaleFactor)
      side = Math.ceil(side * this._page.browserContext._options.deviceScaleFactor);
    if (side > 32767)
      throw new Error("Cannot take screenshot larger than 32767 pixels on any dimension");
  }
  async takeScreenshot(progress3, format2, documentRect, viewportRect, quality, fitsViewport, scale) {
    const rect = documentRect || viewportRect;
    const omitDeviceScaleFactor = scale === "css";
    this.validateScreenshotDimension(rect.width, omitDeviceScaleFactor);
    this.validateScreenshotDimension(rect.height, omitDeviceScaleFactor);
    const result = await progress3.race(this._session.send("Page.snapshotRect", { ...rect, coordinateSystem: documentRect ? "Page" : "Viewport", omitDeviceScaleFactor }));
    const prefix = "data:image/png;base64,";
    let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
    if (format2 === "jpeg")
      buffer = jpegjs2.encode(PNG2.sync.read(buffer), quality).data;
    return buffer;
  }
  async getContentFrame(handle) {
    const nodeInfo = await this._session.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    if (!nodeInfo.contentFrameId)
      return null;
    return this._page.frameManager.frame(nodeInfo.contentFrameId);
  }
  async getOwnerFrame(handle) {
    if (!handle._objectId)
      return null;
    const nodeInfo = await this._session.send("DOM.describeNode", {
      objectId: handle._objectId
    });
    return nodeInfo.ownerFrameId || null;
  }
  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length)
      return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }
    return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
  }
  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send("DOM.scrollIntoViewIfNeeded", {
      objectId: handle._objectId,
      rect
    }).then(() => "done").catch((e) => {
      if (e instanceof Error && e.message.includes("Node does not have a layout object"))
        return "error:notvisible";
      if (e instanceof Error && e.message.includes("Node is detached from document"))
        return "error:notconnected";
      throw e;
    });
  }
  async setScreencastOptions(options2) {
    if (options2) {
      const so = { ...options2, toolbarHeight: this._toolbarHeight() };
      const { generation } = await this._pageProxySession.send("Screencast.startScreencast", so);
      this._screencastGeneration = generation;
    } else {
      await this._pageProxySession.send("Screencast.stopScreencast");
    }
  }
  _onScreencastFrame(event) {
    const generation = this._screencastGeneration;
    this._page.throttleScreencastFrameAck(() => {
      this._pageProxySession.send("Screencast.screencastFrameAck", { generation }).catch((e) => debugLogger.log("error", e));
    });
    const buffer = Buffer.from(event.data, "base64");
    this._page.emit(Page.Events.ScreencastFrame, {
      buffer,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }
  rafCountForStablePosition() {
    return process.platform === "win32" ? 5 : 1;
  }
  async getContentQuads(handle) {
    const result = await this._session.sendMayFail("DOM.getContentQuads", {
      objectId: handle._objectId
    });
    if (!result)
      return null;
    return result.quads.map((quad) => [
      { x: quad[0], y: quad[1] },
      { x: quad[2], y: quad[3] },
      { x: quad[4], y: quad[5] },
      { x: quad[6], y: quad[7] }
    ]);
  }
  async setInputFilePaths(handle, paths) {
    const pageProxyId = this._pageProxySession.sessionId;
    const objectId = handle._objectId;
    await Promise.all([
      this._pageProxySession.connection.browserSession.send("Playwright.grantFileReadAccess", { pageProxyId, paths }),
      this._session.send("DOM.setInputFiles", { objectId, paths })
    ]);
  }
  async adoptElementHandle(handle, to) {
    const result = await this._session.sendMayFail("DOM.resolveNode", {
      objectId: handle._objectId,
      executionContextId: to.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error(kUnableToAdoptErrorMessage);
    return createHandle4(to, result.object);
  }
  async getAccessibilityTree(needle) {
    return getAccessibilityTree3(this._session, needle);
  }
  async inputActionEpilogue() {
  }
  async resetForReuse(progress3) {
  }
  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent)
      throw new Error("Frame has been detached.");
    const context2 = await parent._mainContext();
    const result = await this._session.send("DOM.resolveNode", {
      frameId: frame._id,
      executionContextId: context2.delegate._contextId
    });
    if (!result || result.object.subtype === "null")
      throw new Error("Frame has been detached.");
    return createHandle4(context2, result.object);
  }
  _maybeCancelCoopNavigationRequest(provisionalPage) {
    const navigationRequest = provisionalPage.coopNavigationRequest();
    for (const [requestId, request2] of this._requestIdToRequest) {
      if (request2.request === navigationRequest) {
        this._onLoadingFailed(provisionalPage._session, {
          requestId,
          errorText: "Provisiolal navigation canceled.",
          timestamp: request2._timestamp,
          canceled: true
        });
        return;
      }
    }
  }
  _adoptRequestFromNewProcess(navigationRequest, newSession, newRequestId) {
    for (const [requestId, request2] of this._requestIdToRequest) {
      if (request2.request === navigationRequest) {
        this._requestIdToRequest.delete(requestId);
        request2.adoptRequestFromNewProcess(newSession, newRequestId);
        this._requestIdToRequest.set(newRequestId, request2);
        return;
      }
    }
  }
  _onRequestWillBeSent(session2, event) {
    if (event.request.url.startsWith("data:"))
      return;
    if (event.request.url.startsWith("about:"))
      return;
    if (this._page.needsRequestInterception() && !event.redirectResponse)
      this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
    else
      this._onRequest(session2, event, false);
  }
  _onRequest(session2, event, intercepted) {
    let redirectedFrom = null;
    if (event.redirectResponse) {
      const request22 = this._requestIdToRequest.get(event.requestId);
      if (request22) {
        this._handleRequestRedirect(request22, event.requestId, event.redirectResponse, event.timestamp);
        redirectedFrom = request22;
      }
    }
    const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page.frameManager.frame(event.frameId);
    if (!frame)
      return;
    const isNavigationRequest = event.type === "Document";
    const documentId = isNavigationRequest ? event.loaderId : void 0;
    const request2 = new WKInterceptableRequest(session2, frame, event, redirectedFrom, documentId);
    let route;
    if (intercepted) {
      route = new WKRouteImpl(session2, event.requestId);
      request2.request.setRawRequestHeaders(null);
    }
    this._requestIdToRequest.set(event.requestId, request2);
    this._page.frameManager.requestStarted(request2.request, route);
  }
  _handleRequestRedirect(request2, requestId, responsePayload, timestamp2) {
    const response = request2.createResponse(responsePayload);
    response._securityDetailsFinished();
    response._serverAddrFinished();
    response.setResponseHeadersSize(null);
    response.setEncodedBodySize(null);
    response._requestFinished(responsePayload.timing ? helper.secondsToRoundishMillis(timestamp2 - request2._timestamp) : -1);
    this._requestIdToRequest.delete(requestId);
    this._page.frameManager.requestReceivedResponse(response);
    this._page.frameManager.reportRequestFinished(request2.request, response);
  }
  _onRequestIntercepted(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (!requestWillBeSentEvent) {
      session2.sendMayFail("Network.interceptWithRequest", { requestId: event.requestId });
      return;
    }
    this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
    this._onRequest(session2, requestWillBeSentEvent, true);
  }
  _onResponseReceived(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (requestWillBeSentEvent) {
      this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
      this._onRequest(session2, requestWillBeSentEvent, false);
    }
    const request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2)
      return;
    this._requestIdToResponseReceivedPayloadEvent.set(event.requestId, event);
    const response = request2.createResponse(event.response);
    this._page.frameManager.requestReceivedResponse(response);
    if (response.status() === 204 && request2.request.isNavigationRequest()) {
      this._onLoadingFailed(session2, {
        requestId: event.requestId,
        errorText: "Aborted: 204 No Content",
        timestamp: event.timestamp
      });
    }
  }
  _onLoadingFinished(event) {
    const request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2)
      return;
    const response = request2.request._existingResponse();
    if (response) {
      const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(event.requestId);
      response._serverAddrFinished(parseRemoteAddress(event?.metrics?.remoteAddress));
      response._securityDetailsFinished({
        protocol: isLoadedSecurely(response.url(), response.timing()) ? event.metrics?.securityConnection?.protocol : void 0,
        subjectName: responseReceivedPayload?.response.security?.certificate?.subject,
        validFrom: responseReceivedPayload?.response.security?.certificate?.validFrom,
        validTo: responseReceivedPayload?.response.security?.certificate?.validUntil
      });
      if (event.metrics?.protocol)
        response._setHttpVersion(event.metrics.protocol);
      response.setEncodedBodySize(event.metrics?.responseBodyBytesReceived ?? null);
      response.setResponseHeadersSize(event.metrics?.responseHeaderBytesReceived ?? null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request2._timestamp));
    } else {
      request2.request.setRawRequestHeaders(null);
    }
    this._requestIdToResponseReceivedPayloadEvent.delete(event.requestId);
    this._requestIdToRequest.delete(event.requestId);
    this._page.frameManager.reportRequestFinished(request2.request, response);
  }
  _onLoadingFailed(session2, event) {
    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
    if (requestWillBeSentEvent) {
      this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
      this._onRequest(session2, requestWillBeSentEvent, false);
    }
    const request2 = this._requestIdToRequest.get(event.requestId);
    if (!request2)
      return;
    const response = request2.request._existingResponse();
    if (response) {
      response._serverAddrFinished();
      response._securityDetailsFinished();
      response.setResponseHeadersSize(null);
      response.setEncodedBodySize(null);
      response._requestFinished(helper.secondsToRoundishMillis(event.timestamp - request2._timestamp));
    } else {
      request2.request.setRawRequestHeaders(null);
    }
    this._requestIdToRequest.delete(event.requestId);
    request2.request._setFailureText(event.errorText);
    this._page.frameManager.requestFailed(request2.request, event.errorText.includes("cancelled"));
  }
  async _grantPermissions(origin, permissions) {
    const webPermissionToProtocol = /* @__PURE__ */ new Map([
      ["geolocation", "geolocation"],
      ["notifications", "notifications"],
      ["clipboard-read", "clipboard-read"]
    ]);
    const filtered = permissions.map((permission2) => {
      const protocolPermission = webPermissionToProtocol.get(permission2);
      if (!protocolPermission)
        throw new Error("Unknown permission: " + permission2);
      return protocolPermission;
    });
    await this._pageProxySession.send("Emulation.grantPermissions", { origin, permissions: filtered });
  }
  async _clearPermissions() {
    await this._pageProxySession.send("Emulation.resetPermissions", {});
  }
  shouldToggleStyleSheetToSyncAnimations() {
    return true;
  }
};
function parseRemoteAddress(value) {
  if (!value)
    return;
  try {
    const colon = value.lastIndexOf(":");
    const dot = value.lastIndexOf(".");
    if (dot < 0) {
      return {
        ipAddress: `[${value.slice(0, colon)}]`,
        port: +value.slice(colon + 1)
      };
    }
    if (colon > dot) {
      const [address, port] = value.split(":");
      return {
        ipAddress: address,
        port: +port
      };
    } else {
      const [address, port] = value.split(".");
      return {
        ipAddress: `[${address}]`,
        port: +port
      };
    }
  } catch (_) {
  }
}
__name(parseRemoteAddress, "parseRemoteAddress");
function isLoadedSecurely(url4, timing) {
  try {
    const u = new URL(url4);
    if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
      return false;
    if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
      return false;
    return true;
  } catch (_) {
  }
}
__name(isLoadedSecurely, "isLoadedSecurely");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/wkBrowser.js
var BROWSER_VERSION = "26.0";
var DEFAULT_USER_AGENT = `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/${BROWSER_VERSION} Safari/605.1.15`;
var WKBrowser = class _WKBrowser extends Browser {
  static {
    __name(this, "WKBrowser");
  }
  constructor(parent, transport, options2) {
    super(parent, options2);
    this._contexts = /* @__PURE__ */ new Map();
    this._wkPages = /* @__PURE__ */ new Map();
    this._connection = new WKConnection(transport, this._onDisconnect.bind(this), options2.protocolLogger, options2.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._browserSession.on("Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this));
    this._browserSession.on("Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this));
    this._browserSession.on("Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event));
    this._browserSession.on("Playwright.windowOpen", (event) => this._onWindowOpen(event));
    this._browserSession.on("Playwright.downloadCreated", this._onDownloadCreated.bind(this));
    this._browserSession.on("Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this));
    this._browserSession.on("Playwright.downloadFinished", this._onDownloadFinished.bind(this));
    this._browserSession.on("Playwright.screencastFinished", this._onScreencastFinished.bind(this));
    this._browserSession.on(kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this));
  }
  static async connect(parent, transport, options2) {
    const browser3 = new _WKBrowser(parent, transport, options2);
    if (options2.__testHookOnConnectToBrowser)
      await options2.__testHookOnConnectToBrowser();
    const promises = [
      browser3._browserSession.send("Playwright.enable")
    ];
    if (options2.persistent) {
      options2.persistent.userAgent ||= DEFAULT_USER_AGENT;
      browser3._defaultContext = new WKBrowserContext(browser3, void 0, options2.persistent);
      promises.push(browser3._defaultContext._initialize());
    }
    await Promise.all(promises);
    return browser3;
  }
  _onDisconnect() {
    for (const wkPage of this._wkPages.values())
      wkPage.didClose();
    this._wkPages.clear();
    for (const video of this._idToVideo.values())
      video.artifact.reportFinished(new TargetClosedError());
    this._idToVideo.clear();
    this._didClose();
  }
  async doCreateNewContext(options2) {
    const proxy = options2.proxyOverride || options2.proxy;
    const createOptions = proxy ? {
      // Enable socks5 hostname resolution on Windows.
      // See https://github.com/microsoft/playwright/issues/20451
      proxyServer: process.platform === "win32" ? proxy.server.replace(/^socks5:\/\//, "socks5h://") : proxy.server,
      proxyBypassList: proxy.bypass
    } : void 0;
    const { browserContextId } = await this._browserSession.send("Playwright.createContext", createOptions);
    options2.userAgent = options2.userAgent || DEFAULT_USER_AGENT;
    const context2 = new WKBrowserContext(this, browserContextId, options2);
    await context2._initialize();
    this._contexts.set(browserContextId, context2);
    return context2;
  }
  contexts() {
    return Array.from(this._contexts.values());
  }
  version() {
    return BROWSER_VERSION;
  }
  userAgent() {
    return DEFAULT_USER_AGENT;
  }
  _onDownloadCreated(payload) {
    const page = this._wkPages.get(payload.pageProxyId);
    if (!page)
      return;
    page._page.frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
    let originPage = page._page.initializedOrUndefined();
    if (!originPage) {
      page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
      if (page._opener)
        originPage = page._opener._page.initializedOrUndefined();
    }
    if (!originPage)
      return;
    this._downloadCreated(originPage, payload.uuid, payload.url);
  }
  _onDownloadFilenameSuggested(payload) {
    this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
  }
  _onDownloadFinished(payload) {
    this._downloadFinished(payload.uuid, payload.error);
  }
  _onScreencastFinished(payload) {
    this._takeVideo(payload.screencastId)?.reportFinished();
  }
  _onPageProxyCreated(event) {
    const pageProxyId = event.pageProxyId;
    let context2 = null;
    if (event.browserContextId) {
      context2 = this._contexts.get(event.browserContextId) || null;
    }
    if (!context2)
      context2 = this._defaultContext;
    if (!context2)
      return;
    const pageProxySession = new WKSession(this._connection, pageProxyId, (message) => {
      this._connection.rawSend({ ...message, pageProxyId });
    });
    const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
    const wkPage = new WKPage(context2, pageProxySession, opener || null);
    this._wkPages.set(pageProxyId, wkPage);
  }
  _onPageProxyDestroyed(event) {
    const pageProxyId = event.pageProxyId;
    const wkPage = this._wkPages.get(pageProxyId);
    if (!wkPage)
      return;
    this._wkPages.delete(pageProxyId);
    wkPage.didClose();
  }
  _onPageProxyMessageReceived(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.dispatchMessageToSession(event.message);
  }
  _onProvisionalLoadFailed(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.handleProvisionalLoadFailed(event);
  }
  _onWindowOpen(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);
    if (!wkPage)
      return;
    wkPage.handleWindowOpen(event);
  }
  isConnected() {
    return !this._connection.isClosed();
  }
};
var WKBrowserContext = class extends BrowserContext {
  static {
    __name(this, "WKBrowserContext");
  }
  constructor(browser3, browserContextId, options2) {
    super(browser3, options2, browserContextId);
    this._validateEmulatedViewport(options2.viewport);
    this._authenticateProxyViaHeader();
  }
  async _initialize() {
    assert3(!this._wkPages().length);
    const browserContextId = this._browserContextId;
    const promises = [super._initialize()];
    promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
      behavior: this._options.acceptDownloads === "accept" ? "allow" : "deny",
      downloadPath: this._browser.options.downloadsPath,
      browserContextId
    }));
    if (this._options.ignoreHTTPSErrors || this._options.internalIgnoreHTTPSErrors)
      promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", { browserContextId, ignore: true }));
    if (this._options.locale)
      promises.push(this._browser._browserSession.send("Playwright.setLanguages", { browserContextId, languages: [this._options.locale] }));
    if (this._options.geolocation)
      promises.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline)
      promises.push(this.doUpdateOffline());
    if (this._options.httpCredentials)
      promises.push(this.setHTTPCredentials(this._options.httpCredentials));
    await Promise.all(promises);
  }
  _wkPages() {
    return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
  }
  possiblyUninitializedPages() {
    return this._wkPages().map((wkPage) => wkPage._page);
  }
  async doCreateNewPage() {
    const { pageProxyId } = await this._browser._browserSession.send("Playwright.createPage", { browserContextId: this._browserContextId });
    return this._browser._wkPages.get(pageProxyId)._page;
  }
  async doGetCookies(urls) {
    const { cookies } = await this._browser._browserSession.send("Playwright.getAllCookies", { browserContextId: this._browserContextId });
    return filterCookies(cookies.map((c) => {
      const { name, value, domain: domain2, path: path30, expires, httpOnly, secure, sameSite } = c;
      const copy = {
        name,
        value,
        domain: domain2,
        path: path30,
        expires: expires === -1 ? -1 : expires / 1e3,
        httpOnly,
        secure,
        sameSite
      };
      return copy;
    }), urls);
  }
  async addCookies(cookies) {
    const cc = rewriteCookies(cookies).map((c) => {
      const { name, value, domain: domain2, path: path30, expires, httpOnly, secure, sameSite } = c;
      const copy = {
        name,
        value,
        domain: domain2,
        path: path30,
        expires: expires && expires !== -1 ? expires * 1e3 : expires,
        httpOnly,
        secure,
        sameSite,
        session: expires === -1 || expires === void 0
      };
      return copy;
    });
    await this._browser._browserSession.send("Playwright.setCookies", { cookies: cc, browserContextId: this._browserContextId });
  }
  async doClearCookies() {
    await this._browser._browserSession.send("Playwright.deleteAllCookies", { browserContextId: this._browserContextId });
  }
  async doGrantPermissions(origin, permissions) {
    await Promise.all(this.pages().map((page) => page.delegate._grantPermissions(origin, permissions)));
  }
  async doClearPermissions() {
    await Promise.all(this.pages().map((page) => page.delegate._clearPermissions()));
  }
  async setGeolocation(geolocation) {
    verifyGeolocation(geolocation);
    this._options.geolocation = geolocation;
    const payload = geolocation ? { ...geolocation, timestamp: Date.now() } : void 0;
    await this._browser._browserSession.send("Playwright.setGeolocationOverride", { browserContextId: this._browserContextId, geolocation: payload });
  }
  async doUpdateExtraHTTPHeaders() {
    for (const page of this.pages())
      await page.delegate.updateExtraHTTPHeaders();
  }
  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;
    for (const page of this.pages())
      await page.delegate.updateUserAgent();
  }
  async doUpdateOffline() {
    for (const page of this.pages())
      await page.delegate.updateOffline();
  }
  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    for (const page of this.pages())
      await page.delegate.updateHttpCredentials();
  }
  async doAddInitScript(initScript) {
    for (const page of this.pages())
      await page.delegate._updateBootstrapScript();
  }
  async doRemoveInitScripts(initScripts) {
    for (const page of this.pages())
      await page.delegate._updateBootstrapScript();
  }
  async doUpdateRequestInterception() {
    for (const page of this.pages())
      await page.delegate.updateRequestInterception();
  }
  async doUpdateDefaultViewport() {
  }
  async doUpdateDefaultEmulatedMedia() {
  }
  async doExposePlaywrightBinding() {
    for (const page of this.pages())
      await page.delegate.exposePlaywrightBinding();
  }
  onClosePersistent() {
  }
  async clearCache() {
    await this._browser._browserSession.send("Playwright.clearMemoryCache", {
      browserContextId: this._browserContextId
    });
  }
  async doClose(reason) {
    if (!this._browserContextId) {
      await Promise.all(this._wkPages().map((wkPage) => wkPage._stopVideo()));
      await this._browser.close({ reason });
    } else {
      await this._browser._browserSession.send("Playwright.deleteContext", { browserContextId: this._browserContextId });
      this._browser._contexts.delete(this._browserContextId);
    }
  }
  async cancelDownload(uuid) {
    await this._browser._browserSession.send("Playwright.cancelDownload", { uuid });
  }
  _validateEmulatedViewport(viewportSize) {
    if (!viewportSize)
      return;
    if (process.platform === "win32" && this._browser.options.headful && (viewportSize.width < 250 || viewportSize.height < 240))
      throw new Error(`WebKit on Windows has a minimal viewport of 250x240.`);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/webkit/webkit.js
var WebKit = class extends BrowserType {
  static {
    __name(this, "WebKit");
  }
  constructor(parent) {
    super(parent, "webkit");
  }
  connectToTransport(transport, options2) {
    return WKBrowser.connect(this.attribution.playwright, transport, options2);
  }
  amendEnvironment(env3, userDataDir, isPersistent) {
    return {
      ...env3,
      CURL_COOKIE_JAR_PATH: process.platform === "win32" && isPersistent ? path29.join(userDataDir, "cookiejar.db") : void 0
    };
  }
  doRewriteStartupLog(error3) {
    if (!error3.logs)
      return error3;
    if (error3.logs.includes("Failed to open display") || error3.logs.includes("cannot open display"))
      error3.logs = "\n" + wrapInASCIIBox(kNoXServerRunningError, 1);
    return error3;
  }
  attemptToGracefullyCloseBrowser(transport) {
    transport.send({ method: "Playwright.close", params: {}, id: kBrowserCloseMessageId4 });
  }
  defaultArgs(options2, isPersistent, userDataDir) {
    const { args = [], headless } = options2;
    const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
    if (userDataDirArg)
      throw this._createUserDataDirArgMisuseError("--user-data-dir");
    if (args.find((arg) => !arg.startsWith("-")))
      throw new Error("Arguments can not specify page to be opened");
    const webkitArguments = ["--inspector-pipe"];
    if (process.platform === "win32")
      webkitArguments.push("--disable-accelerated-compositing");
    if (headless)
      webkitArguments.push("--headless");
    if (isPersistent)
      webkitArguments.push(`--user-data-dir=${userDataDir}`);
    else
      webkitArguments.push(`--no-startup-window`);
    const proxy = options2.proxyOverride || options2.proxy;
    if (proxy) {
      if (process.platform === "darwin") {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass)
          webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
      } else if (process.platform === "linux") {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass)
          webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
      } else if (process.platform === "win32") {
        webkitArguments.push(`--curl-proxy=${proxy.server.replace(/^socks5:\/\//, "socks5h://")}`);
        if (proxy.bypass)
          webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
      }
    }
    webkitArguments.push(...args);
    if (isPersistent)
      webkitArguments.push("about:blank");
    return webkitArguments;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/playwright.js
var Playwright = class extends SdkObject {
  static {
    __name(this, "Playwright");
  }
  constructor(options2) {
    super(createRootSdkObject(), void 0, "Playwright");
    this._allPages = /* @__PURE__ */ new Set();
    this._allBrowsers = /* @__PURE__ */ new Set();
    this.options = options2;
    this.attribution.playwright = this;
    this.instrumentation.addListener({
      onBrowserOpen: /* @__PURE__ */ __name((browser3) => this._allBrowsers.add(browser3), "onBrowserOpen"),
      onBrowserClose: /* @__PURE__ */ __name((browser3) => this._allBrowsers.delete(browser3), "onBrowserClose"),
      onPageOpen: /* @__PURE__ */ __name((page) => this._allPages.add(page), "onPageOpen"),
      onPageClose: /* @__PURE__ */ __name((page) => this._allPages.delete(page), "onPageClose")
    }, null);
    this.chromium = new Chromium(this);
    this._bidiChromium = new BidiChromium(this);
    this._bidiFirefox = new BidiFirefox(this);
    this.firefox = new Firefox(this);
    this.webkit = new WebKit(this);
    this.electron = new Electron(this);
    this.android = new Android(this, new AdbBackend());
    this.debugController = new DebugController(this);
  }
  allBrowsers() {
    return [...this._allBrowsers];
  }
  allPages() {
    return [...this._allPages];
  }
};
function createPlaywright(options2) {
  return new Playwright(options2);
}
__name(createPlaywright, "createPlaywright");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/semaphore.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Semaphore = class {
  static {
    __name(this, "Semaphore");
  }
  constructor(max) {
    this._acquired = 0;
    this._queue = [];
    this._max = max;
  }
  setMax(max) {
    this._max = max;
  }
  acquire() {
    const lock = new ManualPromise();
    this._queue.push(lock);
    this._flush();
    return lock;
  }
  release() {
    --this._acquired;
    this._flush();
  }
  _flush() {
    while (this._acquired < this._max && this._queue.length) {
      ++this._acquired;
      this._queue.shift().resolve();
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/server/utils/wsServer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var lastConnectionId = 0;
var kConnectionSymbol = Symbol("kConnection");
var perMessageDeflate = {
  serverNoContextTakeover: true,
  zlibDeflateOptions: {
    level: 3
  },
  zlibInflateOptions: {
    chunkSize: 10 * 1024
  },
  threshold: 10 * 1024
};
var WSServer = class {
  static {
    __name(this, "WSServer");
  }
  constructor(delegate) {
    this._delegate = delegate;
  }
  async listen(port = 0, hostname, path30) {
    debugLogger.log("server", `Server started at ${/* @__PURE__ */ new Date()}`);
    const server = createHttpServer(this._delegate.onRequest);
    server.on("error", (error3) => debugLogger.log("server", String(error3)));
    this.server = server;
    const wsEndpoint = await new Promise((resolve, reject) => {
      server.listen(port, hostname, () => {
        const address = server.address();
        if (!address) {
          reject(new Error("Could not bind server socket"));
          return;
        }
        const wsEndpoint2 = typeof address === "string" ? `${address}${path30}` : `ws://${hostname || "localhost"}:${address.port}${path30}`;
        resolve(wsEndpoint2);
      }).on("error", reject);
    });
    debugLogger.log("server", "Listening at " + wsEndpoint);
    this._wsServer = new wsServer2({
      noServer: true,
      perMessageDeflate
    });
    this._wsServer.on("headers", (headers) => this._delegate.onHeaders(headers));
    server.on("upgrade", (request2, socket, head) => {
      const pathname = new URL("http://localhost" + request2.url).pathname;
      if (pathname !== path30) {
        socket.write(`HTTP/${request2.httpVersion} 400 Bad Request\r
\r
`);
        socket.destroy();
        return;
      }
      const upgradeResult = this._delegate.onUpgrade(request2, socket);
      if (upgradeResult) {
        socket.write(upgradeResult.error);
        socket.destroy();
        return;
      }
      this._wsServer.handleUpgrade(request2, socket, head, (ws3) => this._wsServer.emit("connection", ws3, request2));
    });
    this._wsServer.on("connection", (ws3, request2) => {
      debugLogger.log("server", "Connected client ws.extension=" + ws3.extensions);
      const url4 = new URL("http://localhost" + (request2.url || ""));
      const id = String(++lastConnectionId);
      debugLogger.log("server", `[${id}] serving connection: ${request2.url}`);
      try {
        const connection = this._delegate.onConnection(request2, url4, ws3, id);
        ws3[kConnectionSymbol] = connection;
      } catch (error3) {
        debugLogger.log("server", `[${id}] connection error: ${error3}`);
        ws3.close(1011, String(error3));
      }
    });
    return wsEndpoint;
  }
  async close() {
    const server = this._wsServer;
    if (!server)
      return;
    debugLogger.log("server", "closing websocket server");
    const waitForClose = new Promise((f) => server.close(f));
    await Promise.all(Array.from(server.clients).map(async (ws3) => {
      const connection = ws3[kConnectionSymbol];
      if (connection)
        await connection.close();
      try {
        ws3.terminate();
      } catch (e) {
      }
    }));
    await waitForClose;
    debugLogger.log("server", "closing http server");
    if (this.server)
      await new Promise((f) => this.server.close(f));
    this._wsServer = void 0;
    this.server = void 0;
    debugLogger.log("server", "closed server");
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/remote/playwrightServer.js
import "node:crypto";
import "node:fs";
import "node:path";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
var PlaywrightServer = class {
  static {
    __name(this, "PlaywrightServer");
  }
  constructor(options2) {
    this._dontReuseBrowsers = /* @__PURE__ */ new Set();
    this._options = options2;
    if (options2.preLaunchedBrowser) {
      this._playwright = options2.preLaunchedBrowser.attribution.playwright;
      this._dontReuse(options2.preLaunchedBrowser);
    }
    if (options2.preLaunchedAndroidDevice)
      this._playwright = options2.preLaunchedAndroidDevice._android.attribution.playwright;
    this._playwright ??= createPlaywright({ sdkLanguage: "javascript", isServer: true });
    const browserSemaphore = new Semaphore(this._options.maxConnections);
    const controllerSemaphore = new Semaphore(1);
    const reuseBrowserSemaphore = new Semaphore(1);
    this._wsServer = new WSServer({
      onRequest: /* @__PURE__ */ __name((request2, response) => {
        if (request2.method === "GET" && request2.url === "/json") {
          response.setHeader("Content-Type", "application/json");
          response.end(JSON.stringify({
            wsEndpointPath: this._options.path
          }));
          return;
        }
        response.end("Running");
      }, "onRequest"),
      onUpgrade: /* @__PURE__ */ __name((request2, socket) => {
        const uaError = userAgentVersionMatchesErrorMessage(request2.headers["user-agent"] || "");
        if (uaError)
          return { error: `HTTP/${request2.httpVersion} 428 Precondition Required\r
\r
${uaError}` };
      }, "onUpgrade"),
      onHeaders: /* @__PURE__ */ __name((headers) => {
        if (process.env.PWTEST_SERVER_WS_HEADERS)
          headers.push(process.env.PWTEST_SERVER_WS_HEADERS);
      }, "onHeaders"),
      onConnection: /* @__PURE__ */ __name((request2, url4, ws3, id) => {
        const browserHeader = request2.headers["x-playwright-browser"];
        const browserName = url4.searchParams.get("browser") || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader) || null;
        const proxyHeader = request2.headers["x-playwright-proxy"];
        const proxyValue = url4.searchParams.get("proxy") || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);
        const launchOptionsHeader = request2.headers["x-playwright-launch-options"] || "";
        const launchOptionsHeaderValue = Array.isArray(launchOptionsHeader) ? launchOptionsHeader[0] : launchOptionsHeader;
        const launchOptionsParam = url4.searchParams.get("launch-options");
        let launchOptions = { timeout: DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT };
        try {
          launchOptions = JSON.parse(launchOptionsParam || launchOptionsHeaderValue);
          if (!launchOptions.timeout)
            launchOptions.timeout = DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT;
        } catch (e) {
        }
        const isExtension = this._options.mode === "extension";
        const allowFSPaths = isExtension;
        launchOptions = filterLaunchOptions(launchOptions, allowFSPaths);
        if (url4.searchParams.has("debug-controller")) {
          if (!(this._options.debugController || isExtension))
            throw new Error("Debug controller is not enabled");
          return new PlaywrightConnection(
            controllerSemaphore,
            ws3,
            true,
            this._playwright,
            async () => {
              throw new Error("shouldnt be used");
            },
            id
          );
        }
        if (isExtension) {
          const connectFilter = url4.searchParams.get("connect");
          if (connectFilter) {
            if (connectFilter !== "first")
              throw new Error(`Unknown connect filter: ${connectFilter}`);
            return new PlaywrightConnection(
              browserSemaphore,
              ws3,
              false,
              this._playwright,
              () => this._initConnectMode(id, connectFilter, browserName, launchOptions),
              id
            );
          }
          return new PlaywrightConnection(
            reuseBrowserSemaphore,
            ws3,
            false,
            this._playwright,
            () => this._initReuseBrowsersMode(browserName, launchOptions, id),
            id
          );
        }
        if (this._options.mode === "launchServer" || this._options.mode === "launchServerShared") {
          if (this._options.preLaunchedBrowser) {
            return new PlaywrightConnection(
              browserSemaphore,
              ws3,
              false,
              this._playwright,
              () => this._initPreLaunchedBrowserMode(id),
              id
            );
          }
          return new PlaywrightConnection(
            browserSemaphore,
            ws3,
            false,
            this._playwright,
            () => this._initPreLaunchedAndroidMode(id),
            id
          );
        }
        return new PlaywrightConnection(
          browserSemaphore,
          ws3,
          false,
          this._playwright,
          () => this._initLaunchBrowserMode(browserName, proxyValue, launchOptions, id),
          id
        );
      }, "onConnection")
    });
  }
  async _initReuseBrowsersMode(browserName, launchOptions, id) {
    debugLogger.log("server", `[${id}] engaged reuse browsers mode for ${browserName}`);
    const requestedOptions = launchOptionsHash(launchOptions);
    let browser3 = this._playwright.allBrowsers().find((b) => {
      if (b.options.name !== browserName)
        return false;
      if (this._dontReuseBrowsers.has(b))
        return false;
      const existingOptions = launchOptionsHash({ ...b.options.originalLaunchOptions, timeout: DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT });
      return existingOptions === requestedOptions;
    });
    for (const b of this._playwright.allBrowsers()) {
      if (b === browser3)
        continue;
      if (this._dontReuseBrowsers.has(b))
        continue;
      if (b.options.name === browserName && b.options.channel === launchOptions.channel)
        await b.close({ reason: "Connection terminated" });
    }
    if (!browser3) {
      const browserType = this._playwright[browserName || "chromium"];
      const controller = new ProgressController();
      browser3 = await controller.run((progress3) => browserType.launch(progress3, {
        ...launchOptions,
        headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS
      }), launchOptions.timeout);
    }
    return {
      preLaunchedBrowser: browser3,
      denyLaunch: true,
      dispose: /* @__PURE__ */ __name(async () => {
        for (const context2 of browser3.contexts()) {
          if (!context2.pages().length)
            await context2.close({ reason: "Connection terminated" });
        }
      }, "dispose")
    };
  }
  async _initConnectMode(id, filter, browserName, launchOptions) {
    browserName ??= "chromium";
    debugLogger.log("server", `[${id}] engaged connect mode`);
    let browser3 = this._playwright.allBrowsers().find((b) => b.options.name === browserName);
    if (!browser3) {
      const browserType = this._playwright[browserName];
      const controller = new ProgressController();
      browser3 = await controller.run((progress3) => browserType.launch(progress3, launchOptions), launchOptions.timeout);
      this._dontReuse(browser3);
    }
    return {
      preLaunchedBrowser: browser3,
      denyLaunch: true,
      sharedBrowser: true
    };
  }
  async _initPreLaunchedBrowserMode(id) {
    debugLogger.log("server", `[${id}] engaged pre-launched (browser) mode`);
    const browser3 = this._options.preLaunchedBrowser;
    for (const b of this._playwright.allBrowsers()) {
      if (b !== browser3)
        await b.close({ reason: "Connection terminated" });
    }
    return {
      preLaunchedBrowser: browser3,
      socksProxy: this._options.preLaunchedSocksProxy,
      sharedBrowser: this._options.mode === "launchServerShared",
      denyLaunch: true
    };
  }
  async _initPreLaunchedAndroidMode(id) {
    debugLogger.log("server", `[${id}] engaged pre-launched (Android) mode`);
    const androidDevice = this._options.preLaunchedAndroidDevice;
    return {
      preLaunchedAndroidDevice: androidDevice,
      denyLaunch: true
    };
  }
  async _initLaunchBrowserMode(browserName, proxyValue, launchOptions, id) {
    debugLogger.log("server", `[${id}] engaged launch mode for "${browserName}"`);
    let socksProxy;
    if (proxyValue) {
      socksProxy = new SocksProxy();
      socksProxy.setPattern(proxyValue);
      launchOptions.socksProxyPort = await socksProxy.listen(0);
      debugLogger.log("server", `[${id}] started socks proxy on port ${launchOptions.socksProxyPort}`);
    } else {
      launchOptions.socksProxyPort = void 0;
    }
    const browserType = this._playwright[browserName];
    const controller = new ProgressController();
    const browser3 = await controller.run((progress3) => browserType.launch(progress3, launchOptions), launchOptions.timeout);
    this._dontReuseBrowsers.add(browser3);
    return {
      preLaunchedBrowser: browser3,
      socksProxy,
      denyLaunch: true,
      dispose: /* @__PURE__ */ __name(async () => {
        await browser3.close({ reason: "Connection terminated" });
        socksProxy?.close();
      }, "dispose")
    };
  }
  _dontReuse(browser3) {
    this._dontReuseBrowsers.add(browser3);
    browser3.on(Browser.Events.Disconnected, () => {
      this._dontReuseBrowsers.delete(browser3);
    });
  }
  async listen(port = 0, hostname) {
    return this._wsServer.listen(port, hostname, this._options.path);
  }
  async close() {
    await this._wsServer.close();
  }
};
function userAgentVersionMatchesErrorMessage(userAgent) {
  const match = userAgent.match(/^Playwright\/(\d+\.\d+\.\d+)/);
  if (!match) {
    return;
  }
  const received = match[1].split(".").slice(0, 2).join(".");
  const expected = getPlaywrightVersion(true);
  if (received !== expected) {
    return wrapInASCIIBox([
      `Playwright version mismatch:`,
      `  - server version: v${expected}`,
      `  - client version: v${received}`,
      ``,
      `If you are using VSCode extension, restart VSCode.`,
      ``,
      `If you are connecting to a remote service,`,
      `keep your local Playwright version in sync`,
      `with the remote service version.`,
      ``,
      `<3 Playwright Team`
    ].join("\n"), 1);
  }
}
__name(userAgentVersionMatchesErrorMessage, "userAgentVersionMatchesErrorMessage");
function launchOptionsHash(options2) {
  const copy = { ...options2 };
  for (const k of Object.keys(copy)) {
    const key = k;
    if (copy[key] === defaultLaunchOptions[key])
      delete copy[key];
  }
  for (const key of optionsThatAllowBrowserReuse)
    delete copy[key];
  return JSON.stringify(copy);
}
__name(launchOptionsHash, "launchOptionsHash");
function filterLaunchOptions(options2, allowFSPaths) {
  return {
    channel: options2.channel,
    args: options2.args,
    ignoreAllDefaultArgs: options2.ignoreAllDefaultArgs,
    ignoreDefaultArgs: options2.ignoreDefaultArgs,
    timeout: options2.timeout,
    headless: options2.headless,
    proxy: options2.proxy,
    chromiumSandbox: options2.chromiumSandbox,
    firefoxUserPrefs: options2.firefoxUserPrefs,
    slowMo: options2.slowMo,
    executablePath: isUnderTest() || allowFSPaths ? options2.executablePath : void 0,
    downloadsPath: allowFSPaths ? options2.downloadsPath : void 0
  };
}
__name(filterLaunchOptions, "filterLaunchOptions");
var defaultLaunchOptions = {
  ignoreAllDefaultArgs: false,
  handleSIGINT: false,
  handleSIGTERM: false,
  handleSIGHUP: false,
  headless: true,
  devtools: false
};
var optionsThatAllowBrowserReuse = [
  "headless",
  "timeout",
  "tracesDir"
];

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/androidServerImpl.js
var AndroidServerLauncherImpl = class {
  static {
    __name(this, "AndroidServerLauncherImpl");
  }
  async launchServer(options2 = {}) {
    const playwright2 = createPlaywright({ sdkLanguage: "javascript", isServer: true });
    const controller = new ProgressController();
    let devices2 = await controller.run((progress3) => playwright2.android.devices(progress3, {
      host: options2.adbHost,
      port: options2.adbPort,
      omitDriverInstall: options2.omitDriverInstall
    }));
    if (devices2.length === 0)
      throw new Error("No devices found");
    if (options2.deviceSerialNumber) {
      devices2 = devices2.filter((d) => d.serial === options2.deviceSerialNumber);
      if (devices2.length === 0)
        throw new Error(`No device with serial number '${options2.deviceSerialNumber}' was found`);
    }
    if (devices2.length > 1)
      throw new Error(`More than one device found. Please specify deviceSerialNumber`);
    const device = devices2[0];
    const path30 = options2.wsPath ? options2.wsPath.startsWith("/") ? options2.wsPath : `/${options2.wsPath}` : `/${createGuid()}`;
    const server = new PlaywrightServer({ mode: "launchServer", path: path30, maxConnections: 1, preLaunchedAndroidDevice: device });
    const wsEndpoint = await server.listen(options2.port, options2.host);
    const browserServer = new ws2.EventEmitter();
    browserServer.wsEndpoint = () => wsEndpoint;
    browserServer.close = () => device.close();
    browserServer.kill = () => device.close();
    device.on("close", () => {
      server.close();
      browserServer.emit("close");
    });
    return browserServer;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/browserServerImpl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserServerLauncherImpl = class {
  static {
    __name(this, "BrowserServerLauncherImpl");
  }
  constructor(browserName) {
    this._browserName = browserName;
  }
  async launchServer(options2 = {}) {
    const playwright2 = createPlaywright({ sdkLanguage: "javascript", isServer: true });
    const metadata = { id: "", startTime: 0, endTime: 0, type: "Internal", method: "", params: {}, log: [], internal: true };
    const validatorContext = {
      tChannelImpl: /* @__PURE__ */ __name((names, arg, path30) => {
        throw new ValidationError(`${path30}: channels are not expected in launchServer`);
      }, "tChannelImpl"),
      binary: "buffer",
      isUnderTest
    };
    let launchOptions = {
      ...options2,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray(options2.env) : void 0,
      timeout: options2.timeout ?? DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT
    };
    let browser3;
    try {
      const controller = new ProgressController(metadata);
      browser3 = await controller.run(async (progress3) => {
        if (options2._userDataDir !== void 0) {
          const validator = scheme["BrowserTypeLaunchPersistentContextParams"];
          launchOptions = validator({ ...launchOptions, userDataDir: options2._userDataDir }, "", validatorContext);
          const context2 = await playwright2[this._browserName].launchPersistentContext(progress3, options2._userDataDir, launchOptions);
          return context2._browser;
        } else {
          const validator = scheme["BrowserTypeLaunchParams"];
          launchOptions = validator(launchOptions, "", validatorContext);
          return await playwright2[this._browserName].launch(progress3, launchOptions, toProtocolLogger(options2.logger));
        }
      });
    } catch (e) {
      const log3 = helper.formatBrowserLogs(metadata.log);
      rewriteErrorMessage(e, `${e.message} Failed to launch browser.${log3}`);
      throw e;
    }
    return this.launchServerOnExistingBrowser(browser3, options2);
  }
  async launchServerOnExistingBrowser(browser3, options2) {
    const path30 = options2.wsPath ? options2.wsPath.startsWith("/") ? options2.wsPath : `/${options2.wsPath}` : `/${createGuid()}`;
    const server = new PlaywrightServer({ mode: options2._sharedBrowser ? "launchServerShared" : "launchServer", path: path30, maxConnections: Infinity, preLaunchedBrowser: browser3, debugController: options2._debugController });
    const wsEndpoint = await server.listen(options2.port, options2.host);
    const browserServer = new ws2.EventEmitter();
    browserServer.process = () => browser3.options.browserProcess.process;
    browserServer.wsEndpoint = () => wsEndpoint;
    browserServer.close = () => browser3.options.browserProcess.close();
    browserServer[Symbol.asyncDispose] = browserServer.close;
    browserServer.kill = () => browser3.options.browserProcess.kill();
    browserServer._disconnectForTest = () => server.close();
    browserServer._userDataDirForTest = browser3._userDataDirForTest;
    browser3.options.browserProcess.onclose = (exitCode2, signal) => {
      server.close();
      browserServer.emit("close", exitCode2, signal);
    };
    return browserServer;
  }
};
function toProtocolLogger(logger) {
  return logger ? (direction, message) => {
    if (logger.isEnabled("protocol", "verbose"))
      logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
  } : void 0;
}
__name(toProtocolLogger, "toProtocolLogger");
function envObjectToArray(env3) {
  const result = [];
  for (const name in env3) {
    if (!Object.is(env3[name], void 0))
      result.push({ name, value: String(env3[name]) });
  }
  return result;
}
__name(envObjectToArray, "envObjectToArray");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/inProcessFactory.js
import "node:fs";
import "node:path";
import "node:crypto";
import "node:http";
import "node:http2";
import "node:https";
import "node:url";
import "node:os";

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/connection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/eventEmitter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EventEmitter18 = class {
  static {
    __name(this, "EventEmitter");
  }
  constructor(platform2) {
    this._events = void 0;
    this._eventsCount = 0;
    this._maxListeners = void 0;
    this._pendingHandlers = /* @__PURE__ */ new Map();
    this._platform = platform2;
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
    this.on = this.addListener;
    this.off = this.removeListener;
  }
  setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
  }
  getMaxListeners() {
    return this._maxListeners === void 0 ? this._platform.defaultMaxListeners() : this._maxListeners;
  }
  emit(type, ...args) {
    const events = this._events;
    if (events === void 0)
      return false;
    const handler = events?.[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      this._callHandler(type, handler, args);
    } else {
      const len = handler.length;
      const listeners2 = handler.slice();
      for (let i = 0; i < len; ++i)
        this._callHandler(type, listeners2[i], args);
    }
    return true;
  }
  _callHandler(type, handler, args) {
    const promise = Reflect.apply(handler, this, args);
    if (!(promise instanceof Promise))
      return;
    let set2 = this._pendingHandlers.get(type);
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this._pendingHandlers.set(type, set2);
    }
    set2.add(promise);
    promise.catch((e) => {
      if (this._rejectionHandler)
        this._rejectionHandler(e);
      else
        throw e;
    }).finally(() => set2.delete(promise));
  }
  addListener(type, listener) {
    return this._addListener(type, listener, false);
  }
  on(type, listener) {
    return this._addListener(type, listener, false);
  }
  _addListener(type, listener, prepend) {
    checkListener(listener);
    let events = this._events;
    let existing;
    if (events === void 0) {
      events = this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else {
      if (events.newListener !== void 0) {
        this.emit("newListener", type, unwrapListener(listener));
        events = this._events;
      }
      existing = events[type];
    }
    if (existing === void 0) {
      existing = events[type] = listener;
      ++this._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      const m = this.getMaxListeners();
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        const w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = this;
        w.type = type;
        w.count = existing.length;
        if (!this._platform.isUnderTest()) {
          console.warn(w);
        }
      }
    }
    return this;
  }
  prependListener(type, listener) {
    return this._addListener(type, listener, true);
  }
  once(type, listener) {
    checkListener(listener);
    this.on(type, new OnceWrapper(this, type, listener).wrapperFunction);
    return this;
  }
  prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, new OnceWrapper(this, type, listener).wrapperFunction);
    return this;
  }
  removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === void 0)
      return this;
    const list = events[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
      } else {
        delete events[type];
        if (events.removeListener)
          this.emit("removeListener", type, list.listener ?? listener);
      }
    } else if (typeof list !== "function") {
      let position = -1;
      let originalListener;
      for (let i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || wrappedListener(list[i]) === listener) {
          originalListener = wrappedListener(list[i]);
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else
        list.splice(position, 1);
      if (list.length === 1)
        events[type] = list[0];
      if (events.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  }
  off(type, listener) {
    return this.removeListener(type, listener);
  }
  removeAllListeners(type, options2) {
    this._removeAllListeners(type);
    if (!options2)
      return this;
    if (options2.behavior === "wait") {
      const errors2 = [];
      this._rejectionHandler = (error3) => errors2.push(error3);
      return this._waitFor(type).then(() => {
        if (errors2.length)
          throw errors2[0];
      });
    }
    if (options2.behavior === "ignoreErrors")
      this._rejectionHandler = () => {
      };
    return Promise.resolve();
  }
  _removeAllListeners(type) {
    const events = this._events;
    if (!events)
      return;
    if (!events.removeListener) {
      if (type === void 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events[type];
      }
      return;
    }
    if (type === void 0) {
      const keys = Object.keys(events);
      let key;
      for (let i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener")
          continue;
        this._removeAllListeners(key);
      }
      this._removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return;
    }
    const listeners2 = events[type];
    if (typeof listeners2 === "function") {
      this.removeListener(type, listeners2);
    } else if (listeners2 !== void 0) {
      for (let i = listeners2.length - 1; i >= 0; i--)
        this.removeListener(type, listeners2[i]);
    }
  }
  listeners(type) {
    return this._listeners(this, type, true);
  }
  rawListeners(type) {
    return this._listeners(this, type, false);
  }
  listenerCount(type) {
    const events = this._events;
    if (events !== void 0) {
      const listener = events[type];
      if (typeof listener === "function")
        return 1;
      if (listener !== void 0)
        return listener.length;
    }
    return 0;
  }
  eventNames() {
    return this._eventsCount > 0 && this._events ? Reflect.ownKeys(this._events) : [];
  }
  async _waitFor(type) {
    let promises = [];
    if (type) {
      promises = [...this._pendingHandlers.get(type) || []];
    } else {
      promises = [];
      for (const [, pending] of this._pendingHandlers)
        promises.push(...pending);
    }
    await Promise.all(promises);
  }
  _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === void 0)
      return [];
    const listener = events[type];
    if (listener === void 0)
      return [];
    if (typeof listener === "function")
      return unwrap ? [unwrapListener(listener)] : [listener];
    return unwrap ? unwrapListeners(listener) : listener.slice();
  }
};
function checkListener(listener) {
  if (typeof listener !== "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
__name(checkListener, "checkListener");
var OnceWrapper = class {
  static {
    __name(this, "OnceWrapper");
  }
  constructor(eventEmitter, eventType, listener) {
    this._fired = false;
    this._eventEmitter = eventEmitter;
    this._eventType = eventType;
    this._listener = listener;
    this.wrapperFunction = this._handle.bind(this);
    this.wrapperFunction.listener = listener;
  }
  _handle(...args) {
    if (this._fired)
      return;
    this._fired = true;
    this._eventEmitter.removeListener(this._eventType, this.wrapperFunction);
    return this._listener.apply(this._eventEmitter, args);
  }
};
function unwrapListener(l) {
  return wrappedListener(l) ?? l;
}
__name(unwrapListener, "unwrapListener");
function unwrapListeners(arr) {
  return arr.map((l) => wrappedListener(l) ?? l);
}
__name(unwrapListeners, "unwrapListeners");
function wrappedListener(l) {
  return l.listener;
}
__name(wrappedListener, "wrappedListener");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/android.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/browserContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/artifact.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/channelOwner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/clientStackTrace.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function captureLibraryStackTrace(platform2) {
  const stack = captureRawStack();
  let parsedFrames = stack.map((line) => {
    const frame = parseStackFrame(line, platform2.pathSeparator, platform2.showInternalStackFrames());
    if (!frame || !frame.file)
      return null;
    const isPlaywrightLibrary = !!platform2.coreDir && frame.file.startsWith(platform2.coreDir);
    const parsed = {
      frame,
      frameText: line,
      isPlaywrightLibrary
    };
    return parsed;
  }).filter(Boolean);
  let apiName = "";
  for (let i = 0; i < parsedFrames.length - 1; i++) {
    const parsedFrame = parsedFrames[i];
    if (parsedFrame.isPlaywrightLibrary && !parsedFrames[i + 1].isPlaywrightLibrary) {
      apiName = apiName || normalizeAPIName(parsedFrame.frame.function);
      break;
    }
  }
  function normalizeAPIName(name) {
    if (!name)
      return "";
    const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
    if (!match)
      return name;
    return match[1].toLowerCase() + match[2];
  }
  __name(normalizeAPIName, "normalizeAPIName");
  const filterPrefixes = platform2.boxedStackPrefixes();
  parsedFrames = parsedFrames.filter((f) => {
    if (filterPrefixes.some((prefix) => f.frame.file.startsWith(prefix)))
      return false;
    return true;
  });
  return {
    frames: parsedFrames.map((p) => p.frame),
    apiName
  };
}
__name(captureLibraryStackTrace, "captureLibraryStackTrace");

// node_modules/@cloudflare/playwright/lib/cloudflare/apiCallZone.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { AsyncLocalStorage as AsyncLocalStorage3 } from "node:async_hooks";
var apiCallZone = new AsyncLocalStorage3();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/channelOwner.js
var ChannelOwner = class _ChannelOwner extends EventEmitter18 {
  static {
    __name(this, "ChannelOwner");
  }
  constructor(parent, type, guid, initializer) {
    const connection = parent instanceof _ChannelOwner ? parent._connection : parent;
    super(connection._platform);
    this._objects = /* @__PURE__ */ new Map();
    this._eventToSubscriptionMapping = /* @__PURE__ */ new Map();
    this._wasCollected = false;
    this.setMaxListeners(0);
    this._connection = connection;
    this._type = type;
    this._guid = guid;
    this._parent = parent instanceof _ChannelOwner ? parent : void 0;
    this._instrumentation = this._connection._instrumentation;
    this._connection._objects.set(guid, this);
    if (this._parent) {
      this._parent._objects.set(guid, this);
      this._logger = this._parent._logger;
    }
    this._channel = this._createChannel(new EventEmitter18(connection._platform));
    this._initializer = initializer;
  }
  _setEventToSubscriptionMapping(mapping) {
    this._eventToSubscriptionMapping = mapping;
  }
  _updateSubscription(event, enabled) {
    const protocolEvent = this._eventToSubscriptionMapping.get(String(event));
    if (protocolEvent)
      this._channel.updateSubscription({ event: protocolEvent, enabled }).catch(() => {
      });
  }
  on(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.on(event, listener);
    return this;
  }
  addListener(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.addListener(event, listener);
    return this;
  }
  prependListener(event, listener) {
    if (!this.listenerCount(event))
      this._updateSubscription(event, true);
    super.prependListener(event, listener);
    return this;
  }
  off(event, listener) {
    super.off(event, listener);
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
    return this;
  }
  removeListener(event, listener) {
    super.removeListener(event, listener);
    if (!this.listenerCount(event))
      this._updateSubscription(event, false);
    return this;
  }
  _adopt(child) {
    child._parent._objects.delete(child._guid);
    this._objects.set(child._guid, child);
    child._parent = this;
  }
  _dispose(reason) {
    if (this._parent)
      this._parent._objects.delete(this._guid);
    this._connection._objects.delete(this._guid);
    this._wasCollected = reason === "gc";
    for (const object of [...this._objects.values()])
      object._dispose(reason);
    this._objects.clear();
  }
  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
    };
  }
  _validatorToWireContext() {
    return {
      tChannelImpl: tChannelImplToWire,
      binary: this._connection.rawBuffers() ? "buffer" : "toBase64",
      isUnderTest: /* @__PURE__ */ __name(() => this._platform.isUnderTest(), "isUnderTest")
    };
  }
  _createChannel(base) {
    const channel2 = new Proxy(base, {
      get: /* @__PURE__ */ __name((obj, prop) => {
        if (typeof prop === "string") {
          const validator = maybeFindValidator(this._type, prop, "Params");
          const { internal } = methodMetainfo.get(this._type + "." + prop) || {};
          if (validator) {
            return async (params) => {
              return await this._wrapApiCall(async (apiZone) => {
                const validatedParams = validator(params, "", this._validatorToWireContext());
                if (!apiZone.internal && !apiZone.reported) {
                  apiZone.reported = true;
                  this._instrumentation.onApiCallBegin(apiZone, { type: this._type, method: prop, params });
                  logApiCall(this._platform, this._logger, `=> ${apiZone.apiName} started`);
                  return await this._connection.sendMessageToServer(this, prop, validatedParams, apiZone);
                }
                return await this._connection.sendMessageToServer(this, prop, validatedParams, { internal: true });
              }, { internal });
            };
          }
        }
        return obj[prop];
      }, "get")
    });
    channel2._object = this;
    return channel2;
  }
  async _wrapApiCall(func, options2) {
    const logger = this._logger;
    const existingApiZone = this._platform.zones.current().data();
    if (existingApiZone)
      return await func(existingApiZone);
    const apiCall = apiCallZone.getStore();
    const stackTrace = captureLibraryStackTrace(this._platform);
    const apiZone = { title: options2?.title, apiName: apiCall?.apiName ?? stackTrace.apiName, frames: stackTrace.frames, internal: options2?.internal ?? false, reported: false, userData: void 0, stepId: void 0 };
    try {
      const result = await this._platform.zones.current().push(apiZone).run(async () => await func(apiZone));
      if (!options2?.internal) {
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} succeeded`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      return result;
    } catch (e) {
      const innerError = (this._platform.showInternalStackFrames() || this._platform.isUnderTest()) && e.stack ? "\n<inner error>\n" + e.stack : "";
      if (apiZone.apiName && !apiZone.apiName.includes("<anonymous>"))
        e.message = apiZone.apiName + ": " + e.message;
      const stackFrames = "\n" + stringifyStackFrames(stackTrace.frames).join("\n") + innerError;
      if (stackFrames.trim())
        e.stack = e.message + stackFrames;
      else
        e.stack = "";
      if (!options2?.internal) {
        const recoveryHandlers = [];
        apiZone.error = e;
        this._instrumentation.onApiCallRecovery(apiZone, e, recoveryHandlers);
        for (const handler of recoveryHandlers) {
          const recoverResult = await handler();
          if (recoverResult.status === "recovered")
            return recoverResult.value;
        }
        logApiCall(this._platform, logger, `<= ${apiZone.apiName} failed`);
        this._instrumentation.onApiCallEnd(apiZone);
      }
      throw e;
    }
  }
  toJSON() {
    return {
      _type: this._type,
      _guid: this._guid
    };
  }
};
function logApiCall(platform2, logger, message) {
  if (logger && logger.isEnabled("api", "info"))
    logger.log("api", "info", message, [], { color: "cyan" });
  platform2.log("api", message);
}
__name(logApiCall, "logApiCall");
function tChannelImplToWire(names, arg, path30, context2) {
  if (arg._object instanceof ChannelOwner && (names === "*" || names.includes(arg._object._type)))
    return { guid: arg._object._guid };
  throw new ValidationError(`${path30}: expected channel ${names.toString()}`);
}
__name(tChannelImplToWire, "tChannelImplToWire");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/stream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Stream = class extends ChannelOwner {
  static {
    __name(this, "Stream");
  }
  static from(Stream2) {
    return Stream2._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }
  stream() {
    return this._platform.streamReadable(this._channel);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/fileUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fileUploadSizeLimit2 = 50 * 1024 * 1024;
async function mkdirIfNeeded2(platform2, filePath) {
  await platform2.fs().promises.mkdir(platform2.path().dirname(filePath), { recursive: true }).catch(() => {
  });
}
__name(mkdirIfNeeded2, "mkdirIfNeeded");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/artifact.js
var Artifact2 = class extends ChannelOwner {
  static {
    __name(this, "Artifact");
  }
  static from(channel2) {
    return channel2._object;
  }
  async pathAfterFinished() {
    if (this._connection.isRemote())
      throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    return (await this._channel.pathAfterFinished()).value;
  }
  async saveAs(path30) {
    if (!this._connection.isRemote()) {
      await this._channel.saveAs({ path: path30 });
      return;
    }
    const result = await this._channel.saveAsStream();
    const stream = Stream.from(result.stream);
    await mkdirIfNeeded2(this._platform, path30);
    await new Promise((resolve, reject) => {
      stream.stream().pipe(this._platform.fs().createWriteStream(path30)).on("finish", resolve).on("error", reject);
    });
  }
  async failure() {
    return (await this._channel.failure()).error || null;
  }
  async createReadStream() {
    const result = await this._channel.stream();
    const stream = Stream.from(result.stream);
    return stream.stream();
  }
  async readIntoBuffer() {
    const stream = await this.createReadStream();
    return await new Promise((resolve, reject) => {
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
      });
      stream.on("end", () => {
        resolve(Buffer.concat(chunks));
      });
      stream.on("error", reject);
    });
  }
  async cancel() {
    return await this._channel.cancel();
  }
  async delete() {
    return await this._channel.delete();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/cdpSession.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CDPSession2 = class extends ChannelOwner {
  static {
    __name(this, "CDPSession");
  }
  static from(cdpSession) {
    return cdpSession._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._channel.on("event", ({ method, params }) => {
      this.emit(method, params);
    });
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }
  async send(method, params) {
    const result = await this._channel.send({ method, params });
    return result.result;
  }
  async detach() {
    return await this._channel.detach();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/clientHelper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function envObjectToArray2(env3) {
  const result = [];
  for (const name in env3) {
    if (!Object.is(env3[name], void 0))
      result.push({ name, value: String(env3[name]) });
  }
  return result;
}
__name(envObjectToArray2, "envObjectToArray");
async function evaluationScript(platform2, fun, arg, addSourceUrl = true) {
  if (typeof fun === "function") {
    const source8 = `((__name => (${fun.toString()}))(t => t))`;
    const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
    return `(${source8})(${argString})`;
  }
  if (arg !== void 0)
    throw new Error("Cannot evaluate a string with arguments");
  if (isString(fun))
    return fun;
  if (fun.content !== void 0)
    return fun.content;
  if (fun.path !== void 0) {
    let source8 = await platform2.fs().promises.readFile(fun.path, "utf8");
    if (addSourceUrl)
      source8 = addSourceUrlToScript(source8, fun.path);
    return source8;
  }
  throw new Error("Either path or content property must be present");
}
__name(evaluationScript, "evaluationScript");
function addSourceUrlToScript(source8, path30) {
  return `${source8}
//# sourceURL=${path30.replace(/\n/g, "")}`;
}
__name(addSourceUrlToScript, "addSourceUrlToScript");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/clock.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Clock2 = class {
  static {
    __name(this, "Clock");
  }
  constructor(browserContext) {
    this._browserContext = browserContext;
  }
  async install(options2 = {}) {
    await this._browserContext._channel.clockInstall(options2.time !== void 0 ? parseTime2(options2.time) : {});
  }
  async fastForward(ticks) {
    await this._browserContext._channel.clockFastForward(parseTicks2(ticks));
  }
  async pauseAt(time3) {
    await this._browserContext._channel.clockPauseAt(parseTime2(time3));
  }
  async resume() {
    await this._browserContext._channel.clockResume({});
  }
  async runFor(ticks) {
    await this._browserContext._channel.clockRunFor(parseTicks2(ticks));
  }
  async setFixedTime(time3) {
    await this._browserContext._channel.clockSetFixedTime(parseTime2(time3));
  }
  async setSystemTime(time3) {
    await this._browserContext._channel.clockSetSystemTime(parseTime2(time3));
  }
};
function parseTime2(time3) {
  if (typeof time3 === "number")
    return { timeNumber: time3 };
  if (typeof time3 === "string")
    return { timeString: time3 };
  if (!isFinite(time3.getTime()))
    throw new Error(`Invalid date: ${time3}`);
  return { timeNumber: time3.getTime() };
}
__name(parseTime2, "parseTime");
function parseTicks2(ticks) {
  return {
    ticksNumber: typeof ticks === "number" ? ticks : void 0,
    ticksString: typeof ticks === "string" ? ticks : void 0
  };
}
__name(parseTicks2, "parseTicks");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/consoleMessage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/jsHandle.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TimeoutError2 = class extends Error {
  static {
    __name(this, "TimeoutError");
  }
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var TargetClosedError2 = class extends Error {
  static {
    __name(this, "TargetClosedError");
  }
  constructor(cause) {
    super(cause || "Target page, context or browser has been closed");
  }
};
function isTargetClosedError2(error3) {
  return error3 instanceof TargetClosedError2;
}
__name(isTargetClosedError2, "isTargetClosedError");
function serializeError2(e) {
  if (isError2(e))
    return { error: { message: e.message, stack: e.stack, name: e.name } };
  return { value: serializeValue(e, (value) => ({ fallThrough: value })) };
}
__name(serializeError2, "serializeError");
function parseError2(error3) {
  if (!error3.error) {
    if (error3.value === void 0)
      throw new Error("Serialized error must have either an error or a value");
    return parseSerializedValue(error3.value, void 0);
  }
  if (error3.error.name === "TimeoutError") {
    const e2 = new TimeoutError2(error3.error.message);
    e2.stack = error3.error.stack || "";
    return e2;
  }
  if (error3.error.name === "TargetClosedError") {
    const e2 = new TargetClosedError2(error3.error.message);
    e2.stack = error3.error.stack || "";
    return e2;
  }
  const e = new Error(error3.error.message);
  e.stack = error3.error.stack || "";
  e.name = error3.error.name;
  return e;
}
__name(parseError2, "parseError");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/jsHandle.js
var JSHandle2 = class _JSHandle extends ChannelOwner {
  static {
    __name(this, "JSHandle");
  }
  static from(handle) {
    return handle._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._preview = this._initializer.preview;
    this._channel.on("previewUpdated", ({ preview }) => this._preview = preview);
  }
  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async _evaluateFunction(functionDeclaration) {
    const result = await this._channel.evaluateExpression({ expression: functionDeclaration, isFunction: true, arg: serializeArgument(void 0) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return _JSHandle.from(result.handle);
  }
  async getProperty(propertyName) {
    const result = await this._channel.getProperty({ name: propertyName });
    return _JSHandle.from(result.handle);
  }
  async getProperties() {
    const map2 = /* @__PURE__ */ new Map();
    for (const { name, value } of (await this._channel.getPropertyList()).properties)
      map2.set(name, _JSHandle.from(value));
    return map2;
  }
  async jsonValue() {
    return parseResult((await this._channel.jsonValue()).value);
  }
  asElement() {
    return null;
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose() {
    try {
      await this._channel.dispose();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  toString() {
    return this._preview;
  }
};
function serializeArgument(arg) {
  const handles = [];
  const pushHandle = /* @__PURE__ */ __name((channel2) => {
    handles.push(channel2);
    return handles.length - 1;
  }, "pushHandle");
  const value = serializeValue(arg, (value2) => {
    if (value2 instanceof JSHandle2)
      return { h: pushHandle(value2._channel) };
    return { fallThrough: value2 };
  });
  return { value, handles };
}
__name(serializeArgument, "serializeArgument");
function parseResult(value) {
  return parseSerializedValue(value, void 0);
}
__name(parseResult, "parseResult");
function assertMaxArguments(count3, max) {
  if (count3 > max)
    throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
}
__name(assertMaxArguments, "assertMaxArguments");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/page.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/accessibility.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function axNodeFromProtocol(axNode) {
  const result = {
    ...axNode,
    value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
    checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
    pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
    children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
  };
  delete result.valueNumber;
  delete result.valueString;
  return result;
}
__name(axNodeFromProtocol, "axNodeFromProtocol");
var Accessibility2 = class {
  static {
    __name(this, "Accessibility");
  }
  constructor(channel2) {
    this._channel = channel2;
  }
  async snapshot(options2 = {}) {
    const root = options2.root ? options2.root._elementChannel : void 0;
    const result = await this._channel.accessibilitySnapshot({ interestingOnly: options2.interestingOnly, root });
    return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/coverage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Coverage = class {
  static {
    __name(this, "Coverage");
  }
  constructor(channel2) {
    this._channel = channel2;
  }
  async startJSCoverage(options2 = {}) {
    await this._channel.startJSCoverage(options2);
  }
  async stopJSCoverage() {
    return (await this._channel.stopJSCoverage()).entries;
  }
  async startCSSCoverage(options2 = {}) {
    await this._channel.startCSSCoverage(options2);
  }
  async stopCSSCoverage() {
    return (await this._channel.stopCSSCoverage()).entries;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/download.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Download2 = class {
  static {
    __name(this, "Download");
  }
  constructor(page, url4, suggestedFilename, artifact) {
    this._page = page;
    this._url = url4;
    this._suggestedFilename = suggestedFilename;
    this._artifact = artifact;
  }
  page() {
    return this._page;
  }
  url() {
    return this._url;
  }
  suggestedFilename() {
    return this._suggestedFilename;
  }
  async path() {
    return await this._artifact.pathAfterFinished();
  }
  async saveAs(path30) {
    return await this._artifact.saveAs(path30);
  }
  async failure() {
    return await this._artifact.failure();
  }
  async createReadStream() {
    return await this._artifact.createReadStream();
  }
  async cancel() {
    return await this._artifact.cancel();
  }
  async delete() {
    return await this._artifact.delete();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/elementHandle.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/frame.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/events.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Events = {
  AndroidDevice: {
    WebView: "webview",
    Close: "close"
  },
  AndroidSocket: {
    Data: "data",
    Close: "close"
  },
  AndroidWebView: {
    Close: "close"
  },
  Browser: {
    Disconnected: "disconnected"
  },
  BrowserContext: {
    Console: "console",
    Close: "close",
    Dialog: "dialog",
    Page: "page",
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    WebError: "weberror",
    BackgroundPage: "backgroundpage",
    ServiceWorker: "serviceworker",
    Request: "request",
    Response: "response",
    RequestFailed: "requestfailed",
    RequestFinished: "requestfinished"
  },
  Page: {
    Close: "close",
    Crash: "crash",
    Console: "console",
    Dialog: "dialog",
    Download: "download",
    FileChooser: "filechooser",
    DOMContentLoaded: "domcontentloaded",
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    PageError: "pageerror",
    Request: "request",
    Response: "response",
    RequestFailed: "requestfailed",
    RequestFinished: "requestfinished",
    FrameAttached: "frameattached",
    FrameDetached: "framedetached",
    FrameNavigated: "framenavigated",
    Load: "load",
    Popup: "popup",
    WebSocket: "websocket",
    Worker: "worker"
  },
  WebSocket: {
    Close: "close",
    Error: "socketerror",
    FrameReceived: "framereceived",
    FrameSent: "framesent"
  },
  Worker: {
    Close: "close"
  },
  ElectronApplication: {
    Close: "close",
    Console: "console",
    Window: "window"
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/locator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/utils/isomorphic/locatorUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getByAttributeTextSelector(attrName, text, options2) {
  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, options2?.exact || false)}]`;
}
__name(getByAttributeTextSelector, "getByAttributeTextSelector");
function getByTestIdSelector(testIdAttributeName2, testId) {
  return `internal:testid=[${testIdAttributeName2}=${escapeForAttributeSelector(testId, true)}]`;
}
__name(getByTestIdSelector, "getByTestIdSelector");
function getByLabelSelector(text, options2) {
  return "internal:label=" + escapeForTextSelector(text, !!options2?.exact);
}
__name(getByLabelSelector, "getByLabelSelector");
function getByAltTextSelector(text, options2) {
  return getByAttributeTextSelector("alt", text, options2);
}
__name(getByAltTextSelector, "getByAltTextSelector");
function getByTitleSelector(text, options2) {
  return getByAttributeTextSelector("title", text, options2);
}
__name(getByTitleSelector, "getByTitleSelector");
function getByPlaceholderSelector(text, options2) {
  return getByAttributeTextSelector("placeholder", text, options2);
}
__name(getByPlaceholderSelector, "getByPlaceholderSelector");
function getByTextSelector(text, options2) {
  return "internal:text=" + escapeForTextSelector(text, !!options2?.exact);
}
__name(getByTextSelector, "getByTextSelector");
function getByRoleSelector(role, options2 = {}) {
  const props = [];
  if (options2.checked !== void 0)
    props.push(["checked", String(options2.checked)]);
  if (options2.disabled !== void 0)
    props.push(["disabled", String(options2.disabled)]);
  if (options2.selected !== void 0)
    props.push(["selected", String(options2.selected)]);
  if (options2.expanded !== void 0)
    props.push(["expanded", String(options2.expanded)]);
  if (options2.includeHidden !== void 0)
    props.push(["include-hidden", String(options2.includeHidden)]);
  if (options2.level !== void 0)
    props.push(["level", String(options2.level)]);
  if (options2.name !== void 0)
    props.push(["name", escapeForAttributeSelector(options2.name, !!options2.exact)]);
  if (options2.pressed !== void 0)
    props.push(["pressed", String(options2.pressed)]);
  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;
}
__name(getByRoleSelector, "getByRoleSelector");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/locator.js
var Locator = class _Locator {
  static {
    __name(this, "Locator");
  }
  constructor(frame, selector, options2) {
    this._frame = frame;
    this._selector = selector;
    if (options2?.hasText)
      this._selector += ` >> internal:has-text=${escapeForTextSelector(options2.hasText, false)}`;
    if (options2?.hasNotText)
      this._selector += ` >> internal:has-not-text=${escapeForTextSelector(options2.hasNotText, false)}`;
    if (options2?.has) {
      const locator = options2.has;
      if (locator._frame !== frame)
        throw new Error(`Inner "has" locator must belong to the same frame.`);
      this._selector += ` >> internal:has=` + JSON.stringify(locator._selector);
    }
    if (options2?.hasNot) {
      const locator = options2.hasNot;
      if (locator._frame !== frame)
        throw new Error(`Inner "hasNot" locator must belong to the same frame.`);
      this._selector += ` >> internal:has-not=` + JSON.stringify(locator._selector);
    }
    if (options2?.visible !== void 0)
      this._selector += ` >> visible=${options2.visible ? "true" : "false"}`;
    if (this._frame._platform.inspectCustom)
      this[this._frame._platform.inspectCustom] = () => this._inspect();
  }
  async _withElement(task, options2) {
    const timeout = this._frame._timeout({ timeout: options2.timeout });
    const deadline = timeout ? monotonicTime() + timeout : 0;
    return await this._frame._wrapApiCall(async () => {
      const result = await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, state: "attached", timeout });
      const handle = ElementHandle2.fromNullable(result.element);
      if (!handle)
        throw new Error(`Could not resolve ${this._selector} to DOM Element`);
      try {
        return await task(handle, deadline ? deadline - monotonicTime() : 0);
      } finally {
        await handle.dispose();
      }
    }, { title: options2.title, internal: options2.internal });
  }
  _equals(locator) {
    return this._frame === locator._frame && this._selector === locator._selector;
  }
  page() {
    return this._frame.page();
  }
  async boundingBox(options2) {
    return await this._withElement((h) => h.boundingBox(), { title: "Bounding box", timeout: options2?.timeout });
  }
  async check(options2 = {}) {
    return await this._frame.check(this._selector, { strict: true, ...options2 });
  }
  async click(options2 = {}) {
    return await this._frame.click(this._selector, { strict: true, ...options2 });
  }
  async dblclick(options2 = {}) {
    await this._frame.dblclick(this._selector, { strict: true, ...options2 });
  }
  async dispatchEvent(type, eventInit = {}, options2) {
    return await this._frame.dispatchEvent(this._selector, type, eventInit, { strict: true, ...options2 });
  }
  async dragTo(target, options2 = {}) {
    return await this._frame.dragAndDrop(this._selector, target._selector, {
      strict: true,
      ...options2
    });
  }
  async evaluate(pageFunction, arg, options2) {
    return await this._withElement((h) => h.evaluate(pageFunction, arg), { title: "Evaluate", timeout: options2?.timeout });
  }
  async _evaluateFunction(functionDeclaration, options2) {
    return await this._withElement((h) => h._evaluateFunction(functionDeclaration), { title: "Evaluate", timeout: options2?.timeout });
  }
  async evaluateAll(pageFunction, arg) {
    return await this._frame.$$eval(this._selector, pageFunction, arg);
  }
  async evaluateHandle(pageFunction, arg, options2) {
    return await this._withElement((h) => h.evaluateHandle(pageFunction, arg), { title: "Evaluate", timeout: options2?.timeout });
  }
  async fill(value, options2 = {}) {
    return await this._frame.fill(this._selector, value, { strict: true, ...options2 });
  }
  async clear(options2 = {}) {
    await this._frame._wrapApiCall(() => this.fill("", options2), { title: "Clear" });
  }
  async _highlight() {
    return await this._frame._highlight(this._selector);
  }
  async highlight() {
    return await this._frame._highlight(this._selector);
  }
  locator(selectorOrLocator, options2) {
    if (isString(selectorOrLocator))
      return new _Locator(this._frame, this._selector + " >> " + selectorOrLocator, options2);
    if (selectorOrLocator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + " >> internal:chain=" + JSON.stringify(selectorOrLocator._selector), options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  frameLocator(selector) {
    return new FrameLocator(this._frame, this._selector + " >> " + selector);
  }
  filter(options2) {
    return new _Locator(this._frame, this._selector, options2);
  }
  async elementHandle(options2) {
    return await this._frame.waitForSelector(this._selector, { strict: true, state: "attached", ...options2 });
  }
  async elementHandles() {
    return await this._frame.$$(this._selector);
  }
  contentFrame() {
    return new FrameLocator(this._frame, this._selector);
  }
  describe(description) {
    return new _Locator(this._frame, this._selector + " >> internal:describe=" + JSON.stringify(description));
  }
  first() {
    return new _Locator(this._frame, this._selector + " >> nth=0");
  }
  last() {
    return new _Locator(this._frame, this._selector + ` >> nth=-1`);
  }
  nth(index2) {
    return new _Locator(this._frame, this._selector + ` >> nth=${index2}`);
  }
  and(locator) {
    if (locator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + ` >> internal:and=` + JSON.stringify(locator._selector));
  }
  or(locator) {
    if (locator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new _Locator(this._frame, this._selector + ` >> internal:or=` + JSON.stringify(locator._selector));
  }
  async focus(options2) {
    return await this._frame.focus(this._selector, { strict: true, ...options2 });
  }
  async blur(options2) {
    await this._frame._channel.blur({ selector: this._selector, strict: true, ...options2, timeout: this._frame._timeout(options2) });
  }
  // options are only here for testing
  async count(_options) {
    return await this._frame._queryCount(this._selector, _options);
  }
  async _resolveSelector() {
    return await this._frame._channel.resolveSelector({ selector: this._selector });
  }
  async getAttribute(name, options2) {
    return await this._frame.getAttribute(this._selector, name, { strict: true, ...options2 });
  }
  async hover(options2 = {}) {
    return await this._frame.hover(this._selector, { strict: true, ...options2 });
  }
  async innerHTML(options2) {
    return await this._frame.innerHTML(this._selector, { strict: true, ...options2 });
  }
  async innerText(options2) {
    return await this._frame.innerText(this._selector, { strict: true, ...options2 });
  }
  async inputValue(options2) {
    return await this._frame.inputValue(this._selector, { strict: true, ...options2 });
  }
  async isChecked(options2) {
    return await this._frame.isChecked(this._selector, { strict: true, ...options2 });
  }
  async isDisabled(options2) {
    return await this._frame.isDisabled(this._selector, { strict: true, ...options2 });
  }
  async isEditable(options2) {
    return await this._frame.isEditable(this._selector, { strict: true, ...options2 });
  }
  async isEnabled(options2) {
    return await this._frame.isEnabled(this._selector, { strict: true, ...options2 });
  }
  async isHidden(options2) {
    return await this._frame.isHidden(this._selector, { strict: true, ...options2 });
  }
  async isVisible(options2) {
    return await this._frame.isVisible(this._selector, { strict: true, ...options2 });
  }
  async press(key, options2 = {}) {
    return await this._frame.press(this._selector, key, { strict: true, ...options2 });
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    return await this._withElement((h, timeout) => h.screenshot({ ...options2, mask, timeout }), { title: "Screenshot", timeout: options2.timeout });
  }
  async ariaSnapshot(options2) {
    const result = await this._frame._channel.ariaSnapshot({ ...options2, selector: this._selector, timeout: this._frame._timeout(options2) });
    return result.snapshot;
  }
  async scrollIntoViewIfNeeded(options2 = {}) {
    return await this._withElement((h, timeout) => h.scrollIntoViewIfNeeded({ ...options2, timeout }), { title: "Scroll into view", timeout: options2.timeout });
  }
  async selectOption(values, options2 = {}) {
    return await this._frame.selectOption(this._selector, values, { strict: true, ...options2 });
  }
  async selectText(options2 = {}) {
    return await this._withElement((h, timeout) => h.selectText({ ...options2, timeout }), { title: "Select text", timeout: options2.timeout });
  }
  async setChecked(checked, options2) {
    if (checked)
      await this.check(options2);
    else
      await this.uncheck(options2);
  }
  async setInputFiles(files, options2 = {}) {
    return await this._frame.setInputFiles(this._selector, files, { strict: true, ...options2 });
  }
  async tap(options2 = {}) {
    return await this._frame.tap(this._selector, { strict: true, ...options2 });
  }
  async textContent(options2) {
    return await this._frame.textContent(this._selector, { strict: true, ...options2 });
  }
  async type(text, options2 = {}) {
    return await this._frame.type(this._selector, text, { strict: true, ...options2 });
  }
  async pressSequentially(text, options2 = {}) {
    return await this.type(text, options2);
  }
  async uncheck(options2 = {}) {
    return await this._frame.uncheck(this._selector, { strict: true, ...options2 });
  }
  async all() {
    return new Array(await this.count()).fill(0).map((e, i) => this.nth(i));
  }
  async allInnerTexts() {
    return await this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
  }
  async allTextContents() {
    return await this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
  }
  async waitFor(options2) {
    await this._frame._channel.waitForSelector({ selector: this._selector, strict: true, omitReturnValue: true, ...options2, timeout: this._frame._timeout(options2) });
  }
  async _expect(expression, options2) {
    return this._frame._expect(expression, {
      ...options2,
      selector: this._selector
    });
  }
  _inspect() {
    return this.toString();
  }
  toString() {
    return asLocator("javascript", this._selector);
  }
};
var FrameLocator = class _FrameLocator {
  static {
    __name(this, "FrameLocator");
  }
  constructor(frame, selector) {
    this._frame = frame;
    this._frameSelector = selector;
  }
  locator(selectorOrLocator, options2) {
    if (isString(selectorOrLocator))
      return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator, options2);
    if (selectorOrLocator._frame !== this._frame)
      throw new Error(`Locators must belong to the same frame.`);
    return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator._selector, options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  owner() {
    return new Locator(this._frame, this._frameSelector);
  }
  frameLocator(selector) {
    return new _FrameLocator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selector);
  }
  first() {
    return new _FrameLocator(this._frame, this._frameSelector + " >> nth=0");
  }
  last() {
    return new _FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
  }
  nth(index2) {
    return new _FrameLocator(this._frame, this._frameSelector + ` >> nth=${index2}`);
  }
};
var _testIdAttributeName = "data-testid";
function testIdAttributeName() {
  return _testIdAttributeName;
}
__name(testIdAttributeName, "testIdAttributeName");
function setTestIdAttribute(attributeName) {
  _testIdAttributeName = attributeName;
}
__name(setTestIdAttribute, "setTestIdAttribute");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/network.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/fetch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/tracing.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Tracing2 = class extends ChannelOwner {
  static {
    __name(this, "Tracing");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._includeSources = false;
    this._isTracing = false;
  }
  static from(channel2) {
    return channel2._object;
  }
  async start(options2 = {}) {
    await this._wrapApiCall(async () => {
      this._includeSources = !!options2.sources;
      await this._channel.tracingStart({
        name: options2.name,
        snapshots: options2.snapshots,
        screenshots: options2.screenshots,
        live: options2._live
      });
      const { traceName } = await this._channel.tracingStartChunk({ name: options2.name, title: options2.title });
      await this._startCollectingStacks(traceName);
    });
  }
  async startChunk(options2 = {}) {
    await this._wrapApiCall(async () => {
      const { traceName } = await this._channel.tracingStartChunk(options2);
      await this._startCollectingStacks(traceName);
    });
  }
  async group(name, options2 = {}) {
    await this._channel.tracingGroup({ name, location: options2.location });
  }
  async groupEnd() {
    await this._channel.tracingGroupEnd();
  }
  async _startCollectingStacks(traceName) {
    if (!this._isTracing) {
      this._isTracing = true;
      this._connection.setIsTracing(true);
    }
    const result = await this._connection.localUtils()?.tracingStarted({ tracesDir: this._tracesDir, traceName });
    this._stacksId = result?.stacksId;
  }
  async stopChunk(options2 = {}) {
    await this._wrapApiCall(async () => {
      await this._doStopChunk(options2.path);
    });
  }
  async stop(options2 = {}) {
    await this._wrapApiCall(async () => {
      await this._doStopChunk(options2.path);
      await this._channel.tracingStop();
    });
  }
  async _doStopChunk(filePath) {
    this._resetStackCounter();
    if (!filePath) {
      await this._channel.tracingStopChunk({ mode: "discard" });
      if (this._stacksId)
        await this._connection.localUtils().traceDiscarded({ stacksId: this._stacksId });
      return;
    }
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Cannot save trace in thin clients");
    const isLocal = !this._connection.isRemote();
    if (isLocal) {
      const result2 = await this._channel.tracingStopChunk({ mode: "entries" });
      await localUtils.zip({ zipFile: filePath, entries: result2.entries, mode: "write", stacksId: this._stacksId, includeSources: this._includeSources });
      return;
    }
    const result = await this._channel.tracingStopChunk({ mode: "archive" });
    if (!result.artifact) {
      if (this._stacksId)
        await localUtils.traceDiscarded({ stacksId: this._stacksId });
      return;
    }
    const artifact = Artifact2.from(result.artifact);
    await artifact.saveAs(filePath);
    await artifact.delete();
    await localUtils.zip({ zipFile: filePath, entries: [], mode: "append", stacksId: this._stacksId, includeSources: this._includeSources });
  }
  _resetStackCounter() {
    if (this._isTracing) {
      this._isTracing = false;
      this._connection.setIsTracing(false);
    }
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/timeoutSettings.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TimeoutSettings = class {
  static {
    __name(this, "TimeoutSettings");
  }
  constructor(platform2, parent) {
    this._parent = parent;
    this._platform = platform2;
  }
  setDefaultTimeout(timeout) {
    this._defaultTimeout = timeout;
  }
  setDefaultNavigationTimeout(timeout) {
    this._defaultNavigationTimeout = timeout;
  }
  defaultNavigationTimeout() {
    return this._defaultNavigationTimeout;
  }
  defaultTimeout() {
    return this._defaultTimeout;
  }
  navigationTimeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._defaultNavigationTimeout !== void 0)
      return this._defaultNavigationTimeout;
    if (this._platform.isDebugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.navigationTimeout(options2);
    return DEFAULT_PLAYWRIGHT_TIMEOUT;
  }
  timeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._platform.isDebugMode())
      return 0;
    if (this._defaultTimeout !== void 0)
      return this._defaultTimeout;
    if (this._parent)
      return this._parent.timeout(options2);
    return DEFAULT_PLAYWRIGHT_TIMEOUT;
  }
  launchTimeout(options2) {
    if (typeof options2.timeout === "number")
      return options2.timeout;
    if (this._platform.isDebugMode())
      return 0;
    if (this._parent)
      return this._parent.launchTimeout(options2);
    return DEFAULT_PLAYWRIGHT_LAUNCH_TIMEOUT;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/fetch.js
var APIRequest = class {
  static {
    __name(this, "APIRequest");
  }
  constructor(playwright2) {
    this._contexts = /* @__PURE__ */ new Set();
    this._playwright = playwright2;
  }
  async newContext(options2 = {}) {
    options2 = {
      ...this._playwright._defaultContextOptions,
      ...options2
    };
    const storageState = typeof options2.storageState === "string" ? JSON.parse(await this._playwright._platform.fs().promises.readFile(options2.storageState, "utf8")) : options2.storageState;
    const context2 = APIRequestContext2.from((await this._playwright._channel.newRequest({
      ...options2,
      extraHTTPHeaders: options2.extraHTTPHeaders ? headersObjectToArray(options2.extraHTTPHeaders) : void 0,
      storageState,
      tracesDir: this._playwright._defaultLaunchOptions?.tracesDir,
      // We do not expose tracesDir in the API, so do not allow options to accidentally override it.
      clientCertificates: await toClientCertificatesProtocol(this._playwright._platform, options2.clientCertificates)
    })).request);
    this._contexts.add(context2);
    context2._request = this;
    context2._timeoutSettings.setDefaultTimeout(options2.timeout ?? this._playwright._defaultContextTimeout);
    context2._tracing._tracesDir = this._playwright._defaultLaunchOptions?.tracesDir;
    await context2._instrumentation.runAfterCreateRequestContext(context2);
    return context2;
  }
};
var APIRequestContext2 = class extends ChannelOwner {
  static {
    __name(this, "APIRequestContext");
  }
  static from(channel2) {
    return channel2._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._tracing = Tracing2.from(initializer.tracing);
    this._timeoutSettings = new TimeoutSettings(this._platform);
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose(options2 = {}) {
    this._closeReason = options2.reason;
    await this._instrumentation.runBeforeCloseRequestContext(this);
    try {
      await this._channel.dispose(options2);
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
    this._tracing._resetStackCounter();
    this._request?._contexts.delete(this);
  }
  async delete(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "DELETE"
    });
  }
  async head(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "HEAD"
    });
  }
  async get(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "GET"
    });
  }
  async patch(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "PATCH"
    });
  }
  async post(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "POST"
    });
  }
  async put(url4, options2) {
    return await this.fetch(url4, {
      ...options2,
      method: "PUT"
    });
  }
  async fetch(urlOrRequest, options2 = {}) {
    const url4 = isString(urlOrRequest) ? urlOrRequest : void 0;
    const request2 = isString(urlOrRequest) ? void 0 : urlOrRequest;
    return await this._innerFetch({ url: url4, request: request2, ...options2 });
  }
  async _innerFetch(options2 = {}) {
    return await this._wrapApiCall(async () => {
      if (this._closeReason)
        throw new TargetClosedError2(this._closeReason);
      assert3(options2.request || typeof options2.url === "string", "First argument must be either URL string or Request");
      assert3((options2.data === void 0 ? 0 : 1) + (options2.form === void 0 ? 0 : 1) + (options2.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      assert3(options2.maxRedirects === void 0 || options2.maxRedirects >= 0, `'maxRedirects' must be greater than or equal to '0'`);
      assert3(options2.maxRetries === void 0 || options2.maxRetries >= 0, `'maxRetries' must be greater than or equal to '0'`);
      const url4 = options2.url !== void 0 ? options2.url : options2.request.url();
      const method = options2.method || options2.request?.method();
      let encodedParams = void 0;
      if (typeof options2.params === "string")
        encodedParams = options2.params;
      else if (options2.params instanceof URLSearchParams)
        encodedParams = options2.params.toString();
      const headersObj = options2.headers || options2.request?.headers();
      const headers = headersObj ? headersObjectToArray(headersObj) : void 0;
      let jsonData;
      let formData;
      let multipartData;
      let postDataBuffer;
      if (options2.data !== void 0) {
        if (isString(options2.data)) {
          if (isJsonContentType(headers))
            jsonData = isJsonParsable(options2.data) ? options2.data : JSON.stringify(options2.data);
          else
            postDataBuffer = Buffer.from(options2.data, "utf8");
        } else if (Buffer.isBuffer(options2.data)) {
          postDataBuffer = options2.data;
        } else if (typeof options2.data === "object" || typeof options2.data === "number" || typeof options2.data === "boolean") {
          jsonData = JSON.stringify(options2.data);
        } else {
          throw new Error(`Unexpected 'data' type`);
        }
      } else if (options2.form) {
        if (globalThis.FormData && options2.form instanceof FormData) {
          formData = [];
          for (const [name, value] of options2.form.entries()) {
            if (typeof value !== "string")
              throw new Error(`Expected string for options.form["${name}"], found File. Please use options.multipart instead.`);
            formData.push({ name, value });
          }
        } else {
          formData = objectToArray(options2.form);
        }
      } else if (options2.multipart) {
        multipartData = [];
        if (globalThis.FormData && options2.multipart instanceof FormData) {
          const form = options2.multipart;
          for (const [name, value] of form.entries()) {
            if (isString(value)) {
              multipartData.push({ name, value });
            } else {
              const file = {
                name: value.name,
                mimeType: value.type,
                buffer: Buffer.from(await value.arrayBuffer())
              };
              multipartData.push({ name, file });
            }
          }
        } else {
          for (const [name, value] of Object.entries(options2.multipart))
            multipartData.push(await toFormField(this._platform, name, value));
        }
      }
      if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
        postDataBuffer = options2.request?.postDataBuffer() || void 0;
      const fixtures = {
        __testHookLookup: options2.__testHookLookup
      };
      const result = await this._channel.fetch({
        url: url4,
        params: typeof options2.params === "object" ? objectToArray(options2.params) : void 0,
        encodedParams,
        method,
        headers,
        postData: postDataBuffer,
        jsonData,
        formData,
        multipartData,
        timeout: this._timeoutSettings.timeout(options2),
        failOnStatusCode: options2.failOnStatusCode,
        ignoreHTTPSErrors: options2.ignoreHTTPSErrors,
        maxRedirects: options2.maxRedirects,
        maxRetries: options2.maxRetries,
        ...fixtures
      });
      return new APIResponse(this, result.response);
    });
  }
  async storageState(options2 = {}) {
    const state = await this._channel.storageState({ indexedDB: options2.indexedDB });
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
    }
    return state;
  }
};
async function toFormField(platform2, name, value) {
  const typeOfValue = typeof value;
  if (isFilePayload(value)) {
    const payload = value;
    if (!Buffer.isBuffer(payload.buffer))
      throw new Error(`Unexpected buffer type of 'data.${name}'`);
    return { name, file: filePayloadToJson(payload) };
  } else if (typeOfValue === "string" || typeOfValue === "number" || typeOfValue === "boolean") {
    return { name, value: String(value) };
  } else {
    return { name, file: await readStreamToJson(platform2, value) };
  }
}
__name(toFormField, "toFormField");
function isJsonParsable(value) {
  if (typeof value !== "string")
    return false;
  try {
    JSON.parse(value);
    return true;
  } catch (e) {
    if (e instanceof SyntaxError)
      return false;
    else
      throw e;
  }
}
__name(isJsonParsable, "isJsonParsable");
var APIResponse = class {
  static {
    __name(this, "APIResponse");
  }
  constructor(context2, initializer) {
    this._request = context2;
    this._initializer = initializer;
    this._headers = new RawHeaders(this._initializer.headers);
    if (context2._platform.inspectCustom)
      this[context2._platform.inspectCustom] = () => this._inspect();
  }
  ok() {
    return this._initializer.status >= 200 && this._initializer.status <= 299;
  }
  url() {
    return this._initializer.url;
  }
  status() {
    return this._initializer.status;
  }
  statusText() {
    return this._initializer.statusText;
  }
  headers() {
    return this._headers.headers();
  }
  headersArray() {
    return this._headers.headersArray();
  }
  async body() {
    return await this._request._wrapApiCall(async () => {
      try {
        const result = await this._request._channel.fetchResponseBody({ fetchUid: this._fetchUid() });
        if (result.binary === void 0)
          throw new Error("Response has been disposed");
        return result.binary;
      } catch (e) {
        if (isTargetClosedError2(e))
          throw new Error("Response has been disposed");
        throw e;
      }
    }, { internal: true });
  }
  async text() {
    const content = await this.body();
    return content.toString("utf8");
  }
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  async dispose() {
    await this._request._channel.disposeAPIResponse({ fetchUid: this._fetchUid() });
  }
  _inspect() {
    const headers = this.headersArray().map(({ name, value }) => `  ${name}: ${value}`);
    return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
  }
  _fetchUid() {
    return this._initializer.fetchUid;
  }
  async _fetchLog() {
    const { log: log3 } = await this._request._channel.fetchLog({ fetchUid: this._fetchUid() });
    return log3;
  }
};
function filePayloadToJson(payload) {
  return {
    name: payload.name,
    mimeType: payload.mimeType,
    buffer: payload.buffer
  };
}
__name(filePayloadToJson, "filePayloadToJson");
async function readStreamToJson(platform2, stream) {
  const buffer = await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", (err) => reject(err));
  });
  const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
  return {
    name: platform2.path().basename(streamPath),
    buffer
  };
}
__name(readStreamToJson, "readStreamToJson");
function isJsonContentType(headers) {
  if (!headers)
    return false;
  for (const { name, value } of headers) {
    if (name.toLocaleLowerCase() === "content-type")
      return value === "application/json";
  }
  return false;
}
__name(isJsonContentType, "isJsonContentType");
function objectToArray(map2) {
  if (!map2)
    return void 0;
  const result = [];
  for (const [name, value] of Object.entries(map2)) {
    if (value !== void 0)
      result.push({ name, value: String(value) });
  }
  return result;
}
__name(objectToArray, "objectToArray");
function isFilePayload(value) {
  return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
}
__name(isFilePayload, "isFilePayload");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/waiter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Waiter = class _Waiter {
  static {
    __name(this, "Waiter");
  }
  constructor(channelOwner, event) {
    this._failures = [];
    this._logs = [];
    this._waitId = channelOwner._platform.createGuid();
    this._channelOwner = channelOwner;
    this._savedZone = channelOwner._platform.zones.current().pop();
    this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "before", event } }).catch(() => {
    });
    this._dispose = [
      () => this._channelOwner._wrapApiCall(async () => {
        await this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "after", error: this._error } });
      }, { internal: true }).catch(() => {
      })
    ];
  }
  static createForEvent(channelOwner, event) {
    return new _Waiter(channelOwner, event);
  }
  async waitForEvent(emitter, event, predicate) {
    const { promise, dispose } = waitForEvent(emitter, event, this._savedZone, predicate);
    return await this.waitForPromise(promise, dispose);
  }
  rejectOnEvent(emitter, event, error3, predicate) {
    const { promise, dispose } = waitForEvent(emitter, event, this._savedZone, predicate);
    this._rejectOn(promise.then(() => {
      throw typeof error3 === "function" ? error3() : error3;
    }), dispose);
  }
  rejectOnTimeout(timeout, message) {
    if (!timeout)
      return;
    const { promise, dispose } = waitForTimeout(timeout);
    this._rejectOn(promise.then(() => {
      throw new TimeoutError2(message);
    }), dispose);
  }
  rejectImmediately(error3) {
    this._immediateError = error3;
  }
  dispose() {
    for (const dispose of this._dispose)
      dispose();
  }
  async waitForPromise(promise, dispose) {
    try {
      if (this._immediateError)
        throw this._immediateError;
      const result = await Promise.race([promise, ...this._failures]);
      if (dispose)
        dispose();
      return result;
    } catch (e) {
      if (dispose)
        dispose();
      this._error = e.message;
      this.dispose();
      rewriteErrorMessage(e, e.message + formatLogRecording(this._logs));
      throw e;
    }
  }
  log(s) {
    this._logs.push(s);
    this._channelOwner._wrapApiCall(async () => {
      await this._channelOwner._channel.waitForEventInfo({ info: { waitId: this._waitId, phase: "log", message: s } });
    }, { internal: true }).catch(() => {
    });
  }
  _rejectOn(promise, dispose) {
    this._failures.push(promise);
    if (dispose)
      this._dispose.push(dispose);
  }
};
function waitForEvent(emitter, event, savedZone, predicate) {
  let listener;
  const promise = new Promise((resolve, reject) => {
    listener = /* @__PURE__ */ __name(async (eventArg) => {
      await savedZone.run(async () => {
        try {
          if (predicate && !await predicate(eventArg))
            return;
          emitter.removeListener(event, listener);
          resolve(eventArg);
        } catch (e) {
          emitter.removeListener(event, listener);
          reject(e);
        }
      });
    }, "listener");
    emitter.addListener(event, listener);
  });
  const dispose = /* @__PURE__ */ __name(() => emitter.removeListener(event, listener), "dispose");
  return { promise, dispose };
}
__name(waitForEvent, "waitForEvent");
function waitForTimeout(timeout) {
  let timeoutId;
  const promise = new Promise((resolve) => timeoutId = setTimeout(resolve, timeout));
  const dispose = /* @__PURE__ */ __name(() => clearTimeout(timeoutId), "dispose");
  return { promise, dispose };
}
__name(waitForTimeout, "waitForTimeout");
function formatLogRecording(log3) {
  if (!log3.length)
    return "";
  const header = ` logs `;
  const headerLength = 60;
  const leftLength = (headerLength - header.length) / 2;
  const rightLength = headerLength - header.length - leftLength;
  return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log3.join("\n")}
${"=".repeat(headerLength)}`;
}
__name(formatLogRecording, "formatLogRecording");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/worker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Worker2 = class extends ChannelOwner {
  static {
    __name(this, "Worker");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._closedScope = new LongStandingScope();
    this._channel.on("close", () => {
      if (this._page)
        this._page._workers.delete(this);
      if (this._context)
        this._context._serviceWorkers.delete(this);
      this.emit(Events.Worker.Close, this);
    });
    this.once(Events.Worker.Close, () => this._closedScope.close(this._page?._closeErrorWithReason() || new TargetClosedError2()));
  }
  static from(worker) {
    return worker._object;
  }
  url() {
    return this._initializer.url;
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/network.js
var Request2 = class _Request extends ChannelOwner {
  static {
    __name(this, "Request");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._redirectedFrom = null;
    this._redirectedTo = null;
    this._failureText = null;
    this._fallbackOverrides = {};
    this._redirectedFrom = _Request.fromNullable(initializer.redirectedFrom);
    if (this._redirectedFrom)
      this._redirectedFrom._redirectedTo = this;
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._timing = {
      startTime: 0,
      domainLookupStart: -1,
      domainLookupEnd: -1,
      connectStart: -1,
      secureConnectionStart: -1,
      connectEnd: -1,
      requestStart: -1,
      responseStart: -1,
      responseEnd: -1
    };
  }
  static from(request2) {
    return request2._object;
  }
  static fromNullable(request2) {
    return request2 ? _Request.from(request2) : null;
  }
  url() {
    return this._fallbackOverrides.url || this._initializer.url;
  }
  resourceType() {
    return this._initializer.resourceType;
  }
  method() {
    return this._fallbackOverrides.method || this._initializer.method;
  }
  postData() {
    return (this._fallbackOverrides.postDataBuffer || this._initializer.postData)?.toString("utf-8") || null;
  }
  postDataBuffer() {
    return this._fallbackOverrides.postDataBuffer || this._initializer.postData || null;
  }
  postDataJSON() {
    const postData = this.postData();
    if (!postData)
      return null;
    const contentType = this.headers()["content-type"];
    if (contentType?.includes("application/x-www-form-urlencoded")) {
      const entries = {};
      const parsed = new URLSearchParams(postData);
      for (const [k, v] of parsed.entries())
        entries[k] = v;
      return entries;
    }
    try {
      return JSON.parse(postData);
    } catch (e) {
      throw new Error("POST data is not a valid JSON object: " + postData);
    }
  }
  /**
   * @deprecated
   */
  headers() {
    if (this._fallbackOverrides.headers)
      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();
    return this._provisionalHeaders.headers();
  }
  async _actualHeaders() {
    if (this._fallbackOverrides.headers)
      return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers);
    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = this._wrapApiCall(async () => {
        return new RawHeaders((await this._channel.rawRequestHeaders()).headers);
      }, { internal: true });
    }
    return await this._actualHeadersPromise;
  }
  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }
  async headersArray() {
    return (await this._actualHeaders()).headersArray();
  }
  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }
  async response() {
    return Response3.fromNullable((await this._channel.response()).response);
  }
  async _internalResponse() {
    return Response3.fromNullable((await this._channel.response()).response);
  }
  frame() {
    if (!this._initializer.frame) {
      assert3(this.serviceWorker());
      throw new Error("Service Worker requests do not have an associated frame.");
    }
    const frame = Frame2.from(this._initializer.frame);
    if (!frame._page) {
      throw new Error([
        "Frame for this navigation request is not available, because the request",
        "was issued before the frame is created. You can check whether the request",
        "is a navigation request by calling isNavigationRequest() method."
      ].join("\n"));
    }
    return frame;
  }
  _safePage() {
    return Frame2.fromNullable(this._initializer.frame)?._page || null;
  }
  serviceWorker() {
    return this._initializer.serviceWorker ? Worker2.from(this._initializer.serviceWorker) : null;
  }
  isNavigationRequest() {
    return this._initializer.isNavigationRequest;
  }
  redirectedFrom() {
    return this._redirectedFrom;
  }
  redirectedTo() {
    return this._redirectedTo;
  }
  failure() {
    if (this._failureText === null)
      return null;
    return {
      errorText: this._failureText
    };
  }
  timing() {
    return this._timing;
  }
  async sizes() {
    const response = await this.response();
    if (!response)
      throw new Error("Unable to fetch sizes for failed request");
    return (await response._channel.sizes()).sizes;
  }
  _setResponseEndTiming(responseEndTiming) {
    this._timing.responseEnd = responseEndTiming;
    if (this._timing.responseStart === -1)
      this._timing.responseStart = responseEndTiming;
  }
  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }
  _applyFallbackOverrides(overrides) {
    if (overrides.url)
      this._fallbackOverrides.url = overrides.url;
    if (overrides.method)
      this._fallbackOverrides.method = overrides.method;
    if (overrides.headers)
      this._fallbackOverrides.headers = overrides.headers;
    if (isString(overrides.postData))
      this._fallbackOverrides.postDataBuffer = Buffer.from(overrides.postData, "utf-8");
    else if (overrides.postData instanceof Buffer)
      this._fallbackOverrides.postDataBuffer = overrides.postData;
    else if (overrides.postData)
      this._fallbackOverrides.postDataBuffer = Buffer.from(JSON.stringify(overrides.postData), "utf-8");
  }
  _fallbackOverridesForContinue() {
    return this._fallbackOverrides;
  }
  _targetClosedScope() {
    return this.serviceWorker()?._closedScope || this._safePage()?._closedOrCrashedScope || new LongStandingScope();
  }
};
var Route2 = class extends ChannelOwner {
  static {
    __name(this, "Route");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._handlingPromise = null;
    this._didThrow = false;
  }
  static from(route) {
    return route._object;
  }
  request() {
    return Request2.from(this._initializer.request);
  }
  async _raceWithTargetClose(promise) {
    return await this.request()._targetClosedScope().safeRace(promise);
  }
  async _startHandling() {
    this._handlingPromise = new ManualPromise();
    return await this._handlingPromise;
  }
  async fallback(options2 = {}) {
    this._checkNotHandled();
    this.request()._applyFallbackOverrides(options2);
    this._reportHandled(false);
  }
  async abort(errorCode) {
    await this._handleRoute(async () => {
      await this._raceWithTargetClose(this._channel.abort({ errorCode }));
    });
  }
  async _redirectNavigationRequest(url4) {
    await this._handleRoute(async () => {
      await this._raceWithTargetClose(this._channel.redirectNavigationRequest({ url: url4 }));
    });
  }
  async fetch(options2 = {}) {
    return await this._wrapApiCall(async () => {
      return await this._context.request._innerFetch({ request: this.request(), data: options2.postData, ...options2 });
    });
  }
  async fulfill(options2 = {}) {
    await this._handleRoute(async () => {
      await this._innerFulfill(options2);
    });
  }
  async _handleRoute(callback) {
    this._checkNotHandled();
    try {
      await callback();
      this._reportHandled(true);
    } catch (e) {
      this._didThrow = true;
      throw e;
    }
  }
  async _innerFulfill(options2 = {}) {
    let fetchResponseUid;
    let { status: statusOption, headers: headersOption, body } = options2;
    if (options2.json !== void 0) {
      assert3(options2.body === void 0, "Can specify either body or json parameters");
      body = JSON.stringify(options2.json);
    }
    if (options2.response instanceof APIResponse) {
      statusOption ??= options2.response.status();
      headersOption ??= options2.response.headers();
      if (body === void 0 && options2.path === void 0) {
        if (options2.response._request._connection === this._connection)
          fetchResponseUid = options2.response._fetchUid();
        else
          body = await options2.response.body();
      }
    }
    let isBase64 = false;
    let length = 0;
    if (options2.path) {
      const buffer = await this._platform.fs().promises.readFile(options2.path);
      body = buffer.toString("base64");
      isBase64 = true;
      length = buffer.length;
    } else if (isString(body)) {
      isBase64 = false;
      length = Buffer.byteLength(body);
    } else if (body) {
      length = body.length;
      body = body.toString("base64");
      isBase64 = true;
    }
    const headers = {};
    for (const header of Object.keys(headersOption || {}))
      headers[header.toLowerCase()] = String(headersOption[header]);
    if (options2.contentType)
      headers["content-type"] = String(options2.contentType);
    else if (options2.json)
      headers["content-type"] = "application/json";
    else if (options2.path)
      headers["content-type"] = getMimeTypeForPath(options2.path) || "application/octet-stream";
    if (length && !("content-length" in headers))
      headers["content-length"] = String(length);
    await this._raceWithTargetClose(this._channel.fulfill({
      status: statusOption || 200,
      headers: headersObjectToArray(headers),
      body,
      isBase64,
      fetchResponseUid
    }));
  }
  async continue(options2 = {}) {
    await this._handleRoute(async () => {
      this.request()._applyFallbackOverrides(options2);
      await this._innerContinue(
        false
        /* isFallback */
      );
    });
  }
  _checkNotHandled() {
    if (!this._handlingPromise)
      throw new Error("Route is already handled!");
  }
  _reportHandled(done) {
    const chain = this._handlingPromise;
    this._handlingPromise = null;
    chain.resolve(done);
  }
  async _innerContinue(isFallback) {
    const options2 = this.request()._fallbackOverridesForContinue();
    return await this._raceWithTargetClose(this._channel.continue({
      url: options2.url,
      method: options2.method,
      headers: options2.headers ? headersObjectToArray(options2.headers) : void 0,
      postData: options2.postDataBuffer,
      isFallback
    }));
  }
};
var WebSocketRoute = class extends ChannelOwner {
  static {
    __name(this, "WebSocketRoute");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._connected = false;
    this._server = {
      onMessage: /* @__PURE__ */ __name((handler) => {
        this._onServerMessage = handler;
      }, "onMessage"),
      onClose: /* @__PURE__ */ __name((handler) => {
        this._onServerClose = handler;
      }, "onClose"),
      connectToServer: /* @__PURE__ */ __name(() => {
        throw new Error(`connectToServer must be called on the page-side WebSocketRoute`);
      }, "connectToServer"),
      url: /* @__PURE__ */ __name(() => {
        return this._initializer.url;
      }, "url"),
      close: /* @__PURE__ */ __name(async (options2 = {}) => {
        await this._channel.closeServer({ ...options2, wasClean: true }).catch(() => {
        });
      }, "close"),
      send: /* @__PURE__ */ __name((message) => {
        if (isString(message))
          this._channel.sendToServer({ message, isBase64: false }).catch(() => {
          });
        else
          this._channel.sendToServer({ message: message.toString("base64"), isBase64: true }).catch(() => {
          });
      }, "send"),
      async [Symbol.asyncDispose]() {
        await this.close();
      }
    };
    this._channel.on("messageFromPage", ({ message, isBase64 }) => {
      if (this._onPageMessage)
        this._onPageMessage(isBase64 ? Buffer.from(message, "base64") : message);
      else if (this._connected)
        this._channel.sendToServer({ message, isBase64 }).catch(() => {
        });
    });
    this._channel.on("messageFromServer", ({ message, isBase64 }) => {
      if (this._onServerMessage)
        this._onServerMessage(isBase64 ? Buffer.from(message, "base64") : message);
      else
        this._channel.sendToPage({ message, isBase64 }).catch(() => {
        });
    });
    this._channel.on("closePage", ({ code, reason, wasClean }) => {
      if (this._onPageClose)
        this._onPageClose(code, reason);
      else
        this._channel.closeServer({ code, reason, wasClean }).catch(() => {
        });
    });
    this._channel.on("closeServer", ({ code, reason, wasClean }) => {
      if (this._onServerClose)
        this._onServerClose(code, reason);
      else
        this._channel.closePage({ code, reason, wasClean }).catch(() => {
        });
    });
  }
  static from(route) {
    return route._object;
  }
  url() {
    return this._initializer.url;
  }
  async close(options2 = {}) {
    await this._channel.closePage({ ...options2, wasClean: true }).catch(() => {
    });
  }
  connectToServer() {
    if (this._connected)
      throw new Error("Already connected to the server");
    this._connected = true;
    this._channel.connect().catch(() => {
    });
    return this._server;
  }
  send(message) {
    if (isString(message))
      this._channel.sendToPage({ message, isBase64: false }).catch(() => {
      });
    else
      this._channel.sendToPage({ message: message.toString("base64"), isBase64: true }).catch(() => {
      });
  }
  onMessage(handler) {
    this._onPageMessage = handler;
  }
  onClose(handler) {
    this._onPageClose = handler;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async _afterHandle() {
    if (this._connected)
      return;
    await this._channel.ensureOpened().catch(() => {
    });
  }
};
var WebSocketRouteHandler = class {
  static {
    __name(this, "WebSocketRouteHandler");
  }
  constructor(baseURL, url4, handler) {
    this._baseURL = baseURL;
    this.url = url4;
    this.handler = handler;
  }
  static prepareInterceptionPatterns(handlers) {
    const patterns = [];
    let all = false;
    for (const handler of handlers) {
      if (isString(handler.url))
        patterns.push({ glob: handler.url });
      else if (isRegExp2(handler.url))
        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });
      else
        all = true;
    }
    if (all)
      return [{ glob: "**/*" }];
    return patterns;
  }
  matches(wsURL) {
    return urlMatches(this._baseURL, wsURL, this.url, true);
  }
  async handle(webSocketRoute) {
    const handler = this.handler;
    await handler(webSocketRoute);
    await webSocketRoute._afterHandle();
  }
};
var Response3 = class _Response extends ChannelOwner {
  static {
    __name(this, "Response");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._finishedPromise = new ManualPromise();
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._request = Request2.from(this._initializer.request);
    Object.assign(this._request._timing, this._initializer.timing);
  }
  static from(response) {
    return response._object;
  }
  static fromNullable(response) {
    return response ? _Response.from(response) : null;
  }
  url() {
    return this._initializer.url;
  }
  ok() {
    return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
  }
  status() {
    return this._initializer.status;
  }
  statusText() {
    return this._initializer.statusText;
  }
  fromServiceWorker() {
    return this._initializer.fromServiceWorker;
  }
  /**
   * @deprecated
   */
  headers() {
    return this._provisionalHeaders.headers();
  }
  async _actualHeaders() {
    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = (async () => {
        return new RawHeaders((await this._channel.rawResponseHeaders()).headers);
      })();
    }
    return await this._actualHeadersPromise;
  }
  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }
  async headersArray() {
    return (await this._actualHeaders()).headersArray().slice();
  }
  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }
  async headerValues(name) {
    return (await this._actualHeaders()).getAll(name);
  }
  async finished() {
    return await this.request()._targetClosedScope().race(this._finishedPromise);
  }
  async body() {
    return (await this._channel.body()).binary;
  }
  async text() {
    const content = await this.body();
    return content.toString("utf8");
  }
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
  request() {
    return this._request;
  }
  frame() {
    return this._request.frame();
  }
  async serverAddr() {
    return (await this._channel.serverAddr()).value || null;
  }
  async securityDetails() {
    return (await this._channel.securityDetails()).value || null;
  }
};
var WebSocket3 = class extends ChannelOwner {
  static {
    __name(this, "WebSocket");
  }
  static from(webSocket) {
    return webSocket._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._isClosed = false;
    this._page = parent;
    this._channel.on("frameSent", (event) => {
      if (event.opcode === 1)
        this.emit(Events.WebSocket.FrameSent, { payload: event.data });
      else if (event.opcode === 2)
        this.emit(Events.WebSocket.FrameSent, { payload: Buffer.from(event.data, "base64") });
    });
    this._channel.on("frameReceived", (event) => {
      if (event.opcode === 1)
        this.emit(Events.WebSocket.FrameReceived, { payload: event.data });
      else if (event.opcode === 2)
        this.emit(Events.WebSocket.FrameReceived, { payload: Buffer.from(event.data, "base64") });
    });
    this._channel.on("socketError", ({ error: error3 }) => this.emit(Events.WebSocket.Error, error3));
    this._channel.on("close", () => {
      this._isClosed = true;
      this.emit(Events.WebSocket.Close, this);
    });
  }
  url() {
    return this._initializer.url;
  }
  isClosed() {
    return this._isClosed;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.WebSocket.Error)
        waiter.rejectOnEvent(this, Events.WebSocket.Error, new Error("Socket error"));
      if (event !== Events.WebSocket.Close)
        waiter.rejectOnEvent(this, Events.WebSocket.Close, new Error("Socket closed"));
      waiter.rejectOnEvent(this._page, Events.Page.Close, () => this._page._closeErrorWithReason());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
};
function validateHeaders(headers) {
  for (const key of Object.keys(headers)) {
    const value = headers[key];
    if (!Object.is(value, void 0) && !isString(value))
      throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
  }
}
__name(validateHeaders, "validateHeaders");
var RouteHandler = class {
  static {
    __name(this, "RouteHandler");
  }
  constructor(platform2, baseURL, url4, handler, times = Number.MAX_SAFE_INTEGER) {
    this.handledCount = 0;
    this._ignoreException = false;
    this._activeInvocations = /* @__PURE__ */ new Set();
    this._baseURL = baseURL;
    this._times = times;
    this.url = url4;
    this.handler = handler;
    this._savedZone = platform2.zones.current().pop();
  }
  static prepareInterceptionPatterns(handlers) {
    const patterns = [];
    let all = false;
    for (const handler of handlers) {
      if (isString(handler.url))
        patterns.push({ glob: handler.url });
      else if (isRegExp2(handler.url))
        patterns.push({ regexSource: handler.url.source, regexFlags: handler.url.flags });
      else
        all = true;
    }
    if (all)
      return [{ glob: "**/*" }];
    return patterns;
  }
  matches(requestURL) {
    return urlMatches(this._baseURL, requestURL, this.url);
  }
  async handle(route) {
    return await this._savedZone.run(async () => this._handleImpl(route));
  }
  async _handleImpl(route) {
    const handlerInvocation = { complete: new ManualPromise(), route };
    this._activeInvocations.add(handlerInvocation);
    try {
      return await this._handleInternal(route);
    } catch (e) {
      if (this._ignoreException)
        return false;
      if (isTargetClosedError2(e)) {
        rewriteErrorMessage(e, `"${e.message}" while running route callback.
Consider awaiting \`await page.unrouteAll({ behavior: 'ignoreErrors' })\`
before the end of the test to ignore remaining routes in flight.`);
      }
      throw e;
    } finally {
      handlerInvocation.complete.resolve();
      this._activeInvocations.delete(handlerInvocation);
    }
  }
  async stop(behavior) {
    if (behavior === "ignoreErrors") {
      this._ignoreException = true;
    } else {
      const promises = [];
      for (const activation of this._activeInvocations) {
        if (!activation.route._didThrow)
          promises.push(activation.complete);
      }
      await Promise.all(promises);
    }
  }
  async _handleInternal(route) {
    ++this.handledCount;
    const handledPromise = route._startHandling();
    const handler = this.handler;
    const [handled] = await Promise.all([
      handledPromise,
      handler(route, route.request())
    ]);
    return handled;
  }
  willExpire() {
    return this.handledCount + 1 >= this._times;
  }
};
var RawHeaders = class _RawHeaders {
  static {
    __name(this, "RawHeaders");
  }
  constructor(headers) {
    this._headersMap = new MultiMap();
    this._headersArray = headers;
    for (const header of headers)
      this._headersMap.set(header.name.toLowerCase(), header.value);
  }
  static _fromHeadersObjectLossy(headers) {
    const headersArray = Object.entries(headers).map(([name, value]) => ({
      name,
      value
    })).filter((header) => header.value !== void 0);
    return new _RawHeaders(headersArray);
  }
  get(name) {
    const values = this.getAll(name);
    if (!values || !values.length)
      return null;
    return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
  }
  getAll(name) {
    return [...this._headersMap.get(name.toLowerCase())];
  }
  headers() {
    const result = {};
    for (const name of this._headersMap.keys())
      result[name] = this.get(name);
    return result;
  }
  headersArray() {
    return this._headersArray;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var kLifecycleEvents2 = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/frame.js
var Frame2 = class _Frame extends ChannelOwner {
  static {
    __name(this, "Frame");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._parentFrame = null;
    this._url = "";
    this._name = "";
    this._detached = false;
    this._childFrames = /* @__PURE__ */ new Set();
    this._eventEmitter = new EventEmitter18(parent._platform);
    this._eventEmitter.setMaxListeners(0);
    this._parentFrame = _Frame.fromNullable(initializer.parentFrame);
    if (this._parentFrame)
      this._parentFrame._childFrames.add(this);
    this._name = initializer.name;
    this._url = initializer.url;
    this._loadStates = new Set(initializer.loadStates);
    this._channel.on("loadstate", (event) => {
      if (event.add) {
        this._loadStates.add(event.add);
        this._eventEmitter.emit("loadstate", event.add);
      }
      if (event.remove)
        this._loadStates.delete(event.remove);
      if (!this._parentFrame && event.add === "load" && this._page)
        this._page.emit(Events.Page.Load, this._page);
      if (!this._parentFrame && event.add === "domcontentloaded" && this._page)
        this._page.emit(Events.Page.DOMContentLoaded, this._page);
    });
    this._channel.on("navigated", (event) => {
      this._url = event.url;
      this._name = event.name;
      this._eventEmitter.emit("navigated", event);
      if (!event.error && this._page)
        this._page.emit(Events.Page.FrameNavigated, this);
    });
  }
  static from(frame) {
    return frame._object;
  }
  static fromNullable(frame) {
    return frame ? _Frame.from(frame) : null;
  }
  page() {
    return this._page;
  }
  _timeout(options2) {
    const timeoutSettings = this._page?._timeoutSettings || new TimeoutSettings(this._platform);
    return timeoutSettings.timeout(options2 || {});
  }
  _navigationTimeout(options2) {
    const timeoutSettings = this._page?._timeoutSettings || new TimeoutSettings(this._platform);
    return timeoutSettings.navigationTimeout(options2 || {});
  }
  async goto(url4, options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goto({ url: url4, ...options2, waitUntil, timeout: this._navigationTimeout(options2) })).response);
  }
  _setupNavigationWaiter(options2) {
    const waiter = new Waiter(this._page, "");
    if (this._page.isClosed())
      waiter.rejectImmediately(this._page._closeErrorWithReason());
    waiter.rejectOnEvent(this._page, Events.Page.Close, () => this._page._closeErrorWithReason());
    waiter.rejectOnEvent(this._page, Events.Page.Crash, new Error("Navigation failed because page crashed!"));
    waiter.rejectOnEvent(this._page, Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
    const timeout = this._page._timeoutSettings.navigationTimeout(options2);
    waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
    return waiter;
  }
  async waitForNavigation(options2 = {}) {
    return await this._page._wrapApiCall(async () => {
      const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
      const waiter = this._setupNavigationWaiter(options2);
      const toUrl = typeof options2.url === "string" ? ` to "${options2.url}"` : "";
      waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
      const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
        if (event.error)
          return true;
        waiter.log(`  navigated to "${event.url}"`);
        return urlMatches(this._page?.context()._options.baseURL, event.url, options2.url);
      });
      if (navigatedEvent.error) {
        const e = new Error(navigatedEvent.error);
        e.stack = "";
        await waiter.waitForPromise(Promise.reject(e));
      }
      if (!this._loadStates.has(waitUntil)) {
        await waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
          waiter.log(`  "${s}" event fired`);
          return s === waitUntil;
        });
      }
      const request2 = navigatedEvent.newDocument ? Request2.fromNullable(navigatedEvent.newDocument.request) : null;
      const response = request2 ? await waiter.waitForPromise(request2._finalRequest()._internalResponse()) : null;
      waiter.dispose();
      return response;
    }, { title: "Wait for navigation" });
  }
  async waitForLoadState(state = "load", options2 = {}) {
    state = verifyLoadState("state", state);
    return await this._page._wrapApiCall(async () => {
      const waiter = this._setupNavigationWaiter(options2);
      if (this._loadStates.has(state)) {
        waiter.log(`  not waiting, "${state}" event already fired`);
      } else {
        await waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
          waiter.log(`  "${s}" event fired`);
          return s === state;
        });
      }
      waiter.dispose();
    }, { title: `Wait for load state "${state}"` });
  }
  async waitForURL(url4, options2 = {}) {
    if (urlMatches(this._page?.context()._options.baseURL, this.url(), url4))
      return await this.waitForLoadState(options2.waitUntil, options2);
    await this.waitForNavigation({ url: url4, ...options2 });
  }
  async frameElement() {
    return ElementHandle2.from((await this._channel.frameElement()).element);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async _evaluateFunction(functionDeclaration) {
    const result = await this._channel.evaluateExpression({ expression: functionDeclaration, isFunction: true, arg: serializeArgument(void 0) });
    return parseResult(result.value);
  }
  async _evaluateExposeUtilityScript(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $(selector, options2) {
    const result = await this._channel.querySelector({ selector, ...options2 });
    return ElementHandle2.fromNullable(result.element);
  }
  async waitForSelector(selector, options2 = {}) {
    if (options2.visibility)
      throw new Error("options.visibility is not supported, did you mean options.state?");
    if (options2.waitFor && options2.waitFor !== "visible")
      throw new Error("options.waitFor is not supported, did you mean options.state?");
    const result = await this._channel.waitForSelector({ selector, ...options2, timeout: this._timeout(options2) });
    return ElementHandle2.fromNullable(result.element);
  }
  async dispatchEvent(selector, type, eventInit, options2 = {}) {
    await this._channel.dispatchEvent({ selector, type, eventInit: serializeArgument(eventInit), ...options2, timeout: this._timeout(options2) });
  }
  async $eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    const result = await this._channel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    const result = await this._channel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$(selector) {
    const result = await this._channel.querySelectorAll({ selector });
    return result.elements.map((e) => ElementHandle2.from(e));
  }
  async _queryCount(selector, options2) {
    return (await this._channel.queryCount({ selector, ...options2 })).value;
  }
  async content() {
    return (await this._channel.content()).value;
  }
  async setContent(html, options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    await this._channel.setContent({ html, ...options2, waitUntil, timeout: this._navigationTimeout(options2) });
  }
  name() {
    return this._name || "";
  }
  url() {
    return this._url;
  }
  parentFrame() {
    return this._parentFrame;
  }
  childFrames() {
    return Array.from(this._childFrames);
  }
  isDetached() {
    return this._detached;
  }
  async addScriptTag(options2 = {}) {
    const copy = { ...options2 };
    if (copy.path) {
      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();
      copy.content = addSourceUrlToScript(copy.content, copy.path);
    }
    return ElementHandle2.from((await this._channel.addScriptTag({ ...copy })).element);
  }
  async addStyleTag(options2 = {}) {
    const copy = { ...options2 };
    if (copy.path) {
      copy.content = (await this._platform.fs().promises.readFile(copy.path)).toString();
      copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
    }
    return ElementHandle2.from((await this._channel.addStyleTag({ ...copy })).element);
  }
  async click(selector, options2 = {}) {
    return await this._channel.click({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async dblclick(selector, options2 = {}) {
    return await this._channel.dblclick({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async dragAndDrop(source8, target, options2 = {}) {
    return await this._channel.dragAndDrop({ source: source8, target, ...options2, timeout: this._timeout(options2) });
  }
  async tap(selector, options2 = {}) {
    return await this._channel.tap({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async fill(selector, value, options2 = {}) {
    return await this._channel.fill({ selector, value, ...options2, timeout: this._timeout(options2) });
  }
  async _highlight(selector) {
    return await this._channel.highlight({ selector });
  }
  locator(selector, options2) {
    return new Locator(this, selector, options2);
  }
  getByTestId(testId) {
    return this.locator(getByTestIdSelector(testIdAttributeName(), testId));
  }
  getByAltText(text, options2) {
    return this.locator(getByAltTextSelector(text, options2));
  }
  getByLabel(text, options2) {
    return this.locator(getByLabelSelector(text, options2));
  }
  getByPlaceholder(text, options2) {
    return this.locator(getByPlaceholderSelector(text, options2));
  }
  getByText(text, options2) {
    return this.locator(getByTextSelector(text, options2));
  }
  getByTitle(text, options2) {
    return this.locator(getByTitleSelector(text, options2));
  }
  getByRole(role, options2 = {}) {
    return this.locator(getByRoleSelector(role, options2));
  }
  frameLocator(selector) {
    return new FrameLocator(this, selector);
  }
  async focus(selector, options2 = {}) {
    await this._channel.focus({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async textContent(selector, options2 = {}) {
    const value = (await this._channel.textContent({ selector, ...options2, timeout: this._timeout(options2) })).value;
    return value === void 0 ? null : value;
  }
  async innerText(selector, options2 = {}) {
    return (await this._channel.innerText({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async innerHTML(selector, options2 = {}) {
    return (await this._channel.innerHTML({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async getAttribute(selector, name, options2 = {}) {
    const value = (await this._channel.getAttribute({ selector, name, ...options2, timeout: this._timeout(options2) })).value;
    return value === void 0 ? null : value;
  }
  async inputValue(selector, options2 = {}) {
    return (await this._channel.inputValue({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async isChecked(selector, options2 = {}) {
    return (await this._channel.isChecked({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async isDisabled(selector, options2 = {}) {
    return (await this._channel.isDisabled({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async isEditable(selector, options2 = {}) {
    return (await this._channel.isEditable({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async isEnabled(selector, options2 = {}) {
    return (await this._channel.isEnabled({ selector, ...options2, timeout: this._timeout(options2) })).value;
  }
  async isHidden(selector, options2 = {}) {
    return (await this._channel.isHidden({ selector, ...options2 })).value;
  }
  async isVisible(selector, options2 = {}) {
    return (await this._channel.isVisible({ selector, ...options2 })).value;
  }
  async hover(selector, options2 = {}) {
    await this._channel.hover({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async selectOption(selector, values, options2 = {}) {
    return (await this._channel.selectOption({ selector, ...convertSelectOptionValues(values), ...options2, timeout: this._timeout(options2) })).values;
  }
  async setInputFiles(selector, files, options2 = {}) {
    const converted = await convertInputFiles(this._platform, files, this.page().context());
    await this._channel.setInputFiles({ selector, ...converted, ...options2, timeout: this._timeout(options2) });
  }
  async type(selector, text, options2 = {}) {
    await this._channel.type({ selector, text, ...options2, timeout: this._timeout(options2) });
  }
  async press(selector, key, options2 = {}) {
    await this._channel.press({ selector, key, ...options2, timeout: this._timeout(options2) });
  }
  async check(selector, options2 = {}) {
    await this._channel.check({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async uncheck(selector, options2 = {}) {
    await this._channel.uncheck({ selector, ...options2, timeout: this._timeout(options2) });
  }
  async setChecked(selector, checked, options2) {
    if (checked)
      await this.check(selector, options2);
    else
      await this.uncheck(selector, options2);
  }
  async waitForTimeout(timeout) {
    await this._channel.waitForTimeout({ waitTimeout: timeout });
  }
  async waitForFunction(pageFunction, arg, options2 = {}) {
    if (typeof options2.polling === "string")
      assert3(options2.polling === "raf", "Unknown polling option: " + options2.polling);
    const result = await this._channel.waitForFunction({
      ...options2,
      pollingInterval: options2.polling === "raf" ? void 0 : options2.polling,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === "function",
      arg: serializeArgument(arg),
      timeout: this._timeout(options2)
    });
    return JSHandle2.from(result.handle);
  }
  async title() {
    return (await this._channel.title()).value;
  }
  async _expect(expression, options2) {
    const params = { expression, ...options2, isNot: !!options2.isNot };
    params.expectedValue = serializeArgument(options2.expectedValue);
    const result = await this._channel.expect(params);
    if (result.received !== void 0)
      result.received = parseResult(result.received);
    return result;
  }
};
function verifyLoadState(name, waitUntil) {
  if (waitUntil === "networkidle0")
    waitUntil = "networkidle";
  if (!kLifecycleEvents2.has(waitUntil))
    throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}
__name(verifyLoadState, "verifyLoadState");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/writableStream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WritableStream = class extends ChannelOwner {
  static {
    __name(this, "WritableStream");
  }
  static from(Stream2) {
    return Stream2._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }
  stream() {
    return this._platform.streamWritable(this._channel);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/elementHandle.js
var ElementHandle2 = class _ElementHandle extends JSHandle2 {
  static {
    __name(this, "ElementHandle");
  }
  static from(handle) {
    return handle._object;
  }
  static fromNullable(handle) {
    return handle ? _ElementHandle.from(handle) : null;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._frame = parent;
    this._elementChannel = this._channel;
  }
  asElement() {
    return this;
  }
  async ownerFrame() {
    return Frame2.fromNullable((await this._elementChannel.ownerFrame()).frame);
  }
  async contentFrame() {
    return Frame2.fromNullable((await this._elementChannel.contentFrame()).frame);
  }
  async getAttribute(name) {
    const value = (await this._elementChannel.getAttribute({ name })).value;
    return value === void 0 ? null : value;
  }
  async inputValue() {
    return (await this._elementChannel.inputValue()).value;
  }
  async textContent() {
    const value = (await this._elementChannel.textContent()).value;
    return value === void 0 ? null : value;
  }
  async innerText() {
    return (await this._elementChannel.innerText()).value;
  }
  async innerHTML() {
    return (await this._elementChannel.innerHTML()).value;
  }
  async isChecked() {
    return (await this._elementChannel.isChecked()).value;
  }
  async isDisabled() {
    return (await this._elementChannel.isDisabled()).value;
  }
  async isEditable() {
    return (await this._elementChannel.isEditable()).value;
  }
  async isEnabled() {
    return (await this._elementChannel.isEnabled()).value;
  }
  async isHidden() {
    return (await this._elementChannel.isHidden()).value;
  }
  async isVisible() {
    return (await this._elementChannel.isVisible()).value;
  }
  async dispatchEvent(type, eventInit = {}) {
    await this._elementChannel.dispatchEvent({ type, eventInit: serializeArgument(eventInit) });
  }
  async scrollIntoViewIfNeeded(options2 = {}) {
    await this._elementChannel.scrollIntoViewIfNeeded({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async hover(options2 = {}) {
    await this._elementChannel.hover({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async click(options2 = {}) {
    return await this._elementChannel.click({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async dblclick(options2 = {}) {
    return await this._elementChannel.dblclick({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async tap(options2 = {}) {
    return await this._elementChannel.tap({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async selectOption(values, options2 = {}) {
    const result = await this._elementChannel.selectOption({ ...convertSelectOptionValues(values), ...options2, timeout: this._frame._timeout(options2) });
    return result.values;
  }
  async fill(value, options2 = {}) {
    return await this._elementChannel.fill({ value, ...options2, timeout: this._frame._timeout(options2) });
  }
  async selectText(options2 = {}) {
    await this._elementChannel.selectText({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async setInputFiles(files, options2 = {}) {
    const frame = await this.ownerFrame();
    if (!frame)
      throw new Error("Cannot set input files to detached element");
    const converted = await convertInputFiles(this._platform, files, frame.page().context());
    await this._elementChannel.setInputFiles({ ...converted, ...options2, timeout: this._frame._timeout(options2) });
  }
  async focus() {
    await this._elementChannel.focus();
  }
  async type(text, options2 = {}) {
    await this._elementChannel.type({ text, ...options2, timeout: this._frame._timeout(options2) });
  }
  async press(key, options2 = {}) {
    await this._elementChannel.press({ key, ...options2, timeout: this._frame._timeout(options2) });
  }
  async check(options2 = {}) {
    return await this._elementChannel.check({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async uncheck(options2 = {}) {
    return await this._elementChannel.uncheck({ ...options2, timeout: this._frame._timeout(options2) });
  }
  async setChecked(checked, options2) {
    if (checked)
      await this.check(options2);
    else
      await this.uncheck(options2);
  }
  async boundingBox() {
    const value = (await this._elementChannel.boundingBox()).value;
    return value === void 0 ? null : value;
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    const copy = { ...options2, mask: void 0, timeout: this._frame._timeout(options2) };
    if (!copy.type)
      copy.type = determineScreenshotType(options2);
    if (mask) {
      copy.mask = mask.map((locator) => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }
    const result = await this._elementChannel.screenshot(copy);
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, result.binary);
    }
    return result.binary;
  }
  async $(selector) {
    return _ElementHandle.fromNullable((await this._elementChannel.querySelector({ selector })).element);
  }
  async $$(selector) {
    const result = await this._elementChannel.querySelectorAll({ selector });
    return result.elements.map((h) => _ElementHandle.from(h));
  }
  async $eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelector({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async $$eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelectorAll({ selector, expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async waitForElementState(state, options2 = {}) {
    return await this._elementChannel.waitForElementState({ state, ...options2, timeout: this._frame._timeout(options2) });
  }
  async waitForSelector(selector, options2 = {}) {
    const result = await this._elementChannel.waitForSelector({ selector, ...options2, timeout: this._frame._timeout(options2) });
    return _ElementHandle.fromNullable(result.element);
  }
};
function convertSelectOptionValues(values) {
  if (values === null)
    return {};
  if (!Array.isArray(values))
    values = [values];
  if (!values.length)
    return {};
  for (let i = 0; i < values.length; i++)
    assert3(values[i] !== null, `options[${i}]: expected object, got null`);
  if (values[0] instanceof ElementHandle2)
    return { elements: values.map((v) => v._elementChannel) };
  if (isString(values[0]))
    return { options: values.map((valueOrLabel) => ({ valueOrLabel })) };
  return { options: values };
}
__name(convertSelectOptionValues, "convertSelectOptionValues");
function filePayloadExceedsSizeLimit(payloads) {
  return payloads.reduce((size, item) => size + (item.buffer ? item.buffer.byteLength : 0), 0) >= fileUploadSizeLimit2;
}
__name(filePayloadExceedsSizeLimit, "filePayloadExceedsSizeLimit");
async function resolvePathsAndDirectoryForInputFiles(platform2, items) {
  let localPaths;
  let localDirectory;
  for (const item of items) {
    const stat = await platform2.fs().promises.stat(item);
    if (stat.isDirectory()) {
      if (localDirectory)
        throw new Error("Multiple directories are not supported");
      localDirectory = platform2.path().resolve(item);
    } else {
      localPaths ??= [];
      localPaths.push(platform2.path().resolve(item));
    }
  }
  if (localPaths?.length && localDirectory)
    throw new Error("File paths must be all files or a single directory");
  return [localPaths, localDirectory];
}
__name(resolvePathsAndDirectoryForInputFiles, "resolvePathsAndDirectoryForInputFiles");
async function convertInputFiles(platform2, files, context2) {
  const items = Array.isArray(files) ? files.slice() : [files];
  if (items.some((item) => typeof item === "string")) {
    if (!items.every((item) => typeof item === "string"))
      throw new Error("File paths cannot be mixed with buffers");
    const [localPaths, localDirectory] = await resolvePathsAndDirectoryForInputFiles(platform2, items);
    if (context2._connection.isRemote()) {
      const files2 = localDirectory ? (await platform2.fs().promises.readdir(localDirectory, { withFileTypes: true, recursive: true })).filter((f) => f.isFile()).map((f) => platform2.path().join(f.path, f.name)) : localPaths;
      const { writableStreams, rootDir } = await context2._wrapApiCall(async () => context2._channel.createTempFiles({
        rootDirName: localDirectory ? platform2.path().basename(localDirectory) : void 0,
        items: await Promise.all(files2.map(async (file) => {
          const lastModifiedMs = (await platform2.fs().promises.stat(file)).mtimeMs;
          return {
            name: localDirectory ? platform2.path().relative(localDirectory, file) : platform2.path().basename(file),
            lastModifiedMs
          };
        }))
      }), { internal: true });
      for (let i = 0; i < files2.length; i++) {
        const writable = WritableStream.from(writableStreams[i]);
        await platform2.streamFile(files2[i], writable.stream());
      }
      return {
        directoryStream: rootDir,
        streams: localDirectory ? void 0 : writableStreams
      };
    }
    return {
      localPaths,
      localDirectory
    };
  }
  const payloads = items;
  if (filePayloadExceedsSizeLimit(payloads))
    throw new Error("Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.");
  return { payloads };
}
__name(convertInputFiles, "convertInputFiles");
function determineScreenshotType(options2) {
  if (options2.path) {
    const mimeType = getMimeTypeForPath(options2.path);
    if (mimeType === "image/png")
      return "png";
    else if (mimeType === "image/jpeg")
      return "jpeg";
    throw new Error(`path: unsupported mime type "${mimeType}"`);
  }
  return options2.type;
}
__name(determineScreenshotType, "determineScreenshotType");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/fileChooser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FileChooser2 = class {
  static {
    __name(this, "FileChooser");
  }
  constructor(page, elementHandle, isMultiple) {
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }
  element() {
    return this._elementHandle;
  }
  isMultiple() {
    return this._isMultiple;
  }
  page() {
    return this._page;
  }
  async setFiles(files, options2) {
    return await this._elementHandle.setInputFiles(files, options2);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/harRouter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HarRouter = class _HarRouter {
  static {
    __name(this, "HarRouter");
  }
  static async create(localUtils, file, notFoundAction, options2) {
    const { harId, error: error3 } = await localUtils.harOpen({ file });
    if (error3)
      throw new Error(error3);
    return new _HarRouter(localUtils, harId, notFoundAction, options2);
  }
  constructor(localUtils, harId, notFoundAction, options2) {
    this._localUtils = localUtils;
    this._harId = harId;
    this._options = options2;
    this._notFoundAction = notFoundAction;
  }
  async _handle(route) {
    const request2 = route.request();
    const response = await this._localUtils.harLookup({
      harId: this._harId,
      url: request2.url(),
      method: request2.method(),
      headers: await request2.headersArray(),
      postData: request2.postDataBuffer() || void 0,
      isNavigationRequest: request2.isNavigationRequest()
    });
    if (response.action === "redirect") {
      route._platform.log("api", `HAR: ${route.request().url()} redirected to ${response.redirectURL}`);
      await route._redirectNavigationRequest(response.redirectURL);
      return;
    }
    if (response.action === "fulfill") {
      if (response.status === -1)
        return;
      await route.fulfill({
        status: response.status,
        headers: Object.fromEntries(response.headers.map((h) => [h.name, h.value])),
        body: response.body
      });
      return;
    }
    if (response.action === "error")
      route._platform.log("api", "HAR: " + response.message);
    if (this._notFoundAction === "abort") {
      await route.abort();
      return;
    }
    await route.fallback();
  }
  async addContextRoute(context2) {
    await context2.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
  }
  async addPageRoute(page) {
    await page.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
  }
  async [Symbol.asyncDispose]() {
    await this.dispose();
  }
  dispose() {
    this._localUtils.harClose({ harId: this._harId }).catch(() => {
    });
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/input.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Keyboard2 = class {
  static {
    __name(this, "Keyboard");
  }
  constructor(page) {
    this._page = page;
  }
  async down(key) {
    await this._page._channel.keyboardDown({ key });
  }
  async up(key) {
    await this._page._channel.keyboardUp({ key });
  }
  async insertText(text) {
    await this._page._channel.keyboardInsertText({ text });
  }
  async type(text, options2 = {}) {
    await this._page._channel.keyboardType({ text, ...options2 });
  }
  async press(key, options2 = {}) {
    await this._page._channel.keyboardPress({ key, ...options2 });
  }
};
var Mouse2 = class {
  static {
    __name(this, "Mouse");
  }
  constructor(page) {
    this._page = page;
  }
  async move(x, y, options2 = {}) {
    await this._page._channel.mouseMove({ x, y, ...options2 });
  }
  async down(options2 = {}) {
    await this._page._channel.mouseDown({ ...options2 });
  }
  async up(options2 = {}) {
    await this._page._channel.mouseUp(options2);
  }
  async click(x, y, options2 = {}) {
    await this._page._channel.mouseClick({ x, y, ...options2 });
  }
  async dblclick(x, y, options2 = {}) {
    await this._page._wrapApiCall(async () => {
      await this.click(x, y, { ...options2, clickCount: 2 });
    }, { title: "Double click" });
  }
  async wheel(deltaX, deltaY) {
    await this._page._channel.mouseWheel({ deltaX, deltaY });
  }
};
var Touchscreen2 = class {
  static {
    __name(this, "Touchscreen");
  }
  constructor(page) {
    this._page = page;
  }
  async tap(x, y) {
    await this._page._channel.touchscreenTap({ x, y });
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/video.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Video = class {
  static {
    __name(this, "Video");
  }
  constructor(page, connection) {
    this._artifact = null;
    this._artifactReadyPromise = new ManualPromise();
    this._isRemote = false;
    this._isRemote = connection.isRemote();
    this._artifact = page._closedOrCrashedScope.safeRace(this._artifactReadyPromise);
  }
  _artifactReady(artifact) {
    this._artifactReadyPromise.resolve(artifact);
  }
  async path() {
    if (this._isRemote)
      throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    const artifact = await this._artifact;
    if (!artifact)
      throw new Error("Page did not produce any video frames");
    return artifact._initializer.absolutePath;
  }
  async saveAs(path30) {
    const artifact = await this._artifact;
    if (!artifact)
      throw new Error("Page did not produce any video frames");
    return await artifact.saveAs(path30);
  }
  async delete() {
    const artifact = await this._artifact;
    if (artifact)
      await artifact.delete();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/page.js
var Page2 = class _Page extends ChannelOwner {
  static {
    __name(this, "Page");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._frames = /* @__PURE__ */ new Set();
    this._workers = /* @__PURE__ */ new Set();
    this._closed = false;
    this._closedOrCrashedScope = new LongStandingScope();
    this._routes = [];
    this._webSocketRoutes = [];
    this._bindings = /* @__PURE__ */ new Map();
    this._video = null;
    this._closeWasCalled = false;
    this._harRouters = [];
    this._locatorHandlers = /* @__PURE__ */ new Map();
    this._browserContext = parent;
    this._timeoutSettings = new TimeoutSettings(this._platform, this._browserContext._timeoutSettings);
    this.accessibility = new Accessibility2(this._channel);
    this.keyboard = new Keyboard2(this);
    this.mouse = new Mouse2(this);
    this.request = this._browserContext.request;
    this.touchscreen = new Touchscreen2(this);
    this.clock = this._browserContext.clock;
    this._mainFrame = Frame2.from(initializer.mainFrame);
    this._mainFrame._page = this;
    this._frames.add(this._mainFrame);
    this._viewportSize = initializer.viewportSize;
    this._closed = initializer.isClosed;
    this._opener = _Page.fromNullable(initializer.opener);
    this._channel.on("bindingCall", ({ binding: binding3 }) => this._onBinding(BindingCall.from(binding3)));
    this._channel.on("close", () => this._onClose());
    this._channel.on("crash", () => this._onCrash());
    this._channel.on("download", ({ url: url4, suggestedFilename, artifact }) => {
      const artifactObject = Artifact2.from(artifact);
      this.emit(Events.Page.Download, new Download2(this, url4, suggestedFilename, artifactObject));
    });
    this._channel.on("fileChooser", ({ element, isMultiple }) => this.emit(Events.Page.FileChooser, new FileChooser2(this, ElementHandle2.from(element), isMultiple)));
    this._channel.on("frameAttached", ({ frame }) => this._onFrameAttached(Frame2.from(frame)));
    this._channel.on("frameDetached", ({ frame }) => this._onFrameDetached(Frame2.from(frame)));
    this._channel.on("locatorHandlerTriggered", ({ uid }) => this._onLocatorHandlerTriggered(uid));
    this._channel.on("route", ({ route }) => this._onRoute(Route2.from(route)));
    this._channel.on("webSocketRoute", ({ webSocketRoute }) => this._onWebSocketRoute(WebSocketRoute.from(webSocketRoute)));
    this._channel.on("video", ({ artifact }) => {
      const artifactObject = Artifact2.from(artifact);
      this._forceVideo()._artifactReady(artifactObject);
    });
    this._channel.on("viewportSizeChanged", ({ viewportSize }) => this._viewportSize = viewportSize);
    this._channel.on("webSocket", ({ webSocket }) => this.emit(Events.Page.WebSocket, WebSocket3.from(webSocket)));
    this._channel.on("worker", ({ worker }) => this._onWorker(Worker2.from(worker)));
    this.coverage = new Coverage(this._channel);
    this.once(Events.Page.Close, () => this._closedOrCrashedScope.close(this._closeErrorWithReason()));
    this.once(Events.Page.Crash, () => this._closedOrCrashedScope.close(new TargetClosedError2()));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.Page.Console, "console"],
      [Events.Page.Dialog, "dialog"],
      [Events.Page.Request, "request"],
      [Events.Page.Response, "response"],
      [Events.Page.RequestFinished, "requestFinished"],
      [Events.Page.RequestFailed, "requestFailed"],
      [Events.Page.FileChooser, "fileChooser"]
    ]));
  }
  static from(page) {
    return page._object;
  }
  static fromNullable(page) {
    return page ? _Page.from(page) : null;
  }
  _onFrameAttached(frame) {
    frame._page = this;
    this._frames.add(frame);
    if (frame._parentFrame)
      frame._parentFrame._childFrames.add(frame);
    this.emit(Events.Page.FrameAttached, frame);
  }
  _onFrameDetached(frame) {
    this._frames.delete(frame);
    frame._detached = true;
    if (frame._parentFrame)
      frame._parentFrame._childFrames.delete(frame);
    this.emit(Events.Page.FrameDetached, frame);
  }
  async _onRoute(route) {
    route._context = this.context();
    const routeHandlers = this._routes.slice();
    for (const routeHandler of routeHandlers) {
      if (this._closeWasCalled || this._browserContext._closingStatus !== "none")
        return;
      if (!routeHandler.matches(route.request().url()))
        continue;
      const index2 = this._routes.indexOf(routeHandler);
      if (index2 === -1)
        continue;
      if (routeHandler.willExpire())
        this._routes.splice(index2, 1);
      const handled = await routeHandler.handle(route);
      if (!this._routes.length)
        this._updateInterceptionPatterns({ internal: true }).catch(() => {
        });
      if (handled)
        return;
    }
    await this._browserContext._onRoute(route);
  }
  async _onWebSocketRoute(webSocketRoute) {
    const routeHandler = this._webSocketRoutes.find((route) => route.matches(webSocketRoute.url()));
    if (routeHandler)
      await routeHandler.handle(webSocketRoute);
    else
      await this._browserContext._onWebSocketRoute(webSocketRoute);
  }
  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);
    if (func) {
      await bindingCall.call(func);
      return;
    }
    await this._browserContext._onBinding(bindingCall);
  }
  _onWorker(worker) {
    this._workers.add(worker);
    worker._page = this;
    this.emit(Events.Page.Worker, worker);
  }
  _onClose() {
    this._closed = true;
    this._browserContext._pages.delete(this);
    this._browserContext._backgroundPages.delete(this);
    this._disposeHarRouters();
    this.emit(Events.Page.Close, this);
  }
  _onCrash() {
    this.emit(Events.Page.Crash, this);
  }
  context() {
    return this._browserContext;
  }
  async opener() {
    if (!this._opener || this._opener.isClosed())
      return null;
    return this._opener;
  }
  mainFrame() {
    return this._mainFrame;
  }
  frame(frameSelector) {
    const name = isString(frameSelector) ? frameSelector : frameSelector.name;
    const url4 = isObject(frameSelector) ? frameSelector.url : void 0;
    assert3(name || url4, "Either name or url matcher should be specified");
    return this.frames().find((f) => {
      if (name)
        return f.name() === name;
      return urlMatches(this._browserContext._options.baseURL, f.url(), url4);
    }) || null;
  }
  frames() {
    return [...this._frames];
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  _forceVideo() {
    if (!this._video)
      this._video = new Video(this, this._connection);
    return this._video;
  }
  video() {
    if (!this._browserContext._options.recordVideo)
      return null;
    return this._forceVideo();
  }
  async $(selector, options2) {
    return await this._mainFrame.$(selector, options2);
  }
  async waitForSelector(selector, options2) {
    return await this._mainFrame.waitForSelector(selector, options2);
  }
  async dispatchEvent(selector, type, eventInit, options2) {
    return await this._mainFrame.dispatchEvent(selector, type, eventInit, options2);
  }
  async evaluateHandle(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    return await this._mainFrame.evaluateHandle(pageFunction, arg);
  }
  async $eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    return await this._mainFrame.$eval(selector, pageFunction, arg);
  }
  async $$eval(selector, pageFunction, arg) {
    assertMaxArguments(arguments.length, 3);
    return await this._mainFrame.$$eval(selector, pageFunction, arg);
  }
  async $$(selector) {
    return await this._mainFrame.$$(selector);
  }
  async addScriptTag(options2 = {}) {
    return await this._mainFrame.addScriptTag(options2);
  }
  async addStyleTag(options2 = {}) {
    return await this._mainFrame.addStyleTag(options2);
  }
  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({ name });
    const binding3 = /* @__PURE__ */ __name((source8, ...args) => callback(...args), "binding");
    this._bindings.set(name, binding3);
  }
  async exposeBinding(name, callback, options2 = {}) {
    await this._channel.exposeBinding({ name, needsHandle: options2.handle });
    this._bindings.set(name, callback);
  }
  async setExtraHTTPHeaders(headers) {
    validateHeaders(headers);
    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });
  }
  url() {
    return this._mainFrame.url();
  }
  async content() {
    return await this._mainFrame.content();
  }
  async setContent(html, options2) {
    return await this._mainFrame.setContent(html, options2);
  }
  async goto(url4, options2) {
    return await this._mainFrame.goto(url4, options2);
  }
  async reload(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.reload({ ...options2, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options2) })).response);
  }
  async addLocatorHandler(locator, handler, options2 = {}) {
    if (locator._frame !== this._mainFrame)
      throw new Error(`Locator must belong to the main frame of this page`);
    if (options2.times === 0)
      return;
    const { uid } = await this._channel.registerLocatorHandler({ selector: locator._selector, noWaitAfter: options2.noWaitAfter });
    this._locatorHandlers.set(uid, { locator, handler, times: options2.times });
  }
  async _onLocatorHandlerTriggered(uid) {
    let remove = false;
    try {
      const handler = this._locatorHandlers.get(uid);
      if (handler && handler.times !== 0) {
        if (handler.times !== void 0)
          handler.times--;
        await handler.handler(handler.locator);
      }
      remove = handler?.times === 0;
    } finally {
      if (remove)
        this._locatorHandlers.delete(uid);
      this._channel.resolveLocatorHandlerNoReply({ uid, remove }).catch(() => {
      });
    }
  }
  async removeLocatorHandler(locator) {
    for (const [uid, data] of this._locatorHandlers) {
      if (data.locator._equals(locator)) {
        this._locatorHandlers.delete(uid);
        await this._channel.unregisterLocatorHandler({ uid }).catch(() => {
        });
      }
    }
  }
  async waitForLoadState(state, options2) {
    return await this._mainFrame.waitForLoadState(state, options2);
  }
  async waitForNavigation(options2) {
    return await this._mainFrame.waitForNavigation(options2);
  }
  async waitForURL(url4, options2) {
    return await this._mainFrame.waitForURL(url4, options2);
  }
  async waitForRequest(urlOrPredicate, options2 = {}) {
    const predicate = /* @__PURE__ */ __name(async (request2) => {
      if (isString(urlOrPredicate) || isRegExp2(urlOrPredicate))
        return urlMatches(this._browserContext._options.baseURL, request2.url(), urlOrPredicate);
      return await urlOrPredicate(request2);
    }, "predicate");
    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
    return await this._waitForEvent(Events.Page.Request, { predicate, timeout: options2.timeout }, logLine);
  }
  async waitForResponse(urlOrPredicate, options2 = {}) {
    const predicate = /* @__PURE__ */ __name(async (response) => {
      if (isString(urlOrPredicate) || isRegExp2(urlOrPredicate))
        return urlMatches(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
      return await urlOrPredicate(response);
    }, "predicate");
    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
    return await this._waitForEvent(Events.Page.Response, { predicate, timeout: options2.timeout }, logLine);
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
  }
  _closeErrorWithReason() {
    return new TargetClosedError2(this._closeReason || this._browserContext._effectiveCloseReason());
  }
  async _waitForEvent(event, optionsOrPredicate, logLine) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      if (logLine)
        waiter.log(logLine);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.Page.Crash)
        waiter.rejectOnEvent(this, Events.Page.Crash, new Error("Page crashed"));
      if (event !== Events.Page.Close)
        waiter.rejectOnEvent(this, Events.Page.Close, () => this._closeErrorWithReason());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async goBack(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goBack({ ...options2, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options2) })).response);
  }
  async goForward(options2 = {}) {
    const waitUntil = verifyLoadState("waitUntil", options2.waitUntil === void 0 ? "load" : options2.waitUntil);
    return Response3.fromNullable((await this._channel.goForward({ ...options2, waitUntil, timeout: this._timeoutSettings.navigationTimeout(options2) })).response);
  }
  async requestGC() {
    await this._channel.requestGC();
  }
  async emulateMedia(options2 = {}) {
    await this._channel.emulateMedia({
      media: options2.media === null ? "no-override" : options2.media,
      colorScheme: options2.colorScheme === null ? "no-override" : options2.colorScheme,
      reducedMotion: options2.reducedMotion === null ? "no-override" : options2.reducedMotion,
      forcedColors: options2.forcedColors === null ? "no-override" : options2.forcedColors,
      contrast: options2.contrast === null ? "no-override" : options2.contrast
    });
  }
  async setViewportSize(viewportSize) {
    this._viewportSize = viewportSize;
    await this._channel.setViewportSize({ viewportSize });
  }
  viewportSize() {
    return this._viewportSize || null;
  }
  async evaluate(pageFunction, arg) {
    assertMaxArguments(arguments.length, 2);
    return await this._mainFrame.evaluate(pageFunction, arg);
  }
  async _evaluateFunction(functionDeclaration) {
    return this._mainFrame._evaluateFunction(functionDeclaration);
  }
  async addInitScript(script, arg) {
    const source8 = await evaluationScript(this._platform, script, arg);
    await this._channel.addInitScript({ source: source8 });
  }
  async route(url4, handler, options2 = {}) {
    this._routes.unshift(new RouteHandler(this._platform, this._browserContext._options.baseURL, url4, handler, options2.times));
    await this._updateInterceptionPatterns({ title: "Route requests" });
  }
  async routeFromHAR(har, options2 = {}) {
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Route from har is not supported in thin clients");
    if (options2.update) {
      await this._browserContext._recordIntoHAR(har, this, options2);
      return;
    }
    const harRouter = await HarRouter.create(localUtils, har, options2.notFound || "abort", { urlMatch: options2.url });
    this._harRouters.push(harRouter);
    await harRouter.addPageRoute(this);
  }
  async routeWebSocket(url4, handler) {
    this._webSocketRoutes.unshift(new WebSocketRouteHandler(this._browserContext._options.baseURL, url4, handler));
    await this._updateWebSocketInterceptionPatterns({ title: "Route WebSockets" });
  }
  _disposeHarRouters() {
    this._harRouters.forEach((router) => router.dispose());
    this._harRouters = [];
  }
  async unrouteAll(options2) {
    await this._unrouteInternal(this._routes, [], options2?.behavior);
    this._disposeHarRouters();
  }
  async unroute(url4, handler) {
    const removed = [];
    const remaining = [];
    for (const route of this._routes) {
      if (urlMatchesEqual(route.url, url4) && (!handler || route.handler === handler))
        removed.push(route);
      else
        remaining.push(route);
    }
    await this._unrouteInternal(removed, remaining, "default");
  }
  async _unrouteInternal(removed, remaining, behavior) {
    this._routes = remaining;
    if (behavior && behavior !== "default") {
      const promises = removed.map((routeHandler) => routeHandler.stop(behavior));
      await Promise.all(promises);
    }
    await this._updateInterceptionPatterns({ title: "Unroute requests" });
  }
  async _updateInterceptionPatterns(options2) {
    const patterns = RouteHandler.prepareInterceptionPatterns(this._routes);
    await this._wrapApiCall(() => this._channel.setNetworkInterceptionPatterns({ patterns }), options2);
  }
  async _updateWebSocketInterceptionPatterns(options2) {
    const patterns = WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);
    await this._wrapApiCall(() => this._channel.setWebSocketInterceptionPatterns({ patterns }), options2);
  }
  async screenshot(options2 = {}) {
    const mask = options2.mask;
    const copy = { ...options2, mask: void 0, timeout: this._timeoutSettings.timeout(options2) };
    if (!copy.type)
      copy.type = determineScreenshotType(options2);
    if (mask) {
      copy.mask = mask.map((locator) => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }
    const result = await this._channel.screenshot(copy);
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, result.binary);
    }
    return result.binary;
  }
  async _expectScreenshot(options2) {
    const mask = options2?.mask ? options2?.mask.map((locator2) => ({
      frame: locator2._frame._channel,
      selector: locator2._selector
    })) : void 0;
    const locator = options2.locator ? {
      frame: options2.locator._frame._channel,
      selector: options2.locator._selector
    } : void 0;
    return await this._channel.expectScreenshot({
      ...options2,
      isNot: !!options2.isNot,
      locator,
      mask
    });
  }
  async title() {
    return await this._mainFrame.title();
  }
  async bringToFront() {
    await this._channel.bringToFront();
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    this._closeReason = options2.reason;
    this._closeWasCalled = true;
    try {
      if (this._ownedContext)
        await this._ownedContext.close();
      else
        await this._channel.close(options2);
    } catch (e) {
      if (isTargetClosedError2(e) && !options2.runBeforeUnload)
        return;
      throw e;
    }
  }
  isClosed() {
    return this._closed;
  }
  async click(selector, options2) {
    return await this._mainFrame.click(selector, options2);
  }
  async dragAndDrop(source8, target, options2) {
    return await this._mainFrame.dragAndDrop(source8, target, options2);
  }
  async dblclick(selector, options2) {
    await this._mainFrame.dblclick(selector, options2);
  }
  async tap(selector, options2) {
    return await this._mainFrame.tap(selector, options2);
  }
  async fill(selector, value, options2) {
    return await this._mainFrame.fill(selector, value, options2);
  }
  locator(selector, options2) {
    return this.mainFrame().locator(selector, options2);
  }
  getByTestId(testId) {
    return this.mainFrame().getByTestId(testId);
  }
  getByAltText(text, options2) {
    return this.mainFrame().getByAltText(text, options2);
  }
  getByLabel(text, options2) {
    return this.mainFrame().getByLabel(text, options2);
  }
  getByPlaceholder(text, options2) {
    return this.mainFrame().getByPlaceholder(text, options2);
  }
  getByText(text, options2) {
    return this.mainFrame().getByText(text, options2);
  }
  getByTitle(text, options2) {
    return this.mainFrame().getByTitle(text, options2);
  }
  getByRole(role, options2 = {}) {
    return this.mainFrame().getByRole(role, options2);
  }
  frameLocator(selector) {
    return this.mainFrame().frameLocator(selector);
  }
  async focus(selector, options2) {
    return await this._mainFrame.focus(selector, options2);
  }
  async textContent(selector, options2) {
    return await this._mainFrame.textContent(selector, options2);
  }
  async innerText(selector, options2) {
    return await this._mainFrame.innerText(selector, options2);
  }
  async innerHTML(selector, options2) {
    return await this._mainFrame.innerHTML(selector, options2);
  }
  async getAttribute(selector, name, options2) {
    return await this._mainFrame.getAttribute(selector, name, options2);
  }
  async inputValue(selector, options2) {
    return await this._mainFrame.inputValue(selector, options2);
  }
  async isChecked(selector, options2) {
    return await this._mainFrame.isChecked(selector, options2);
  }
  async isDisabled(selector, options2) {
    return await this._mainFrame.isDisabled(selector, options2);
  }
  async isEditable(selector, options2) {
    return await this._mainFrame.isEditable(selector, options2);
  }
  async isEnabled(selector, options2) {
    return await this._mainFrame.isEnabled(selector, options2);
  }
  async isHidden(selector, options2) {
    return await this._mainFrame.isHidden(selector, options2);
  }
  async isVisible(selector, options2) {
    return await this._mainFrame.isVisible(selector, options2);
  }
  async hover(selector, options2) {
    return await this._mainFrame.hover(selector, options2);
  }
  async selectOption(selector, values, options2) {
    return await this._mainFrame.selectOption(selector, values, options2);
  }
  async setInputFiles(selector, files, options2) {
    return await this._mainFrame.setInputFiles(selector, files, options2);
  }
  async type(selector, text, options2) {
    return await this._mainFrame.type(selector, text, options2);
  }
  async press(selector, key, options2) {
    return await this._mainFrame.press(selector, key, options2);
  }
  async check(selector, options2) {
    return await this._mainFrame.check(selector, options2);
  }
  async uncheck(selector, options2) {
    return await this._mainFrame.uncheck(selector, options2);
  }
  async setChecked(selector, checked, options2) {
    return await this._mainFrame.setChecked(selector, checked, options2);
  }
  async waitForTimeout(timeout) {
    return await this._mainFrame.waitForTimeout(timeout);
  }
  async waitForFunction(pageFunction, arg, options2) {
    return await this._mainFrame.waitForFunction(pageFunction, arg, options2);
  }
  workers() {
    return [...this._workers];
  }
  async pause(_options) {
    if (this._platform.isJSDebuggerAttached())
      return;
    const defaultNavigationTimeout = this._browserContext._timeoutSettings.defaultNavigationTimeout();
    const defaultTimeout = this._browserContext._timeoutSettings.defaultTimeout();
    this._browserContext.setDefaultNavigationTimeout(0);
    this._browserContext.setDefaultTimeout(0);
    this._instrumentation?.onWillPause({ keepTestTimeout: !!_options?.__testHookKeepTestTimeout });
    await this._closedOrCrashedScope.safeRace(this.context()._channel.pause());
    this._browserContext.setDefaultNavigationTimeout(defaultNavigationTimeout);
    this._browserContext.setDefaultTimeout(defaultTimeout);
  }
  async pdf(options2 = {}) {
    const transportOptions = { ...options2 };
    if (transportOptions.margin)
      transportOptions.margin = { ...transportOptions.margin };
    if (typeof options2.width === "number")
      transportOptions.width = options2.width + "px";
    if (typeof options2.height === "number")
      transportOptions.height = options2.height + "px";
    for (const margin of ["top", "right", "bottom", "left"]) {
      const index2 = margin;
      if (options2.margin && typeof options2.margin[index2] === "number")
        transportOptions.margin[index2] = transportOptions.margin[index2] + "px";
    }
    const result = await this._channel.pdf(transportOptions);
    if (options2.path) {
      const platform2 = this._platform;
      await platform2.fs().promises.mkdir(platform2.path().dirname(options2.path), { recursive: true });
      await platform2.fs().promises.writeFile(options2.path, result.pdf);
    }
    return result.pdf;
  }
  async _snapshotForAI(options2 = {}) {
    const result = await this._channel.snapshotForAI({ timeout: this._timeoutSettings.timeout(options2) });
    return result.snapshot;
  }
};
var BindingCall = class extends ChannelOwner {
  static {
    __name(this, "BindingCall");
  }
  static from(channel2) {
    return channel2._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }
  async call(func) {
    try {
      const frame = Frame2.from(this._initializer.frame);
      const source8 = {
        context: frame._page.context(),
        page: frame._page,
        frame
      };
      let result;
      if (this._initializer.handle)
        result = await func(source8, JSHandle2.from(this._initializer.handle));
      else
        result = await func(source8, ...this._initializer.args.map(parseResult));
      this._channel.resolve({ result: serializeArgument(result) }).catch(() => {
      });
    } catch (e) {
      this._channel.reject({ error: serializeError2(e) }).catch(() => {
      });
    }
  }
};
function trimUrl(param) {
  if (isRegExp2(param))
    return `/${trimStringWithEllipsis(param.source, 50)}/${param.flags}`;
  if (isString(param))
    return `"${trimStringWithEllipsis(param, 50)}"`;
}
__name(trimUrl, "trimUrl");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/consoleMessage.js
var ConsoleMessage2 = class {
  static {
    __name(this, "ConsoleMessage");
  }
  constructor(platform2, event) {
    this._page = "page" in event && event.page ? Page2.from(event.page) : null;
    this._event = event;
    if (platform2.inspectCustom)
      this[platform2.inspectCustom] = () => this._inspect();
  }
  page() {
    return this._page;
  }
  type() {
    return this._event.type;
  }
  text() {
    return this._event.text;
  }
  args() {
    return this._event.args.map(JSHandle2.from);
  }
  location() {
    return this._event.location;
  }
  _inspect() {
    return this.text();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/dialog.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Dialog2 = class extends ChannelOwner {
  static {
    __name(this, "Dialog");
  }
  static from(dialog) {
    return dialog._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._page = Page2.fromNullable(initializer.page);
  }
  page() {
    return this._page;
  }
  type() {
    return this._initializer.type;
  }
  message() {
    return this._initializer.message;
  }
  defaultValue() {
    return this._initializer.defaultValue;
  }
  async accept(promptText) {
    await this._channel.accept({ promptText });
  }
  async dismiss() {
    await this._channel.dismiss();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/webError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WebError = class {
  static {
    __name(this, "WebError");
  }
  constructor(page, error3) {
    this._page = page;
    this._error = error3;
  }
  page() {
    return this._page;
  }
  error() {
    return this._error;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/browserContext.js
var BrowserContext2 = class _BrowserContext extends ChannelOwner {
  static {
    __name(this, "BrowserContext");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._pages = /* @__PURE__ */ new Set();
    this._routes = [];
    this._webSocketRoutes = [];
    this._browser = null;
    this._bindings = /* @__PURE__ */ new Map();
    this._forReuse = false;
    this._backgroundPages = /* @__PURE__ */ new Set();
    this._serviceWorkers = /* @__PURE__ */ new Set();
    this._harRecorders = /* @__PURE__ */ new Map();
    this._closingStatus = "none";
    this._harRouters = [];
    this._options = initializer.options;
    this._timeoutSettings = new TimeoutSettings(this._platform);
    this.tracing = Tracing2.from(initializer.tracing);
    this.request = APIRequestContext2.from(initializer.requestContext);
    this.request._timeoutSettings = this._timeoutSettings;
    this.clock = new Clock2(this);
    this._channel.on("bindingCall", ({ binding: binding3 }) => this._onBinding(BindingCall.from(binding3)));
    this._channel.on("close", () => this._onClose());
    this._channel.on("page", ({ page }) => this._onPage(Page2.from(page)));
    this._channel.on("route", ({ route }) => this._onRoute(Route2.from(route)));
    this._channel.on("webSocketRoute", ({ webSocketRoute }) => this._onWebSocketRoute(WebSocketRoute.from(webSocketRoute)));
    this._channel.on("backgroundPage", ({ page }) => {
      const backgroundPage = Page2.from(page);
      this._backgroundPages.add(backgroundPage);
      this.emit(Events.BrowserContext.BackgroundPage, backgroundPage);
    });
    this._channel.on("serviceWorker", ({ worker }) => {
      const serviceWorker = Worker2.from(worker);
      serviceWorker._context = this;
      this._serviceWorkers.add(serviceWorker);
      this.emit(Events.BrowserContext.ServiceWorker, serviceWorker);
    });
    this._channel.on("console", (event) => {
      const consoleMessage = new ConsoleMessage2(this._platform, event);
      this.emit(Events.BrowserContext.Console, consoleMessage);
      const page = consoleMessage.page();
      if (page)
        page.emit(Events.Page.Console, consoleMessage);
    });
    this._channel.on("pageError", ({ error: error3, page }) => {
      const pageObject = Page2.from(page);
      const parsedError = parseError2(error3);
      this.emit(Events.BrowserContext.WebError, new WebError(pageObject, parsedError));
      if (pageObject)
        pageObject.emit(Events.Page.PageError, parsedError);
    });
    this._channel.on("dialog", ({ dialog }) => {
      const dialogObject = Dialog2.from(dialog);
      let hasListeners = this.emit(Events.BrowserContext.Dialog, dialogObject);
      const page = dialogObject.page();
      if (page)
        hasListeners = page.emit(Events.Page.Dialog, dialogObject) || hasListeners;
      if (!hasListeners) {
        if (dialogObject.type() === "beforeunload")
          dialog.accept({}).catch(() => {
          });
        else
          dialog.dismiss().catch(() => {
          });
      }
    });
    this._channel.on("request", ({ request: request2, page }) => this._onRequest(Request2.from(request2), Page2.fromNullable(page)));
    this._channel.on("requestFailed", ({ request: request2, failureText, responseEndTiming, page }) => this._onRequestFailed(Request2.from(request2), responseEndTiming, failureText, Page2.fromNullable(page)));
    this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
    this._channel.on("response", ({ response, page }) => this._onResponse(Response3.from(response), Page2.fromNullable(page)));
    this._channel.on("recorderEvent", ({ event, data, page, code }) => {
      if (event === "actionAdded")
        this._onRecorderEventSink?.actionAdded?.(Page2.from(page), data, code);
      else if (event === "actionUpdated")
        this._onRecorderEventSink?.actionUpdated?.(Page2.from(page), data, code);
      else if (event === "signalAdded")
        this._onRecorderEventSink?.signalAdded?.(Page2.from(page), data);
    });
    this._closedPromise = new Promise((f) => this.once(Events.BrowserContext.Close, f));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.BrowserContext.Console, "console"],
      [Events.BrowserContext.Dialog, "dialog"],
      [Events.BrowserContext.Request, "request"],
      [Events.BrowserContext.Response, "response"],
      [Events.BrowserContext.RequestFinished, "requestFinished"],
      [Events.BrowserContext.RequestFailed, "requestFailed"]
    ]));
  }
  static from(context2) {
    return context2._object;
  }
  static fromNullable(context2) {
    return context2 ? _BrowserContext.from(context2) : null;
  }
  async _initializeHarFromOptions(recordHar) {
    if (!recordHar)
      return;
    const defaultContent = recordHar.path.endsWith(".zip") ? "attach" : "embed";
    await this._recordIntoHAR(recordHar.path, null, {
      url: recordHar.urlFilter,
      updateContent: recordHar.content ?? (recordHar.omitContent ? "omit" : defaultContent),
      updateMode: recordHar.mode ?? "full"
    });
  }
  _onPage(page) {
    this._pages.add(page);
    this.emit(Events.BrowserContext.Page, page);
    if (page._opener && !page._opener.isClosed())
      page._opener.emit(Events.Page.Popup, page);
  }
  _onRequest(request2, page) {
    this.emit(Events.BrowserContext.Request, request2);
    if (page)
      page.emit(Events.Page.Request, request2);
  }
  _onResponse(response, page) {
    this.emit(Events.BrowserContext.Response, response);
    if (page)
      page.emit(Events.Page.Response, response);
  }
  _onRequestFailed(request2, responseEndTiming, failureText, page) {
    request2._failureText = failureText || null;
    request2._setResponseEndTiming(responseEndTiming);
    this.emit(Events.BrowserContext.RequestFailed, request2);
    if (page)
      page.emit(Events.Page.RequestFailed, request2);
  }
  _onRequestFinished(params) {
    const { responseEndTiming } = params;
    const request2 = Request2.from(params.request);
    const response = Response3.fromNullable(params.response);
    const page = Page2.fromNullable(params.page);
    request2._setResponseEndTiming(responseEndTiming);
    this.emit(Events.BrowserContext.RequestFinished, request2);
    if (page)
      page.emit(Events.Page.RequestFinished, request2);
    if (response)
      response._finishedPromise.resolve(null);
  }
  async _onRoute(route) {
    route._context = this;
    const page = route.request()._safePage();
    const routeHandlers = this._routes.slice();
    for (const routeHandler of routeHandlers) {
      if (page?._closeWasCalled || this._closingStatus !== "none")
        return;
      if (!routeHandler.matches(route.request().url()))
        continue;
      const index2 = this._routes.indexOf(routeHandler);
      if (index2 === -1)
        continue;
      if (routeHandler.willExpire())
        this._routes.splice(index2, 1);
      const handled = await routeHandler.handle(route);
      if (!this._routes.length)
        this._updateInterceptionPatterns({ internal: true }).catch(() => {
        });
      if (handled)
        return;
    }
    await route._innerContinue(
      true
      /* isFallback */
    ).catch(() => {
    });
  }
  async _onWebSocketRoute(webSocketRoute) {
    const routeHandler = this._webSocketRoutes.find((route) => route.matches(webSocketRoute.url()));
    if (routeHandler)
      await routeHandler.handle(webSocketRoute);
    else
      webSocketRoute.connectToServer();
  }
  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);
    if (!func)
      return;
    await bindingCall.call(func);
  }
  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  browser() {
    return this._browser;
  }
  pages() {
    return [...this._pages];
  }
  async newPage() {
    if (this._ownerPage)
      throw new Error("Please use browser.newContext()");
    return Page2.from((await this._channel.newPage()).page);
  }
  async cookies(urls) {
    if (!urls)
      urls = [];
    if (urls && typeof urls === "string")
      urls = [urls];
    return (await this._channel.cookies({ urls })).cookies;
  }
  async addCookies(cookies) {
    await this._channel.addCookies({ cookies });
  }
  async clearCookies(options2 = {}) {
    await this._channel.clearCookies({
      name: isString(options2.name) ? options2.name : void 0,
      nameRegexSource: isRegExp2(options2.name) ? options2.name.source : void 0,
      nameRegexFlags: isRegExp2(options2.name) ? options2.name.flags : void 0,
      domain: isString(options2.domain) ? options2.domain : void 0,
      domainRegexSource: isRegExp2(options2.domain) ? options2.domain.source : void 0,
      domainRegexFlags: isRegExp2(options2.domain) ? options2.domain.flags : void 0,
      path: isString(options2.path) ? options2.path : void 0,
      pathRegexSource: isRegExp2(options2.path) ? options2.path.source : void 0,
      pathRegexFlags: isRegExp2(options2.path) ? options2.path.flags : void 0
    });
  }
  async grantPermissions(permissions, options2) {
    await this._channel.grantPermissions({ permissions, ...options2 });
  }
  async clearPermissions() {
    await this._channel.clearPermissions();
  }
  async setGeolocation(geolocation) {
    await this._channel.setGeolocation({ geolocation: geolocation || void 0 });
  }
  async setExtraHTTPHeaders(headers) {
    validateHeaders(headers);
    await this._channel.setExtraHTTPHeaders({ headers: headersObjectToArray(headers) });
  }
  async setOffline(offline) {
    await this._channel.setOffline({ offline });
  }
  async setHTTPCredentials(httpCredentials) {
    await this._channel.setHTTPCredentials({ httpCredentials: httpCredentials || void 0 });
  }
  async addInitScript(script, arg) {
    const source8 = await evaluationScript(this._platform, script, arg);
    await this._channel.addInitScript({ source: source8 });
  }
  async exposeBinding(name, callback, options2 = {}) {
    await this._channel.exposeBinding({ name, needsHandle: options2.handle });
    this._bindings.set(name, callback);
  }
  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({ name });
    const binding3 = /* @__PURE__ */ __name((source8, ...args) => callback(...args), "binding");
    this._bindings.set(name, binding3);
  }
  async route(url4, handler, options2 = {}) {
    this._routes.unshift(new RouteHandler(this._platform, this._options.baseURL, url4, handler, options2.times));
    await this._updateInterceptionPatterns({ title: "Route requests" });
  }
  async routeWebSocket(url4, handler) {
    this._webSocketRoutes.unshift(new WebSocketRouteHandler(this._options.baseURL, url4, handler));
    await this._updateWebSocketInterceptionPatterns({ title: "Route WebSockets" });
  }
  async _recordIntoHAR(har, page, options2 = {}) {
    const { harId } = await this._channel.harStart({
      page: page?._channel,
      options: {
        zip: har.endsWith(".zip"),
        content: options2.updateContent ?? "attach",
        urlGlob: isString(options2.url) ? options2.url : void 0,
        urlRegexSource: isRegExp2(options2.url) ? options2.url.source : void 0,
        urlRegexFlags: isRegExp2(options2.url) ? options2.url.flags : void 0,
        mode: options2.updateMode ?? "minimal"
      }
    });
    this._harRecorders.set(harId, { path: har, content: options2.updateContent ?? "attach" });
  }
  async routeFromHAR(har, options2 = {}) {
    const localUtils = this._connection.localUtils();
    if (!localUtils)
      throw new Error("Route from har is not supported in thin clients");
    if (options2.update) {
      await this._recordIntoHAR(har, null, options2);
      return;
    }
    const harRouter = await HarRouter.create(localUtils, har, options2.notFound || "abort", { urlMatch: options2.url });
    this._harRouters.push(harRouter);
    await harRouter.addContextRoute(this);
  }
  _disposeHarRouters() {
    this._harRouters.forEach((router) => router.dispose());
    this._harRouters = [];
  }
  async unrouteAll(options2) {
    await this._unrouteInternal(this._routes, [], options2?.behavior);
    this._disposeHarRouters();
  }
  async unroute(url4, handler) {
    const removed = [];
    const remaining = [];
    for (const route of this._routes) {
      if (urlMatchesEqual(route.url, url4) && (!handler || route.handler === handler))
        removed.push(route);
      else
        remaining.push(route);
    }
    await this._unrouteInternal(removed, remaining, "default");
  }
  async _unrouteInternal(removed, remaining, behavior) {
    this._routes = remaining;
    if (behavior && behavior !== "default") {
      const promises = removed.map((routeHandler) => routeHandler.stop(behavior));
      await Promise.all(promises);
    }
    await this._updateInterceptionPatterns({ title: "Unroute requests" });
  }
  async _updateInterceptionPatterns(options2) {
    const patterns = RouteHandler.prepareInterceptionPatterns(this._routes);
    await this._wrapApiCall(() => this._channel.setNetworkInterceptionPatterns({ patterns }), options2);
  }
  async _updateWebSocketInterceptionPatterns(options2) {
    const patterns = WebSocketRouteHandler.prepareInterceptionPatterns(this._webSocketRoutes);
    await this._wrapApiCall(() => this._channel.setWebSocketInterceptionPatterns({ patterns }), options2);
  }
  _effectiveCloseReason() {
    return this._closeReason || this._browser?._closeReason;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.BrowserContext.Close)
        waiter.rejectOnEvent(this, Events.BrowserContext.Close, () => new TargetClosedError2(this._effectiveCloseReason()));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async storageState(options2 = {}) {
    const state = await this._channel.storageState({ indexedDB: options2.indexedDB });
    if (options2.path) {
      await mkdirIfNeeded2(this._platform, options2.path);
      await this._platform.fs().promises.writeFile(options2.path, JSON.stringify(state, void 0, 2), "utf8");
    }
    return state;
  }
  backgroundPages() {
    return [...this._backgroundPages];
  }
  serviceWorkers() {
    return [...this._serviceWorkers];
  }
  async newCDPSession(page) {
    if (!(page instanceof Page2) && !(page instanceof Frame2))
      throw new Error("page: expected Page or Frame");
    const result = await this._channel.newCDPSession(page instanceof Page2 ? { page: page._channel } : { frame: page._channel });
    return CDPSession2.from(result.session);
  }
  _onClose() {
    this._closingStatus = "closed";
    this._browser?._contexts.delete(this);
    this._browser?._browserType._contexts.delete(this);
    this._browser?._browserType._playwright.selectors._contextsForSelectors.delete(this);
    this._disposeHarRouters();
    this.tracing._resetStackCounter();
    this.emit(Events.BrowserContext.Close, this);
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    if (this._closingStatus !== "none")
      return;
    this._closeReason = options2.reason;
    this._closingStatus = "closing";
    await this.request.dispose(options2);
    await this._instrumentation.runBeforeCloseBrowserContext(this);
    await this._wrapApiCall(async () => {
      for (const [harId, harParams] of this._harRecorders) {
        const har = await this._channel.harExport({ harId });
        const artifact = Artifact2.from(har.artifact);
        const isCompressed = harParams.content === "attach" || harParams.path.endsWith(".zip");
        const needCompressed = harParams.path.endsWith(".zip");
        if (isCompressed && !needCompressed) {
          const localUtils = this._connection.localUtils();
          if (!localUtils)
            throw new Error("Uncompressed har is not supported in thin clients");
          await artifact.saveAs(harParams.path + ".tmp");
          await localUtils.harUnzip({ zipFile: harParams.path + ".tmp", harFile: harParams.path });
        } else {
          await artifact.saveAs(harParams.path);
        }
        await artifact.delete();
      }
    }, { internal: true });
    await this._channel.close(options2);
    await this._closedPromise;
  }
  async _enableRecorder(params, eventSink) {
    if (eventSink)
      this._onRecorderEventSink = eventSink;
    await this._channel.enableRecorder(params);
  }
  async _disableRecorder() {
    this._onRecorderEventSink = void 0;
    await this._channel.disableRecorder();
  }
};
async function prepareStorageState(platform2, storageState) {
  if (typeof storageState !== "string")
    return storageState;
  try {
    return JSON.parse(await platform2.fs().promises.readFile(storageState, "utf8"));
  } catch (e) {
    rewriteErrorMessage(e, `Error reading storage state from ${storageState}:
` + e.message);
    throw e;
  }
}
__name(prepareStorageState, "prepareStorageState");
async function prepareBrowserContextParams(platform2, options2) {
  if (options2.videoSize && !options2.videosPath)
    throw new Error(`"videoSize" option requires "videosPath" to be specified`);
  if (options2.extraHTTPHeaders)
    validateHeaders(options2.extraHTTPHeaders);
  const contextParams = {
    ...options2,
    viewport: options2.viewport === null ? void 0 : options2.viewport,
    noDefaultViewport: options2.viewport === null,
    extraHTTPHeaders: options2.extraHTTPHeaders ? headersObjectToArray(options2.extraHTTPHeaders) : void 0,
    storageState: options2.storageState ? await prepareStorageState(platform2, options2.storageState) : void 0,
    serviceWorkers: options2.serviceWorkers,
    colorScheme: options2.colorScheme === null ? "no-override" : options2.colorScheme,
    reducedMotion: options2.reducedMotion === null ? "no-override" : options2.reducedMotion,
    forcedColors: options2.forcedColors === null ? "no-override" : options2.forcedColors,
    contrast: options2.contrast === null ? "no-override" : options2.contrast,
    acceptDownloads: toAcceptDownloadsProtocol(options2.acceptDownloads),
    clientCertificates: await toClientCertificatesProtocol(platform2, options2.clientCertificates)
  };
  if (!contextParams.recordVideo && options2.videosPath) {
    contextParams.recordVideo = {
      dir: options2.videosPath,
      size: options2.videoSize
    };
  }
  if (contextParams.recordVideo && contextParams.recordVideo.dir)
    contextParams.recordVideo.dir = platform2.path().resolve(contextParams.recordVideo.dir);
  return contextParams;
}
__name(prepareBrowserContextParams, "prepareBrowserContextParams");
function toAcceptDownloadsProtocol(acceptDownloads) {
  if (acceptDownloads === void 0)
    return void 0;
  if (acceptDownloads)
    return "accept";
  return "deny";
}
__name(toAcceptDownloadsProtocol, "toAcceptDownloadsProtocol");
async function toClientCertificatesProtocol(platform2, certs) {
  if (!certs)
    return void 0;
  const bufferizeContent = /* @__PURE__ */ __name(async (value, path30) => {
    if (value)
      return value;
    if (path30)
      return await platform2.fs().promises.readFile(path30);
  }, "bufferizeContent");
  return await Promise.all(certs.map(async (cert) => ({
    origin: cert.origin,
    cert: await bufferizeContent(cert.cert, cert.certPath),
    key: await bufferizeContent(cert.key, cert.keyPath),
    pfx: await bufferizeContent(cert.pfx, cert.pfxPath),
    passphrase: cert.passphrase
  })));
}
__name(toClientCertificatesProtocol, "toClientCertificatesProtocol");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/webSocket.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
async function connectOverWebSocket(parentConnection, params) {
  const localUtils = parentConnection.localUtils();
  const transport = localUtils ? new JsonPipeTransport(localUtils) : new WebSocketTransport2();
  const connectHeaders = await transport.connect(params);
  const connection = new Connection(parentConnection._platform, localUtils, parentConnection._instrumentation, connectHeaders);
  connection.markAsRemote();
  connection.on("close", () => transport.close());
  let closeError;
  const onTransportClosed = /* @__PURE__ */ __name((reason) => {
    connection.close(reason || closeError);
  }, "onTransportClosed");
  transport.onClose((reason) => onTransportClosed(reason));
  connection.onmessage = (message) => transport.send(message).catch(() => onTransportClosed());
  transport.onMessage((message) => {
    try {
      connection.dispatch(message);
    } catch (e) {
      closeError = String(e);
      transport.close().catch(() => {
      });
    }
  });
  return connection;
}
__name(connectOverWebSocket, "connectOverWebSocket");
var JsonPipeTransport = class {
  static {
    __name(this, "JsonPipeTransport");
  }
  constructor(owner) {
    this._owner = owner;
  }
  async connect(params) {
    const { pipe, headers: connectHeaders } = await this._owner._channel.connect(params);
    this._pipe = pipe;
    return connectHeaders;
  }
  async send(message) {
    await this._pipe.send({ message });
  }
  onMessage(callback) {
    this._pipe.on("message", ({ message }) => callback(message));
  }
  onClose(callback) {
    this._pipe.on("closed", ({ reason }) => callback(reason));
  }
  async close() {
    await this._pipe.close().catch(() => {
    });
  }
};
var WebSocketTransport2 = class {
  static {
    __name(this, "WebSocketTransport");
  }
  async connect(params) {
    this._ws = new window.WebSocket(params.wsEndpoint);
    return [];
  }
  async send(message) {
    this._ws.send(JSON.stringify(message));
  }
  onMessage(callback) {
    this._ws.addEventListener("message", (event) => callback(JSON.parse(event.data)));
  }
  onClose(callback) {
    this._ws.addEventListener("close", () => callback());
  }
  async close() {
    this._ws.close();
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/android.js
var Android2 = class extends ChannelOwner {
  static {
    __name(this, "Android");
  }
  static from(android) {
    return android._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._timeoutSettings = new TimeoutSettings(this._platform);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  async devices(options2 = {}) {
    const { devices: devices2 } = await this._channel.devices(options2);
    return devices2.map((d) => AndroidDevice2.from(d));
  }
  async launchServer(options2 = {}) {
    if (!this._serverLauncher)
      throw new Error("Launching server is not supported");
    return await this._serverLauncher.launchServer(options2);
  }
  async connect(wsEndpoint, options2 = {}) {
    return await this._wrapApiCall(async () => {
      const deadline = options2.timeout ? monotonicTime() + options2.timeout : 0;
      const headers = { "x-playwright-browser": "android", ...options2.headers };
      const connectParams = { wsEndpoint, headers, slowMo: options2.slowMo, timeout: options2.timeout || 0 };
      const connection = await connectOverWebSocket(this._connection, connectParams);
      let device;
      connection.on("close", () => {
        device?._didClose();
      });
      const result = await raceAgainstDeadline(async () => {
        const playwright2 = await connection.initializePlaywright();
        if (!playwright2._initializer.preConnectedAndroidDevice) {
          connection.close();
          throw new Error("Malformed endpoint. Did you use Android.launchServer method?");
        }
        device = AndroidDevice2.from(playwright2._initializer.preConnectedAndroidDevice);
        device._shouldCloseConnectionOnClose = true;
        device.on(Events.AndroidDevice.Close, () => connection.close());
        return device;
      }, deadline);
      if (!result.timedOut) {
        return result.result;
      } else {
        connection.close();
        throw new Error(`Timeout ${options2.timeout}ms exceeded`);
      }
    });
  }
};
var AndroidDevice2 = class extends ChannelOwner {
  static {
    __name(this, "AndroidDevice");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._webViews = /* @__PURE__ */ new Map();
    this._shouldCloseConnectionOnClose = false;
    this._android = parent;
    this.input = new AndroidInput(this);
    this._timeoutSettings = new TimeoutSettings(this._platform, parent._timeoutSettings);
    this._channel.on("webViewAdded", ({ webView }) => this._onWebViewAdded(webView));
    this._channel.on("webViewRemoved", ({ socketName }) => this._onWebViewRemoved(socketName));
    this._channel.on("close", () => this._didClose());
  }
  static from(androidDevice) {
    return androidDevice._object;
  }
  _onWebViewAdded(webView) {
    const view = new AndroidWebView(this, webView);
    this._webViews.set(webView.socketName, view);
    this.emit(Events.AndroidDevice.WebView, view);
  }
  _onWebViewRemoved(socketName) {
    const view = this._webViews.get(socketName);
    this._webViews.delete(socketName);
    if (view)
      view.emit(Events.AndroidWebView.Close);
  }
  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }
  serial() {
    return this._initializer.serial;
  }
  model() {
    return this._initializer.model;
  }
  webViews() {
    return [...this._webViews.values()];
  }
  async webView(selector, options2) {
    const predicate = /* @__PURE__ */ __name((v) => {
      if (selector.pkg)
        return v.pkg() === selector.pkg;
      if (selector.socketName)
        return v._socketName() === selector.socketName;
      return false;
    }, "predicate");
    const webView = [...this._webViews.values()].find(predicate);
    if (webView)
      return webView;
    return await this.waitForEvent("webview", { ...options2, predicate });
  }
  async wait(selector, options2 = {}) {
    await this._channel.wait({ androidSelector: toSelectorChannel(selector), ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async fill(selector, text, options2 = {}) {
    await this._channel.fill({ androidSelector: toSelectorChannel(selector), text, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async press(selector, key, options2 = {}) {
    await this.tap(selector, options2);
    await this.input.press(key);
  }
  async tap(selector, options2 = {}) {
    await this._channel.tap({ androidSelector: toSelectorChannel(selector), ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async drag(selector, dest, options2 = {}) {
    await this._channel.drag({ androidSelector: toSelectorChannel(selector), dest, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async fling(selector, direction, options2 = {}) {
    await this._channel.fling({ androidSelector: toSelectorChannel(selector), direction, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async longTap(selector, options2 = {}) {
    await this._channel.longTap({ androidSelector: toSelectorChannel(selector), ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async pinchClose(selector, percent, options2 = {}) {
    await this._channel.pinchClose({ androidSelector: toSelectorChannel(selector), percent, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async pinchOpen(selector, percent, options2 = {}) {
    await this._channel.pinchOpen({ androidSelector: toSelectorChannel(selector), percent, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async scroll(selector, direction, percent, options2 = {}) {
    await this._channel.scroll({ androidSelector: toSelectorChannel(selector), direction, percent, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async swipe(selector, direction, percent, options2 = {}) {
    await this._channel.swipe({ androidSelector: toSelectorChannel(selector), direction, percent, ...options2, timeout: this._timeoutSettings.timeout(options2) });
  }
  async info(selector) {
    return (await this._channel.info({ androidSelector: toSelectorChannel(selector) })).info;
  }
  async screenshot(options2 = {}) {
    const { binary: binary2 } = await this._channel.screenshot();
    if (options2.path)
      await this._platform.fs().promises.writeFile(options2.path, binary2);
    return binary2;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close() {
    try {
      if (this._shouldCloseConnectionOnClose)
        this._connection.close();
      else
        await this._channel.close();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  _didClose() {
    this.emit(Events.AndroidDevice.Close, this);
  }
  async shell(command) {
    const { result } = await this._channel.shell({ command });
    return result;
  }
  async open(command) {
    return AndroidSocket.from((await this._channel.open({ command })).socket);
  }
  async installApk(file, options2) {
    await this._channel.installApk({ file: await loadFile(this._platform, file), args: options2 && options2.args });
  }
  async push(file, path30, options2) {
    await this._channel.push({ file: await loadFile(this._platform, file), path: path30, mode: options2 ? options2.mode : void 0 });
  }
  async launchBrowser(options2 = {}) {
    const contextOptions = await prepareBrowserContextParams(this._platform, options2);
    const result = await this._channel.launchBrowser(contextOptions);
    const context2 = BrowserContext2.from(result.context);
    const selectors2 = this._android._playwright.selectors;
    selectors2._contextsForSelectors.add(context2);
    context2.once(Events.BrowserContext.Close, () => selectors2._contextsForSelectors.delete(context2));
    await context2._initializeHarFromOptions(options2.recordHar);
    return context2;
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.AndroidDevice.Close)
        waiter.rejectOnEvent(this, Events.AndroidDevice.Close, () => new TargetClosedError2());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
};
var AndroidSocket = class extends ChannelOwner {
  static {
    __name(this, "AndroidSocket");
  }
  static from(androidDevice) {
    return androidDevice._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._channel.on("data", ({ data }) => this.emit(Events.AndroidSocket.Data, data));
    this._channel.on("close", () => this.emit(Events.AndroidSocket.Close));
  }
  async write(data) {
    await this._channel.write({ data });
  }
  async close() {
    await this._channel.close();
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
};
async function loadFile(platform2, file) {
  if (isString(file))
    return await platform2.fs().promises.readFile(file);
  return file;
}
__name(loadFile, "loadFile");
var AndroidInput = class {
  static {
    __name(this, "AndroidInput");
  }
  constructor(device) {
    this._device = device;
  }
  async type(text) {
    await this._device._channel.inputType({ text });
  }
  async press(key) {
    await this._device._channel.inputPress({ key });
  }
  async tap(point) {
    await this._device._channel.inputTap({ point });
  }
  async swipe(from, segments, steps) {
    await this._device._channel.inputSwipe({ segments, steps });
  }
  async drag(from, to, steps) {
    await this._device._channel.inputDrag({ from, to, steps });
  }
};
function toSelectorChannel(selector) {
  const {
    checkable,
    checked,
    clazz,
    clickable,
    depth,
    desc,
    enabled,
    focusable,
    focused,
    hasChild,
    hasDescendant,
    longClickable,
    pkg,
    res,
    scrollable,
    selected,
    text
  } = selector;
  const toRegex = /* @__PURE__ */ __name((value) => {
    if (value === void 0)
      return void 0;
    if (isRegExp2(value))
      return value.source;
    return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
  }, "toRegex");
  return {
    checkable,
    checked,
    clazz: toRegex(clazz),
    pkg: toRegex(pkg),
    desc: toRegex(desc),
    res: toRegex(res),
    text: toRegex(text),
    clickable,
    depth,
    enabled,
    focusable,
    focused,
    hasChild: hasChild ? { androidSelector: toSelectorChannel(hasChild.selector) } : void 0,
    hasDescendant: hasDescendant ? { androidSelector: toSelectorChannel(hasDescendant.selector), maxDepth: hasDescendant.maxDepth } : void 0,
    longClickable,
    scrollable,
    selected
  };
}
__name(toSelectorChannel, "toSelectorChannel");
var AndroidWebView = class extends EventEmitter18 {
  static {
    __name(this, "AndroidWebView");
  }
  constructor(device, data) {
    super(device._platform);
    this._device = device;
    this._data = data;
  }
  pid() {
    return this._data.pid;
  }
  pkg() {
    return this._data.pkg;
  }
  _socketName() {
    return this._data.socketName;
  }
  async page() {
    if (!this._pagePromise)
      this._pagePromise = this._fetchPage();
    return await this._pagePromise;
  }
  async _fetchPage() {
    const { context: context2 } = await this._device._channel.connectToWebView({ socketName: this._data.socketName });
    return BrowserContext2.from(context2).pages()[0];
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Browser2 = class extends ChannelOwner {
  static {
    __name(this, "Browser");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._contexts = /* @__PURE__ */ new Set();
    this._isConnected = true;
    this._shouldCloseConnectionOnClose = false;
    this._options = {};
    this._name = initializer.name;
    this._channel.on("context", ({ context: context2 }) => this._didCreateContext(BrowserContext2.from(context2)));
    this._channel.on("close", () => this._didClose());
    this._closedPromise = new Promise((f) => this.once(Events.Browser.Disconnected, f));
  }
  static from(browser3) {
    return browser3._object;
  }
  browserType() {
    return this._browserType;
  }
  async newContext(options2 = {}) {
    if (!options2.userAgent) {
      options2.userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36";
    }
    return await this._innerNewContext(options2, false);
  }
  async _newContextForReuse(options2 = {}) {
    return await this._innerNewContext(options2, true);
  }
  async _disconnectFromReusedContext(reason) {
    const context2 = [...this._contexts].find((context22) => context22._forReuse);
    if (!context2)
      return;
    await this._instrumentation.runBeforeCloseBrowserContext(context2);
    for (const page of context2.pages())
      page._onClose();
    context2._onClose();
    await this._channel.disconnectFromReusedContext({ reason });
  }
  async _innerNewContext(options2 = {}, forReuse) {
    options2 = this._browserType._playwright.selectors._withSelectorOptions({
      ...this._browserType._playwright._defaultContextOptions,
      ...options2
    });
    const contextOptions = await prepareBrowserContextParams(this._platform, options2);
    const response = forReuse ? await this._channel.newContextForReuse(contextOptions) : await this._channel.newContext(contextOptions);
    const context2 = BrowserContext2.from(response.context);
    if (forReuse)
      context2._forReuse = true;
    if (options2.logger)
      context2._logger = options2.logger;
    await context2._initializeHarFromOptions(options2.recordHar);
    await this._instrumentation.runAfterCreateBrowserContext(context2);
    return context2;
  }
  _connectToBrowserType(browserType, browserOptions, logger) {
    this._browserType = browserType;
    this._options = browserOptions;
    this._logger = logger;
    for (const context2 of this._contexts)
      this._setupBrowserContext(context2);
  }
  _didCreateContext(context2) {
    context2._browser = this;
    this._contexts.add(context2);
    if (this._browserType)
      this._setupBrowserContext(context2);
  }
  _setupBrowserContext(context2) {
    context2._logger = this._logger;
    context2.tracing._tracesDir = this._options.tracesDir;
    this._browserType._contexts.add(context2);
    this._browserType._playwright.selectors._contextsForSelectors.add(context2);
    context2.setDefaultTimeout(this._browserType._playwright._defaultContextTimeout);
    context2.setDefaultNavigationTimeout(this._browserType._playwright._defaultContextNavigationTimeout);
  }
  contexts() {
    return [...this._contexts];
  }
  version() {
    return this._initializer.version;
  }
  async newPage(options2 = {}) {
    return await this._wrapApiCall(async () => {
      const context2 = await this.newContext(options2);
      const page = await context2.newPage();
      page._ownedContext = context2;
      context2._ownerPage = page;
      return page;
    }, { title: "Create page" });
  }
  isConnected() {
    return this._isConnected;
  }
  async newBrowserCDPSession() {
    return CDPSession2.from((await this._channel.newBrowserCDPSession()).session);
  }
  async _launchServer(options2 = {}) {
    const serverLauncher = this._browserType._serverLauncher;
    const browserImpl = this._connection.toImpl?.(this);
    if (!serverLauncher || !browserImpl)
      throw new Error("Launching server is not supported");
    return await serverLauncher.launchServerOnExistingBrowser(browserImpl, {
      _sharedBrowser: true,
      ...options2
    });
  }
  async startTracing(page, options2 = {}) {
    this._path = options2.path;
    await this._channel.startTracing({ ...options2, page: page ? page._channel : void 0 });
  }
  async stopTracing() {
    const artifact = Artifact2.from((await this._channel.stopTracing()).artifact);
    const buffer = await artifact.readIntoBuffer();
    await artifact.delete();
    if (this._path) {
      await mkdirIfNeeded2(this._platform, this._path);
      await this._platform.fs().promises.writeFile(this._path, buffer);
      this._path = void 0;
    }
    return buffer;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close(options2 = {}) {
    this._closeReason = options2.reason;
    try {
      if (this._shouldCloseConnectionOnClose)
        this._connection.close();
      else
        await this._channel.close(options2);
      await this._closedPromise;
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  _didClose() {
    this._isConnected = false;
    this.emit(Events.Browser.Disconnected, this);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/browserType.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrowserType2 = class extends ChannelOwner {
  static {
    __name(this, "BrowserType");
  }
  constructor() {
    super(...arguments);
    this._contexts = /* @__PURE__ */ new Set();
  }
  static from(browserType) {
    return browserType._object;
  }
  executablePath() {
    if (!this._initializer.executablePath)
      throw new Error("Browser is not supported on current platform");
    return this._initializer.executablePath;
  }
  name() {
    return this._initializer.name;
  }
  async launch(options2 = {}) {
    assert3(!options2.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
    assert3(!options2.port, "Cannot specify a port without launching as a server.");
    const logger = options2.logger || this._playwright._defaultLaunchOptions?.logger;
    options2 = { ...this._playwright._defaultLaunchOptions, ...options2 };
    const launchOptions = {
      ...options2,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray2(options2.env) : void 0,
      timeout: new TimeoutSettings(this._platform).launchTimeout(options2)
    };
    return await this._wrapApiCall(async () => {
      const browser3 = Browser2.from((await this._channel.launch(launchOptions)).browser);
      browser3._connectToBrowserType(this, options2, logger);
      return browser3;
    });
  }
  async launchServer(options2 = {}) {
    if (!this._serverLauncher)
      throw new Error("Launching server is not supported");
    options2 = { ...this._playwright._defaultLaunchOptions, ...options2 };
    return await this._serverLauncher.launchServer(options2);
  }
  async launchPersistentContext(userDataDir, options2 = {}) {
    const logger = options2.logger || this._playwright._defaultLaunchOptions?.logger;
    assert3(!options2.port, "Cannot specify a port without launching as a server.");
    options2 = this._playwright.selectors._withSelectorOptions({
      ...this._playwright._defaultLaunchOptions,
      ...this._playwright._defaultContextOptions,
      ...options2
    });
    const contextParams = await prepareBrowserContextParams(this._platform, options2);
    const persistentParams = {
      ...contextParams,
      ignoreDefaultArgs: Array.isArray(options2.ignoreDefaultArgs) ? options2.ignoreDefaultArgs : void 0,
      ignoreAllDefaultArgs: !!options2.ignoreDefaultArgs && !Array.isArray(options2.ignoreDefaultArgs),
      env: options2.env ? envObjectToArray2(options2.env) : void 0,
      channel: options2.channel,
      userDataDir: this._platform.path().isAbsolute(userDataDir) || !userDataDir ? userDataDir : this._platform.path().resolve(userDataDir),
      timeout: new TimeoutSettings(this._platform).launchTimeout(options2)
    };
    const context2 = await this._wrapApiCall(async () => {
      const result = await this._channel.launchPersistentContext(persistentParams);
      const browser3 = Browser2.from(result.browser);
      browser3._connectToBrowserType(this, options2, logger);
      const context22 = BrowserContext2.from(result.context);
      await context22._initializeHarFromOptions(options2.recordHar);
      return context22;
    });
    await this._instrumentation.runAfterCreateBrowserContext(context2);
    return context2;
  }
  async connect(optionsOrWsEndpoint, options2) {
    if (typeof optionsOrWsEndpoint === "string")
      return await this._connect({ ...options2, wsEndpoint: optionsOrWsEndpoint });
    assert3(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
    return await this._connect(optionsOrWsEndpoint);
  }
  async _connect(params) {
    const logger = params.logger;
    return await this._wrapApiCall(async () => {
      const deadline = params.timeout ? monotonicTime() + params.timeout : 0;
      const headers = { "x-playwright-browser": this.name(), ...params.headers };
      const connectParams = {
        wsEndpoint: params.wsEndpoint,
        headers,
        exposeNetwork: params.exposeNetwork ?? params._exposeNetwork,
        slowMo: params.slowMo,
        timeout: params.timeout || 0
      };
      if (params.__testHookRedirectPortForwarding)
        connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;
      const connection = await connectOverWebSocket(this._connection, connectParams);
      let browser3;
      connection.on("close", () => {
        for (const context2 of browser3?.contexts() || []) {
          for (const page of context2.pages())
            page._onClose();
          context2._onClose();
        }
        setTimeout(() => browser3?._didClose(), 0);
      });
      const result = await raceAgainstDeadline(async () => {
        if (params.__testHookBeforeCreateBrowser)
          await params.__testHookBeforeCreateBrowser();
        const playwright2 = await connection.initializePlaywright();
        if (!playwright2._initializer.preLaunchedBrowser) {
          connection.close();
          throw new Error("Malformed endpoint. Did you use BrowserType.launchServer method?");
        }
        playwright2.selectors = this._playwright.selectors;
        browser3 = Browser2.from(playwright2._initializer.preLaunchedBrowser);
        browser3._connectToBrowserType(this, {}, logger);
        browser3._shouldCloseConnectionOnClose = true;
        browser3.on(Events.Browser.Disconnected, () => connection.close());
        return browser3;
      }, deadline);
      if (!result.timedOut) {
        return result.result;
      } else {
        connection.close();
        throw new Error(`Timeout ${params.timeout}ms exceeded`);
      }
    });
  }
  async connectOverCDP(endpointURLOrOptions, options2) {
    if (typeof endpointURLOrOptions === "string")
      return await this._connectOverCDP(endpointURLOrOptions, options2);
    const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
    assert3(endpointURL, "Cannot connect over CDP without wsEndpoint.");
    return await this.connectOverCDP(endpointURL, endpointURLOrOptions);
  }
  async _connectOverCDP(endpointURL, params = {}) {
    if (this.name() !== "chromium")
      throw new Error("Connecting over CDP is only supported in Chromium.");
    const headers = params.headers ? headersObjectToArray(params.headers) : void 0;
    const result = await this._channel.connectOverCDP({
      endpointURL,
      headers,
      slowMo: params.slowMo,
      timeout: new TimeoutSettings(this._platform).timeout(params)
    });
    const browser3 = Browser2.from(result.browser);
    browser3._connectToBrowserType(this, {}, params.logger);
    if (result.defaultContext)
      await this._instrumentation.runAfterCreateBrowserContext(BrowserContext2.from(result.defaultContext));
    return browser3;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/clientInstrumentation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function createInstrumentation2() {
  const listeners2 = [];
  return new Proxy({}, {
    get: /* @__PURE__ */ __name((obj, prop) => {
      if (typeof prop !== "string")
        return obj[prop];
      if (prop === "addListener")
        return (listener) => listeners2.push(listener);
      if (prop === "removeListener")
        return (listener) => listeners2.splice(listeners2.indexOf(listener), 1);
      if (prop === "removeAllListeners")
        return () => listeners2.splice(0, listeners2.length);
      if (prop.startsWith("run")) {
        return async (...params) => {
          for (const listener of listeners2)
            await listener[prop]?.(...params);
        };
      }
      if (prop.startsWith("on")) {
        return (...params) => {
          for (const listener of listeners2)
            listener[prop]?.(...params);
        };
      }
      return obj[prop];
    }, "get")
  });
}
__name(createInstrumentation2, "createInstrumentation");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/electron.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Electron2 = class extends ChannelOwner {
  static {
    __name(this, "Electron");
  }
  static from(electron) {
    return electron._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }
  async launch(options2 = {}) {
    options2 = this._playwright.selectors._withSelectorOptions(options2);
    const params = {
      ...await prepareBrowserContextParams(this._platform, options2),
      env: envObjectToArray2(options2.env ? options2.env : this._platform.env),
      tracesDir: options2.tracesDir,
      timeout: new TimeoutSettings(this._platform).launchTimeout(options2)
    };
    const app = ElectronApplication2.from((await this._channel.launch(params)).electronApplication);
    this._playwright.selectors._contextsForSelectors.add(app._context);
    app.once(Events.ElectronApplication.Close, () => this._playwright.selectors._contextsForSelectors.delete(app._context));
    await app._context._initializeHarFromOptions(options2.recordHar);
    app._context.tracing._tracesDir = options2.tracesDir;
    return app;
  }
};
var ElectronApplication2 = class extends ChannelOwner {
  static {
    __name(this, "ElectronApplication");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._windows = /* @__PURE__ */ new Set();
    this._timeoutSettings = new TimeoutSettings(this._platform);
    this._context = BrowserContext2.from(initializer.context);
    for (const page of this._context._pages)
      this._onPage(page);
    this._context.on(Events.BrowserContext.Page, (page) => this._onPage(page));
    this._channel.on("close", () => {
      this.emit(Events.ElectronApplication.Close);
    });
    this._channel.on("console", (event) => this.emit(Events.ElectronApplication.Console, new ConsoleMessage2(this._platform, event)));
    this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([
      [Events.ElectronApplication.Console, "console"]
    ]));
  }
  static from(electronApplication) {
    return electronApplication._object;
  }
  process() {
    return this._connection.toImpl?.(this)?.process();
  }
  _onPage(page) {
    this._windows.add(page);
    this.emit(Events.ElectronApplication.Window, page);
    page.once(Events.Page.Close, () => this._windows.delete(page));
  }
  windows() {
    return [...this._windows];
  }
  async firstWindow(options2) {
    if (this._windows.size)
      return this._windows.values().next().value;
    return await this.waitForEvent("window", options2);
  }
  context() {
    return this._context;
  }
  async [Symbol.asyncDispose]() {
    await this.close();
  }
  async close() {
    try {
      await this._context.close();
    } catch (e) {
      if (isTargetClosedError2(e))
        return;
      throw e;
    }
  }
  async waitForEvent(event, optionsOrPredicate = {}) {
    return await this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
      const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
      const waiter = Waiter.createForEvent(this, event);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== Events.ElectronApplication.Close)
        waiter.rejectOnEvent(this, Events.ElectronApplication.Close, () => new TargetClosedError2());
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }
  async browserWindow(page) {
    const result = await this._channel.browserWindow({ page: page._channel });
    return JSHandle2.from(result.handle);
  }
  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return parseResult(result.value);
  }
  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({ expression: String(pageFunction), isFunction: typeof pageFunction === "function", arg: serializeArgument(arg) });
    return JSHandle2.from(result.handle);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/jsonPipe.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JsonPipe = class extends ChannelOwner {
  static {
    __name(this, "JsonPipe");
  }
  static from(jsonPipe) {
    return jsonPipe._object;
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }
  channel() {
    return this._channel;
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/localUtils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LocalUtils = class extends ChannelOwner {
  static {
    __name(this, "LocalUtils");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this.devices = {};
    for (const { name, descriptor } of initializer.deviceDescriptors)
      this.devices[name] = descriptor;
  }
  async zip(params) {
    return await this._channel.zip(params);
  }
  async harOpen(params) {
    return await this._channel.harOpen(params);
  }
  async harLookup(params) {
    return await this._channel.harLookup(params);
  }
  async harClose(params) {
    return await this._channel.harClose(params);
  }
  async harUnzip(params) {
    return await this._channel.harUnzip(params);
  }
  async tracingStarted(params) {
    return await this._channel.tracingStarted(params);
  }
  async traceDiscarded(params) {
    return await this._channel.traceDiscarded(params);
  }
  async addStackToTracingNoReply(params) {
    return await this._channel.addStackToTracingNoReply(params);
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/playwright.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/selectors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Selectors2 = class {
  static {
    __name(this, "Selectors");
  }
  constructor(platform2) {
    this._selectorEngines = [];
    this._contextsForSelectors = /* @__PURE__ */ new Set();
    this._platform = platform2;
  }
  async register(name, script, options2 = {}) {
    if (this._selectorEngines.some((engine) => engine.name === name))
      throw new Error(`selectors.register: "${name}" selector engine has been already registered`);
    const source8 = await evaluationScript(this._platform, script, void 0, false);
    const selectorEngine = { ...options2, name, source: source8 };
    for (const context2 of this._contextsForSelectors)
      await context2._channel.registerSelectorEngine({ selectorEngine });
    this._selectorEngines.push(selectorEngine);
  }
  setTestIdAttribute(attributeName) {
    this._testIdAttributeName = attributeName;
    setTestIdAttribute(attributeName);
    for (const context2 of this._contextsForSelectors)
      context2._channel.setTestIdAttributeName({ testIdAttributeName: attributeName }).catch(() => {
      });
  }
  _withSelectorOptions(options2) {
    return { ...options2, selectorEngines: this._selectorEngines, testIdAttributeName: this._testIdAttributeName };
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/playwright.js
var Playwright2 = class extends ChannelOwner {
  static {
    __name(this, "Playwright");
  }
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this.request = new APIRequest(this);
    this.chromium = BrowserType2.from(initializer.chromium);
    this.chromium._playwright = this;
    this.firefox = BrowserType2.from(initializer.firefox);
    this.firefox._playwright = this;
    this.webkit = BrowserType2.from(initializer.webkit);
    this.webkit._playwright = this;
    this._android = Android2.from(initializer.android);
    this._android._playwright = this;
    this._electron = Electron2.from(initializer.electron);
    this._electron._playwright = this;
    this._bidiChromium = BrowserType2.from(initializer._bidiChromium);
    this._bidiChromium._playwright = this;
    this._bidiFirefox = BrowserType2.from(initializer._bidiFirefox);
    this._bidiFirefox._playwright = this;
    this.devices = this._connection.localUtils()?.devices ?? {};
    this.selectors = new Selectors2(this._connection._platform);
    this.errors = { TimeoutError: TimeoutError2 };
  }
  static from(channel2) {
    return channel2._object;
  }
  _browserTypes() {
    return [this.chromium, this.firefox, this.webkit, this._bidiChromium, this._bidiFirefox];
  }
  _preLaunchedBrowser() {
    const browser3 = Browser2.from(this._initializer.preLaunchedBrowser);
    browser3._connectToBrowserType(this[browser3._name], {}, void 0);
    return browser3;
  }
  _allContexts() {
    return this._browserTypes().flatMap((type) => [...type._contexts]);
  }
  _allPages() {
    return this._allContexts().flatMap((context2) => context2.pages());
  }
};

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/client/connection.js
var Root = class extends ChannelOwner {
  static {
    __name(this, "Root");
  }
  constructor(connection) {
    super(connection, "Root", "", {});
  }
  async initialize() {
    return Playwright2.from((await this._channel.initialize({
      sdkLanguage: "javascript"
    })).playwright);
  }
};
var DummyChannelOwner = class extends ChannelOwner {
  static {
    __name(this, "DummyChannelOwner");
  }
};
var Connection = class extends EventEmitter18 {
  static {
    __name(this, "Connection");
  }
  constructor(platform2, localUtils, instrumentation, headers = []) {
    super(platform2);
    this._objects = /* @__PURE__ */ new Map();
    this.onmessage = (message) => {
    };
    this._lastId = 0;
    this._callbacks = /* @__PURE__ */ new Map();
    this._isRemote = false;
    this._rawBuffers = false;
    this._tracingCount = 0;
    this._instrumentation = instrumentation || createInstrumentation2();
    this._localUtils = localUtils;
    this._rootObject = new Root(this);
    this.headers = headers;
  }
  markAsRemote() {
    this._isRemote = true;
  }
  isRemote() {
    return this._isRemote;
  }
  useRawBuffers() {
    this._rawBuffers = true;
  }
  rawBuffers() {
    return this._rawBuffers;
  }
  localUtils() {
    return this._localUtils;
  }
  async initializePlaywright() {
    return await this._rootObject.initialize();
  }
  getObjectWithKnownName(guid) {
    return this._objects.get(guid);
  }
  setIsTracing(isTracing) {
    if (isTracing)
      this._tracingCount++;
    else
      this._tracingCount--;
  }
  async sendMessageToServer(object, method, params, options2) {
    if (this._closedError)
      throw this._closedError;
    if (object._wasCollected)
      throw new Error("The object has been collected to prevent unbounded heap growth.");
    const guid = object._guid;
    const type = object._type;
    const id = ++this._lastId;
    const message = { id, guid, method, params };
    if (this._platform.isLogEnabled("channel")) {
      this._platform.log("channel", "SEND> " + JSON.stringify(message));
    }
    const location2 = options2.frames?.[0] ? { file: options2.frames[0].file, line: options2.frames[0].line, column: options2.frames[0].column } : void 0;
    const metadata = { title: options2.title, location: location2, internal: options2.internal, stepId: options2.stepId };
    if (this._tracingCount && options2.frames && type !== "LocalUtils")
      this._localUtils?.addStackToTracingNoReply({ callData: { stack: options2.frames ?? [], id } }).catch(() => {
      });
    this._platform.zones.empty.run(() => this.onmessage({ ...message, metadata }));
    return await new Promise((resolve, reject) => this._callbacks.set(id, { resolve, reject, title: options2.title, type, method }));
  }
  _validatorFromWireContext() {
    return {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this._rawBuffers ? "buffer" : "fromBase64",
      isUnderTest: /* @__PURE__ */ __name(() => this._platform.isUnderTest(), "isUnderTest")
    };
  }
  dispatch(message) {
    if (this._closedError)
      return;
    const { id, guid, method, params, result, error: error3, log: log3 } = message;
    if (id) {
      if (this._platform.isLogEnabled("channel"))
        this._platform.log("channel", "<RECV " + JSON.stringify(message));
      const callback = this._callbacks.get(id);
      if (!callback)
        throw new Error(`Cannot find command to respond: ${id}`);
      this._callbacks.delete(id);
      if (error3 && !result) {
        const parsedError = parseError2(error3);
        rewriteErrorMessage(parsedError, parsedError.message + formatCallLog(this._platform, log3));
        callback.reject(parsedError);
      } else {
        const validator2 = findValidator(callback.type, callback.method, "Result");
        callback.resolve(validator2(result, "", this._validatorFromWireContext()));
      }
      return;
    }
    if (this._platform.isLogEnabled("channel"))
      this._platform.log("channel", "<EVENT " + JSON.stringify(message));
    if (method === "__create__") {
      this._createRemoteObject(guid, params.type, params.guid, params.initializer);
      return;
    }
    const object = this._objects.get(guid);
    if (!object)
      throw new Error(`Cannot find object to "${method}": ${guid}`);
    if (method === "__adopt__") {
      const child = this._objects.get(params.guid);
      if (!child)
        throw new Error(`Unknown new child: ${params.guid}`);
      object._adopt(child);
      return;
    }
    if (method === "__dispose__") {
      object._dispose(params.reason);
      return;
    }
    const validator = findValidator(object._type, method, "Event");
    object._channel.emit(method, validator(params, "", this._validatorFromWireContext()));
  }
  close(cause) {
    if (this._closedError)
      return;
    this._closedError = new TargetClosedError2(cause);
    for (const callback of this._callbacks.values())
      callback.reject(this._closedError);
    this._callbacks.clear();
    this.emit("close");
  }
  _tChannelImplFromWire(names, arg, path30, context2) {
    if (arg && typeof arg === "object" && typeof arg.guid === "string") {
      const object = this._objects.get(arg.guid);
      if (!object)
        throw new Error(`Object with guid ${arg.guid} was not bound in the connection`);
      if (names !== "*" && !names.includes(object._type))
        throw new ValidationError(`${path30}: expected channel ${names.toString()}`);
      return object._channel;
    }
    throw new ValidationError(`${path30}: expected channel ${names.toString()}`);
  }
  _createRemoteObject(parentGuid, type, guid, initializer) {
    const parent = this._objects.get(parentGuid);
    if (!parent)
      throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
    let result;
    const validator = findValidator(type, "", "Initializer");
    initializer = validator(initializer, "", this._validatorFromWireContext());
    switch (type) {
      case "Android":
        result = new Android2(parent, type, guid, initializer);
        break;
      case "AndroidSocket":
        result = new AndroidSocket(parent, type, guid, initializer);
        break;
      case "AndroidDevice":
        result = new AndroidDevice2(parent, type, guid, initializer);
        break;
      case "APIRequestContext":
        result = new APIRequestContext2(parent, type, guid, initializer);
        break;
      case "Artifact":
        result = new Artifact2(parent, type, guid, initializer);
        break;
      case "BindingCall":
        result = new BindingCall(parent, type, guid, initializer);
        break;
      case "Browser":
        result = new Browser2(parent, type, guid, initializer);
        break;
      case "BrowserContext":
        result = new BrowserContext2(parent, type, guid, initializer);
        break;
      case "BrowserType":
        result = new BrowserType2(parent, type, guid, initializer);
        break;
      case "CDPSession":
        result = new CDPSession2(parent, type, guid, initializer);
        break;
      case "Dialog":
        result = new Dialog2(parent, type, guid, initializer);
        break;
      case "Electron":
        result = new Electron2(parent, type, guid, initializer);
        break;
      case "ElectronApplication":
        result = new ElectronApplication2(parent, type, guid, initializer);
        break;
      case "ElementHandle":
        result = new ElementHandle2(parent, type, guid, initializer);
        break;
      case "Frame":
        result = new Frame2(parent, type, guid, initializer);
        break;
      case "JSHandle":
        result = new JSHandle2(parent, type, guid, initializer);
        break;
      case "JsonPipe":
        result = new JsonPipe(parent, type, guid, initializer);
        break;
      case "LocalUtils":
        result = new LocalUtils(parent, type, guid, initializer);
        if (!this._localUtils)
          this._localUtils = result;
        break;
      case "Page":
        result = new Page2(parent, type, guid, initializer);
        break;
      case "Playwright":
        result = new Playwright2(parent, type, guid, initializer);
        break;
      case "Request":
        result = new Request2(parent, type, guid, initializer);
        break;
      case "Response":
        result = new Response3(parent, type, guid, initializer);
        break;
      case "Route":
        result = new Route2(parent, type, guid, initializer);
        break;
      case "Stream":
        result = new Stream(parent, type, guid, initializer);
        break;
      case "SocksSupport":
        result = new DummyChannelOwner(parent, type, guid, initializer);
        break;
      case "Tracing":
        result = new Tracing2(parent, type, guid, initializer);
        break;
      case "WebSocket":
        result = new WebSocket3(parent, type, guid, initializer);
        break;
      case "WebSocketRoute":
        result = new WebSocketRoute(parent, type, guid, initializer);
        break;
      case "Worker":
        result = new Worker2(parent, type, guid, initializer);
        break;
      case "WritableStream":
        result = new WritableStream(parent, type, guid, initializer);
        break;
      default:
        throw new Error("Missing type " + type);
    }
    return result;
  }
};
function formatCallLog(platform2, log3) {
  if (!log3 || !log3.some((l) => !!l))
    return "";
  return `
Call log:
${platform2.colors.dim(log3.join("\n"))}
`;
}
__name(formatCallLog, "formatCallLog");

// node_modules/@cloudflare/playwright/lib/packages/playwright-core/src/inProcessFactory.js
function createInProcessPlaywright() {
  const playwright2 = createPlaywright({ sdkLanguage: process.env.PW_LANG_NAME || "javascript" });
  const clientConnection = new Connection(nodePlatform);
  clientConnection.useRawBuffers();
  const dispatcherConnection = new DispatcherConnection(
    true
    /* local */
  );
  dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
  clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
  const rootScope = new RootDispatcher(dispatcherConnection);
  new PlaywrightDispatcher(rootScope, playwright2);
  const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
  playwrightAPI.chromium._serverLauncher = new BrowserServerLauncherImpl("chromium");
  playwrightAPI.firefox._serverLauncher = new BrowserServerLauncherImpl("firefox");
  playwrightAPI.webkit._serverLauncher = new BrowserServerLauncherImpl("webkit");
  playwrightAPI._android._serverLauncher = new AndroidServerLauncherImpl();
  playwrightAPI._bidiChromium._serverLauncher = new BrowserServerLauncherImpl("_bidiChromium");
  playwrightAPI._bidiFirefox._serverLauncher = new BrowserServerLauncherImpl("_bidiFirefox");
  dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
  clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
  clientConnection.toImpl = (x) => {
    if (x instanceof Connection)
      return x === clientConnection ? dispatcherConnection : void 0;
    if (!x)
      return dispatcherConnection._dispatcherByGuid.get("");
    return dispatcherConnection._dispatcherByGuid.get(x._guid)._object;
  };
  return playwrightAPI;
}
__name(createInProcessPlaywright, "createInProcessPlaywright");

// node_modules/@cloudflare/playwright/lib/index.js
import { env as env2 } from "cloudflare:workers";

// node_modules/@cloudflare/playwright/lib/cloudflare/wrapClientApis.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var apis = {
  accessibility: [Accessibility2.prototype, { snapshot: true }],
  // android: [Android.prototype],
  // androidDevice: [AndroidDevice.prototype],
  // androidWebView: [AndroidWebView.prototype],
  // androidInput: [AndroidInput.prototype],
  // androidSocket: [AndroidSocket.prototype],
  browser: [Browser2.prototype, { newContext: true, newPage: true, newBrowserCDPSession: true, startTracing: true, stopTracing: true, close: true }],
  browserContext: [BrowserContext2.prototype, {
    newPage: true,
    cookies: true,
    addCookies: true,
    clearCookies: true,
    grantPermissions: true,
    clearPermissions: true,
    setGeolocation: true,
    setExtraHTTPHeaders: true,
    setOffline: true,
    setHTTPCredentials: true,
    addInitScript: true,
    exposeBinding: true,
    exposeFunction: true,
    route: true,
    routeFromHAR: true,
    unrouteAll: true,
    unroute: true,
    waitForEvent: true,
    storageState: true,
    newCDPSession: true,
    close: true,
    routeWebSocket: true
  }],
  browserType: [BrowserType2.prototype, { launch: true, launchServer: true, launchPersistentContext: true, connect: true, connectOverCDP: true }],
  clock: [Clock2.prototype, { install: true, fastForward: true, pauseAt: true, resume: true, runFor: true, setFixedTime: true, setSystemTime: true }],
  consoleMessage: [ConsoleMessage2.prototype, {}],
  coverage: [Coverage.prototype, { startCSSCoverage: true, stopCSSCoverage: true, startJSCoverage: true, stopJSCoverage: true }],
  dialog: [Dialog2.prototype, { accept: true, dismiss: true }],
  download: [Download2.prototype, { cancel: true, createReadStream: true, path: true, failure: true, delete: true, saveAs: true }],
  // electron: [Electron.prototype, {}],
  // electronApplication: [ElectronApplication.prototype, {}],
  locator: [Locator.prototype, {
    boundingBox: true,
    check: true,
    click: true,
    dblclick: true,
    dispatchEvent: true,
    dragTo: true,
    evaluate: true,
    evaluateAll: true,
    evaluateHandle: true,
    fill: true,
    clear: true,
    highlight: true,
    elementHandle: true,
    elementHandles: true,
    focus: true,
    blur: true,
    count: true,
    getAttribute: true,
    hover: true,
    innerHTML: true,
    innerText: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    press: true,
    screenshot: true,
    scrollIntoViewIfNeeded: true,
    selectOption: true,
    selectText: true,
    setChecked: true,
    setInputFiles: true,
    tap: true,
    textContent: true,
    type: true,
    pressSequentially: true,
    uncheck: true,
    all: true,
    allInnerTexts: true,
    allTextContents: true,
    waitFor: true,
    ariaSnapshot: true
  }],
  frameLocator: [FrameLocator.prototype, {}],
  elementHandle: [ElementHandle2.prototype, {
    // from JSHandle
    evaluate: true,
    evaluateHandle: true,
    getProperty: true,
    getProperties: true,
    jsonValue: true,
    dispose: true,
    // from ElementHandle
    ownerFrame: true,
    contentFrame: true,
    getAttribute: true,
    inputValue: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    dispatchEvent: true,
    scrollIntoViewIfNeeded: true,
    hover: true,
    click: true,
    dblclick: true,
    tap: true,
    selectOption: true,
    fill: true,
    selectText: true,
    setInputFiles: true,
    focus: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    boundingBox: true,
    screenshot: true,
    $: true,
    $$: true,
    $eval: true,
    $$eval: true,
    waitForElementState: true,
    waitForSelector: true
  }],
  fileChooser: [FileChooser2.prototype, { setFiles: true }],
  timeoutError: [TimeoutError2.prototype, {}],
  frame: [Frame2.prototype, {
    goto: true,
    waitForNavigation: true,
    waitForLoadState: true,
    waitForURL: true,
    frameElement: true,
    evaluateHandle: true,
    evaluate: true,
    $: true,
    $$: true,
    waitForSelector: true,
    dispatchEvent: true,
    $eval: true,
    $$eval: true,
    content: true,
    setContent: true,
    addScriptTag: true,
    addStyleTag: true,
    click: true,
    dblclick: true,
    dragAndDrop: true,
    tap: true,
    fill: true,
    focus: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    getAttribute: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    hover: true,
    selectOption: true,
    setInputFiles: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    waitForTimeout: true,
    waitForFunction: true,
    title: true
  }],
  keyboard: [Keyboard2.prototype, { down: true, up: true, insertText: true, type: true, press: true }],
  mouse: [Mouse2.prototype, { click: true, dblclick: true, down: true, up: true, move: true, wheel: true }],
  touchscreen: [Touchscreen2.prototype, { tap: true }],
  jSHandle: [JSHandle2.prototype, { evaluate: true, evaluateHandle: true, getProperty: true, jsonValue: true, getProperties: true, dispose: true }],
  route: [Route2.prototype, { fallback: true, abort: true, fetch: true, fulfill: true, continue: true }],
  webSocket: [WebSocket3.prototype, { waitForEvent: true }],
  webSocketRoute: [WebSocketRoute.prototype, { close: true }],
  request: [APIRequest.prototype, { newContext: true }],
  requestContext: [APIRequestContext2.prototype, { dispose: true, delete: true, head: true, get: true, patch: true, post: true, put: true, fetch: true, storageState: true }],
  response: [APIResponse.prototype, { body: true, json: true, text: true, dispose: true }],
  page: [Page2.prototype, {
    opener: true,
    waitForSelector: true,
    dispatchEvent: true,
    evaluateHandle: true,
    $: true,
    $$: true,
    $eval: true,
    $$eval: true,
    addScriptTag: true,
    addStyleTag: true,
    exposeFunction: true,
    exposeBinding: true,
    setExtraHTTPHeaders: true,
    content: true,
    setContent: true,
    goto: true,
    reload: true,
    addLocatorHandler: true,
    waitForLoadState: true,
    waitForNavigation: true,
    waitForURL: true,
    waitForRequest: true,
    waitForResponse: true,
    waitForEvent: true,
    goBack: true,
    goForward: true,
    emulateMedia: true,
    setViewportSize: true,
    evaluate: true,
    addInitScript: true,
    route: true,
    routeFromHAR: true,
    unrouteAll: true,
    unroute: true,
    screenshot: true,
    title: true,
    bringToFront: true,
    close: true,
    click: true,
    dragAndDrop: true,
    dblclick: true,
    tap: true,
    fill: true,
    focus: true,
    textContent: true,
    innerText: true,
    innerHTML: true,
    getAttribute: true,
    inputValue: true,
    isChecked: true,
    isDisabled: true,
    isEditable: true,
    isEnabled: true,
    isHidden: true,
    isVisible: true,
    hover: true,
    selectOption: true,
    setInputFiles: true,
    type: true,
    press: true,
    check: true,
    uncheck: true,
    setChecked: true,
    waitForTimeout: true,
    waitForFunction: true,
    pause: true,
    pdf: true,
    removeLocatorHandler: true,
    requestGC: true,
    routeWebSocket: true
  }],
  selectors: [Selectors2.prototype, { register: true }],
  tracing: [Tracing2.prototype, { start: true, startChunk: true, stop: true, stopChunk: true, group: false, groupEnd: false }],
  video: [Video.prototype, { delete: true, path: true, saveAs: true }],
  worker: [Worker2.prototype, { evaluate: true, evaluateHandle: true }],
  session: [CDPSession2.prototype, { send: true, detach: true }],
  playwright: [Playwright2.prototype, { devices: false }],
  webError: [WebError.prototype, {}]
};
var kApiFunctionWrapped = Symbol("kApiFunctionWrapped");
function wrapClientApis() {
  for (const [typeName, [proto, props]] of Object.entries(apis)) {
    for (const [key, needsWrap] of Object.entries(props)) {
      if (!needsWrap)
        continue;
      const originalFn = proto[key];
      if (!originalFn || typeof originalFn !== "function")
        throw new Error(`Method ${key} not found in ${typeName}`);
      if (originalFn[kApiFunctionWrapped] === true)
        continue;
      const wrapFn = /* @__PURE__ */ __name(async function(...args) {
        const apiName = apiCallZone.getStore();
        if (apiName)
          return await originalFn.apply(this, args);
        return await apiCallZone.run({ apiName: `${typeName}.${key}` }, async () => await originalFn.apply(this, args));
      }, "wrapFn");
      wrapFn[kApiFunctionWrapped] = true;
      proto[key] = wrapFn;
    }
  }
}
__name(wrapClientApis, "wrapClientApis");

// node_modules/@cloudflare/playwright/lib/cloudflare/unsupportedOperations.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unsupportedOperations(playwright2) {
  playwright2.chromium.launch = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launch.");
  };
  playwright2.chromium.launchPersistentContext = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launchPersistentContext.");
  };
  playwright2.chromium.launchServer = async () => {
    throw new Error("Cloudflare Workers does not support browserType.launchServer.");
  };
  playwright2.chromium.connect = async () => {
    throw new Error("Cloudflare Workers does not support browserType.connect.");
  };
}
__name(unsupportedOperations, "unsupportedOperations");

// node_modules/@cloudflare/playwright/lib/packages/playwright-cloudflare/package.json.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version5 = "1.0.0";

// node_modules/@cloudflare/playwright/lib/index.js
function resetMonotonicTime() {
  if (timeOrigin() === 0 && Date.now() !== 0)
    setTimeOrigin(Date.now());
}
__name(resetMonotonicTime, "resetMonotonicTime");
var playwright = createInProcessPlaywright();
unsupportedOperations(playwright);
wrapClientApis();
var HTTP_FAKE_HOST = "http://fake.host";
var WS_FAKE_HOST = "ws://fake.host";
var originalConnectOverCDP = playwright.chromium.connectOverCDP;
playwright.chromium.connectOverCDP = (endpointURLOrOptions) => {
  const wsEndpoint = typeof endpointURLOrOptions === "string" ? endpointURLOrOptions : endpointURLOrOptions.wsEndpoint ?? endpointURLOrOptions.endpointURL;
  if (!wsEndpoint)
    throw new Error("No wsEndpoint provided");
  const wsUrl = new URL(wsEndpoint);
  if (!wsUrl.searchParams.has("persistent"))
    wsUrl.searchParams.set("persistent", "true");
  return wsUrl.searchParams.has("browser_session") ? connect(wsUrl.toString()) : launch(wsUrl.toString());
};
async function connectDevtools(endpoint, options2) {
  resetMonotonicTime();
  const url4 = new URL(`${HTTP_FAKE_HOST}/v1/connectDevtools`);
  url4.searchParams.set("browser_session", options2.sessionId);
  if (options2.persistent)
    url4.searchParams.set("persistent", "true");
  const response = await getBrowserBinding(endpoint).fetch(url4, {
    headers: {
      "Upgrade": "websocket",
      "cf-brapi-client": `@cloudflare/playwright@${version5}`
    }
  });
  const webSocket = response.webSocket;
  webSocket.accept();
  return webSocket;
}
__name(connectDevtools, "connectDevtools");
function extractOptions(endpoint) {
  if (typeof endpoint === "string" || endpoint instanceof URL) {
    const url4 = endpoint instanceof URL ? endpoint : new URL(endpoint);
    const sessionId = url4.searchParams.get("browser_session") ?? void 0;
    const keepAlive = url4.searchParams.has("keep_alive") ? parseInt(url4.searchParams.get("keep_alive"), 10) : void 0;
    const persistent = url4.searchParams.has("persistent");
    return { sessionId, keep_alive: keepAlive, persistent };
  }
  return {};
}
__name(extractOptions, "extractOptions");
function endpointURLString(binding3, options2) {
  const bindingKey = typeof binding3 === "string" ? binding3 : Object.keys(env2).find((key) => env2[key] === binding3);
  if (!bindingKey || !(bindingKey in env2))
    throw new Error(`No binding found for ${binding3}`);
  const url4 = new URL(`${HTTP_FAKE_HOST}/v1/connectDevtools`);
  url4.searchParams.set("browser_binding", bindingKey);
  if (options2?.sessionId)
    url4.searchParams.set("browser_session", options2.sessionId);
  if (options2?.persistent)
    url4.searchParams.set("persistent", "true");
  if (options2?.keepAlive)
    url4.searchParams.set("keep_alive", options2.keepAlive.toString());
  return url4.toString();
}
__name(endpointURLString, "endpointURLString");
async function createBrowser(transport, options2) {
  return await transportZone.run(transport, async () => {
    const url4 = new URL(WS_FAKE_HOST);
    if (options2?.persistent)
      url4.searchParams.set("persistent", "true");
    const browser3 = await originalConnectOverCDP.call(playwright.chromium, url4.toString(), {});
    browser3.sessionId = () => transport.sessionId;
    return browser3;
  });
}
__name(createBrowser, "createBrowser");
function getBrowserBinding(endpoint) {
  if (typeof endpoint === "string" || endpoint instanceof URL) {
    const url4 = endpoint instanceof URL ? endpoint : new URL(endpoint);
    const binding3 = url4.searchParams.get("browser_binding");
    if (!binding3 || !(binding3 in env2))
      throw new Error(`No binding found for ${binding3}`);
    return env2[binding3];
  }
  return endpoint;
}
__name(getBrowserBinding, "getBrowserBinding");
async function connect(endpoint, sessionIdOrOptions) {
  const extraOptions = typeof sessionIdOrOptions === "string" ? { sessionId: sessionIdOrOptions } : sessionIdOrOptions ?? {};
  const options2 = { ...extractOptions(endpoint), ...extraOptions };
  if (!options2.sessionId)
    throw new Error(`Session ID is required for connect()`);
  const webSocket = await connectDevtools(getBrowserBinding(endpoint), options2);
  const transport = new WebSocketTransport(webSocket, options2.sessionId);
  return await createBrowser(transport, options2);
}
__name(connect, "connect");
async function launch(endpoint, launchOptions) {
  const { sessionId } = await acquire(endpoint, launchOptions);
  const options2 = { ...extractOptions(endpoint), ...launchOptions, sessionId };
  const webSocket = await connectDevtools(getBrowserBinding(endpoint), options2);
  const transport = new WebSocketTransport(webSocket, sessionId);
  const browser3 = await createBrowser(transport, options2);
  const browserImpl = browser3._connection.toImpl(browser3);
  const doClose = /* @__PURE__ */ __name(async () => {
    const message = { method: "Browser.close", id: kBrowserCloseMessageId, params: {} };
    transport.send(message);
  }, "doClose");
  browserImpl.options.browserProcess = { close: doClose, kill: doClose };
  return browser3;
}
__name(launch, "launch");
async function acquire(endpoint, options2) {
  options2 = { ...extractOptions(endpoint), ...options2 };
  let acquireUrl = `${HTTP_FAKE_HOST}/v1/acquire`;
  if (options2?.keep_alive)
    acquireUrl = `${acquireUrl}?keep_alive=${options2.keep_alive}`;
  const res = await getBrowserBinding(endpoint).fetch(acquireUrl);
  const status = res.status;
  const text = await res.text();
  if (status !== 200) {
    throw new Error(
      `Unable to create new browser: code: ${status}: message: ${text}`
    );
  }
  const response = JSON.parse(text);
  return response;
}
__name(acquire, "acquire");
var chromium = playwright.chromium;
var selectors = playwright.selectors;
var devices = playwright.devices;
var errors = playwright.errors;
var request = playwright.request;
var _instrumentation = playwright._instrumentation;

// src/index.ts
var DEVICE_PRESETS = {
  desktop: {
    viewport: { width: 1920, height: 1080 },
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    isMobile: false,
    hasTouch: false
  },
  "desktop-hd": {
    viewport: { width: 2560, height: 1440 },
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    isMobile: false,
    hasTouch: false
  },
  tablet: {
    viewport: { width: 768, height: 1024 },
    userAgent: "Mozilla/5.0 (iPad; CPU OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    isMobile: true,
    hasTouch: true
  },
  "tablet-landscape": {
    viewport: { width: 1024, height: 768 },
    userAgent: "Mozilla/5.0 (iPad; CPU OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    isMobile: true,
    hasTouch: true
  },
  mobile: {
    viewport: { width: 375, height: 812 },
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    isMobile: true,
    hasTouch: true
  },
  "mobile-android": {
    viewport: { width: 412, height: 915 },
    userAgent: "Mozilla/5.0 (Linux; Android 14; Pixel 8) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36",
    isMobile: true,
    hasTouch: true
  },
  "mobile-landscape": {
    viewport: { width: 812, height: 375 },
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
    isMobile: true,
    hasTouch: true
  }
};
var ActRequestSchema = external_exports.object({
  url: external_exports.string().url(),
  // Can be a natural language instruction OR a deterministic action
  instruction: external_exports.string().optional(),
  action: external_exports.object({
    selector: external_exports.string(),
    description: external_exports.string(),
    method: external_exports.string(),
    arguments: external_exports.array(external_exports.string()).optional().default([])
  }).optional(),
  // Variables for substitution (e.g., %email% -> actual email)
  variables: external_exports.record(external_exports.string()).optional(),
  timeout: external_exports.number().optional().default(3e4),
  device: external_exports.enum(["desktop", "desktop-hd", "tablet", "tablet-landscape", "mobile", "mobile-android", "mobile-landscape"]).optional().default("desktop"),
  viewport: external_exports.object({ width: external_exports.number(), height: external_exports.number() }).optional(),
  // Self-healing: try alternative selectors on failure
  selfHeal: external_exports.boolean().optional().default(true)
});
var ExtractRequestSchema = external_exports.object({
  url: external_exports.string().url(),
  instruction: external_exports.string().optional(),
  // Schema can be a simple object or full Zod-like definition
  schema: external_exports.record(external_exports.union([
    external_exports.string(),
    external_exports.object({
      type: external_exports.string(),
      description: external_exports.string().optional(),
      enum: external_exports.array(external_exports.string()).optional()
    })
  ])).optional(),
  // Selector to scope extraction
  selector: external_exports.string().optional(),
  timeout: external_exports.number().optional().default(3e4),
  device: external_exports.enum(["desktop", "desktop-hd", "tablet", "tablet-landscape", "mobile", "mobile-android", "mobile-landscape"]).optional().default("desktop")
});
var ObserveRequestSchema = external_exports.object({
  url: external_exports.string().url(),
  instruction: external_exports.string().optional().default("Find all interactive elements"),
  // Selector to scope observation
  selector: external_exports.string().optional(),
  timeout: external_exports.number().optional().default(3e4),
  device: external_exports.enum(["desktop", "desktop-hd", "tablet", "tablet-landscape", "mobile", "mobile-android", "mobile-landscape"]).optional().default("desktop")
});
var AgentRequestSchema = external_exports.object({
  url: external_exports.string().url(),
  instruction: external_exports.string(),
  systemPrompt: external_exports.string().optional(),
  maxSteps: external_exports.number().optional().default(20),
  timeout: external_exports.number().optional().default(6e4),
  device: external_exports.enum(["desktop", "desktop-hd", "tablet", "tablet-landscape", "mobile", "mobile-android", "mobile-landscape"]).optional().default("desktop"),
  viewport: external_exports.object({ width: external_exports.number(), height: external_exports.number() }).optional(),
  // Return screenshots at each step
  captureScreenshots: external_exports.boolean().optional().default(false)
});
var TestRequestSchema = external_exports.object({
  url: external_exports.string().url(),
  steps: external_exports.array(external_exports.string()),
  extract: external_exports.record(external_exports.string()).optional(),
  screenshot: external_exports.boolean().optional().default(false),
  timeout: external_exports.number().optional().default(3e4),
  device: external_exports.enum(["desktop", "desktop-hd", "tablet", "tablet-landscape", "mobile", "mobile-android", "mobile-landscape"]).optional().default("desktop"),
  viewport: external_exports.object({ width: external_exports.number(), height: external_exports.number() }).optional(),
  useAI: external_exports.boolean().optional().default(true)
});
var actionCache = /* @__PURE__ */ new Map();
var CACHE_TTL = 5 * 60 * 1e3;
function getCachedSelector(url4, instruction) {
  const key = `${url4}:${instruction}`;
  const cached = actionCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.selector;
  }
  return null;
}
__name(getCachedSelector, "getCachedSelector");
function setCachedSelector(url4, instruction, selector) {
  const key = `${url4}:${instruction}`;
  actionCache.set(key, { selector, timestamp: Date.now() });
}
__name(setCachedSelector, "setCachedSelector");
async function interpretAction(env3, instruction, pageHtml, interactiveElements) {
  try {
    const prompt = `You are a browser automation expert. Given a natural language instruction, determine the exact Playwright action to execute.

INSTRUCTION: "${instruction}"

AVAILABLE ACTIONS:
- click: Click on an element
- fill: Type text into an input field
- type: Type text character by character
- select: Select an option from a dropdown
- check: Check a checkbox
- uncheck: Uncheck a checkbox
- hover: Hover over an element
- scroll: Scroll the page or to an element
- press: Press a keyboard key
- wait: Wait for an element

INTERACTIVE ELEMENTS ON PAGE:
${interactiveElements}

HTML SNIPPET (first 3000 chars):
${pageHtml.substring(0, 3e3)}

RESPOND WITH ONLY A JSON OBJECT:
{
  "action": "click|fill|type|select|check|uncheck|hover|scroll|press|wait",
  "selector": "CSS selector or text selector (e.g., 'text=Submit', 'button.primary', '#email')",
  "value": "value for fill/type/select actions (optional)",
  "description": "human readable description of what this action does"
}`;
    const response = await env3.AI.run("@cf/meta/llama-3.1-8b-instruct", {
      messages: [{ role: "user", content: prompt }],
      max_tokens: 300
    });
    const text = typeof response === "string" ? response : response.response;
    const jsonMatch = text.match(/\{[\s\S]*?\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    return null;
  } catch (e) {
    console.error("AI interpretation failed:", e);
    return null;
  }
}
__name(interpretAction, "interpretAction");
async function extractWithAI(env3, instruction, schema2, pageContent) {
  let prompt;
  if (!instruction && !schema2) {
    return { pageText: pageContent.substring(0, 1e4) };
  }
  if (schema2) {
    const schemaDescription = Object.entries(schema2).map(([key, value]) => {
      if (typeof value === "string") {
        return `- ${key}: ${value}`;
      } else if (typeof value === "object") {
        const desc = value.description ? ` (${value.description})` : "";
        const enumVals = value.enum ? ` [one of: ${value.enum.join(", ")}]` : "";
        return `- ${key}: ${value.type}${desc}${enumVals}`;
      }
      return `- ${key}: unknown`;
    }).join("\n");
    prompt = `Extract structured data from this webpage.

${instruction ? `INSTRUCTION: ${instruction}` : ""}

REQUIRED OUTPUT SCHEMA:
${schemaDescription}

PAGE CONTENT:
${pageContent.substring(0, 6e3)}

RESPOND WITH ONLY A VALID JSON OBJECT matching the schema exactly. No explanation.`;
  } else {
    prompt = `${instruction}

PAGE CONTENT:
${pageContent.substring(0, 6e3)}

RESPOND WITH ONLY A VALID JSON OBJECT containing the extracted data. No explanation.`;
  }
  const response = await env3.AI.run("@cf/meta/llama-3.1-8b-instruct", {
    messages: [{ role: "user", content: prompt }],
    max_tokens: 1e3
  });
  const text = typeof response === "string" ? response : response.response;
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      return JSON.parse(jsonMatch[0]);
    } catch {
      return { extraction: text, raw: true };
    }
  }
  return { extraction: text };
}
__name(extractWithAI, "extractWithAI");
async function observeWithAI(env3, instruction, elements) {
  const elementsJson = JSON.stringify(elements.slice(0, 50), null, 2);
  const prompt = `You are analyzing a webpage to find interactive elements that match this instruction: "${instruction}"

INTERACTIVE ELEMENTS FOUND:
${elementsJson}

For each relevant element, provide an action object. Return a JSON array of actions:
[
  {
    "selector": "CSS or XPath selector to locate the element",
    "description": "Human-readable description of what this element does",
    "method": "suggested method (click, fill, select, etc.)",
    "arguments": ["any required arguments like text to type"]
  }
]

RESPOND WITH ONLY THE JSON ARRAY. Order by relevance to the instruction.`;
  const response = await env3.AI.run("@cf/meta/llama-3.1-8b-instruct", {
    messages: [{ role: "user", content: prompt }],
    max_tokens: 1500
  });
  const text = typeof response === "string" ? response : response.response;
  const jsonMatch = text.match(/\[[\s\S]*\]/);
  if (jsonMatch) {
    try {
      return JSON.parse(jsonMatch[0]);
    } catch {
      return [];
    }
  }
  return [];
}
__name(observeWithAI, "observeWithAI");
async function planNextStep(env3, goal, systemPrompt, currentUrl, pageContent, history, interactiveElements) {
  const historyText = history.length > 0 ? history.map((a, i) => `${i + 1}. ${a.description}`).join("\n") : "No actions taken yet";
  const prompt = `${systemPrompt || "You are an AI browser automation agent. Complete the given task by taking appropriate actions."}

GOAL: ${goal}

CURRENT URL: ${currentUrl}

ACTIONS TAKEN SO FAR:
${historyText}

INTERACTIVE ELEMENTS ON CURRENT PAGE:
${interactiveElements}

PAGE CONTENT (excerpt):
${pageContent.substring(0, 2e3)}

DECIDE THE NEXT ACTION:
1. If the goal is COMPLETE, respond with: {"completed": true, "message": "explanation of completion"}
2. If more actions needed, respond with:
{
  "completed": false,
  "action": {
    "selector": "CSS selector for the element",
    "description": "what this action does",
    "method": "click|fill|type|select|scroll|press",
    "arguments": ["any values needed"]
  },
  "message": "why this action is needed"
}

RESPOND WITH ONLY THE JSON OBJECT.`;
  const response = await env3.AI.run("@cf/meta/llama-3.1-8b-instruct", {
    messages: [{ role: "user", content: prompt }],
    max_tokens: 500
  });
  const text = typeof response === "string" ? response : response.response;
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      const result = JSON.parse(jsonMatch[0]);
      return {
        action: result.action || null,
        completed: result.completed || false,
        message: result.message || ""
      };
    } catch {
      return { action: null, completed: false, message: "Failed to parse AI response" };
    }
  }
  return { action: null, completed: false, message: "No valid response from AI" };
}
__name(planNextStep, "planNextStep");
async function getInteractiveElements(page, scopeSelector) {
  return await page.evaluate((scope) => {
    const root = scope ? document.querySelector(scope) || document : document;
    const elements = [];
    const getSelector = /* @__PURE__ */ __name((el) => {
      if (el.id) return `#${el.id}`;
      if (el.className && typeof el.className === "string") {
        const classes = el.className.trim().split(/\s+/).slice(0, 2).join(".");
        if (classes) return `${el.tagName.toLowerCase()}.${classes}`;
      }
      return el.tagName.toLowerCase();
    }, "getSelector");
    const getAttributes = /* @__PURE__ */ __name((el) => {
      const attrs = {};
      ["href", "type", "name", "placeholder", "aria-label", "role", "value"].forEach((attr) => {
        const val = el.getAttribute(attr);
        if (val) attrs[attr] = val;
      });
      return attrs;
    }, "getAttributes");
    root.querySelectorAll("button").forEach((el) => {
      elements.push({
        tag: "button",
        text: el.textContent?.trim().substring(0, 100) || "",
        selector: getSelector(el),
        attributes: getAttributes(el)
      });
    });
    root.querySelectorAll("a[href]").forEach((el) => {
      elements.push({
        tag: "a",
        text: el.textContent?.trim().substring(0, 100) || "",
        selector: getSelector(el),
        attributes: getAttributes(el)
      });
    });
    root.querySelectorAll('input:not([type="hidden"])').forEach((el) => {
      elements.push({
        tag: "input",
        text: el.placeholder || el.name || "",
        selector: getSelector(el),
        attributes: getAttributes(el)
      });
    });
    root.querySelectorAll("textarea").forEach((el) => {
      elements.push({
        tag: "textarea",
        text: el.placeholder || el.name || "",
        selector: getSelector(el),
        attributes: getAttributes(el)
      });
    });
    root.querySelectorAll("select").forEach((el) => {
      elements.push({
        tag: "select",
        text: el.name || "",
        selector: getSelector(el),
        attributes: getAttributes(el)
      });
    });
    root.querySelectorAll('[role="button"], [onclick], [tabindex="0"]').forEach((el) => {
      if (!["BUTTON", "A", "INPUT"].includes(el.tagName)) {
        elements.push({
          tag: el.tagName.toLowerCase(),
          text: el.textContent?.trim().substring(0, 100) || "",
          selector: getSelector(el),
          attributes: getAttributes(el)
        });
      }
    });
    return elements.slice(0, 100);
  }, scopeSelector);
}
__name(getInteractiveElements, "getInteractiveElements");
async function executePlaywrightAction(page, action, timeout, selfHeal = true) {
  const selectors2 = [action.selector];
  if (selfHeal) {
    const text = action.selector.match(/text=(.+)/)?.[1];
    if (text) {
      selectors2.push(`button:has-text("${text}")`);
      selectors2.push(`a:has-text("${text}")`);
      selectors2.push(`[aria-label*="${text}"]`);
      selectors2.push(`*:has-text("${text}")`);
    }
  }
  for (let i = 0; i < selectors2.length; i++) {
    const selector = selectors2[i];
    try {
      switch (action.action) {
        case "click":
          await page.click(selector, { timeout });
          break;
        case "fill":
          await page.fill(selector, action.value || action.arguments?.[0] || "", { timeout });
          break;
        case "type":
          await page.type(selector, action.value || action.arguments?.[0] || "", { timeout });
          break;
        case "select":
          await page.selectOption(selector, action.value || action.arguments?.[0] || "", { timeout });
          break;
        case "check":
          await page.check(selector, { timeout });
          break;
        case "uncheck":
          await page.uncheck(selector, { timeout });
          break;
        case "hover":
          await page.hover(selector, { timeout });
          break;
        case "scroll":
          if (selector === "down" || selector === "bottom") {
            await page.evaluate(() => window.scrollBy(0, 500));
          } else if (selector === "up" || selector === "top") {
            await page.evaluate(() => window.scrollBy(0, -500));
          } else {
            await page.locator(selector).scrollIntoViewIfNeeded({ timeout });
          }
          break;
        case "press":
          await page.keyboard.press(action.value || action.arguments?.[0] || "Enter");
          break;
        case "wait":
          if (selector.match(/^\d+$/)) {
            await page.waitForTimeout(parseInt(selector));
          } else {
            await page.waitForSelector(selector, { timeout });
          }
          break;
        default:
          throw new Error(`Unknown action: ${action.action}`);
      }
      return { success: true, healed: i > 0, finalSelector: selector };
    } catch (e) {
      if (i === selectors2.length - 1) {
        return {
          success: false,
          healed: false,
          finalSelector: action.selector,
          error: e instanceof Error ? e.message : "Unknown error"
        };
      }
      console.log(`Selector failed, trying alternative: ${selectors2[i + 1]}`);
    }
  }
  return { success: false, healed: false, finalSelector: action.selector, error: "All selectors failed" };
}
__name(executePlaywrightAction, "executePlaywrightAction");
function substituteVariables(instruction, variables) {
  if (!variables) return instruction;
  let result = instruction;
  for (const [key, value] of Object.entries(variables)) {
    result = result.replace(new RegExp(`%${key}%`, "g"), value);
  }
  return result;
}
__name(substituteVariables, "substituteVariables");
function authenticate(request2, env3) {
  if (!env3.API_TOKEN) return true;
  const authHeader = request2.headers.get("Authorization");
  if (!authHeader) return false;
  const token = authHeader.replace("Bearer ", "");
  return token === env3.API_TOKEN;
}
__name(authenticate, "authenticate");
async function handleAct(request2, env3, corsHeaders) {
  const body = await request2.json();
  const parsed = ActRequestSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json(
      { error: "Invalid request", details: parsed.error.message },
      { status: 400, headers: corsHeaders }
    );
  }
  const { url: url4, instruction, action, variables, timeout, device, viewport, selfHeal } = parsed.data;
  if (!instruction && !action) {
    return Response.json(
      { error: "Invalid request", details: "Either 'instruction' or 'action' is required" },
      { status: 400, headers: corsHeaders }
    );
  }
  let browser3;
  try {
    const cdpUrl = endpointURLString(env3.BROWSER);
    browser3 = await chromium.connectOverCDP(cdpUrl);
    const deviceSettings = DEVICE_PRESETS[device] || DEVICE_PRESETS.desktop;
    const finalViewport = viewport || deviceSettings.viewport;
    const context2 = await browser3.newContext({
      viewport: finalViewport,
      userAgent: deviceSettings.userAgent,
      isMobile: deviceSettings.isMobile,
      hasTouch: deviceSettings.hasTouch
    });
    const page = await context2.newPage();
    await page.goto(url4, { waitUntil: "domcontentloaded", timeout });
    let actionToExecute;
    const executedActions = [];
    if (action) {
      actionToExecute = {
        action: action.method,
        selector: action.selector,
        value: action.arguments?.[0],
        description: action.description
      };
    } else {
      const processedInstruction = substituteVariables(instruction, variables);
      const cachedSelector = getCachedSelector(url4, processedInstruction);
      if (cachedSelector) {
        actionToExecute = {
          action: "click",
          // Default to click for cached
          selector: cachedSelector,
          description: processedInstruction
        };
      } else {
        const pageHtml = await page.content();
        const elements = await getInteractiveElements(page);
        const elementsStr = elements.map((e) => `${e.tag}: "${e.text}" [${e.selector}]`).join("\n");
        const interpreted = await interpretAction(env3, processedInstruction, pageHtml, elementsStr);
        if (!interpreted) {
          await browser3.close();
          return Response.json({
            success: false,
            message: "Failed to interpret instruction",
            actionDescription: processedInstruction,
            actions: []
          }, { headers: corsHeaders });
        }
        actionToExecute = interpreted;
        setCachedSelector(url4, processedInstruction, interpreted.selector);
      }
    }
    const result = await executePlaywrightAction(
      page,
      actionToExecute,
      Math.min(timeout, 1e4),
      selfHeal
    );
    executedActions.push({
      selector: result.finalSelector,
      description: actionToExecute.description,
      method: actionToExecute.action,
      arguments: actionToExecute.value ? [actionToExecute.value] : []
    });
    await browser3.close();
    return Response.json({
      success: result.success,
      message: result.success ? `Successfully executed: ${actionToExecute.description}` : `Failed: ${result.error}`,
      actionDescription: actionToExecute.description,
      actions: executedActions,
      healed: result.healed
    }, { headers: corsHeaders });
  } catch (error3) {
    console.error("Act failed:", error3);
    if (browser3) await browser3.close().catch(() => {
    });
    return Response.json({
      success: false,
      message: error3 instanceof Error ? error3.message : "Unknown error",
      actionDescription: instruction || action?.description || "",
      actions: []
    }, { status: 500, headers: corsHeaders });
  }
}
__name(handleAct, "handleAct");
async function handleExtract(request2, env3, corsHeaders) {
  const body = await request2.json();
  const parsed = ExtractRequestSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json(
      { error: "Invalid request", details: parsed.error.message },
      { status: 400, headers: corsHeaders }
    );
  }
  const { url: url4, instruction, schema: schema2, selector, timeout, device } = parsed.data;
  let browser3;
  try {
    const cdpUrl = endpointURLString(env3.BROWSER);
    browser3 = await chromium.connectOverCDP(cdpUrl);
    const deviceSettings = DEVICE_PRESETS[device] || DEVICE_PRESETS.desktop;
    const context2 = await browser3.newContext({
      viewport: deviceSettings.viewport,
      userAgent: deviceSettings.userAgent,
      isMobile: deviceSettings.isMobile,
      hasTouch: deviceSettings.hasTouch
    });
    const page = await context2.newPage();
    await page.goto(url4, { waitUntil: "domcontentloaded", timeout });
    let pageContent;
    if (selector) {
      try {
        pageContent = await page.locator(selector).innerText({ timeout: 5e3 });
      } catch {
        pageContent = await page.evaluate(() => document.body.innerText);
      }
    } else {
      pageContent = await page.evaluate(() => document.body.innerText);
    }
    const data = await extractWithAI(env3, instruction, schema2, pageContent);
    await browser3.close();
    if (!instruction && !schema2) {
      return Response.json({ pageText: data.pageText }, { headers: corsHeaders });
    } else if (schema2) {
      return Response.json(data, { headers: corsHeaders });
    } else {
      return Response.json({ extraction: data.extraction || JSON.stringify(data) }, { headers: corsHeaders });
    }
  } catch (error3) {
    console.error("Extract failed:", error3);
    if (browser3) await browser3.close().catch(() => {
    });
    return Response.json(
      { error: "Extract failed", details: error3 instanceof Error ? error3.message : "Unknown error" },
      { status: 500, headers: corsHeaders }
    );
  }
}
__name(handleExtract, "handleExtract");
async function handleObserve(request2, env3, corsHeaders) {
  const body = await request2.json();
  const parsed = ObserveRequestSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json(
      { error: "Invalid request", details: parsed.error.message },
      { status: 400, headers: corsHeaders }
    );
  }
  const { url: url4, instruction, selector, timeout, device } = parsed.data;
  let browser3;
  try {
    const cdpUrl = endpointURLString(env3.BROWSER);
    browser3 = await chromium.connectOverCDP(cdpUrl);
    const deviceSettings = DEVICE_PRESETS[device] || DEVICE_PRESETS.desktop;
    const context2 = await browser3.newContext({
      viewport: deviceSettings.viewport,
      userAgent: deviceSettings.userAgent,
      isMobile: deviceSettings.isMobile,
      hasTouch: deviceSettings.hasTouch
    });
    const page = await context2.newPage();
    await page.goto(url4, { waitUntil: "domcontentloaded", timeout });
    const elements = await getInteractiveElements(page, selector);
    const actions = await observeWithAI(env3, instruction, elements);
    await browser3.close();
    return Response.json(actions, { headers: corsHeaders });
  } catch (error3) {
    console.error("Observe failed:", error3);
    if (browser3) await browser3.close().catch(() => {
    });
    return Response.json(
      { error: "Observe failed", details: error3 instanceof Error ? error3.message : "Unknown error" },
      { status: 500, headers: corsHeaders }
    );
  }
}
__name(handleObserve, "handleObserve");
async function handleAgent(request2, env3, corsHeaders) {
  const body = await request2.json();
  const parsed = AgentRequestSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json(
      { error: "Invalid request", details: parsed.error.message },
      { status: 400, headers: corsHeaders }
    );
  }
  const { url: url4, instruction, systemPrompt, maxSteps, timeout, device, viewport, captureScreenshots } = parsed.data;
  let browser3;
  try {
    const cdpUrl = endpointURLString(env3.BROWSER);
    browser3 = await chromium.connectOverCDP(cdpUrl);
    const deviceSettings = DEVICE_PRESETS[device] || DEVICE_PRESETS.desktop;
    const finalViewport = viewport || deviceSettings.viewport;
    const context2 = await browser3.newContext({
      viewport: finalViewport,
      userAgent: deviceSettings.userAgent,
      isMobile: deviceSettings.isMobile,
      hasTouch: deviceSettings.hasTouch
    });
    const page = await context2.newPage();
    await page.goto(url4, { waitUntil: "domcontentloaded", timeout });
    const history = [];
    const screenshots = [];
    let completed = false;
    let finalMessage = "";
    let totalInputTokens = 0;
    let totalOutputTokens = 0;
    for (let step = 0; step < maxSteps && !completed; step++) {
      console.log(`Agent step ${step + 1}/${maxSteps}`);
      const currentUrl = page.url();
      const pageContent = await page.evaluate(() => document.body.innerText);
      const elements = await getInteractiveElements(page);
      const elementsStr = elements.map((e) => `${e.tag}: "${e.text}" [${e.selector}]`).join("\n");
      if (captureScreenshots) {
        try {
          const buffer = await page.screenshot({ type: "png", fullPage: false });
          screenshots.push(Buffer.from(buffer).toString("base64"));
        } catch (e) {
          console.error("Screenshot failed:", e);
        }
      }
      const plan = await planNextStep(
        env3,
        instruction,
        systemPrompt,
        currentUrl,
        pageContent,
        history,
        elementsStr
      );
      totalInputTokens += Math.floor((pageContent.length + elementsStr.length) / 4);
      totalOutputTokens += 100;
      if (plan.completed) {
        completed = true;
        finalMessage = plan.message;
        break;
      }
      if (!plan.action) {
        finalMessage = "Agent could not determine next action";
        break;
      }
      const result = await executePlaywrightAction(
        page,
        {
          action: plan.action.method || "click",
          selector: plan.action.selector,
          value: plan.action.arguments?.[0]
        },
        5e3,
        true
      );
      history.push({
        ...plan.action,
        selector: result.finalSelector
      });
      if (!result.success) {
        finalMessage = `Action failed: ${result.error}`;
        break;
      }
      await page.waitForTimeout(500);
    }
    await browser3.close();
    const agentResult = {
      success: completed,
      message: finalMessage || (completed ? "Task completed successfully" : "Max steps reached"),
      actions: history,
      completed,
      usage: {
        inputTokens: totalInputTokens,
        outputTokens: totalOutputTokens,
        totalSteps: history.length
      }
    };
    if (captureScreenshots && screenshots.length > 0) {
      agentResult.screenshots = screenshots;
    }
    return Response.json(agentResult, { headers: corsHeaders });
  } catch (error3) {
    console.error("Agent failed:", error3);
    if (browser3) await browser3.close().catch(() => {
    });
    return Response.json({
      success: false,
      message: error3 instanceof Error ? error3.message : "Unknown error",
      actions: [],
      completed: false,
      usage: { inputTokens: 0, outputTokens: 0, totalSteps: 0 }
    }, { status: 500, headers: corsHeaders });
  }
}
__name(handleAgent, "handleAgent");
async function handleTest(request2, env3, corsHeaders) {
  const body = await request2.json();
  const parsed = TestRequestSchema.safeParse(body);
  if (!parsed.success) {
    return Response.json(
      { error: "Invalid request", details: parsed.error.message },
      { status: 400, headers: corsHeaders }
    );
  }
  const { url: url4, steps, screenshot, timeout, device, viewport, useAI } = parsed.data;
  const startTime = Date.now();
  let browser3;
  try {
    const cdpUrl = endpointURLString(env3.BROWSER);
    browser3 = await chromium.connectOverCDP(cdpUrl);
    const deviceSettings = DEVICE_PRESETS[device] || DEVICE_PRESETS.desktop;
    const finalViewport = viewport || deviceSettings.viewport;
    const context2 = await browser3.newContext({
      viewport: finalViewport,
      userAgent: deviceSettings.userAgent,
      isMobile: deviceSettings.isMobile,
      hasTouch: deviceSettings.hasTouch
    });
    const page = await context2.newPage();
    await page.goto(url4, { waitUntil: "domcontentloaded", timeout });
    const stepResults = [];
    let cachedCount = 0;
    let healedCount = 0;
    for (const step of steps) {
      try {
        const pageHtml = await page.content();
        const elements = await getInteractiveElements(page);
        const elementsStr = elements.map((e) => `${e.tag}: "${e.text}" [${e.selector}]`).join("\n");
        const cachedSelector = getCachedSelector(url4, step);
        let actionToExecute;
        let wasCached = false;
        if (cachedSelector) {
          actionToExecute = { action: "click", selector: cachedSelector };
          wasCached = true;
        } else if (useAI) {
          const interpreted = await interpretAction(env3, step, pageHtml, elementsStr);
          if (!interpreted) {
            throw new Error("AI could not interpret the instruction");
          }
          actionToExecute = interpreted;
          setCachedSelector(url4, step, interpreted.selector);
        } else {
          actionToExecute = { action: "click", selector: `text=${step}` };
        }
        const result = await executePlaywrightAction(page, actionToExecute, 5e3, true);
        if (wasCached) cachedCount++;
        if (result.healed) healedCount++;
        stepResults.push({
          instruction: step,
          success: result.success,
          cached: wasCached,
          healed: result.healed,
          error: result.success ? void 0 : result.error
        });
        if (!result.success) break;
      } catch (error3) {
        stepResults.push({
          instruction: step,
          success: false,
          error: error3 instanceof Error ? error3.message : "Unknown error"
        });
        break;
      }
    }
    let screenshotBase64;
    if (screenshot) {
      try {
        const buffer = await page.screenshot({ type: "png", fullPage: false });
        screenshotBase64 = Buffer.from(buffer).toString("base64");
      } catch (e) {
        console.error("Screenshot failed:", e);
      }
    }
    await browser3.close();
    return Response.json({
      success: stepResults.every((s) => s.success),
      steps: stepResults,
      screenshot: screenshotBase64,
      device,
      viewport: finalViewport,
      stats: {
        totalDuration: Date.now() - startTime,
        cachedActions: cachedCount,
        healedActions: healedCount
      }
    }, { headers: corsHeaders });
  } catch (error3) {
    console.error("Test failed:", error3);
    if (browser3) await browser3.close().catch(() => {
    });
    return Response.json(
      { error: "Test failed", details: error3 instanceof Error ? error3.message : "Unknown error" },
      { status: 500, headers: corsHeaders }
    );
  }
}
__name(handleTest, "handleTest");
var src_default = {
  async fetch(request2, env3) {
    const url4 = new URL(request2.url);
    const path30 = url4.pathname;
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    };
    if (request2.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders });
    }
    if (path30 === "/health" && request2.method === "GET") {
      return Response.json({
        status: "healthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        features: ["act", "extract", "observe", "agent", "test"],
        devices: Object.keys(DEVICE_PRESETS)
      }, { headers: corsHeaders });
    }
    if (path30 === "/" && request2.method === "GET") {
      return Response.json({
        name: "E2E Testing Agent API",
        version: "2.0.0",
        description: "Stagehand-compatible browser automation API",
        endpoints: {
          "POST /act": "Execute a single browser action",
          "POST /extract": "Extract structured data from a page",
          "POST /observe": "Discover available actions on a page",
          "POST /agent": "Run autonomous multi-step workflow",
          "POST /test": "Run a test with multiple steps (legacy)",
          "GET /health": "Health check"
        },
        devices: Object.keys(DEVICE_PRESETS)
      }, { headers: corsHeaders });
    }
    if (path30 === "/debug/browser" && request2.method === "GET") {
      try {
        const cdpUrl = endpointURLString(env3.BROWSER);
        return Response.json({ success: true, cdpUrl }, { headers: corsHeaders });
      } catch (e) {
        return Response.json(
          { success: false, error: e instanceof Error ? e.message : "Unknown" },
          { status: 500, headers: corsHeaders }
        );
      }
    }
    if (!authenticate(request2, env3)) {
      return Response.json(
        { error: "Unauthorized" },
        { status: 401, headers: corsHeaders }
      );
    }
    try {
      switch (path30) {
        case "/act":
          if (request2.method === "POST") return await handleAct(request2, env3, corsHeaders);
          break;
        case "/extract":
          if (request2.method === "POST") return await handleExtract(request2, env3, corsHeaders);
          break;
        case "/observe":
          if (request2.method === "POST") return await handleObserve(request2, env3, corsHeaders);
          break;
        case "/agent":
          if (request2.method === "POST") return await handleAgent(request2, env3, corsHeaders);
          break;
        case "/test":
          if (request2.method === "POST") return await handleTest(request2, env3, corsHeaders);
          break;
      }
      return Response.json(
        { error: "Not found", details: `Unknown endpoint: ${path30}` },
        { status: 404, headers: corsHeaders }
      );
    } catch (error3) {
      console.error("Request failed:", error3);
      return Response.json(
        { error: "Internal server error", details: error3 instanceof Error ? error3.message : "Unknown" },
        { status: 500, headers: corsHeaders }
      );
    }
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request2, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env3);
  } finally {
    try {
      if (request2.body !== null && !request2.bodyUsed) {
        const reader = request2.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// .wrangler/tmp/bundle-rpkAQp/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default
];
var middleware_insertion_facade_default = src_default;

// node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request2, env3, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request2, env3, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request2, env3, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request2, env3, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-rpkAQp/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request2, env3, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request2, env3, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request2, env3, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env3, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request2, env3, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request2, env3, ctx) => {
      this.env = env3;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request2);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request2) {
      return __facade_invoke__(
        request2,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

@cloudflare/playwright/lib/bundles/utilsBundleImpl.js:
  (*!
   * node-progress
   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
   * MIT Licensed
   *)

@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiProtocolPermissions.js:
@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiDeserializer.js:
@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiSerializer.js:
@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/bidiKeyboard.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * Modifications copyright (c) Microsoft Corporation.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/playwright/lib/packages/playwright-core/src/server/bidi/third_party/firefoxPrefs.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=index.js.map
