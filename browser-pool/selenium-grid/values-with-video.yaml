# Selenium Grid 4 - Configuration with Video Recording to Cloudflare R2
# Deploy with: helm upgrade --install selenium-grid selenium/selenium-grid -f values-with-video.yaml -n selenium-grid --create-namespace
#
# IMPORTANT: This configuration enables video recording with automatic upload to Cloudflare R2
# Requires:
#   1. r2-credentials Secret with access_key_id and secret_access_key
#   2. r2-config ConfigMap with account_id and bucket
#
# Apply secrets first:
#   kubectl apply -f ../kubernetes/r2-video-config.yaml -n selenium-grid

global:
  seleniumGrid:
    imageTag: "4.27.0"
    logLevel: "INFO"
    # Session timeout - auto-cleanup stuck sessions after 60 seconds
    sessionTimeout: 60

# ============================================================================
# VIDEO RECORDER - Global settings for all browser nodes
# Uses rclone for S3-compatible upload to Cloudflare R2
# ============================================================================
videoRecorder:
  # Enable video recording for all browser sessions
  enabled: true
  # Run video recorder as sidecar container (separate from browser)
  sidecarContainer: true
  # Video storage directory inside container
  targetFolder: "/videos"
  # Resource limits for video recorder container
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"
  # Terminate gracefully to allow final upload
  terminationGracePeriodSeconds: 60

  # Video uploader configuration using rclone
  uploader:
    enabled: true
    # rclone destination: remotename://bucket/path
    # The remote name "R2" (uppercase) matches RCLONE_CONFIG_R2_* env vars
    destinationPrefix: "R2://argus-artifacts/videos"
    # Pull secrets from our r2-credentials Kubernetes secret
    extraEnvFrom:
      - secretRef:
          name: r2-uploader-rclone-config

# ============================================================================
# HUB - Central Selenium Grid hub
# ============================================================================
hub:
  enabled: true
  replicas: 1
  serviceType: LoadBalancer
  annotations:
    service.beta.kubernetes.io/vultr-loadbalancer-protocol: "tcp"
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

# Disable distributed components (using hub instead)
components:
  router:
    enabled: false
  distributor:
    enabled: false
  sessionMap:
    enabled: false
  sessionQueue:
    enabled: false
  eventBus:
    enabled: false

# ============================================================================
# CHROME NODES
# ============================================================================
chromeNode:
  enabled: true
  replicas: 2
  maxSessions: 2
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "1.5Gi"
      cpu: "750m"

# ============================================================================
# FIREFOX NODES
# ============================================================================
firefoxNode:
  enabled: true
  replicas: 1
  maxSessions: 1
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

# ============================================================================
# EDGE NODES
# ============================================================================
edgeNode:
  enabled: true
  replicas: 1
  maxSessions: 1
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "1.5Gi"
      cpu: "750m"

# Ingress disabled - using LoadBalancer directly
ingress:
  enabled: false

# Disable monitoring stack to save resources (use external Prometheus)
prometheus:
  enabled: false

grafana:
  enabled: false

# Basic auth disabled for now
basicAuth:
  enabled: false

# Tracing disabled
tracing:
  enabled: false
