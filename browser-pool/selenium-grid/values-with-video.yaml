# Selenium Grid 4 - Configuration with Video Recording to Cloudflare R2
# Deploy with: helm upgrade --install selenium-grid selenium/selenium-grid -f values-with-video.yaml -n selenium-grid --create-namespace
#
# IMPORTANT: This configuration enables video recording with automatic upload to Cloudflare R2
# Requires:
#   1. r2-credentials Secret with access_key_id and secret_access_key
#   2. r2-config ConfigMap with account_id and bucket
#
# Apply secrets first:
#   kubectl apply -f ../kubernetes/r2-video-config.yaml -n selenium-grid

global:
  seleniumGrid:
    imageTag: "4.27.0"
    logLevel: "INFO"
    # Session timeout at HUB level - auto-cleanup stuck sessions (seconds)
    # Note: Node-level nodeSessionTimeout also set per-node for defense in depth
    sessionTimeout: 120
    # Request timeout - how long session queue waits before failing request (seconds)
    sessionRequestTimeout: 60
    # Retry interval for session requests (seconds)
    sessionRetryInterval: 5

# ============================================================================
# VIDEO RECORDER - Global settings for all browser nodes
# Uses rclone for S3-compatible upload to Cloudflare R2
#
# Architecture:
# 1. Video recorder sidecar captures screen during session
# 2. When session ends, video is saved as {session_id}.mp4
# 3. Uploader copies video to R2: R2://argus-artifacts/videos/{session_id}.mp4
# 4. Python backend constructs URL: /artifacts/video/{session_id}
# ============================================================================
videoRecorder:
  # Enable video recording for all browser sessions
  enabled: true
  # Run video recorder as sidecar container (separate from browser)
  sidecarContainer: true
  # Video storage directory inside container
  targetFolder: "/videos"

  # CRITICAL: These env vars enable upload functionality
  # SE_VIDEO_FILE_NAME=auto uses session ID as filename
  extraEnvs:
    - name: SE_VIDEO_UPLOAD_ENABLED
      value: "true"
    - name: SE_VIDEO_FILE_NAME
      value: "auto"

  # Resource limits for video recorder container
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"
  # Terminate gracefully to allow final upload
  terminationGracePeriodSeconds: 60

  # Video uploader configuration using rclone
  uploader:
    enabled: true
    # rclone destination: remotename://bucket/path
    # The remote name "R2" (uppercase) matches RCLONE_CONFIG_R2_* env vars
    destinationPrefix: "R2://argus-artifacts/videos"
    # Pull secrets from our r2-credentials Kubernetes secret
    extraEnvFrom:
      - secretRef:
          name: r2-uploader-rclone-config

# ============================================================================
# HUB - Central Selenium Grid hub
# ============================================================================
hub:
  enabled: true
  replicas: 1
  serviceType: LoadBalancer
  annotations:
    service.beta.kubernetes.io/vultr-loadbalancer-protocol: "tcp"
  # Hub-level timeout settings (seconds)
  sessionRequestTimeout: 60
  sessionRetryInterval: 5
  newSessionThreadPoolSize: 4
  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

# Disable distributed components (using hub instead)
components:
  router:
    enabled: false
  distributor:
    enabled: false
  sessionMap:
    enabled: false
  sessionQueue:
    enabled: false
  eventBus:
    enabled: false

# ============================================================================
# CHROME NODES
# ============================================================================
# Key settings for preventing zombie sessions:
# - nodeDrainAfterSessionCount: Pod restarts after N sessions (built-in Helm value)
# - nodeSessionTimeout: Session timeout at node level
# - nodeMaxSessions=1: One session per pod for clean state and video
# Reference: https://github.com/SeleniumHQ/docker-selenium/discussions/2512
chromeNode:
  enabled: true
  replicas: 2
  # One session per pod - ensures clean state for each test + proper video recording
  nodeMaxSessions: 1
  # CRITICAL: Drain node after each session - prevents zombie sessions
  # Pod restarts after N sessions, ensuring clean state
  # Set to 1 for video recording (one video per pod lifecycle)
  nodeDrainAfterSessionCount: 1
  # Session timeout at NODE level (seconds) - cleanup if session goes stale
  nodeSessionTimeout: 120
  # Browser timeout - how long to wait for browser to respond
  browserTimeout: 60
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "1.5Gi"
      cpu: "750m"

# ============================================================================
# FIREFOX NODES
# ============================================================================
firefoxNode:
  enabled: true
  replicas: 1
  nodeMaxSessions: 1
  nodeDrainAfterSessionCount: 1
  nodeSessionTimeout: 120
  browserTimeout: 60
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

# ============================================================================
# EDGE NODES
# ============================================================================
edgeNode:
  enabled: true
  replicas: 1
  nodeMaxSessions: 1
  nodeDrainAfterSessionCount: 1
  nodeSessionTimeout: 120
  browserTimeout: 60
  resources:
    requests:
      memory: "768Mi"
      cpu: "300m"
    limits:
      memory: "1.5Gi"
      cpu: "750m"

# Ingress disabled - using LoadBalancer directly
ingress:
  enabled: false

# Disable monitoring stack to save resources (use external Prometheus)
prometheus:
  enabled: false

grafana:
  enabled: false

# Basic auth disabled for now
basicAuth:
  enabled: false

# Tracing disabled
tracing:
  enabled: false
