# Browser Worker Code ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: browser-worker-code
  namespace: browser-pool
data:
  package.json: |
    {
      "name": "browser-worker",
      "version": "1.0.0",
      "main": "server.js",
      "dependencies": {
        "playwright": "^1.57.0",
        "express": "^4.18.2",
        "prom-client": "^15.1.0",
        "uuid": "^9.0.0"
      }
    }

  server.js: |
    const express = require('express');
    const { chromium } = require('playwright');
    const { v4: uuidv4 } = require('uuid');
    const promClient = require('prom-client');

    const app = express();
    app.use(express.json({ limit: '50mb' }));

    const PORT = process.env.PORT || 3000;
    const METRICS_PORT = process.env.METRICS_PORT || 9090;
    const POOL_SIZE = parseInt(process.env.BROWSER_POOL_SIZE || '2');
    const SESSION_TIMEOUT = parseInt(process.env.SESSION_TIMEOUT_MS || '300000');

    // Prometheus metrics
    const register = new promClient.Registry();
    promClient.collectDefaultMetrics({ register });

    const sessionCounter = new promClient.Counter({
      name: 'browser_sessions_total',
      help: 'Total browser sessions created',
      registers: [register]
    });

    const activeGauge = new promClient.Gauge({
      name: 'browser_sessions_active',
      help: 'Currently active browser sessions',
      registers: [register]
    });

    const actionDuration = new promClient.Histogram({
      name: 'browser_action_duration_seconds',
      help: 'Browser action duration',
      buckets: [0.1, 0.5, 1, 2, 5, 10, 30],
      registers: [register]
    });

    // Browser pool
    let browserPool = [];
    const sessions = new Map();

    // Initialize browser pool
    async function initPool() {
      console.log(`Initializing browser pool with ${POOL_SIZE} browsers...`);
      for (let i = 0; i < POOL_SIZE; i++) {
        const browser = await chromium.launch({
          headless: true,
          args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--disable-software-rasterizer'
          ]
        });
        browserPool.push({ browser, inUse: false });
      }
      console.log('Browser pool initialized');
    }

    // Get available browser
    function getBrowser() {
      const available = browserPool.find(b => !b.inUse);
      if (available) {
        available.inUse = true;
        return available.browser;
      }
      return null;
    }

    // Release browser
    function releaseBrowser(browser) {
      const poolEntry = browserPool.find(b => b.browser === browser);
      if (poolEntry) {
        poolEntry.inUse = false;
      }
    }

    // Health check
    app.get('/health', (req, res) => {
      const healthy = browserPool.every(b => b.browser.isConnected());
      res.status(healthy ? 200 : 503).json({
        status: healthy ? 'healthy' : 'unhealthy',
        poolSize: POOL_SIZE,
        activeSessions: sessions.size
      });
    });

    // Readiness check
    app.get('/ready', (req, res) => {
      const available = browserPool.filter(b => !b.inUse).length;
      res.status(available > 0 ? 200 : 503).json({
        ready: available > 0,
        available
      });
    });

    // OBSERVE endpoint (MCP compatible - argus_discover)
    app.post('/observe', async (req, res) => {
      const end = actionDuration.startTimer();
      const { url, instruction } = req.body;

      try {
        const browser = getBrowser();
        if (!browser) {
          return res.status(503).json({ success: false, error: 'No browsers available' });
        }

        const context = await browser.newContext({
          viewport: { width: 1920, height: 1080 },
          userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        });
        const page = await context.newPage();

        await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });

        // Extract interactive elements
        const actions = await page.evaluate(() => {
          const elements = [];
          const selectors = 'a, button, input, select, textarea, [role="button"], [onclick], [type="submit"]';

          document.querySelectorAll(selectors).forEach((el, idx) => {
            const rect = el.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) return;

            let selector = '';
            if (el.id) selector = `#${el.id}`;
            else if (el.getAttribute('data-testid')) selector = `[data-testid="${el.getAttribute('data-testid')}"]`;
            else if (el.name) selector = `[name="${el.name}"]`;
            else selector = `${el.tagName.toLowerCase()}:nth-of-type(${idx + 1})`;

            elements.push({
              selector,
              type: el.tagName.toLowerCase(),
              text: el.textContent?.trim().slice(0, 100) || el.value || '',
              description: el.getAttribute('aria-label') || el.title || el.placeholder || el.textContent?.trim().slice(0, 50) || '',
              confidence: el.id ? 0.95 : el.getAttribute('data-testid') ? 0.9 : 0.7
            });
          });

          return elements;
        });

        await context.close();
        releaseBrowser(browser);
        end();

        res.json({ success: true, actions, url });

      } catch (error) {
        end();
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // ACT endpoint (MCP compatible - argus_act)
    app.post('/act', async (req, res) => {
      const end = actionDuration.startTimer();
      const { url, instruction, selfHeal = true, screenshot = true } = req.body;

      try {
        const browser = getBrowser();
        if (!browser) {
          return res.status(503).json({ success: false, error: 'No browsers available' });
        }

        const context = await browser.newContext({
          viewport: { width: 1920, height: 1080 }
        });
        const page = await context.newPage();

        await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });

        // Parse instruction and execute
        const actions = [];
        const lowerInstruction = instruction.toLowerCase();

        if (lowerInstruction.includes('click')) {
          // Extract target from instruction
          const match = instruction.match(/click\s+(?:on\s+)?(?:the\s+)?["']?([^"']+)["']?/i);
          if (match) {
            const target = match[1].trim();
            // Try multiple selectors
            const selectors = [
              `text="${target}"`,
              `button:has-text("${target}")`,
              `a:has-text("${target}")`,
              `[aria-label="${target}"]`,
              `[title="${target}"]`
            ];

            for (const sel of selectors) {
              try {
                await page.click(sel, { timeout: 5000 });
                actions.push({ action: 'click', selector: sel, success: true });
                break;
              } catch (e) {
                // Try next selector
              }
            }
          }
        } else if (lowerInstruction.includes('type') || lowerInstruction.includes('fill')) {
          const match = instruction.match(/(?:type|fill)\s+["']([^"']+)["']\s+(?:in|into)\s+(?:the\s+)?(.+)/i);
          if (match) {
            const [, value, target] = match;
            await page.fill(`input[placeholder*="${target}" i], input[name*="${target}" i]`, value);
            actions.push({ action: 'fill', value, success: true });
          }
        } else if (lowerInstruction.includes('navigate') || lowerInstruction.includes('go to')) {
          const match = instruction.match(/(?:navigate|go)\s+to\s+(.+)/i);
          if (match) {
            const targetUrl = match[1].startsWith('http') ? match[1] : `${url}${match[1]}`;
            await page.goto(targetUrl);
            actions.push({ action: 'navigate', url: targetUrl, success: true });
          }
        }

        let screenshotData = null;
        if (screenshot) {
          screenshotData = await page.screenshot({ type: 'png', encoding: 'base64' });
        }

        await context.close();
        releaseBrowser(browser);
        end();

        res.json({
          success: actions.length > 0 && actions.every(a => a.success),
          actions,
          message: actions.length > 0 ? 'Action completed' : 'No action matched',
          screenshot: screenshotData
        });

      } catch (error) {
        end();
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // TEST endpoint (multi-step test)
    app.post('/test', async (req, res) => {
      const { url, steps, browser: browserType = 'chrome', captureScreenshots = true } = req.body;

      try {
        const browser = getBrowser();
        if (!browser) {
          return res.status(503).json({ success: false, error: 'No browsers available' });
        }

        const context = await browser.newContext({
          viewport: { width: 1920, height: 1080 }
        });
        const page = await context.newPage();

        await page.goto(url, { waitUntil: 'networkidle' });

        const stepResults = [];
        let allPassed = true;

        for (let i = 0; i < steps.length; i++) {
          const step = steps[i];
          const startTime = Date.now();

          try {
            // Execute step (simplified - real implementation would parse instructions)
            await page.evaluate(() => new Promise(r => setTimeout(r, 100)));

            stepResults.push({
              instruction: step,
              success: true,
              duration: Date.now() - startTime
            });
          } catch (error) {
            allPassed = false;
            stepResults.push({
              instruction: step,
              success: false,
              error: error.message,
              duration: Date.now() - startTime
            });
          }
        }

        let finalScreenshot = null;
        if (captureScreenshots) {
          finalScreenshot = await page.screenshot({ type: 'png', encoding: 'base64' });
        }

        await context.close();
        releaseBrowser(browser);

        res.json({
          success: allPassed,
          steps: stepResults,
          finalScreenshot
        });

      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // Metrics endpoint
    const metricsApp = express();
    metricsApp.get('/metrics', async (req, res) => {
      res.set('Content-Type', register.contentType);
      res.end(await register.metrics());
    });

    // Start servers
    initPool().then(() => {
      app.listen(PORT, () => console.log(`Browser worker on port ${PORT}`));
      metricsApp.listen(METRICS_PORT, () => console.log(`Metrics on port ${METRICS_PORT}`));
    });
---
# Browser Manager Code ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: browser-manager-code
  namespace: browser-pool
data:
  package.json: |
    {
      "name": "browser-manager",
      "version": "1.0.0",
      "main": "manager.js",
      "dependencies": {
        "express": "^4.18.2",
        "axios": "^1.6.0",
        "prom-client": "^15.1.0",
        "@kubernetes/client-node": "^0.20.0"
      }
    }

  manager.js: |
    const express = require('express');
    const axios = require('axios');
    const promClient = require('prom-client');
    const k8s = require('@kubernetes/client-node');
    const crypto = require('crypto');

    const app = express();
    app.use(express.json({ limit: '50mb' }));

    const PORT = process.env.PORT || 8080;
    const METRICS_PORT = process.env.METRICS_PORT || 9090;
    const BROWSER_SERVICE = process.env.BROWSER_SERVICE || 'browser-worker';
    const BROWSER_PORT = process.env.BROWSER_PORT || 3000;
    const NAMESPACE = process.env.KUBERNETES_NAMESPACE || 'browser-pool';

    // Auth secrets
    const JWT_SECRET = process.env.BROWSER_POOL_JWT_SECRET || '';
    const LEGACY_API_KEY = process.env.BROWSER_POOL_API_KEY || '';

    // Rate limiting config
    const RATE_LIMIT_WINDOW_MS = 60000;  // 1 minute
    const RATE_LIMIT_MAX_REQUESTS = 100;  // per user per minute
    const userRateLimits = new Map();

    // Audit log buffer (in production, write to database)
    const auditLog = [];
    const MAX_AUDIT_ENTRIES = 10000;

    // ========================================
    // JWT Token Verification (Production-Grade)
    // ========================================

    function base64UrlDecode(str) {
      const padded = str + '='.repeat((4 - str.length % 4) % 4);
      return Buffer.from(padded.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString('utf8');
    }

    function verifyJwt(token) {
      try {
        const parts = token.split('.');
        if (parts.length !== 3) return { valid: false, error: 'Invalid format' };

        const [header, body, signature] = parts;

        // Verify signature using HMAC-SHA256
        const expectedSig = crypto
          .createHmac('sha256', JWT_SECRET)
          .update(`${header}.${body}`)
          .digest();

        // Convert base64url to standard base64, then decode
        const sigBase64 = signature.replace(/-/g, '+').replace(/_/g, '/') + '='.repeat((4 - signature.length % 4) % 4);
        const actualSig = Buffer.from(sigBase64, 'base64');

        // Timing-safe comparison to prevent timing attacks
        if (expectedSig.length !== actualSig.length ||
            !crypto.timingSafeEqual(expectedSig, actualSig)) {
          return { valid: false, error: 'Invalid signature' };
        }

        // Parse payload
        const payload = JSON.parse(base64UrlDecode(body));

        // Check expiration
        const now = Math.floor(Date.now() / 1000);
        if (payload.exp && payload.exp < now) {
          return { valid: false, error: 'Token expired' };
        }

        // Check audience
        if (payload.aud && payload.aud !== 'browser-pool') {
          return { valid: false, error: 'Invalid audience' };
        }

        return { valid: true, payload };
      } catch (e) {
        return { valid: false, error: e.message };
      }
    }

    // ========================================
    // Audit Logging
    // ========================================

    function logAudit(entry) {
      const fullEntry = {
        timestamp: new Date().toISOString(),
        ...entry
      };

      auditLog.push(fullEntry);
      if (auditLog.length > MAX_AUDIT_ENTRIES) {
        auditLog.splice(0, MAX_AUDIT_ENTRIES / 2);
      }

      // Structured log for aggregation (stdout â†’ CloudWatch/Loki/etc)
      console.log(JSON.stringify({ type: 'AUDIT', ...fullEntry }));
    }

    // ========================================
    // Rate Limiting (Per User)
    // ========================================

    function checkRateLimit(userId) {
      const now = Date.now();
      let limit = userRateLimits.get(userId);

      if (!limit || limit.resetTime < now) {
        limit = { count: 0, resetTime: now + RATE_LIMIT_WINDOW_MS };
        userRateLimits.set(userId, limit);
      }

      limit.count++;
      const remaining = Math.max(0, RATE_LIMIT_MAX_REQUESTS - limit.count);
      const retryAfter = Math.ceil((limit.resetTime - now) / 1000);

      return {
        allowed: limit.count <= RATE_LIMIT_MAX_REQUESTS,
        remaining,
        retryAfter,
        resetTime: limit.resetTime
      };
    }

    // Cleanup old rate limit entries every minute
    setInterval(() => {
      const now = Date.now();
      for (const [key, value] of userRateLimits.entries()) {
        if (value.resetTime < now) userRateLimits.delete(key);
      }
    }, 60000);

    // ========================================
    // Authentication Middleware (Production-Grade)
    // ========================================

    const authMiddleware = (req, res, next) => {
      // Skip auth for health/metrics endpoints
      if (req.path === '/health' || req.path === '/metrics' || req.path === '/ready') {
        return next();
      }

      // No secrets configured = dev mode
      if (!JWT_SECRET && !LEGACY_API_KEY) {
        console.warn('WARNING: No auth secrets configured - running in INSECURE mode');
        req.user = { user_id: 'dev-mode', org_id: 'dev', legacy: true };
        return next();
      }

      const authHeader = req.headers['authorization'];
      if (!authHeader) {
        logAudit({ user_id: 'anonymous', action: 'auth_failed', reason: 'missing_header', ip: req.ip, endpoint: req.path });
        return res.status(401).json({ error: 'Unauthorized', message: 'Missing Authorization header' });
      }

      const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : authHeader;

      // Try JWT verification first (production)
      if (JWT_SECRET) {
        const result = verifyJwt(token);
        if (result.valid) {
          req.user = {
            user_id: result.payload.sub,
            org_id: result.payload.org_id,
            email: result.payload.email,
            token_id: result.payload.jti,
            issuer: result.payload.iss,
            ip: result.payload.ip || req.ip
          };
          return next();
        }
      }

      // Fallback to legacy API key (for migration period)
      if (LEGACY_API_KEY && token === LEGACY_API_KEY) {
        console.warn('DEPRECATION WARNING: Using legacy API key. Migrate to JWT tokens.');
        req.user = { user_id: 'legacy-api-key', org_id: 'default', legacy: true };
        return next();
      }

      logAudit({ user_id: 'anonymous', action: 'auth_failed', reason: 'invalid_token', ip: req.ip, endpoint: req.path });
      return res.status(401).json({ error: 'Unauthorized', message: 'Invalid or expired token' });
    };

    // ========================================
    // Rate Limit Middleware
    // ========================================

    const rateLimitMiddleware = (req, res, next) => {
      if (!req.user || req.user.legacy) return next();  // Skip for legacy/dev

      const limit = checkRateLimit(req.user.user_id);

      res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX_REQUESTS);
      res.setHeader('X-RateLimit-Remaining', limit.remaining);
      res.setHeader('X-RateLimit-Reset', Math.ceil(limit.resetTime / 1000));

      if (!limit.allowed) {
        logAudit({
          user_id: req.user.user_id,
          org_id: req.user.org_id,
          action: 'rate_limited',
          endpoint: req.path,
          ip: req.user.ip
        });
        return res.status(429).json({
          error: 'Too Many Requests',
          message: `Rate limit exceeded. Retry in ${limit.retryAfter}s`,
          retryAfter: limit.retryAfter
        });
      }

      next();
    };

    // ========================================
    // Audit Middleware
    // ========================================

    const auditMiddleware = (req, res, next) => {
      const startTime = Date.now();
      const originalEnd = res.end;

      res.end = function(...args) {
        if (req.user && !req.user.legacy) {
          logAudit({
            token_id: req.user.token_id || 'unknown',
            user_id: req.user.user_id,
            org_id: req.user.org_id,
            email: req.user.email,
            action: req.body?.instruction || req.method,
            endpoint: req.path,
            url: req.body?.url,
            ip: req.user.ip,
            success: res.statusCode < 400,
            duration_ms: Date.now() - startTime,
            status_code: res.statusCode
          });
        }
        return originalEnd.apply(this, args);
      };

      next();
    };

    // Apply middleware stack
    app.use(authMiddleware);
    app.use(rateLimitMiddleware);
    app.use(auditMiddleware);

    // Prometheus metrics
    const register = new promClient.Registry();
    promClient.collectDefaultMetrics({ register });

    const requestCounter = new promClient.Counter({
      name: 'manager_requests_total',
      help: 'Total requests to manager',
      labelNames: ['endpoint', 'status'],
      registers: [register]
    });

    const requestDuration = new promClient.Histogram({
      name: 'manager_request_duration_seconds',
      help: 'Request duration',
      labelNames: ['endpoint'],
      buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60],
      registers: [register]
    });

    // Kubernetes client
    const kc = new k8s.KubeConfig();
    kc.loadFromCluster();
    const coreV1Api = kc.makeApiClient(k8s.CoreV1Api);

    // Get available browser pods
    async function getBrowserPods() {
      try {
        const res = await coreV1Api.listNamespacedPod(
          NAMESPACE,
          undefined, undefined, undefined, undefined,
          'app=browser-worker'
        );
        return res.body.items
          .filter(pod => pod.status.phase === 'Running')
          .map(pod => ({
            name: pod.metadata.name,
            ip: pod.status.podIP
          }));
      } catch (error) {
        console.error('Failed to get pods:', error.message);
        return [];
      }
    }

    // Round-robin index
    let currentPodIndex = 0;

    // Get next available pod
    async function getNextPod() {
      const pods = await getBrowserPods();
      if (pods.length === 0) return null;

      currentPodIndex = (currentPodIndex + 1) % pods.length;
      return pods[currentPodIndex];
    }

    // Forward request to browser pod
    async function forwardToBrowser(endpoint, body) {
      const pod = await getNextPod();
      if (!pod) {
        throw new Error('No browser pods available');
      }

      const url = `http://${pod.ip}:${BROWSER_PORT}${endpoint}`;
      console.log(`Forwarding to ${pod.name}: ${url}`);

      const response = await axios.post(url, body, {
        timeout: 60000,
        headers: { 'Content-Type': 'application/json' }
      });

      return response.data;
    }

    // Health check
    app.get('/health', async (req, res) => {
      const pods = await getBrowserPods();
      res.json({
        status: 'healthy',
        service: 'browser-manager',
        availablePods: pods.length
      });
    });

    // Readiness check
    app.get('/ready', async (req, res) => {
      const pods = await getBrowserPods();
      if (pods.length > 0) {
        res.json({ ready: true, pods: pods.length });
      } else {
        res.status(503).json({ ready: false, error: 'No browser pods available' });
      }
    });

    // OBSERVE endpoint (MCP compatible)
    app.post('/observe', async (req, res) => {
      const end = requestDuration.startTimer({ endpoint: 'observe' });
      try {
        const result = await forwardToBrowser('/observe', req.body);
        requestCounter.inc({ endpoint: 'observe', status: 'success' });
        end();
        res.json(result);
      } catch (error) {
        requestCounter.inc({ endpoint: 'observe', status: 'error' });
        end();
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // ACT endpoint (MCP compatible)
    app.post('/act', async (req, res) => {
      const end = requestDuration.startTimer({ endpoint: 'act' });
      try {
        const result = await forwardToBrowser('/act', req.body);
        requestCounter.inc({ endpoint: 'act', status: 'success' });
        end();
        res.json(result);
      } catch (error) {
        requestCounter.inc({ endpoint: 'act', status: 'error' });
        end();
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // TEST endpoint
    app.post('/test', async (req, res) => {
      const end = requestDuration.startTimer({ endpoint: 'test' });
      try {
        const result = await forwardToBrowser('/test', req.body);
        requestCounter.inc({ endpoint: 'test', status: 'success' });
        end();
        res.json(result);
      } catch (error) {
        requestCounter.inc({ endpoint: 'test', status: 'error' });
        end();
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // ========================================
    // Audit Endpoints (Admin Only)
    // ========================================

    // Get recent audit entries
    app.get('/audit', (req, res) => {
      // Only allow for authenticated users (not legacy)
      if (!req.user || req.user.legacy) {
        return res.status(403).json({ error: 'Forbidden', message: 'JWT auth required for audit access' });
      }

      const limit = Math.min(parseInt(req.query.limit) || 100, 1000);
      const userId = req.query.user_id;
      const orgId = req.query.org_id || req.user.org_id;

      let entries = auditLog;

      // Filter by org (users can only see their own org's audit)
      if (orgId) {
        entries = entries.filter(e => e.org_id === orgId);
      }

      // Optionally filter by user
      if (userId) {
        entries = entries.filter(e => e.user_id === userId);
      }

      res.json({
        total: entries.length,
        entries: entries.slice(-limit)
      });
    });

    // Get audit stats
    app.get('/audit/stats', (req, res) => {
      if (!req.user || req.user.legacy) {
        return res.status(403).json({ error: 'Forbidden', message: 'JWT auth required' });
      }

      const orgId = req.user.org_id;
      const orgEntries = orgId ? auditLog.filter(e => e.org_id === orgId) : auditLog;

      const last24h = Date.now() - 24 * 60 * 60 * 1000;
      const recentEntries = orgEntries.filter(e => new Date(e.timestamp).getTime() > last24h);

      const byEndpoint = {};
      const byUser = {};
      let successCount = 0;
      let failCount = 0;

      for (const entry of recentEntries) {
        byEndpoint[entry.endpoint] = (byEndpoint[entry.endpoint] || 0) + 1;
        byUser[entry.user_id] = (byUser[entry.user_id] || 0) + 1;
        if (entry.success) successCount++;
        else failCount++;
      }

      res.json({
        total_24h: recentEntries.length,
        success_rate: recentEntries.length > 0 ? (successCount / recentEntries.length * 100).toFixed(1) + '%' : 'N/A',
        by_endpoint: byEndpoint,
        by_user: byUser,
        top_users: Object.entries(byUser).sort((a, b) => b[1] - a[1]).slice(0, 10)
      });
    });

    // Metrics
    const metricsApp = express();
    metricsApp.get('/metrics', async (req, res) => {
      res.set('Content-Type', register.contentType);
      res.end(await register.metrics());
    });

    // Start
    app.listen(PORT, () => console.log(`Browser manager on port ${PORT}`));
    metricsApp.listen(METRICS_PORT, () => console.log(`Metrics on port ${METRICS_PORT}`));
